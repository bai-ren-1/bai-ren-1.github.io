<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="白仁的博客" type="application/atom+xml" />






<meta name="description" content="Java审计-DAY1本文转载自 https:&#x2F;&#x2F;blog.csdn.net&#x2F;niexinming&#x2F;article&#x2F;details&#x2F;84264261  可预测的伪随机数发生器漏洞特征：PREDICTABLE_RANDOM在某些关键的安全环境中使用可预测的随机数可能会导致漏洞，比如，当这个值被作为：  csrf token；如果攻击者可以预测csrf的token值的话，就可以发动csrf攻击 重置密">
<meta property="og:type" content="article">
<meta property="og:title" content="Java审计-DAY1">
<meta property="og:url" content="http:&#x2F;&#x2F;bai-ren-1.github.io&#x2F;2020&#x2F;03&#x2F;02&#x2F;Java%E5%AE%A1%E8%AE%A1-DAY1&#x2F;index.html">
<meta property="og:site_name" content="白仁的博客">
<meta property="og:description" content="Java审计-DAY1本文转载自 https:&#x2F;&#x2F;blog.csdn.net&#x2F;niexinming&#x2F;article&#x2F;details&#x2F;84264261  可预测的伪随机数发生器漏洞特征：PREDICTABLE_RANDOM在某些关键的安全环境中使用可预测的随机数可能会导致漏洞，比如，当这个值被作为：  csrf token；如果攻击者可以预测csrf的token值的话，就可以发动csrf攻击 重置密">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-03-03T03:35:33.336Z">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://bai-ren-1.github.io/2020/03/02/Java审计-DAY1/"/>





  <title>Java审计-DAY1 | 白仁的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">白仁的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bai-ren-1.github.io/2020/03/02/Java%E5%AE%A1%E8%AE%A1-DAY1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="白仁">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="白仁的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java审计-DAY1</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-02T14:56:43+08:00">
                2020-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB%E5%AE%89%E5%85%A8/" itemprop="url" rel="index">
                    <span itemprop="name">WEB安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java审计-DAY1"><a href="#Java审计-DAY1" class="headerlink" title="Java审计-DAY1"></a>Java审计-DAY1</h1><p>本文转载自 <a href="https://blog.csdn.net/niexinming/article/details/84264261" target="_blank" rel="noopener">https://blog.csdn.net/niexinming/article/details/84264261</a> </p>
<h1 id="可预测的伪随机数发生器"><a href="#可预测的伪随机数发生器" class="headerlink" title="可预测的伪随机数发生器"></a>可预测的伪随机数发生器</h1><p>漏洞特征：<code>PREDICTABLE_RANDOM</code><br>在某些关键的安全环境中使用可预测的随机数可能会导致漏洞，比如，当这个值被作为：</p>
<ul>
<li>csrf token；如果攻击者可以预测csrf的token值的话，就可以发动csrf攻击</li>
<li>重置密码的token（通过邮件发送）；如果重置密码的token被替换的话，那么就会导致用户账户被接管，因为攻击者会猜测到重置密码的链接。</li>
<li>其他包含秘密的信息</li>
</ul>
<p>修复这个漏洞最快的方式是用强随机数生成器（ 比如：<code>java.security.SecureRandom</code>）替换掉<br><code>java.util.Random</code></p>
<p>有漏洞的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">generateSecretToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">return</span> Long.toHexString(r.nextLong());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Hex;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">generateSecretToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecureRandom secRandom = <span class="keyword">new</span> SecureRandom();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>];</span><br><span class="line">    secRandom.nextBytes(result);</span><br><span class="line">    <span class="keyword">return</span> Hex.encodeHexString(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p>引用：</p>
<p><a href="http://jazzy.id.au/default/2010/09/20/cracking_random_number_generators_part_1.html" target="_blank" rel="noopener">Cracking Random Number Generators - Part 1 (http://jazzy.id.au)</a><br><a href="https://www.securecoding.cert.org/confluence/display/java/MSC02-J.+Generate+strong+random+numbers" target="_blank" rel="noopener">CERT: MSC02-J. Generate strong random numbers</a><br><a href="http://cwe.mitre.org/data/definitions/330.html" target="_blank" rel="noopener">CWE-330: Use of Insufficiently Random Values</a><br><a href="http://blog.h3xstream.com/2014/12/predicting-struts-csrf-token-cve-2014.html" target="_blank" rel="noopener">Predicting Struts CSRF Token (Example of real-life vulnerability and exploitation)</a></p>
<h1 id="可预测的伪随机数发生器（Scala）"><a href="#可预测的伪随机数发生器（Scala）" class="headerlink" title="可预测的伪随机数发生器（Scala）"></a>可预测的伪随机数发生器（Scala）</h1><p>漏洞特征：<code>PREDICTABLE_RANDOM_SCALA</code><br>在某些关键的安全环境中使用可预测的随机数可能会导致漏洞，比如，当这个值被作为：</p>
<ul>
<li>csrf token；如果攻击者可以预测csrf的token值的话，就可以发动csrf攻击</li>
<li>重置密码的token（通过邮件发送）；如果重置密码的token被替换的话，那么就会导致用户账户被接管，因为攻击者会猜测到重置密码的链接。</li>
<li>其他包含秘密的信息</li>
</ul>
<p>修复这个漏洞最快的方式是用强随机数生成器（ 比如：<code>java.security.SecureRandom</code>）替换掉<br><code>java.util.Random</code><br>有漏洞的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.Random</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">generateSecretToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    val result = Seq.fill(<span class="number">16</span>)(Random.nextInt)</span><br><span class="line">    <span class="keyword">return</span> result.map(<span class="string">"%02x"</span> format _).mkString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.SecureRandom</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">generateSecretToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    val rand = <span class="keyword">new</span> SecureRandom()</span><br><span class="line">    val value = Array.ofDim[Byte](<span class="number">16</span>)</span><br><span class="line">    rand.nextBytes(value)</span><br><span class="line">    <span class="keyword">return</span> value.map(<span class="string">"%02x"</span> format _).mkString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://jazzy.id.au/default/2010/09/20/cracking_random_number_generators_part_1.html" target="_blank" rel="noopener">Cracking Random Number Generators - Part 1 (http://jazzy.id.au)</a><br><a href="https://www.securecoding.cert.org/confluence/display/java/MSC02-J.+Generate+strong+random+numbers" target="_blank" rel="noopener">CERT: MSC02-J. Generate strong random numbers</a><br><a href="http://cwe.mitre.org/data/definitions/330.html" target="_blank" rel="noopener">CWE-330: Use of Insufficiently Random Values</a><br><a href="http://blog.h3xstream.com/2014/12/predicting-struts-csrf-token-cve-2014.html" target="_blank" rel="noopener">Predicting Struts CSRF Token (Example of real-life vulnerability and exploitation)</a></p>
<h1 id="没有做任何安全检查的servlet-参数"><a href="#没有做任何安全检查的servlet-参数" class="headerlink" title="没有做任何安全检查的servlet 参数"></a>没有做任何安全检查的servlet 参数</h1><p>漏洞特征：<code>SERVLET_PARAMETER</code><br>Servlet 会从各种函数中获取到GET和POST的值。这些被获取的值肯定是不安全的。在进入到敏感的api函数之前你可能需要验证和过滤这些值：</p>
<ul>
<li>sql 查询 （可能导致sql注入）</li>
<li>文件操作 （ 可能会导致目录穿越 ）</li>
<li>命令执行 （ 可能会导致命令注入 ）</li>
<li>html解析 （可能会导致xss)</li>
<li>其他的</li>
</ul>
<p>引用：<br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p>
<h1 id="没有做任何安全检查Content-Type-头"><a href="#没有做任何安全检查Content-Type-头" class="headerlink" title="没有做任何安全检查Content-Type 头"></a>没有做任何安全检查Content-Type 头</h1><p>漏洞特征：SERVLET_CONTENT_TYPE<br>服务器端程序通过客户端收集http的Content-Type的值。这个值可能会影响影响应用的安全性</p>
<p>引用：<br><a href="http://cwe.mitre.org/data/definitions/807.html" target="_blank" rel="noopener">CWE-807: Untrusted Inputs in a Security Decision</a></p>
<h1 id="没有做任何安全检查Hostname-头"><a href="#没有做任何安全检查Hostname-头" class="headerlink" title="没有做任何安全检查Hostname 头"></a>没有做任何安全检查Hostname 头</h1><p>漏洞特征： SERVLET_SERVER_NAME<br>服务器端程序通过客户端收集http的hostname 的值。这个值可能会影响影响应用的安全性。<code>ServletRequest.getServerName()</code>和 <code>HttpServletRequest.getHeader(&quot;Host&quot;)</code>的行为很相似，都是从http头部中获取到host的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /testpage HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">[...]</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>默认情况下，web容器可能会直接将请求重定向到你的应用程序中。这就允许用户把恶意的请求放入http的host头中。我建议你不要信任来自客户端的任何输入。</p>
<p>引用：<br><a href="http://cwe.mitre.org/data/definitions/807.html" target="_blank" rel="noopener">CWE-807: Untrusted Inputs in a Security Decision</a></p>
<h1 id="没有做任何安全检查的session-cookie值"><a href="#没有做任何安全检查的session-cookie值" class="headerlink" title="没有做任何安全检查的session cookie值"></a>没有做任何安全检查的session cookie值</h1><p>漏洞特征： SERVLET_SESSION_ID<br><code>HttpServletRequest.getRequestedSessionId()</code>( <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRequestedSessionId()" target="_blank" rel="noopener">http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRequestedSessionId()</a> )函数返回cookie中JSESSIONID的值。这个值通常被session 管理器访问，而不是开发者代码。<br>传递给客户端的值通常是字母数字（ 例如：JSESSIONID=jp6q31lq2myn ），无论如何，这个值可以被客户端改变，下面的http请求展示了潜在的危险</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /somePage HTTP/1.1</span><br><span class="line">Host: yourwebsite.com</span><br><span class="line">User-Agent: Mozilla/5.0</span><br><span class="line">Cookie: JSESSIONID=Any value of the user&apos;s choice!!??&apos;&apos;&apos;&quot;&gt;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>像这样，JSESSIONID应该仅被使用判断是否与存在的session ID相匹配，如果不存在对应的session ID，那么这个用户就可能会是未授权用户。此外， session ID的值应该从来不被记录，如果记录了，那么日志文件中就会包含有效的且在激活状态的session IDs，这样就会允许内部员工可以通过日志记录来劫持任意在线用户。</p>
<p>引用：</p>
<p><a href="https://www.owasp.org/index.php/Session_Management_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Session Management Cheat Sheet</a><br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p>
<h1 id="没有做任何安全检查的查询字符串"><a href="#没有做任何安全检查的查询字符串" class="headerlink" title="没有做任何安全检查的查询字符串"></a>没有做任何安全检查的查询字符串</h1><p>漏洞特征： SERVLET_QUERY_STRING<br>查询字符串是get请求中参数名和参数值的串联，可以传入预期之外的参数。 比如URL请求：/app/servlet.htm?a=1&amp;b=2 ，查询字符串就是a=1&amp;b=2<br>通过函数 HttpServletRequest.getParameter() 接收每一个传递进来的参数的值，通过 HttpServletRequest.getQueryString() 这个函数获取到的值应该被看做不安全的。你应该在查询字符串进入敏感函数之前去充分的效验和过滤它们。</p>
<p>引用：<br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p>
<h1 id="没有做任何安全检查的HTTP头"><a href="#没有做任何安全检查的HTTP头" class="headerlink" title="没有做任何安全检查的HTTP头"></a>没有做任何安全检查的HTTP头</h1><p>漏洞特征：SERVLET_HEADER<br>http请求头很容易会被用户所修改。通常，不要假想请求来自于没有被黑客修改的常规浏览器。我建议你，不要相信客户端传递进来的http头部值</p>
<p>引用：<br><a href="http://cwe.mitre.org/data/definitions/807.html" target="_blank" rel="noopener">CWE-807: Untrusted Inputs in a Security Decision</a></p>
<h1 id="没有做任何安全检查的Referer值"><a href="#没有做任何安全检查的Referer值" class="headerlink" title="没有做任何安全检查的Referer值"></a>没有做任何安全检查的Referer值</h1><p>漏洞特征：SERVLET_HEADER_REFERER<br>行为：</p>
<ul>
<li>如果请求来自于恶意用户，那么Referer的值会是任意的情况。</li>
<li>如果请求来自于另一个安全的源（https），那么Referer头就是空的。</li>
</ul>
<p>建议：</p>
<ul>
<li>访问控制不应该基于此标头的值。</li>
<li>csrf保护不应该仅基于此值。（ <a href="http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14" target="_blank" rel="noopener">因为这个选项</a> ）</li>
</ul>
<p>引用：<br><a href="http://cwe.mitre.org/data/definitions/807.html" target="_blank" rel="noopener">CWE-807: Untrusted Inputs in a Security Decision</a></p>
<h1 id="没有做任何安全检查的User-Agent值"><a href="#没有做任何安全检查的User-Agent值" class="headerlink" title="没有做任何安全检查的User-Agent值"></a>没有做任何安全检查的User-Agent值</h1><p>漏洞特征： SERVLET_HEADER_USER_AGENT<br>“User-Agent” 很容易被客户端伪造，不建议基于不同的User-Agent（比如爬虫的UA）来适配不同的行为。</p>
<p>引用：<br><a href="http://cwe.mitre.org/data/definitions/807.html" target="_blank" rel="noopener">CWE-807: Untrusted Inputs in a Security Decision</a></p>
<h1 id="潜在的cookie中包含敏感数据"><a href="#潜在的cookie中包含敏感数据" class="headerlink" title="潜在的cookie中包含敏感数据"></a>潜在的cookie中包含敏感数据</h1><p>漏洞特征： COOKIE_USAGE<br>存储在客户端中cookie的数据不应该包含敏感数据或者与session相关的数据。大多数情况下，敏感数据应该仅仅存储在session中，并且通过通过用户的session值去访问。详细请看HttpSession (HttpServletRequest.getSession())<br>客户端cookie应该是比特定会话维持时间更长且独立于特殊会话</p>
<p>引用：<br><a href="http://cwe.mitre.org/data/definitions/315.html" target="_blank" rel="noopener">CWE-315: Cleartext Storage of Sensitive Information in a Cookie</a></p>
<h1 id="潜在的路径穿越（文件读取）"><a href="#潜在的路径穿越（文件读取）" class="headerlink" title="潜在的路径穿越（文件读取）"></a>潜在的路径穿越（文件读取）</h1><p>漏洞特征：PATH_TRAVERSAL_IN<br>一个文件被打开，然后读取文件内容，这个文件名来自于一个输入的参数。如果没有过滤这个传入的参数，那么本地文件系统中任意文件都会被读取。<br>这个规则识别潜在的路径穿越漏洞。在许多场景中，用户无法控制文件路径，如果有工具报告了这个问题，那么这个就是误报<br>有漏洞代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@GET</span><br><span class="line">@Path(&quot;/images/&#123;image&#125;&quot;)</span><br><span class="line">@Produces(&quot;images/*&quot;)</span><br><span class="line">public Response getImage(@javax.ws.rs.PathParam(&quot;image&quot;) String image) &#123;</span><br><span class="line">    File file = new File(&quot;resources/images/&quot;, image); //Weak point</span><br><span class="line"></span><br><span class="line">    if (!file.exists()) &#123;</span><br><span class="line">        return Response.status(Status.NOT_FOUND).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Response.ok().entity(new FileInputStream(file)).build();</span><br><span class="line">&#125;</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.io.FilenameUtils;</span><br><span class="line"></span><br><span class="line">@GET</span><br><span class="line">@Path(&quot;/images/&#123;image&#125;&quot;)</span><br><span class="line">@Produces(&quot;images/*&quot;)</span><br><span class="line">public Response getImage(@javax.ws.rs.PathParam(&quot;image&quot;) String image) &#123;</span><br><span class="line">    File file = new File(&quot;resources/images/&quot;, FilenameUtils.getName(image)); //Fix</span><br><span class="line"></span><br><span class="line">    if (!file.exists()) &#123;</span><br><span class="line">        return Response.status(Status.NOT_FOUND).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Response.ok().entity(new FileInputStream(file)).build();</span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314</span><br></pre></td></tr></table></figure>

<p>引用：<br>[WASC: Path Traversal](<a href="http://projects.webappsec.org/w/page/13246952/Path" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246952/Path</a> Traversal)<br><a href="https://www.owasp.org/index.php/Path_Traversal" target="_blank" rel="noopener">OWASP: Path Traversal</a><br><a href="http://capec.mitre.org/data/definitions/126.html" target="_blank" rel="noopener">CAPEC-126: Path Traversal</a><br><a href="http://cwe.mitre.org/data/definitions/22.html" target="_blank" rel="noopener">CWE-22: Improper Limitation of a Pathname to a Restricted Directory (‘Path Traversal’)</a></p>
<h1 id="潜在的路径穿越（文件写）"><a href="#潜在的路径穿越（文件写）" class="headerlink" title="潜在的路径穿越（文件写）"></a>潜在的路径穿越（文件写）</h1><p>漏洞特征：PATH_TRAVERSAL_OUT<br>一个文件被打开，然后读取文件内容，这个文件名来自于一个输入的参数。如果没有过滤这个传入的参数，那么本地文件系统中任意文件都会被修改。<br>这个规则识别潜在的路径穿越漏洞。在许多场景中，用户无法控制文件路径，如果有工具报告了这个问题，那么这个就是误报<br>引用：<br>[WASC: Path Traversal](<a href="http://projects.webappsec.org/w/page/13246952/Path" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246952/Path</a> Traversal)<br><a href="https://www.owasp.org/index.php/Path_Traversal" target="_blank" rel="noopener">OWASP: Path Traversal</a><br><a href="http://capec.mitre.org/data/definitions/126.html" target="_blank" rel="noopener">CAPEC-126: Path Traversal</a><br><a href="http://cwe.mitre.org/data/definitions/22.html" target="_blank" rel="noopener">CWE-22: Improper Limitation of a Pathname to a Restricted Directory (‘Path Traversal’)</a></p>
<h1 id="潜在的路径穿越（文件读取）-1"><a href="#潜在的路径穿越（文件读取）-1" class="headerlink" title="潜在的路径穿越（文件读取）"></a>潜在的路径穿越（文件读取）</h1><p>漏洞特征：SCALA_PATH_TRAVERSAL_IN<br>一个文件被打开，然后读取文件内容，这个文件名来自于一个输入的参数。如果没有过滤这个传入的参数，那么本地文件系统中任意文件都会被读取。<br>这个规则识别潜在的路径穿越漏洞。在许多场景中，用户无法控制文件路径，如果有工具报告了这个问题，那么这个就是误报<br>有漏洞代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def getWordList(value:String) = Action &#123;</span><br><span class="line">  if (!Files.exists(Paths.get(&quot;public/lists/&quot; + value))) &#123;</span><br><span class="line">    NotFound(&quot;File not found&quot;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    val result = Source.fromFile(&quot;public/lists/&quot; + value).getLines().mkString // Weak point</span><br><span class="line">    Ok(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.io.FilenameUtils;</span><br><span class="line"></span><br><span class="line">def getWordList(value:String) = Action &#123;</span><br><span class="line">  val filename = &quot;public/lists/&quot; + FilenameUtils.getName(value)</span><br><span class="line"></span><br><span class="line">  if (!Files.exists(Paths.get(filename))) &#123;</span><br><span class="line">    NotFound(&quot;File not found&quot;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    val result = Source.fromFile(filename).getLines().mkString // Fix</span><br><span class="line">    Ok(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure>

<p>引用：<br>[WASC: Path Traversal](<a href="http://projects.webappsec.org/w/page/13246952/Path" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246952/Path</a> Traversal)<br><a href="https://www.owasp.org/index.php/Path_Traversal" target="_blank" rel="noopener">OWASP: Path Traversal</a><br><a href="http://capec.mitre.org/data/definitions/126.html" target="_blank" rel="noopener">CAPEC-126: Path Traversal</a><br><a href="http://cwe.mitre.org/data/definitions/22.html" target="_blank" rel="noopener">CWE-22: Improper Limitation of a Pathname to a Restricted Directory (‘Path Traversal’)</a></p>
<h1 id="潜在的命令注入"><a href="#潜在的命令注入" class="headerlink" title="潜在的命令注入"></a>潜在的命令注入</h1><p>漏洞特征：COMMAND_INJECTION<br>高亮部分的api被用来执行系统命令，如果输入这个api的数据没有被过滤，那么就会导致任意命令执行<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.Runtime;</span><br><span class="line"></span><br><span class="line">Runtime r = Runtime.getRuntime();</span><br><span class="line">r.exec(&quot;/bin/sh -c some_tool&quot; + input);</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="https://www.owasp.org/index.php/Command_Injection" target="_blank" rel="noopener">OWASP: Command Injection</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank" rel="noopener">OWASP: Top 10 2013-A1-Injection</a><br><a href="http://cwe.mitre.org/data/definitions/78.html" target="_blank" rel="noopener">CWE-78: Improper Neutralization of Special Elements used in an OS Command (‘OS Command Injection’)</a></p>
<h1 id="潜在的命令注入-Scala"><a href="#潜在的命令注入-Scala" class="headerlink" title="潜在的命令注入(Scala)"></a>潜在的命令注入(Scala)</h1><p>漏洞特征：COMMAND_INJECTION<br>高亮部分的api被用来执行系统命令，如果输入这个api的数据没有被过滤，那么就会导致任意命令执行<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def executeCommand(value:String) = Action &#123;</span><br><span class="line">    val result = value.!</span><br><span class="line">    Ok(&quot;Result:\n&quot;+result)</span><br><span class="line">&#125;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="https://www.owasp.org/index.php/Command_Injection" target="_blank" rel="noopener">OWASP: Command Injection</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank" rel="noopener">OWASP: Top 10 2013-A1-Injection</a><br><a href="http://cwe.mitre.org/data/definitions/78.html" target="_blank" rel="noopener">CWE-78: Improper Neutralization of Special Elements used in an OS Command (‘OS Command Injection’)</a></p>
<h1 id="文件类函数没有过滤空字符"><a href="#文件类函数没有过滤空字符" class="headerlink" title="文件类函数没有过滤空字符"></a>文件类函数没有过滤空字符</h1><p>漏洞特征：WEAK_FILENAMEUTILS<br>一些文件类中方法没有过滤空字节（0x00）<br>如果空字节被注入到文件名之中，如果这个文件被放进系统之中，那么系统则只会读取空字符之前的文件名，字符串就会被空字符截断，甚至java本身也不能关注空字符或者处理这些特殊情况。操作系统的这一特性通常被用来绕过文件名验证去访问其他的文件（例如，后缀是.log”的文件）。</p>
<p>给出两点建议去修复这个问题：</p>
<ul>
<li>升级到7 update 40 或者最近的版本，或者java 8 +，因为空字节注入这个问题已经被这些版本的java所<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8014846" target="_blank" rel="noopener">解决</a></li>
<li>要严格验证用户输入的文件名是否是有效的（例如不能包含空字符，不能包含路径字符）</li>
</ul>
<p>如果你知道你使用的现有的java版本可以避免空字符注入问题，你可以忽略上面的问题。</p>
<p>引用：<br>[WASC-28: Null Byte Injection](<a href="http://projects.webappsec.org/w/page/13246949/Null" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246949/Null</a> Byte Injection)<br><a href="http://cwe.mitre.org/data/definitions/158.html" target="_blank" rel="noopener">CWE-158: Improper Neutralization of Null Byte or NUL Character</a></p>
<h1 id="证书管理器接受任何证书"><a href="#证书管理器接受任何证书" class="headerlink" title="证书管理器接受任何证书"></a>证书管理器接受任何证书</h1><p>漏洞特征： WEAK_TRUST_MANAGER<br>空的证书管理器通常可以更轻松的连接到没有<a href="http://en.wikipedia.org/wiki/Certificate_authority" target="_blank" rel="noopener">根证书</a>的主机上。结果就是，就会更容易受到中间人攻击，因为客户端信任所有的证书。<br>一个证书管理器应该允许信任指定的一种证书（例如：基于信任库）。下面是一种可行的实现方法：<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class TrustAllManager implements X509TrustManager &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123;</span><br><span class="line">        //Trust any client connecting (no certificate validation)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123;</span><br><span class="line">        //Trust any remote server (no certificate validation)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314151617</span><br></pre></td></tr></table></figure>

<p>解决方案(基于证书库的证书管理器）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">KeyStore ks = //Load keystore containing the certificates trusted</span><br><span class="line"></span><br><span class="line">SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line"></span><br><span class="line">TrustManagerFactory tmf = TrustManagerFactory.getInstance(&quot;SunX509&quot;);</span><br><span class="line">tmf.init(ks);</span><br><span class="line"></span><br><span class="line">sc.init(kmf.getKeyManagers(), tmf.getTrustManagers(),null);</span><br><span class="line"></span><br><span class="line">123456789</span><br></pre></td></tr></table></figure>

<p>引用：<br>[WASC-04: Insufficient Transport Layer Protection](<a href="http://projects.webappsec.org/w/page/13246945/Insufficient" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246945/Insufficient</a> Transport Layer Protection)<br><a href="http://cwe.mitre.org/data/definitions/295.html" target="_blank" rel="noopener">CWE-295: Improper Certificate Validation</a></p>
<h1 id="HostnameVerifier-接收任何签名证书"><a href="#HostnameVerifier-接收任何签名证书" class="headerlink" title="HostnameVerifier 接收任何签名证书"></a>HostnameVerifier 接收任何签名证书</h1><p>漏洞规则：WEAK_HOSTNAME_VERIFIER<br>因为证书会被很多主机重复使用，接收任意证书的HostnameVerifier经常被使用。结果就是，就会更容易受到中间人攻击，因为客户端信任所有的证书。<br>一个证书管理器应该允许信任指定的一种证书（例如：基于信任库）。应该创建通配符证书，可以允许多个子域下证书。下面是一种可行的实现方法：<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AllHosts implements HostnameVerifier &#123;</span><br><span class="line">    public boolean verify(final String hostname, final SSLSession session) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>解决方案(基于证书库的证书管理器）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">KeyStore ks = //Load keystore containing the certificates trusted</span><br><span class="line"></span><br><span class="line">SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line"></span><br><span class="line">TrustManagerFactory tmf = TrustManagerFactory.getInstance(&quot;SunX509&quot;);</span><br><span class="line">tmf.init(ks);</span><br><span class="line"></span><br><span class="line">sc.init(kmf.getKeyManagers(), tmf.getTrustManagers(),null);</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>

<p>引用：<br>[WASC-04: Insufficient Transport Layer Protection](<a href="http://projects.webappsec.org/w/page/13246945/Insufficient" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246945/Insufficient</a> Transport Layer Protection)<br><a href="http://cwe.mitre.org/data/definitions/295.html" target="_blank" rel="noopener">CWE-295: Improper Certificate Validation</a></p>
<h1 id="发现JAX-RS-REST服务器端"><a href="#发现JAX-RS-REST服务器端" class="headerlink" title="发现JAX-RS REST服务器端"></a>发现JAX-RS REST服务器端</h1><p>漏洞规则： JAXRS_ENDPOINT<br>这些函数是REST Web Service 的一部分(JSR311).<br>这个网站的安全性应该被分析。例如：</p>
<ul>
<li>权限认证，如果强制实施，就应该被测试</li>
<li>访问控制，如果强制实施，就应该被测试</li>
<li>输入应该被追踪，因为可能会有潜在的漏洞</li>
<li>聊天程序应该使用SSL</li>
<li>如果服务器支持存储私人数据（例如，通过POST），应该调查它是否对csrf有防御</li>
</ul>
<p>引用：<br><a href="https://www.owasp.org/index.php/REST_Assessment_Cheat_Sheet" target="_blank" rel="noopener">OWASP: REST Assessment Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/REST_Security_Cheat_Sheet" target="_blank" rel="noopener">OWASP: REST Security Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Web_Service_Security_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Web Service Security Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)" target="_blank" rel="noopener">OWASP: Cross-Site Request Forgery</a><br><a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: CSRF Prevention Cheat Sheet</a><br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p>
<h1 id="发现Tapestry页面"><a href="#发现Tapestry页面" class="headerlink" title="发现Tapestry页面"></a>发现Tapestry页面</h1><p>漏洞规则： TAPESTRY_ENDPOINT<br>在应用启动的时候，Tapestry会被发现。Tapestry应用的每一个页面又后端java类和相关的Tapestry标记语言构成（a.tml 文件）。当请求到达的时候，GET/POST参数会被映射到后端的java类之中。映射可以使用fieldName完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">    protected String input;</span><br><span class="line">[...]</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>或者显示注释的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">    @org.apache.tapestry5.annotations.Parameter</span><br><span class="line">    protected String parameter1;</span><br><span class="line"></span><br><span class="line">    @org.apache.tapestry5.annotations.Component(id = &quot;password&quot;)</span><br><span class="line">    private PasswordField passwordField;</span><br><span class="line">[...]</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>

<p>这个页面被映射到视图中[/resources/package/PageName].tml.</p>
<p>在应用中的每一个Tapestry页面应该被调查，确保所有的输入都能被自动的映射，并在这些参数被使用之前都是有效的。<br>引用：<br><a href="http://tapestry.apache.org/" target="_blank" rel="noopener">Apache Tapestry Home Page</a><br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p>
<h1 id="发现Wicket的web页面"><a href="#发现Wicket的web页面" class="headerlink" title="发现Wicket的web页面"></a>发现Wicket的web页面</h1><p>漏洞特征：WICKET_ENDPOINT<br>这个类代表一个Wicket web页面。输入的数据会被来自实例中的PageParameters读取，然后把它们送入后端处理程序。当前页面会被映射到视图之中[/package/WebPageName].html.<br>在应用中的每一个Wicket页面应该被调查，确保所有的输入都能被自动的映射，并在这些参数被使用之前都是有效的。<br>引用：<br><a href="https://wicket.apache.org/" target="_blank" rel="noopener">Apache Wicket Home Page</a><br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p>
<h1 id="MD2-MD4-和-MD5都是脆弱的哈希函数"><a href="#MD2-MD4-和-MD5都是脆弱的哈希函数" class="headerlink" title="MD2, MD4 和 MD5都是脆弱的哈希函数"></a>MD2, MD4 和 MD5都是脆弱的哈希函数</h1><p>漏洞特征：WEAK_MESSAGE_DIGEST_MD5<br>不建议使用MD2, MD4 和 MD5这个摘要算法。应该使用PBKDF2作为密码的摘要算法。<br>md5哈希算法的安全性被严重损害。现已存在一种碰撞攻击，这种攻击可以用奔腾2.6 GHz 4核处理器在几秒内碰撞出另一个哈希相同的字符串。进一步来说，还有选择前缀碰撞攻击（chosen-prefix collision attack ），这种攻击能在一个小时之内找到两个前缀相同的哈希，只要现有计算机的计算水平就可以达到。</p>
<p><strong>“SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256:</strong><br>所有散列计算程序都支持这些哈希函数的使用。<br>NISI:通信传输：[传输中建议使用的加密算法和密钥长度](<a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf）" target="_blank" rel="noopener">http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf）</a></p>
<p>PBKDF的主要思想是减缓字典生成的时间或者增加攻击者攻击每一个密码的时间。攻击者会有一个密码表去爆破PBKDF所使用的迭代计数器和salt。因为攻击者必须花费大量的计算时间去尝试破解每一个密码，所以攻击者很难用字典攻击和爆破攻击去获得成功。<br>NISI:<a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf" target="_blank" rel="noopener">基于密码的密钥的加密建议</a></p>
<p>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageDigest md5Digest = MessageDigest.getInstance(&quot;MD5&quot;);</span><br><span class="line">    md5Digest.update(password.getBytes());</span><br><span class="line">    byte[] hashValue = md5Digest.digest();</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;</span><br><span class="line">    PKCS5S2ParametersGenerator gen = new PKCS5S2ParametersGenerator(new SHA256Digest());</span><br><span class="line">    gen.init(password.getBytes(&quot;UTF-8&quot;), salt.getBytes(), 4096);</span><br><span class="line">    return ((KeyParameter) gen.generateDerivedParameters(256)).getKey();</span><br><span class="line">&#125;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>解决方案（java 8 和之后的版本）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;</span><br><span class="line">    KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 4096, 256 * 8);</span><br><span class="line">    SecretKeyFactory f = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);</span><br><span class="line">    return f.generateSecret(spec).getEncoded();</span><br><span class="line">&#125;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>引用：<br>[1] [On Collisions for MD5](<a href="http://www.win.tue.nl/hashclash/On" target="_blank" rel="noopener">http://www.win.tue.nl/hashclash/On</a> Collisions for MD5 - M.M.J. Stevens.pdf): Master Thesis by M.M.J. Stevens<br>[2] [Chosen-prefix collisions for MD5 and applications](<a href="http://homepages.cwi.nl/~stevens/papers/stJOC" target="_blank" rel="noopener">http://homepages.cwi.nl/~stevens/papers/stJOC</a> - Chosen-Prefix Collisions for MD5 and Applications.pdf): Paper written by Marc Stevens<br>Wikipedia: MD5<br><a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf" target="_blank" rel="noopener">NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths</a><br><a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf" target="_blank" rel="noopener">NIST: Recommendation for Password-Based Key Derivation</a><br><a href="https://stackoverflow.com/q/22580853/89769" target="_blank" rel="noopener">Stackoverflow: Reliable implementation of PBKDF2-HMAC-SHA256 for Java</a><br><a href="http://cwe.mitre.org/data/definitions/327.html" target="_blank" rel="noopener">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a></p>
<h1 id="SHA-1-是脆弱的哈希算法"><a href="#SHA-1-是脆弱的哈希算法" class="headerlink" title="SHA-1 是脆弱的哈希算法"></a>SHA-1 是脆弱的哈希算法</h1><p>漏洞特征： WEAK_MESSAGE_DIGEST_SHA1<br>不建议使用SHA-1算法去加密密码、做数字签名和其他用途。应该使用PBKDF2作为密码的摘要算法。</p>
<p><strong>“SHA-1用于生成电子签名：</strong><br>SHA-1可能仅仅用于NIST指导的特殊协议的电子签名的生成。但是在其他的应用中，SHA-1 不应该用于电子签名</p>
<p><strong>SHA-1用于电子签名的验证：</strong><br>对于电子签名的验证，SHA-1可以被用于传统应用<br><strong>“SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256:</strong><br>所有散列计算程序都支持这些哈希函数的使用。<br>NISI:通信传输：[传输中建议使用的加密算法和密钥长度](<a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf）" target="_blank" rel="noopener">http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf）</a></p>
<p>PBKDF的主要思想是减缓字典生成的时间或者增加攻击者攻击每一个密码的时间。攻击者会有一个密码表去爆破PBKDF所使用的迭代计数器和salt。因为攻击者必须花费大量的计算时间去尝试破解每一个密码，所以攻击者很难用字典攻击和爆破攻击去获得成功。<br>NISI:<a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf" target="_blank" rel="noopener">基于密码的密钥的加密建议</a></p>
<p>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MessageDigest sha1Digest = MessageDigest.getInstance(&quot;SHA1&quot;);</span><br><span class="line">sha1Digest.update(password.getBytes());</span><br><span class="line">byte[] hashValue = sha1Digest.digest();</span><br><span class="line">123</span><br><span class="line">byte[] hashValue = DigestUtils.getSha1Digest().digest(password.getBytes());</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;</span><br><span class="line">    PKCS5S2ParametersGenerator gen = new PKCS5S2ParametersGenerator(new SHA256Digest());</span><br><span class="line">    gen.init(password.getBytes(&quot;UTF-8&quot;), salt.getBytes(), 4096);</span><br><span class="line">    return ((KeyParameter) gen.generateDerivedParameters(256)).getKey();</span><br><span class="line">&#125;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>解决方案（java 8 及以后的版本）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;</span><br><span class="line">    KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 4096, 256 * 8);</span><br><span class="line">    SecretKeyFactory f = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);</span><br><span class="line">    return f.generateSecret(spec).getEncoded();</span><br><span class="line">&#125;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="https://community.qualys.com/blogs/securitylabs/2014/09/09/sha1-deprecation-what-you-need-to-know" target="_blank" rel="noopener">Qualys blog: SHA1 Deprecation: What You Need to Know</a><br><a href="https://googleonlinesecurity.blogspot.ca/2014/09/gradually-sunsetting-sha-1.html" target="_blank" rel="noopener">Google Online Security Blog: Gradually sunsetting SHA-1</a><br><a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf" target="_blank" rel="noopener">NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths</a><br><a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf" target="_blank" rel="noopener">NIST: Recommendation for Password-Based Key Derivation</a><br><a href="https://stackoverflow.com/q/22580853/89769" target="_blank" rel="noopener">Stackoverflow: Reliable implementation of PBKDF2-HMAC-SHA256 for Java</a><br><a href="http://cwe.mitre.org/data/definitions/327.html" target="_blank" rel="noopener">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a></p>
<h1 id="DefaultHttpClient的默认构造函数与TLS-1-2不兼容"><a href="#DefaultHttpClient的默认构造函数与TLS-1-2不兼容" class="headerlink" title="DefaultHttpClient的默认构造函数与TLS 1.2不兼容"></a>DefaultHttpClient的默认构造函数与TLS 1.2不兼容</h1><p>漏洞特征： DEFAULT_HTTP_CLIENT<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpClient client = new DefaultHttpClient();</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>解决方案：<br>用建议的构造函数去升级你的代码并且配置jvm中https.protocols选项，使其包含TLSv1.2:<br>使用SystemDefaultHttpClient 代替</p>
<ul>
<li>示例代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpClient client = new SystemDefaultHttpClient();</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<ul>
<li>基于SSLSocketFactory类创建一个HttpClient，通过 <a href="https://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/conn/ssl/SSLSocketFactory.html#getSystemSocketFactory()" target="_blank" rel="noopener">getSystemSocketFactory()</a> 获得一个SSLScoketFactory实例，用这个实例去初始化一个HttpClient</li>
<li>基于SSLConnectionSocketFactory类创建一个HttpClient，通过 <a href="https://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/conn/ssl/SSLSocketFactory.html#getSystemSocketFactory()" target="_blank" rel="noopener">getSystemSocketFactory()</a> 获得一个SSLScoketFactory实例，用这个实例去初始化一个HttpClient</li>
<li>使用HttpClientBuilder，在调用build()之前调用useSystemProperties()<br>示例代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpClient client = HttpClientBuilder.create().useSystemProperties().build();</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<ul>
<li>HttpClients,调用 createSystem()去创建一个实例</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpClient client = HttpClients.createSystem();</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="https://blogs.oracle.com/java-platform-group/entry/diagnosing_tls_ssl_and_https" target="_blank" rel="noopener">Diagnosing TLS, SSL, and HTTPS</a></p>
<h1 id="脆弱的SSLContext"><a href="#脆弱的SSLContext" class="headerlink" title="脆弱的SSLContext"></a>脆弱的SSLContext</h1><p>漏洞特征： SSL_CONTEXT<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SSLContext.getInstance(&quot;SSL&quot;);</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>解决方案：<br>用下面的代码升级你的代码，并且配置jvm的https.protocols选项，使其包含TLSv1.2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SSLContext.getInstance(&quot;TLS&quot;); </span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="https://blogs.oracle.com/java-platform-group/entry/diagnosing_tls_ssl_and_https" target="_blank" rel="noopener">Diagnosing TLS, SSL, and HTTPS</a></p>
<h1 id="习惯使用的信息摘要算法"><a href="#习惯使用的信息摘要算法" class="headerlink" title="习惯使用的信息摘要算法"></a>习惯使用的信息摘要算法</h1><p>自己实现消息摘要算法是不靠谱的。<br><a href="http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html" target="_blank" rel="noopener">NIST</a>建议使用SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, or SHA-512/256。<br><strong>“SHA-1用于生成电子签名：</strong><br>SHA-1可能仅仅用于NIST指导的特殊协议的电子签名的生成。但是在其他的应用中，SHA-1 不应该用于电子签名</p>
<p><strong>SHA-1用于电子签名的验证：</strong><br>对于电子签名的验证，SHA-1可以被用于传统应用<br><strong>“SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256:</strong><br>所有散列计算程序都支持这些哈希函数的使用。<br>NISI:通信传输：<a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf" target="_blank" rel="noopener">传输中建议使用的加密算法和密钥长度</a><br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyProprietaryMessageDigest extends MessageDigest &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected byte[] engineDigest() &#123;</span><br><span class="line">        [...]</span><br><span class="line">        //Creativity is a bad idea</span><br><span class="line">        return [...];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>

<p>使用其中一种信息摘要算法去升级你的代码。这些算法非常强大，能足够满足你的安全需求。<br>解决方案示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MessageDigest sha256Digest = MessageDigest.getInstance(&quot;SHA256&quot;);</span><br><span class="line">sha256Digest.update(password.getBytes());</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html" target="_blank" rel="noopener">NIST Approved Hashing Algorithms</a><br><a href="http://cwe.mitre.org/data/definitions/327.html" target="_blank" rel="noopener">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a></p>
<h1 id="读取文件的缺陷"><a href="#读取文件的缺陷" class="headerlink" title="读取文件的缺陷"></a>读取文件的缺陷</h1><p>漏洞特征： FILE_UPLOAD_FILENAME<br>通过篡改FileUpload API 提供的文件名，客户端可以任意访问系统中的文件<br>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;../../../config/overide_file&quot;</span><br><span class="line"></span><br><span class="line">&quot;shell.jsp\u0000expected.gif&quot;</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>所以，上面的这些值应该没有做任何过滤就直接进入到了文件系统api之中。如果可能，应用应该生成自己的文件名，并且使用它们。<br>即使这样，被提供的文件名也要去验证它们的有效性，以确保它们没有包含未授权的路径（比如./)和未授权的文件。</p>
<p>引用：<br><a href="http://blogs.securiteam.com/index.php/archives/1268" target="_blank" rel="noopener">Securiteam: File upload security recommendations</a><br><a href="http://cwe.mitre.org/data/definitions/22.html" target="_blank" rel="noopener">CWE-22: Improper Limitation of a Pathname to a Restricted Directory (‘Path Traversal’)</a><br>[WASC-33: Path Traversal](<a href="http://projects.webappsec.org/w/page/13246952/Path" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246952/Path</a> Traversal)<br><a href="https://www.owasp.org/index.php/Path_Traversal" target="_blank" rel="noopener">OWASP: Path Traversal</a><br><a href="http://capec.mitre.org/data/definitions/126.html" target="_blank" rel="noopener">CAPEC-126: Path Traversal</a><br><a href="http://cwe.mitre.org/data/definitions/22.html" target="_blank" rel="noopener">CWE-22: Improper Limitation of a Pathname to a Restricted Directory (‘Path Traversal’)</a></p>
<h1 id="正则dos"><a href="#正则dos" class="headerlink" title="正则dos"></a>正则dos</h1><p>漏洞特征： REDOS<br>正则表达式(regexs)经常导致拒绝服务攻击（(DOS)。这是因为当正则表达式引擎分析一些字符串的时候会消耗大量的时间，而这也取决于正则是怎么写的。<br>比如，对于正则<code>^(a+)+$</code>,如果输入”aaaaaaaaaaaaaaaaX”，就会让正则表达式引擎分析65536种不同的路径。<br>所以，可能只要客户端发送一个请求就可以让服务器端消耗巨大的计算资源。问题可能就是类似于这样的正则表达式，由于括号内的+ (or a *)和括号外的+ (or a *) ，当输入相同字符串的时候，可能会有两种不同的处理方式。以这样的方式去写正则，+号会消耗字符’a’。为了修复这样问题，正则表达式应该被重写，目的是消除歧义.比如，上面那个有问题的正则表达式就可以被改写为<code>^a+$</code>，无论如何，这可能是作者的意思。总之，这可能是原来正则表达式的意思，这个新正则表达式会更快的匹配字符串，并且也不会受到ReDos攻击。<br>引用：<br><a href="http://www.jroller.com/sebastianKuebeck/entry/detecting_and_preventing_redos_vulnerabilities" target="_blank" rel="noopener">Sebastian Kubeck’s Weblog: Detecting and Preventing ReDoS Vulnerabilities</a><br>[1] <a href="https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS" target="_blank" rel="noopener">OWASP: Regular expression Denial of Service</a><br><a href="http://cwe.mitre.org/data/definitions/400.html" target="_blank" rel="noopener">CWE-400: Uncontrolled Resource Consumption (‘Resource Exhaustion’)</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/" rel="next" title="物理内存和虚拟内存的联系与区别">
                <i class="fa fa-chevron-left"></i> 物理内存和虚拟内存的联系与区别
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/02/Java%E5%AE%A1%E8%AE%A1-DAY2/" rel="prev" title="Java审计-DAY2">
                Java审计-DAY2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">白仁</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java审计-DAY1"><span class="nav-number">1.</span> <span class="nav-text">Java审计-DAY1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#可预测的伪随机数发生器"><span class="nav-number">2.</span> <span class="nav-text">可预测的伪随机数发生器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#可预测的伪随机数发生器（Scala）"><span class="nav-number">3.</span> <span class="nav-text">可预测的伪随机数发生器（Scala）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#没有做任何安全检查的servlet-参数"><span class="nav-number">4.</span> <span class="nav-text">没有做任何安全检查的servlet 参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#没有做任何安全检查Content-Type-头"><span class="nav-number">5.</span> <span class="nav-text">没有做任何安全检查Content-Type 头</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#没有做任何安全检查Hostname-头"><span class="nav-number">6.</span> <span class="nav-text">没有做任何安全检查Hostname 头</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#没有做任何安全检查的session-cookie值"><span class="nav-number">7.</span> <span class="nav-text">没有做任何安全检查的session cookie值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#没有做任何安全检查的查询字符串"><span class="nav-number">8.</span> <span class="nav-text">没有做任何安全检查的查询字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#没有做任何安全检查的HTTP头"><span class="nav-number">9.</span> <span class="nav-text">没有做任何安全检查的HTTP头</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#没有做任何安全检查的Referer值"><span class="nav-number">10.</span> <span class="nav-text">没有做任何安全检查的Referer值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#没有做任何安全检查的User-Agent值"><span class="nav-number">11.</span> <span class="nav-text">没有做任何安全检查的User-Agent值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#潜在的cookie中包含敏感数据"><span class="nav-number">12.</span> <span class="nav-text">潜在的cookie中包含敏感数据</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#潜在的路径穿越（文件读取）"><span class="nav-number">13.</span> <span class="nav-text">潜在的路径穿越（文件读取）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#潜在的路径穿越（文件写）"><span class="nav-number">14.</span> <span class="nav-text">潜在的路径穿越（文件写）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#潜在的路径穿越（文件读取）-1"><span class="nav-number">15.</span> <span class="nav-text">潜在的路径穿越（文件读取）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#潜在的命令注入"><span class="nav-number">16.</span> <span class="nav-text">潜在的命令注入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#潜在的命令注入-Scala"><span class="nav-number">17.</span> <span class="nav-text">潜在的命令注入(Scala)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件类函数没有过滤空字符"><span class="nav-number">18.</span> <span class="nav-text">文件类函数没有过滤空字符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#证书管理器接受任何证书"><span class="nav-number">19.</span> <span class="nav-text">证书管理器接受任何证书</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HostnameVerifier-接收任何签名证书"><span class="nav-number">20.</span> <span class="nav-text">HostnameVerifier 接收任何签名证书</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#发现JAX-RS-REST服务器端"><span class="nav-number">21.</span> <span class="nav-text">发现JAX-RS REST服务器端</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#发现Tapestry页面"><span class="nav-number">22.</span> <span class="nav-text">发现Tapestry页面</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#发现Wicket的web页面"><span class="nav-number">23.</span> <span class="nav-text">发现Wicket的web页面</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MD2-MD4-和-MD5都是脆弱的哈希函数"><span class="nav-number">24.</span> <span class="nav-text">MD2, MD4 和 MD5都是脆弱的哈希函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SHA-1-是脆弱的哈希算法"><span class="nav-number">25.</span> <span class="nav-text">SHA-1 是脆弱的哈希算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DefaultHttpClient的默认构造函数与TLS-1-2不兼容"><span class="nav-number">26.</span> <span class="nav-text">DefaultHttpClient的默认构造函数与TLS 1.2不兼容</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#脆弱的SSLContext"><span class="nav-number">27.</span> <span class="nav-text">脆弱的SSLContext</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#习惯使用的信息摘要算法"><span class="nav-number">28.</span> <span class="nav-text">习惯使用的信息摘要算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#读取文件的缺陷"><span class="nav-number">29.</span> <span class="nav-text">读取文件的缺陷</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#正则dos"><span class="nav-number">30.</span> <span class="nav-text">正则dos</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">白仁</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
