<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="白仁的博客" type="application/atom+xml" />






<meta name="description" content="Java审计-DAY3转载自 https:&#x2F;&#x2F;blog.csdn.net&#x2F;niexinming&#x2F;article&#x2F;details&#x2F;84455035  在使用脚本引擎时潜在的代码注入漏洞特征：SCRIPT_ENGINE_INJECTION请严格的评估动态代码。应该仔细分析代码的结构。恶意代码的执行会导致数据的泄露或者执行任意系统指令。如果你想动态的运行代码，那么请找一个沙箱（见引用）有害的代码： 12">
<meta property="og:type" content="article">
<meta property="og:title" content="Java审计-DAY3">
<meta property="og:url" content="http:&#x2F;&#x2F;bai-ren-1.github.io&#x2F;2020&#x2F;03&#x2F;02&#x2F;Java%E5%AE%A1%E8%AE%A1-DAY3&#x2F;index.html">
<meta property="og:site_name" content="白仁的博客">
<meta property="og:description" content="Java审计-DAY3转载自 https:&#x2F;&#x2F;blog.csdn.net&#x2F;niexinming&#x2F;article&#x2F;details&#x2F;84455035  在使用脚本引擎时潜在的代码注入漏洞特征：SCRIPT_ENGINE_INJECTION请严格的评估动态代码。应该仔细分析代码的结构。恶意代码的执行会导致数据的泄露或者执行任意系统指令。如果你想动态的运行代码，那么请找一个沙箱（见引用）有害的代码： 12">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-03-03T03:46:29.899Z">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://bai-ren-1.github.io/2020/03/02/Java审计-DAY3/"/>





  <title>Java审计-DAY3 | 白仁的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">白仁的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bai-ren-1.github.io/2020/03/02/Java%E5%AE%A1%E8%AE%A1-DAY3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="白仁">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="白仁的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java审计-DAY3</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-02T14:56:56+08:00">
                2020-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WEB%E5%AE%89%E5%85%A8/" itemprop="url" rel="index">
                    <span itemprop="name">WEB安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java审计-DAY3"><a href="#Java审计-DAY3" class="headerlink" title="Java审计-DAY3"></a>Java审计-DAY3</h1><p>转载自 <a href="https://blog.csdn.net/niexinming/article/details/84455035" target="_blank" rel="noopener">https://blog.csdn.net/niexinming/article/details/84455035</a> </p>
<h1 id="在使用脚本引擎时潜在的代码注入"><a href="#在使用脚本引擎时潜在的代码注入" class="headerlink" title="在使用脚本引擎时潜在的代码注入"></a>在使用脚本引擎时潜在的代码注入</h1><p>漏洞特征：SCRIPT_ENGINE_INJECTION<br>请严格的评估动态代码。应该仔细分析代码的结构。恶意代码的执行会导致数据的泄露或者执行任意系统指令。<br>如果你想动态的运行代码，那么请找一个沙箱（见引用）<br>有害的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void runCustomTrigger(String script) &#123;</span><br><span class="line">    ScriptEngineManager factory = new ScriptEngineManager();</span><br><span class="line">    ScriptEngine engine = factory.getEngineByName(&quot;JavaScript&quot;);</span><br><span class="line"></span><br><span class="line">    engine.eval(script); //Bad things can happen here.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：<br>使用“Cloudbees Rhino Sandbox”库就能安全的评估Javascript代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void runCustomTrigger(String script) &#123;</span><br><span class="line">    SandboxContextFactory contextFactory = new SandboxContextFactory();</span><br><span class="line">    Context context = contextFactory.makeContext();</span><br><span class="line">    contextFactory.enterContext(context);</span><br><span class="line">    try &#123;</span><br><span class="line">        ScriptableObject prototype = context.initStandardObjects();</span><br><span class="line">        prototype.setParentScope(null);</span><br><span class="line">        Scriptable scope = context.newObject(prototype);</span><br><span class="line">        scope.setPrototype(prototype);</span><br><span class="line"></span><br><span class="line">        context.evaluateString(scope,script, null, -1, null);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        context.exit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="https://github.com/cloudbees/rhino-sandbox" target="_blank" rel="noopener">Cloudbees Rhino Sandbox: Utility to create sandbox with Rhino (block access to all classes)</a><br><a href="http://codeutopia.net/blog/2009/01/02/sandboxing-rhino-in-java/" target="_blank" rel="noopener">CodeUtopia.net: Sandboxing Rhino in Java</a><br><a href="http://blog.h3xstream.com/2014/11/remote-code-execution-by-design.html" target="_blank" rel="noopener">Remote Code Execution … by design</a>：里面有一些恶意代码的例子。这些例子能测试沙箱的规则<br><a href="http://cwe.mitre.org/data/definitions/94.html" target="_blank" rel="noopener">CWE-94: Improper Control of Generation of Code (‘Code Injection’)</a><br><a href="https://cwe.mitre.org/data/definitions/95.html" target="_blank" rel="noopener">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code (‘Eval Injection’)</a></p>
<h1 id="使用Spring表达式时潜在的代码注入-SpEL表达式注入）"><a href="#使用Spring表达式时潜在的代码注入-SpEL表达式注入）" class="headerlink" title="使用Spring表达式时潜在的代码注入(SpEL表达式注入）"></a>使用Spring表达式时潜在的代码注入(SpEL表达式注入）</h1><p>漏洞规则：SPEL_INJECTION<br>Spring表达式被用来构建动态的值。源数据应该被严格的检验，以避免未过滤的时候进入到表达式的执行器中<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void parseExpressionInterface(Person personObj,String property) &#123;</span><br><span class="line"></span><br><span class="line">        ExpressionParser parser = new SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">        //Unsafe if the input is control by the user..</span><br><span class="line">        Expression exp = parser.parseExpression(property+&quot; == &apos;Albert&apos;&quot;);</span><br><span class="line"></span><br><span class="line">        StandardEvaluationContext testContext = new StandardEvaluationContext(personObj);</span><br><span class="line">        boolean result = exp.getValue(testContext, Boolean.class);</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="http://cwe.mitre.org/data/definitions/94.html" target="_blank" rel="noopener">CWE-94: Improper Control of Generation of Code (‘Code Injection’)</a><br><a href="http://cwe.mitre.org/data/definitions/95.html" target="_blank" rel="noopener">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code (‘Eval Injection’)</a><br><a href="http://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html" target="_blank" rel="noopener">Spring Expression Language (SpEL) - Official Documentation</a><br><a href="https://www.mindedsecurity.com/fileshare/ExpressionLanguageInjection.pdf" target="_blank" rel="noopener">Minded Security: Expression Language Injection</a><br><a href="http://blog.h3xstream.com/2014/11/remote-code-execution-by-design.html" target="_blank" rel="noopener">Remote Code Execution … by design</a>: 里面有一些恶意代码的例子。这些例子能测试沙箱的规则.<br><a href="https://gosecure.net/2018/05/15/beware-of-the-magic-spell-part-1-cve-2018-1273/" target="_blank" rel="noopener">Spring Data-Commons: (CVE-2018-1273)</a><br><a href="http://gosecure.net/2018/05/17/beware-of-the-magic-spell-part-2-cve-2018-1260/" target="_blank" rel="noopener">Spring OAuth2: CVE-2018-1260</a></p>
<h1 id="使用表达式语言时潜在的代码注入（EL）"><a href="#使用表达式语言时潜在的代码注入（EL）" class="headerlink" title="使用表达式语言时潜在的代码注入（EL）"></a>使用表达式语言时潜在的代码注入（EL）</h1><p>漏洞特征：EL_INJECTION</p>
<p>表达式语言被用来构建动态的值。源数据应该被严格的检验，以避免未过滤的时候进入到表达式的执行器中<br>有漏洞代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void evaluateExpression(String expression) &#123;</span><br><span class="line">    FacesContext context = FacesContext.getCurrentInstance();</span><br><span class="line">    ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();</span><br><span class="line">    ELContext elContext = context.getELContext();</span><br><span class="line">    ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);</span><br><span class="line">    return (String) vex.getValue(elContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="http://blog.mindedsecurity.com/2015/11/reliable-os-shell-with-el-expression.html" target="_blank" rel="noopener">Minded Security: Abusing EL for executing OS commands</a><br><a href="https://docs.oracle.com/javaee/6/tutorial/doc/gjddd.html" target="_blank" rel="noopener">The Java EE 6 Tutorial: Expression Language</a><br><a href="http://cwe.mitre.org/data/definitions/94.html" target="_blank" rel="noopener">CWE-94: Improper Control of Generation of Code (‘Code Injection’)</a><br><a href="http://cwe.mitre.org/data/definitions/95.html" target="_blank" rel="noopener">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code (‘Eval Injection’)</a><br><a href="https://www.mindedsecurity.com/fileshare/ExpressionLanguageInjection.pdf" target="_blank" rel="noopener">Minded Security: Expression Language Injection</a><br><a href="http://danamodio.com/appsec/research/spring-remote-code-with-expression-language-injection/" target="_blank" rel="noopener">Dan Amodio’s blog: Remote Code with Expression Language Injection</a><br><a href="http://blog.h3xstream.com/2014/11/remote-code-execution-by-design.html" target="_blank" rel="noopener">Remote Code Execution … by design</a>: 里面有一些恶意代码的例子。这些例子能测试沙箱的规则.</p>
<h1 id="潜在于Seam-logging-call中的代码注入"><a href="#潜在于Seam-logging-call中的代码注入" class="headerlink" title="潜在于Seam logging call中的代码注入"></a>潜在于Seam logging call中的代码注入</h1><p>漏洞特征：SEAM_LOG_INJECTION<br>Seam Logging API支持表达式语言的解析，目的是引出bean的property到日志消息中去。源数据会利用表达式执行未期望的代码。<br>在这个代码片段里面，表达式语言被用来构建动态的值。源数据应该被严格的检验，以避免未过滤的时候进入到表达式的执行器中<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void logUser(User user) &#123;</span><br><span class="line">    log.info(&quot;Current logged in user : &quot; + user.getUsername());</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void logUser(User user) &#123;</span><br><span class="line">    log.info(&quot;Current logged in user : #0&quot;, user.getUsername());</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="https://issues.jboss.org/browse/JBSEAM-5130" target="_blank" rel="noopener">JBSEAM-5130: Issue documenting the risk</a><br><a href="https://docs.jboss.org/seam/2.3.1.Final/reference/html_single/#d0e4185" target="_blank" rel="noopener">JBoss Seam: Logging (Official documentation)</a><br><a href="https://docs.oracle.com/javaee/6/tutorial/doc/gjddd.html" target="_blank" rel="noopener">The Java EE 6 Tutorial: Expression Language</a><br><a href="http://cwe.mitre.org/data/definitions/94.html" target="_blank" rel="noopener">CWE-94: Improper Control of Generation of Code (‘Code Injection’)</a><br><a href="http://cwe.mitre.org/data/definitions/95.html" target="_blank" rel="noopener">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code (‘Eval Injection’)</a></p>
<h1 id="使用OGNL表达式时潜在的代码注入"><a href="#使用OGNL表达式时潜在的代码注入" class="headerlink" title="使用OGNL表达式时潜在的代码注入"></a>使用OGNL表达式时潜在的代码注入</h1><p>漏洞规则： OGNL_INJECTION<br>表达式语言被用来构建动态的值。源数据应该被严格的检验，以避免未过滤的时候进入到表达式的执行器中<br>有漏洞代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void getUserProperty(String property) &#123;</span><br><span class="line">  [...]</span><br><span class="line">  //The first argument is the dynamic expression.</span><br><span class="line">  return ognlUtil.getValue(&quot;user.&quot;+property, ctx, root, String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案<br>一般，解析OGNL表达式的函数不应该接收用户的输入。它旨在被用于静态配置和jsp。</p>
<p>引用：<br><a href="https://community.saas.hpe.com/t5/Security-Research/Struts-2-OGNL-Expression-Injections/ba-p/288881" target="_blank" rel="noopener">HP Enterprise: Struts 2 OGNL Expression Injections by Alvaro MuÃ±oz</a><br><a href="https://blog.gdssecurity.com/labs/2017/3/27/an-analysis-of-cve-2017-5638.html" target="_blank" rel="noopener">Gotham Digital Science: An Analysis Of CVE-2017-5638</a><br><a href="http://struts.apache.org/docs/s2-016.html" target="_blank" rel="noopener">Apache Struts2: Vulnerability S2-016</a><br><a href="https://struts.apache.org/docs/ognl.html" target="_blank" rel="noopener">Apache Struts 2 Documentation: OGNL</a></p>
<h1 id="潜在的http返回报文被分割"><a href="#潜在的http返回报文被分割" class="headerlink" title="潜在的http返回报文被分割"></a>潜在的http返回报文被分割</h1><p>漏洞特征：HTTP_RESPONSE_SPLITTING<br>当http请求包含未期望的CR 和 LF字符的时候，服务器可能会把返回的报文流解析成两个HTTP返回报文（而不是一个）。攻击者可以控制第二个报文并且发动诸如xss攻击或者缓存投毒攻击。按照OWASP的建议，实际上，这个问题现代java EE应用服务器所修复，但还是要严格检验输入。如果你关注这个漏洞，你应该测试你算关心的那个平台，看看这个平台是否允许CR或者 LF被注入到返回报文的头部中。这个漏洞常常被报告为低危，如果你使用有漏洞的平台，请仔细检查低危告警。<br>有漏洞代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String author = request.getParameter(AUTHOR_PARAMETER);</span><br><span class="line">// ...</span><br><span class="line">Cookie cookie = new Cookie(&quot;author&quot;, author);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>

<p>引用:<br><a href="https://www.owasp.org/index.php/HTTP_Response_Splitting" target="_blank" rel="noopener">OWASP: HTTP Response Splitting</a><br><a href="http://cwe.mitre.org/data/definitions/113.html" target="_blank" rel="noopener">CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers (‘HTTP Response Splitting’)</a><br><a href="http://cwe.mitre.org/data/definitions/93.html" target="_blank" rel="noopener">CWE-93: Improper Neutralization of CRLF Sequences (‘CRLF Injection’)</a></p>
<h1 id="在日志中潜在的CRLF注入"><a href="#在日志中潜在的CRLF注入" class="headerlink" title="在日志中潜在的CRLF注入"></a>在日志中潜在的CRLF注入</h1><p>漏洞规则：CRLF_INJECTION_LOGS<br>当未被信任的输入数据进入到日志中，并且没有正确的做过滤。那么攻击者就可以伪造日志数据或者包含恶意内容。插入恶意的实体通常被用于歪曲统计，分散管理员注意力，或者甚至暗示另一方有恶意行为。如果日志文件被一些自动化的程序自动处理，那么攻击者可以通过破坏文件格式使文件无法使用或者注入一些不被期望的特殊字符。攻击者也可能注入代码或者其他的命令到日志文件中，可能会利用日志处理程序中的漏洞（例如：命令注入或者xss）<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String val = request.getParameter(&quot;user&quot;);</span><br><span class="line">String metadata = request.getParameter(&quot;metadata&quot;);</span><br><span class="line">[...]</span><br><span class="line">if(authenticated) &#123;</span><br><span class="line">    log.info(&quot;User &quot; + val + &quot; (&quot; + metadata + &quot;) was authenticated successfully&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    log.info(&quot;User &quot; + val + &quot; (&quot; + metadata + &quot;) was not authenticated&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>恶意用户可能会发送这样的metadata数据：“Firefox) was authenticated successfully\r\n[INFO] User bbb (Internet Explorer”.</p>
<p>解决方案：<br>你要手工过滤每一个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(&quot;User &quot; + val.replaceAll(&quot;[\r\n]&quot;,&quot;&quot;) + &quot; (&quot; + userAgent.replaceAll(&quot;[\r\n]&quot;,&quot;&quot;) + &quot;) was not authenticated&quot;);</span><br></pre></td></tr></table></figure>

<p>你要配置日志服务器，目的是替换掉所有消息中的\r\n。 OWASP Security Logging已经在Logback 和 Log4j.实现了这个功能。<br>引用：<br><a href="http://cwe.mitre.org/data/definitions/117.html" target="_blank" rel="noopener">CWE-117: Improper Output Neutralization for Logs</a><br><a href="http://cwe.mitre.org/data/definitions/93.html" target="_blank" rel="noopener">CWE-93: Improper Neutralization of CRLF Sequences (‘CRLF Injection’)</a><br><a href="https://logback.qos.ch/manual/layouts.html#replace" target="_blank" rel="noopener">CWE-93: Improper Neutralization of CRLF Sequences (‘CRLF Injection’)</a><br><a href="https://github.com/javabeanz/owasp-security-logging" target="_blank" rel="noopener">OWASP Security Logging</a></p>
<h1 id="潜在的外部控制配置"><a href="#潜在的外部控制配置" class="headerlink" title="潜在的外部控制配置"></a>潜在的外部控制配置</h1><p>漏洞特征：EXTERNAL_CONFIG_CONTROL<br>允许外部控制系统设置会导致系统的中断或者导致应用行为异常，和潜在的恶意行为。攻击者通过提供不存在的catalog名称可能会导致错误，或者链接到未授权的数据库服务器。<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn.setCatalog(request.getParameter(&quot;catalog&quot;));</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="http://cwe.mitre.org/data/definitions/15.html" target="_blank" rel="noopener">CWE-15: External Control of System or Configuration Setting</a></p>
<h1 id="坏的十六进制数据"><a href="#坏的十六进制数据" class="headerlink" title="坏的十六进制数据"></a>坏的十六进制数据</h1><p>漏洞特征： BAD_HEXA_CONVERSION<br>当把十六进制字节数组转换为人类可读的字符串的时候，如果数组是被一个字节一个字节读取的话，可能会导致转换错误。下面这个例子是一个很明显的使用 Integer.toHexString() 做转换的例子，它可能会被字节码中的零字节所截断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MessageDigest md = MessageDigest.getInstance(&quot;SHA-256&quot;);</span><br><span class="line">byte[] resultBytes = md.digest(password.getBytes(&quot;UTF-8&quot;));</span><br><span class="line"></span><br><span class="line">StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">for(byte b :resultBytes) &#123;</span><br><span class="line">    stringBuilder.append( Integer.toHexString( b &amp; 0xFF ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return stringBuilder.toString();</span><br></pre></td></tr></table></figure>

<p>这个错误削弱了hash的计算值，因为它引入了更多的碰撞。比如，用上面的函数计算”0x0679” 和 “0x6709”都会输出679</p>
<p>在下面的解决方案中，使用String.format()替换toHexString()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringBuilder.append( String.format( &quot;%02X&quot;, b ) );</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="http://cwe.mitre.org/data/definitions/704.html" target="_blank" rel="noopener">CWE-704: Incorrect Type Conversion or Cast</a></p>
<h1 id="Hazelcast对称加密"><a href="#Hazelcast对称加密" class="headerlink" title="Hazelcast对称加密"></a>Hazelcast对称加密</h1><p>漏洞规则： HAZELCAST_SYMMETRIC_ENCRYPTION<br>配置Hazelcast让网络通信使用对称加密（可能是DES或者其他的）<br>密码本身不能提供完整性和身份验证。使用非对称加密会更好一些</p>
<p>引用：<br>[WASC-04: Insufficient Transport Layer Protection](<a href="http://projects.webappsec.org/w/page/13246945/Insufficient" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246945/Insufficient</a> Transport Layer Protection)<br><a href="http://docs.hazelcast.org/docs/3.5/manual/html/encryption.html" target="_blank" rel="noopener">Hazelcast Documentation: Encryption</a><br><a href="http://cwe.mitre.org/data/definitions/326.html" target="_blank" rel="noopener">CWE-326: Inadequate Encryption Strength</a></p>
<h1 id="不安全的空密码"><a href="#不安全的空密码" class="headerlink" title="不安全的空密码"></a>不安全的空密码</h1><p>漏洞特征： NULL_CIPHER<br>空密码很少被使用在生产环境中。它通过返回与明文相同的密文来实现Cipher接口。在极少的环境中，比如测试环境，才可能会出现空密码<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cipher doNothingCihper = new NullCipher();</span><br><span class="line">[...]</span><br><span class="line">//The ciphertext produced will be identical to the plaintext.</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure>

<p>解决方案<br>避免使用空密码，意外的使用会导致严重的安全风险。<br>引用：<br><a href="http://cwe.mitre.org/data/definitions/327.html" target="_blank" rel="noopener">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a></p>
<p>未加密的socket<br>漏洞特征：UNENCRYPTED_SOCKET<br>如果网络通信不加密的话，那么传输的数据就会被攻击者拦截并读取里面的内容。<br>有漏洞的代码：<br>明文socket（透明传输）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket soc = new Socket(&quot;www.google.com&quot;,80);</span><br></pre></td></tr></table></figure>

<p>解决方案：<br>ssl socket（加密传输）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket soc = SSLSocketFactory.getDefault().createSocket(&quot;www.google.com&quot;, 443);</span><br></pre></td></tr></table></figure>

<p>使用sslsocket，你需要确保你使用的SSLSocketFactory能验证所提供的证书是否有效，这样你就不会遭受中间人攻击。请阅读owasp中关于传输层协议的那一章，以了解更多正确的做法。</p>
<p>引用：<br><a href="https://www.owasp.org/index.php/Top_10_2010-A9" target="_blank" rel="noopener">OWASP: Top 10 2010-A9-Insufficient Transport Layer Protection</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure" target="_blank" rel="noopener">OWASP: Top 10 2013-A6-Sensitive Data Exposure</a><br><a href="https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Transport Layer Protection Cheat Sheet</a><br>[WASC-04: Insufficient Transport Layer Protection](<a href="http://projects.webappsec.org/w/page/13246945/Insufficient" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246945/Insufficient</a> Transport Layer Protection)<br><a href="http://cwe.mitre.org/data/definitions/319.html" target="_blank" rel="noopener">CWE-319: Cleartext Transmission of Sensitive Information</a></p>
<h1 id="未加密的服务器socket"><a href="#未加密的服务器socket" class="headerlink" title="未加密的服务器socket"></a>未加密的服务器socket</h1><p>漏洞特征：UNENCRYPTED_SERVER_SOCKET</p>
<p>如果网络通信不加密的话，那么传输的数据就会被攻击者拦截并读取里面的内容。<br>有漏洞的代码：<br>明文socket（透明传输）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket soc = new ServerSocket(1234);</span><br></pre></td></tr></table></figure>

<p>解决方案：<br>ssl socket（加密传输）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket soc = SSLServerSocketFactory.getDefault().createServerSocket(1234);</span><br></pre></td></tr></table></figure>

<p>使用sslsocket，你需要确保你使用的SSLSocketFactory能验证所提供的证书是否有效，这样你就不会遭受中间人攻击。请阅读owasp中关于传输层协议的那一章，以了解更多正确的做法。</p>
<p>引用：<br><a href="https://www.owasp.org/index.php/Top_10_2010-A9" target="_blank" rel="noopener">OWASP: Top 10 2010-A9-Insufficient Transport Layer Protection</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure" target="_blank" rel="noopener">OWASP: Top 10 2013-A6-Sensitive Data Exposure</a><br><a href="https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Transport Layer Protection Cheat Sheet</a><br>[WASC-04: Insufficient Transport Layer Protection](<a href="http://projects.webappsec.org/w/page/13246945/Insufficient" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246945/Insufficient</a> Transport Layer Protection)<br><a href="http://cwe.mitre.org/data/definitions/319.html" target="_blank" rel="noopener">CWE-319: Cleartext Transmission of Sensitive Information</a></p>
<h1 id="DES是不安全的"><a href="#DES是不安全的" class="headerlink" title="DES是不安全的"></a>DES是不安全的</h1><p>漏洞特征：DES_USAGE</p>
<p>DES被认为是现代加密系统中比较强壮的加密方式，当前，NIST建议使用AES block ciphers来替代DES<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;DES/ECB/PKCS5Padding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure>

<p>解决方案示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="http://www.nist.gov/itl/fips/060205_des.cfm" target="_blank" rel="noopener">NIST Withdraws Outdated Data Encryption Standard</a><br><a href="http://cwe.mitre.org/data/definitions/326.html" target="_blank" rel="noopener">CWE-326: Inadequate Encryption Strength</a></p>
<h1 id="DESede是不安全的"><a href="#DESede是不安全的" class="headerlink" title="DESede是不安全的"></a>DESede是不安全的</h1><p>漏洞特征:TDES_USAGE</p>
<p>三次DES（也被称为3DES 或者 DESede）被认为是现代加密系统中比较强壮的加密方式，当前，NIST建议使用AES block ciphers来替代DES<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure>

<p>解决方案示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="http://www.nist.gov/itl/fips/060205_des.cfm" target="_blank" rel="noopener">NIST Withdraws Outdated Data Encryption Standard</a><br><a href="http://cwe.mitre.org/data/definitions/326.html" target="_blank" rel="noopener">CWE-326: Inadequate Encryption Strength</a></p>
<h1 id="不用padding的RSA是不安全的"><a href="#不用padding的RSA是不安全的" class="headerlink" title="不用padding的RSA是不安全的"></a>不用padding的RSA是不安全的</h1><p>漏洞特征：RSA_NO_PADDING</p>
<p>软件使用RSA加密算法但是没有使用非对称加密填充(OAEP), 这种加密可能会是比较脆弱的<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cipher.getInstance(&quot;RSA/NONE/NoPadding&quot;)</span><br></pre></td></tr></table></figure>

<p>解决方案：<br>应该用下面的代码来替换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cipher.getInstance(&quot;RSA/ECB/OAEPWithMD5AndMGF1Padding&quot;)</span><br></pre></td></tr></table></figure>

<p>引用:<br><a href="http://cwe.mitre.org/data/definitions/780.html" target="_blank" rel="noopener">CWE-780: Use of RSA Algorithm without OAEP</a><br><a href="http://rdist.root.org/2009/10/06/why-rsa-encryption-padding-is-critical/" target="_blank" rel="noopener">Root Labs: Why RSA encryption padding is critical</a></p>
<h1 id="硬编码密码"><a href="#硬编码密码" class="headerlink" title="硬编码密码"></a>硬编码密码</h1><p>漏洞特征：HARD_CODE_PASSWORD<br>密码不应该留在源码里面，在企业里面源码会被广泛的分享，有些部分甚至会被开源出来，为了更安全的管理，密码和密钥应该被单独的存储在配置文件中，或者keystores中（硬编码密钥会有一个单独的特征：Hard Coded Key pattern)<br>有漏洞的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private String SECRET_PASSWORD = &quot;letMeIn!&quot;;</span><br><span class="line"></span><br><span class="line">Properties props = new Properties();</span><br><span class="line">props.put(Context.SECURITY_CREDENTIALS, &quot;p@ssw0rd&quot;);</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="http://cwe.mitre.org/data/definitions/259.html" target="_blank" rel="noopener">CWE-259: Use of Hard-coded Password</a></p>
<h1 id="硬编码密钥"><a href="#硬编码密钥" class="headerlink" title="硬编码密钥"></a>硬编码密钥</h1><p>漏洞特征： HARD_CODE_KEY<br>加密密钥不应该留在源码里面，在企业里面源码会被广泛的分享，有些部分甚至会被开源出来，为了更安全的管理，密码和密钥应该被单独的存储在配置文件中，或者keystores中（硬编码密码会有一个单独的特征：Hard Coded Password pattern)<br>有漏洞的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte[] key = &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;;</span><br><span class="line">SecretKeySpec spec = new SecretKeySpec(key, &quot;AES&quot;);</span><br><span class="line">Cipher aes = Cipher.getInstance(&quot;AES&quot;);</span><br><span class="line">aes.init(Cipher.ENCRYPT_MODE, spec);</span><br><span class="line">return aesCipher.doFinal(secretData);</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="http://cwe.mitre.org/data/definitions/321.html" target="_blank" rel="noopener">CWE-321: Use of Hard-coded Cryptographic Key</a></p>
<h1 id="不安全的hash比较"><a href="#不安全的hash比较" class="headerlink" title="不安全的hash比较"></a>不安全的hash比较</h1><p>漏洞特征：UNSAFE_HASH_EQUALS<br>攻击者可能会通过密钥的比较时间来发现密钥的hash值，当Arrays.equals() 或者 String.equals()被调用的时候，如果有一些字节被匹配到的话，它们会推出的更早一些<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String actualHash = ...</span><br><span class="line"></span><br><span class="line">if(userInput.equals(actualHash)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String actualHash = ...</span><br><span class="line"></span><br><span class="line">if(MessageDigest.isEqual(userInput.getBytes(),actualHash.getBytes())) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="https://cwe.mitre.org/data/definitions/203.html" target="_blank" rel="noopener">CWE-203: Information Exposure Through DiscrepancyKey</a></p>
<h1 id="来自Struts-Form的输入没有被验证"><a href="#来自Struts-Form的输入没有被验证" class="headerlink" title="来自Struts Form的输入没有被验证"></a>来自Struts Form的输入没有被验证</h1><p>漏洞特征： STRUTS_FORM_VALIDATION<br>来自Form的输入应该被简单的验证一下，预防性的验证能够抵御更进一步的攻击。<br>validate这个函数引入了验证的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class RegistrationForm extends ValidatorForm &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String email;</span><br><span class="line"></span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">    public ActionErrors validate(ActionMapping mapping, HttpServletRequest request) &#123;</span><br><span class="line">        //Validation code for name and email parameters passed in via the HttpRequest goes here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a><br><a href="http://cwe.mitre.org/data/definitions/106.html" target="_blank" rel="noopener">CWE-106: Struts: Plug-in Framework not in Use</a></p>
<h1 id="XSSRequestWrapper的xss防护是脆弱的"><a href="#XSSRequestWrapper的xss防护是脆弱的" class="headerlink" title="XSSRequestWrapper的xss防护是脆弱的"></a>XSSRequestWrapper的xss防护是脆弱的</h1><p>漏洞特征：XSS_REQUEST_WRAPPER<br>在各种公开的博客里面，博主通过实现HttpServletRequestWrapper调用XSSRequestWrapper<br>这个过滤函数的脆弱点在于以下的几个方面：</p>
<ul>
<li>它仅仅覆盖参数，而没有覆盖到http头或者侧信道输入 。</li>
<li>简单替换的方式很容易会被绕过（见下面的例子）</li>
<li>黑名单的方式太脆弱（不如用白名单的方式来验证好的输入）</li>
</ul>
<p>绕过示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scrivbscript:pt&gt;alert(1)&lt;/scrivbscript:pt&gt;</span><br></pre></td></tr></table></figure>

<p>上面的输入会被转换为：<code>alert(1)</code>。移除了vbscript:”之后就变成了<code>&quot;.*&quot;</code></p>
<p>为了更强的保护，请在view (template, jsp, …) 中选择自动编码字符串的解决方案，解决方案里面的规则被定义在OWASP XSS Prevention 备忘录中。<br>引用：<br>[WASC-8: Cross Site Scripting](<a href="http://projects.webappsec.org/w/page/13246920/Cross" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246920/Cross</a> Site Scripting)<br><a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: XSS Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_(XSS)" target="_blank" rel="noopener">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br><a href="http://cwe.mitre.org/data/definitions/79.html" target="_blank" rel="noopener">CWE-79: Improper Neutralization of Input During Web Page Generation (‘Cross-site Scripting’)</a></p>
<h1 id="Blowfish-使用过短的密钥"><a href="#Blowfish-使用过短的密钥" class="headerlink" title="Blowfish 使用过短的密钥"></a>Blowfish 使用过短的密钥</h1><p>漏洞特征：BLOWFISH_KEY_SIZE<br>Blowfish的密钥支持32 bits 到 448 bits的长度。如果密钥太短，会导致加密内容被黑客暴力破解。如果使用Blowfish的话，密钥至少应该选择128 bits 。<br>如果算法被改变，那么应该AES分组密码</p>
<p>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KeyGenerator keyGen = KeyGenerator.getInstance(&quot;Blowfish&quot;);</span><br><span class="line">keyGen.init(64);</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KeyGenerator keyGen = KeyGenerator.getInstance(&quot;Blowfish&quot;);</span><br><span class="line">keyGen.init(128);</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="http://en.wikipedia.org/wiki/Blowfish_(cipher)" target="_blank" rel="noopener">Blowfish (cipher)</a><br><a href="http://cwe.mitre.org/data/definitions/326.html" target="_blank" rel="noopener">CWE-326: Inadequate Encryption Strength</a></p>
<h1 id="RSA使用了过短密钥"><a href="#RSA使用了过短密钥" class="headerlink" title="RSA使用了过短密钥"></a>RSA使用了过短密钥</h1><p>漏洞特征: RSA_KEY_SIZE<br>NIST建议RSA算法应该使用2048bits的密钥或者更长的密钥<br>“电子签名验证 | RSA: 1024 ≤ len(n) &lt; 2048 | 传统使用”<br>“电子签名验证 | RSA: len(n) ≥ 2048 | 可接受”</p>
<ul>
<li>NIST: <a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf" target="_blank" rel="noopener">数据传输建议使用的加密方式和密钥长度 p.7</a></li>
</ul>
<p>漏洞代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line">keyGen.initialize(512);</span><br></pre></td></tr></table></figure>

<p>解决方案：<br>密钥的生成至少应该像下面这样使用2048位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line">keyGen.initialize(2048);</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="http://csrc.nist.gov/groups/ST/toolkit/key_management.html" target="_blank" rel="noopener">NIST: Latest publication on key management</a><br><a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf" target="_blank" rel="noopener">NIST: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths p.7</a><br><a href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/how-large-a-key-should-be-used.htm" target="_blank" rel="noopener">RSA Laboratories: 3.1.5 How large a key should be used in the RSA cryptosystem?</a><br><a href="http://en.wikipedia.org/wiki/Key_size#Asymmetric_algorithm_key_lengths" target="_blank" rel="noopener">Wikipedia: Asymmetric algorithm key lengths</a><br><a href="http://cwe.mitre.org/data/definitions/326.html" target="_blank" rel="noopener">CWE-326: Inadequate Encryption Strength</a><br><a href="http://www.keylength.com/en/compare/" target="_blank" rel="noopener">Keylength.com (BlueKrypt): Aggregate key length recommendations.</a></p>
<h1 id="未验证的重定向"><a href="#未验证的重定向" class="headerlink" title="未验证的重定向"></a>未验证的重定向</h1><p>漏洞特征：UNVALIDATED_REDIRECT<br>未验证重定向漏洞是因为应用跳转到用户输入的指定目标url，这个输入的参数没有被充分的验证。这个漏洞可能会被用来钓鱼</p>
<p>假设的场景：</p>
<ol>
<li>用户被欺骗点了恶意链接：<a href="http://website.com/login?redirect=http://evil.vvebsite.com/fake/login" target="_blank" rel="noopener">http://website.com/login?redirect=http://evil.vvebsite.com/fake/login</a></li>
<li>用户被重定向到了一个虚假的登录页面，这样页面看起来就像真的一样(<a href="http://evil.vvebsite.com/fake/login" target="_blank" rel="noopener">http://evil.vvebsite.com/fake/login</a>)</li>
<li>用户输入了他的凭据</li>
<li>恶意网站偷走了用户的凭据，并且跳转回了原来的网站</li>
</ol>
<p>这个攻击貌似是合理的，因为大多数用户在被重定向之后不会再次检查url。而且跳转到授权页面也是很普遍的现象。<br>漏洞代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    [...]</span><br><span class="line">    resp.sendRedirect(req.getParameter(&quot;redirectUrl&quot;));</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案/对策</p>
<ul>
<li>不要从用户的输入中接受重定向的目的url</li>
<li>接受一个目的地址的key，这个key可以查询到一个合法的目的地址。</li>
<li>仅接受相对路径</li>
<li>urls白名单（如果可行的话）</li>
<li>验证url开始的部分是否在白名单里面</li>
</ul>
<p>引用：<br>[WASC-38: URL Redirector Abuse](<a href="http://projects.webappsec.org/w/page/13246981/URL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246981/URL</a> Redirector Abuse)<br><a href="https://www.owasp.org/index.php/Top_10_2013-A10-Unvalidated_Redirects_and_Forwards" target="_blank" rel="noopener">OWASP: Top 10 2013-A10: Unvalidated Redirects and Forwards</a><br><a href="https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Unvalidated Redirects and Forwards Cheat Sheet</a><br><a href="http://cwe.mitre.org/data/definitions/601.html" target="_blank" rel="noopener">CWE-601: URL Redirection to Untrusted Site (‘Open Redirect’)</a></p>
<h1 id="未验证的重定向-Play-Framework"><a href="#未验证的重定向-Play-Framework" class="headerlink" title="未验证的重定向(Play Framework)"></a>未验证的重定向(Play Framework)</h1><p>漏洞特征：PLAY_UNVALIDATED_REDIRECT<br>未验证重定向漏洞是因为应用跳转到用户输入的指定目标url，这个输入的参数没有被充分的验证。这个漏洞可能会被用来钓鱼</p>
<p>假设的场景：</p>
<ol>
<li>用户被欺骗点了恶意链接：<a href="http://website.com/login?redirect=http://evil.vvebsite.com/fake/login" target="_blank" rel="noopener">http://website.com/login?redirect=http://evil.vvebsite.com/fake/login</a></li>
<li>用户被重定向到了一个虚假的登录页面，这样页面看起来就像真的一样(<a href="http://evil.vvebsite.com/fake/login" target="_blank" rel="noopener">http://evil.vvebsite.com/fake/login</a>)</li>
<li>用户输入了他的凭据</li>
<li>恶意网站偷走了用户的凭据，并且跳转回了原来的网站</li>
</ol>
<p>这个攻击貌似是合理的，因为大多数用户在被重定向之后不会再次检查url。而且跳转到授权页面也是很普遍的现象。<br>漏洞代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def login(redirectUrl:String) = Action &#123;</span><br><span class="line">    [...]</span><br><span class="line">    Redirect(url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案/对策</p>
<ul>
<li>不要从用户的输入中接受重定向的目的url</li>
<li>接受一个目的地址的key，这个key可以查询到一个合法的目的地址。</li>
<li>仅接受相对路径</li>
<li>urls白名单（如果可行的话）</li>
<li>验证url开始的部分是否在白名单里面</li>
</ul>
<p>引用：<br>[WASC-38: URL Redirector Abuse](<a href="http://projects.webappsec.org/w/page/13246981/URL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246981/URL</a> Redirector Abuse)<br><a href="https://www.owasp.org/index.php/Top_10_2013-A10-Unvalidated_Redirects_and_Forwards" target="_blank" rel="noopener">OWASP: Top 10 2013-A10: Unvalidated Redirects and Forwards</a><br><a href="https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Unvalidated Redirects and Forwards Cheat Sheet</a><br><a href="http://cwe.mitre.org/data/definitions/601.html" target="_blank" rel="noopener">CWE-601: URL Redirection to Untrusted Site (‘Open Redirect’)</a></p>
<h1 id="Spring中未验证的重定向"><a href="#Spring中未验证的重定向" class="headerlink" title="Spring中未验证的重定向"></a>Spring中未验证的重定向</h1><p>漏洞特征：SPRING_UNVALIDATED_REDIRECT<br>未验证重定向漏洞是因为应用跳转到用户输入的指定目标url，这个输入的参数没有被充分的验证。这个漏洞可能会被用来钓鱼</p>
<p>假设的场景：</p>
<ol>
<li>用户被欺骗点了恶意链接：<a href="http://website.com/login?redirect=http://evil.vvebsite.com/fake/login" target="_blank" rel="noopener">http://website.com/login?redirect=http://evil.vvebsite.com/fake/login</a></li>
<li>用户被重定向到了一个虚假的登录页面，这样页面看起来就像真的一样(<a href="http://evil.vvebsite.com/fake/login" target="_blank" rel="noopener">http://evil.vvebsite.com/fake/login</a>)</li>
<li>用户输入了他的凭据</li>
<li>恶意网站偷走了用户的凭据，并且跳转回了原来的网站</li>
</ol>
<p>这个攻击貌似是合理的，因为大多数用户在被重定向之后不会再次检查url。而且跳转到授权页面也是很普遍的现象。<br>漏洞代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/redirect&quot;)</span><br><span class="line">public String redirect(@RequestParam(&quot;url&quot;) String url) &#123;</span><br><span class="line">    [...]</span><br><span class="line">    return &quot;redirect:&quot; + url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案/对策</p>
<ul>
<li>不要从用户的输入中接受重定向的目的url</li>
<li>接受一个目的地址的key，这个key可以查询到一个合法的目的地址。</li>
<li>仅接受相对路径</li>
<li>urls白名单（如果可行的话）</li>
<li>验证url开始的部分是否在白名单里面</li>
</ul>
<p>引用：<br>[WASC-38: URL Redirector Abuse](<a href="http://projects.webappsec.org/w/page/13246981/URL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246981/URL</a> Redirector Abuse)<br><a href="https://www.owasp.org/index.php/Top_10_2013-A10-Unvalidated_Redirects_and_Forwards" target="_blank" rel="noopener">OWASP: Top 10 2013-A10: Unvalidated Redirects and Forwards</a><br><a href="https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Unvalidated Redirects and Forwards Cheat Sheet</a><br><a href="http://cwe.mitre.org/data/definitions/601.html" target="_blank" rel="noopener">CWE-601: URL Redirection to Untrusted Site (‘Open Redirect’)</a></p>
<h1 id="jsp动态包含"><a href="#jsp动态包含" class="headerlink" title="jsp动态包含"></a>jsp动态包含</h1><p>漏洞特征：JSP_INCLUDE<br>jsp允许动态包含文件。这可能允许攻击者控制jsp的文件包含。如果出现这样的漏洞的话，攻击者就会包含一个他能控制到的文件。通过直接包含文件，攻击者就能执行任意代码。<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page=&quot;$&#123;param.secret_param&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:if test=&quot;$&#123;param.secret_param == &apos;page1&apos;&#125;&quot;&gt;</span><br><span class="line">    &lt;jsp:include page=&quot;page1.jsp&quot; /&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure>

<p>引用：</p>
<p><a href="http://resources.infosecinstitute.com/file-inclusion-attacks/" target="_blank" rel="noopener">InfosecInstitute: File Inclusion Attacks</a><br>[WASC-05: Remote File Inclusion](<a href="http://projects.webappsec.org/w/page/13246955/Remote" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246955/Remote</a> File Inclusion)</p>
<h1 id="Spring-表达式中的动态变量"><a href="#Spring-表达式中的动态变量" class="headerlink" title="Spring 表达式中的动态变量"></a>Spring 表达式中的动态变量</h1><p>漏洞特征：JSP_SPRING_EVAL<br>Spring使用动态值构建。应该严格检验源数据，以避免未过滤的数据进入到危险函数中。<br>有漏洞的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;spring&quot; uri=&quot;http://www.springframework.org/tags&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;spring:eval expression=&quot;$&#123;param.lang&#125;&quot; var=&quot;lang&quot; /&gt;</span><br><span class="line">&lt;%@ taglib prefix=&quot;spring&quot; uri=&quot;http://www.springframework.org/tags&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;spring:eval expression=&quot;&apos;$&#123;param.lang&#125;&apos;==&apos;fr&apos;&quot; var=&quot;languageIsFrench&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set var=&quot;lang&quot; value=&quot;$&#123;param.lang&#125;&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:set var=&quot;languageIsFrench&quot; value=&quot;$&#123;param.lang == &apos;fr&apos;&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="http://cwe.mitre.org/data/definitions/94.html" target="_blank" rel="noopener">CWE-94: Improper Control of Generation of Code (‘Code Injection’)</a><br><a href="http://cwe.mitre.org/data/definitions/95.html" target="_blank" rel="noopener">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code (‘Eval Injection’)</a></p>
<h1 id="xml字符转义被禁用"><a href="#xml字符转义被禁用" class="headerlink" title="xml字符转义被禁用"></a>xml字符转义被禁用</h1><p>漏洞特征：JSP_JSTL_OUT<br>可能会有潜在的xss漏洞。这可能会在客户端执行未期望的JavaScript。（见引用）<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:out value=&quot;$&#123;param.test_param&#125;&quot; escapeXml=&quot;false&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:out value=&quot;$&#123;param.test_param&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>引用：<br>[WASC-8: Cross Site Scripting](<a href="http://projects.webappsec.org/w/page/13246920/Cross" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246920/Cross</a> Site Scripting)<br><a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: XSS Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_(XSS)" target="_blank" rel="noopener">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br><a href="http://cwe.mitre.org/data/definitions/79.html" target="_blank" rel="noopener">CWE-79: Improper Neutralization of Input During Web Page Generation (‘Cross-site Scripting’)</a><br><a href="http://docs.oracle.com/javaee/5/jstl/1.1/docs/tlddocs/c/out.html" target="_blank" rel="noopener">JSTL Javadoc: Out tag</a></p>
<h1 id="jsp中潜在的xss"><a href="#jsp中潜在的xss" class="headerlink" title="jsp中潜在的xss"></a>jsp中潜在的xss</h1><p>漏洞特征：XSS_JSP_PRINT<br>可能会有潜在的xss漏洞。这可能会在客户端执行未期望的JavaScript。（见引用）<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">String taintedInput = (String) request.getAttribute(&quot;input&quot;);</span><br><span class="line">%&gt;</span><br><span class="line">[...]</span><br><span class="line">&lt;%= taintedInput %&gt;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">String taintedInput = (String) request.getAttribute(&quot;input&quot;);</span><br><span class="line">%&gt;</span><br><span class="line">[...]</span><br><span class="line">&lt;%= Encode.forHtml(taintedInput) %&gt;</span><br></pre></td></tr></table></figure>

<p>抵御xss最好的方式是像上面在输出中编码特殊的字符。有4种环境类型要考虑：HTML, JavaScript, CSS (styles), 和URLs.请遵守OWASP XSS Prevention备忘录中定义的xss保护规则，里面会介绍一些防御的细节。<br>引用：<br>[WASC-8: Cross Site Scripting](<a href="http://projects.webappsec.org/w/page/13246920/Cross" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246920/Cross</a> Site Scripting)<br><a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: XSS Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_(XSS)" target="_blank" rel="noopener">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br><a href="http://cwe.mitre.org/data/definitions/79.html" target="_blank" rel="noopener">CWE-79: Improper Neutralization of Input During Web Page Generation (‘Cross-site Scripting’)</a><br><a href="https://code.google.com/p/owasp-java-encoder/" target="_blank" rel="noopener">OWASP Java Encoder</a></p>
<h1 id="Servlet中潜在的xss"><a href="#Servlet中潜在的xss" class="headerlink" title="Servlet中潜在的xss"></a>Servlet中潜在的xss</h1><p>漏洞特征：XSS_SERVLET<br>可能会有潜在的xss漏洞。这可能会在客户端执行未期望的JavaScript。（见引用）<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    String input1 = req.getParameter(&quot;input1&quot;);</span><br><span class="line">    [...]</span><br><span class="line">    resp.getWriter().write(input1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    String input1 = req.getParameter(&quot;input1&quot;);</span><br><span class="line">    [...]</span><br><span class="line">    resp.getWriter().write(Encode.forHtml(input1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抵御xss最好的方式是像上面在输出中编码特殊的字符。有4种环境类型要考虑：HTML, JavaScript, CSS (styles), 和URLs.请遵守OWASP XSS Prevention备忘录中定义的xss保护规则，里面会介绍一些防御的细节。<br>注意Servlet中的xss规则看着都很类似，但是要用不同的规则寻找‘XSS：Servlet反射型xss’和‘xss:在Servlet错误页面中反射型xss’</p>
<p>引用：<br>[WASC-8: Cross Site Scripting](<a href="http://projects.webappsec.org/w/page/13246920/Cross" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246920/Cross</a> Site Scripting)<br><a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: XSS Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_(XSS)" target="_blank" rel="noopener">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br><a href="http://cwe.mitre.org/data/definitions/79.html" target="_blank" rel="noopener">CWE-79: Improper Neutralization of Input During Web Page Generation (‘Cross-site Scripting’)</a><br><a href="https://code.google.com/p/owasp-java-encoder/" target="_blank" rel="noopener">OWASP Java Encoder</a></p>
<h1 id="XMLDecoder的使用"><a href="#XMLDecoder的使用" class="headerlink" title="XMLDecoder的使用"></a>XMLDecoder的使用</h1><p>漏洞规则：XML_DECODER<br>不应该用XMLDecoder解析不受信任的数据。反序列化用户输入数据会导致代码执行。这是因为XMLDecoder 支持任意的方法调用。这个功能旨在调用setter方法，但是实际上，这个功能什么方法都能调用。<br>恶意的xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;</span><br><span class="line">  &lt;object class=&quot;java.io.PrintWriter&quot;&gt;</span><br><span class="line">    &lt;string&gt;/tmp/Hacked.txt&lt;/string&gt;</span><br><span class="line">    &lt;void method=&quot;println&quot;&gt;</span><br><span class="line">      &lt;string&gt;Hello World!&lt;/string&gt;</span><br><span class="line">    &lt;/void&gt;</span><br><span class="line">    &lt;void method=&quot;close&quot;/&gt;</span><br><span class="line">  &lt;/object&gt;</span><br><span class="line">&lt;/java&gt;</span><br></pre></td></tr></table></figure>

<p>上面这个xml代码可能会在服务器中创建一个内容为”Hello World!”.的文件。</p>
<p>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XMLDecoder d = new XMLDecoder(in);</span><br><span class="line">try &#123;</span><br><span class="line">    Object result = d.readObject();</span><br><span class="line">&#125;</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<p>解决方案：<br>解决方案是避免使用XMLDecoder去解析不受信任的用户输入数据</p>
<p>引用：<br><a href="http://blog.diniscruz.com/2013/08/using-xmldecoder-to-execute-server-side.html" target="_blank" rel="noopener">Dinis Cruz Blog: Using XMLDecoder to execute server-side Java Code on an Restlet application</a><br><a href="https://securityblog.redhat.com/2014/01/23/java-deserialization-flaws-part-2-xml-deserialization/" target="_blank" rel="noopener">RedHat blog : Java deserialization flaws: Part 2, XML deserialization</a><br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p>
<h1 id="固定IV"><a href="#固定IV" class="headerlink" title="固定IV"></a>固定IV</h1><p>漏洞规则：STATIC_IV<br>每一条消息都应该为它初始化生成一个新的加密向量<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static byte[] IV = new byte[16] &#123;(byte)0,(byte)1,(byte)2,[...]&#125;;</span><br><span class="line"></span><br><span class="line">public void encrypt(String message) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    IvParameterSpec ivSpec = new IvParameterSpec(IV);</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<p>解决方案:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void encrypt(String message) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    byte[] iv = new byte[16];</span><br><span class="line">    new SecureRandom().nextBytes(iv);</span><br><span class="line"></span><br><span class="line">    IvParameterSpec ivSpec = new IvParameterSpec(iv);</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="http://en.wikipedia.org/wiki/Initialization_vector" target="_blank" rel="noopener">Wikipedia: Initialization vector</a><br><a href="http://cwe.mitre.org/data/definitions/329.html" target="_blank" rel="noopener">CWE-329: Not Using a Random IV with CBC Mode</a><br><a href="https://defuse.ca/cbcmodeiv.htm" target="_blank" rel="noopener">Encryption - CBC Mode IV: Secret or Not?</a></p>
<h1 id="ECB模式是不安全的"><a href="#ECB模式是不安全的" class="headerlink" title="ECB模式是不安全的"></a>ECB模式是不安全的</h1><p>漏洞规则： ECB_MODE</p>
<p>提供了最好机密性的授权加密模式应该替换电码本模式(Electronic Codebook Book (ECB))，因为ecb没有提供很好的机密性。尤其，在ecb模式下，输入相同的数据，每一次的输出也是相同的。所以，如果用户发送一个密码，它的加密值每次都是相同的。这允许攻击者可以去拦截并且也可也重放这些数据<br>为了修复这个。一些像Galois/Counter Mode (GCM)也应该被替换<br>有漏洞的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/ECB/NoPadding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="http://en.wikipedia.org/wiki/Authenticated_encryption" target="_blank" rel="noopener">Wikipedia: Authenticated encryption</a><br><a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01" target="_blank" rel="noopener">NIST: Authenticated Encryption Modes</a><br><a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29" target="_blank" rel="noopener">Wikipedia: Block cipher modes of operation</a><br><a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf" target="_blank" rel="noopener">NIST: Recommendation for Block Cipher Modes of Operation</a></p>
<h1 id="加密容易受到Padding-Oracle的影响"><a href="#加密容易受到Padding-Oracle的影响" class="headerlink" title="加密容易受到Padding Oracle的影响"></a>加密容易受到Padding Oracle的影响</h1><p>漏洞特征：PADDING_ORACLE<br>具有PKCS5Padding的CBC特定模式容易受到padding oracle攻击。如果系统暴露了的明文数据与有效padding或无效padding之间的差异。那么攻击者就可能会解密数据。有效padding和无效padding的差别通常可以通过每一次返回的报错信息来揭露。<br>有漏洞的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf" target="_blank" rel="noopener">Padding Oracles for the masses (by Matias Soler)</a><br><a href="http://en.wikipedia.org/wiki/Authenticated_encryption" target="_blank" rel="noopener">Wikipedia: Authenticated encryption</a><br><a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01/" target="_blank" rel="noopener">NIST: Authenticated Encryption Modes</a><br><a href="http://capec.mitre.org/data/definitions/463.html" target="_blank" rel="noopener">CAPEC: Padding Oracle Crypto Attack</a><br><a href="http://cwe.mitre.org/data/definitions/696.html" target="_blank" rel="noopener">CWE-696: Incorrect Behavior Order</a></p>
<h1 id="密码没有完整性"><a href="#密码没有完整性" class="headerlink" title="密码没有完整性"></a>密码没有完整性</h1><p>漏洞特征：CIPHER_INTEGRITY<br>产生的密文容易被对手改变。这就意味着，加密提供者没法发现数据是否遭到篡改。如果加密数据被攻击者控制，那么它可能会被偷偷改掉。<br>解决方案通常是加密数据通常包含基本的身份验证hash(HMAC) 去签名数据。把HMAC方法和现有的加密方式结合容易出错。尤其，推荐你要首先去验证HMAC，并且如果数据没有被篡改，你才能执行所有的解密操作。<br>如果没有提供HMAC，下面的模式都是有漏洞的：</p>
<ul>
<li>CBC</li>
<li>OFB</li>
<li>CTR</li>
<li>ECB<br>下面的片段是一些有漏洞的代码:<br>有漏洞的代码<br>aes的cbc模式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure>

<p>三次DES的ECB模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure>

<p>在上面这个例子中，GCM模式把HMAC引入到加密数据的结果之中，提供了结果的完整性<br>引用：<br><a href="http://en.wikipedia.org/wiki/Authenticated_encryption" target="_blank" rel="noopener">Wikipedia: Authenticated encryption</a><br><a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01" target="_blank" rel="noopener">NIST: Authenticated Encryption Modes</a><br><a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/" target="_blank" rel="noopener">Moxie Marlinspike’s blog: The Cryptographic Doom Principle</a><br><a href="http://cwe.mitre.org/data/definitions/353.html" target="_blank" rel="noopener">CWE-353: Missing Support for Integrity Check</a></p>
<h1 id="使用ESAPI加密"><a href="#使用ESAPI加密" class="headerlink" title="使用ESAPI加密"></a>使用ESAPI加密</h1><p>漏洞规则：ESAPI_ENCRYPTOR<br>ESAPI的加密组件在历史上有一些小的漏洞。这里有一个能够快速验证的列表，以保证授权的加密是以期望的方式运行的。</p>
<ol>
<li>库的版本</li>
</ol>
<p>这个问题在2.1.0这个版本被修正。在2.0.1版本以下有漏洞可以绕过MAC（CVE-2013-5679）<br>对于Maven使用者，使用下面的命令可以查看插件的版本。有效的ESAPI将会被输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn versions:display-dependency-updates</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">[INFO] The following dependencies in Dependencies have newer versions:</span><br><span class="line">[INFO]   org.slf4j:slf4j-api ................................... 1.6.4 -&gt; 1.7.7</span><br><span class="line">[INFO]   org.owasp.esapi:esapi ................................. 2.0.1 -&gt; 2.1.0</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<p>或者可以直接查看配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.owasp.esapi&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;esapi&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>对于Ant使用者，应该使用 <a href="http://repo1.maven.org/maven2/org/owasp/esapi/esapi/2.1.0/esapi-2.1.0.jar" target="_blank" rel="noopener">esapi-2.1.0.jar</a> 这个jar。</p>
<p>2.配置<br>在2.1.0这个版本中，在密文定义中，密钥的改变会导致漏洞(CVE-2013-5960)。需要使用一些预防措施。<br>如果存在以下任何元素，那么ESAPI的加密算法就是有问题的<br>不安全的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Encryptor.CipherText.useMAC=false</span><br><span class="line"></span><br><span class="line">Encryptor.EncryptionAlgorithm=AES</span><br><span class="line">Encryptor.CipherTransformation=AES/CBC/PKCS5Padding</span><br><span class="line"></span><br><span class="line">Encryptor.cipher_modes.additional_allowed=CBC</span><br></pre></td></tr></table></figure>

<p>安全的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#Needed</span><br><span class="line">Encryptor.CipherText.useMAC=true</span><br><span class="line"></span><br><span class="line">#Needed to have a solid auth. encryption</span><br><span class="line">Encryptor.EncryptionAlgorithm=AES</span><br><span class="line">Encryptor.CipherTransformation=AES/GCM/NoPadding</span><br><span class="line"></span><br><span class="line">#CBC mode should be removed to avoid padding oracle</span><br><span class="line">Encryptor.cipher_modes.additional_allowed=</span><br></pre></td></tr></table></figure>

<p>引用：<br><a href="http://owasp-esapi-java.googlecode.com/svn/trunk/documentation/ESAPI-security-bulletin1.pdf" target="_blank" rel="noopener">ESAPI Security bulletin 1 (CVE-2013-5679)</a><br><a href="http://nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-5679" target="_blank" rel="noopener">Vulnerability Summary for CVE-2013-5679</a><br><a href="http://www.synacktiv.com/ressources/synacktiv_owasp_esapi_hmac_bypass.pdf" target="_blank" rel="noopener">Synactiv: Bypassing HMAC validation in OWASP ESAPI symmetric encryption</a><br><a href="http://cwe.mitre.org/data/definitions/310.html" target="_blank" rel="noopener">CWE-310: Cryptographic Issues</a><br><a href="http://lists.owasp.org/pipermail/esapi-dev/2015-March/002533.html" target="_blank" rel="noopener">ESAPI-dev mailing list: Status of CVE-2013-5960</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/02/Java%E5%AE%A1%E8%AE%A1-DAY2/" rel="next" title="Java审计-DAY2">
                <i class="fa fa-chevron-left"></i> Java审计-DAY2
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/02/Java%E5%AE%A1%E8%AE%A1-DAY4/" rel="prev" title="Java审计-DAY4">
                Java审计-DAY4 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">白仁</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java审计-DAY3"><span class="nav-number">1.</span> <span class="nav-text">Java审计-DAY3</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在使用脚本引擎时潜在的代码注入"><span class="nav-number">2.</span> <span class="nav-text">在使用脚本引擎时潜在的代码注入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用Spring表达式时潜在的代码注入-SpEL表达式注入）"><span class="nav-number">3.</span> <span class="nav-text">使用Spring表达式时潜在的代码注入(SpEL表达式注入）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用表达式语言时潜在的代码注入（EL）"><span class="nav-number">4.</span> <span class="nav-text">使用表达式语言时潜在的代码注入（EL）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#潜在于Seam-logging-call中的代码注入"><span class="nav-number">5.</span> <span class="nav-text">潜在于Seam logging call中的代码注入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用OGNL表达式时潜在的代码注入"><span class="nav-number">6.</span> <span class="nav-text">使用OGNL表达式时潜在的代码注入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#潜在的http返回报文被分割"><span class="nav-number">7.</span> <span class="nav-text">潜在的http返回报文被分割</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在日志中潜在的CRLF注入"><span class="nav-number">8.</span> <span class="nav-text">在日志中潜在的CRLF注入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#潜在的外部控制配置"><span class="nav-number">9.</span> <span class="nav-text">潜在的外部控制配置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#坏的十六进制数据"><span class="nav-number">10.</span> <span class="nav-text">坏的十六进制数据</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hazelcast对称加密"><span class="nav-number">11.</span> <span class="nav-text">Hazelcast对称加密</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#不安全的空密码"><span class="nav-number">12.</span> <span class="nav-text">不安全的空密码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#未加密的服务器socket"><span class="nav-number">13.</span> <span class="nav-text">未加密的服务器socket</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DES是不安全的"><span class="nav-number">14.</span> <span class="nav-text">DES是不安全的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DESede是不安全的"><span class="nav-number">15.</span> <span class="nav-text">DESede是不安全的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#不用padding的RSA是不安全的"><span class="nav-number">16.</span> <span class="nav-text">不用padding的RSA是不安全的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#硬编码密码"><span class="nav-number">17.</span> <span class="nav-text">硬编码密码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#硬编码密钥"><span class="nav-number">18.</span> <span class="nav-text">硬编码密钥</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#不安全的hash比较"><span class="nav-number">19.</span> <span class="nav-text">不安全的hash比较</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#来自Struts-Form的输入没有被验证"><span class="nav-number">20.</span> <span class="nav-text">来自Struts Form的输入没有被验证</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#XSSRequestWrapper的xss防护是脆弱的"><span class="nav-number">21.</span> <span class="nav-text">XSSRequestWrapper的xss防护是脆弱的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Blowfish-使用过短的密钥"><span class="nav-number">22.</span> <span class="nav-text">Blowfish 使用过短的密钥</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RSA使用了过短密钥"><span class="nav-number">23.</span> <span class="nav-text">RSA使用了过短密钥</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#未验证的重定向"><span class="nav-number">24.</span> <span class="nav-text">未验证的重定向</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#未验证的重定向-Play-Framework"><span class="nav-number">25.</span> <span class="nav-text">未验证的重定向(Play Framework)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring中未验证的重定向"><span class="nav-number">26.</span> <span class="nav-text">Spring中未验证的重定向</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jsp动态包含"><span class="nav-number">27.</span> <span class="nav-text">jsp动态包含</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-表达式中的动态变量"><span class="nav-number">28.</span> <span class="nav-text">Spring 表达式中的动态变量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#xml字符转义被禁用"><span class="nav-number">29.</span> <span class="nav-text">xml字符转义被禁用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jsp中潜在的xss"><span class="nav-number">30.</span> <span class="nav-text">jsp中潜在的xss</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Servlet中潜在的xss"><span class="nav-number">31.</span> <span class="nav-text">Servlet中潜在的xss</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#XMLDecoder的使用"><span class="nav-number">32.</span> <span class="nav-text">XMLDecoder的使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#固定IV"><span class="nav-number">33.</span> <span class="nav-text">固定IV</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ECB模式是不安全的"><span class="nav-number">34.</span> <span class="nav-text">ECB模式是不安全的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#加密容易受到Padding-Oracle的影响"><span class="nav-number">35.</span> <span class="nav-text">加密容易受到Padding Oracle的影响</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#密码没有完整性"><span class="nav-number">36.</span> <span class="nav-text">密码没有完整性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用ESAPI加密"><span class="nav-number">37.</span> <span class="nav-text">使用ESAPI加密</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">白仁</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
